<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GAMES104</title>
      <link href="/2023/07/12/GAMES104/"/>
      <url>/2023/07/12/GAMES104/</url>
      
        <content type="html"><![CDATA[<h1 id="二、引擎架构分层与整体pipeline"><a href="#二、引擎架构分层与整体pipeline" class="headerlink" title="二、引擎架构分层与整体pipeline"></a>二、引擎架构分层与整体pipeline</h1><h2 id="2-1游戏引擎分层简介-5-1"><a href="#2-1游戏引擎分层简介-5-1" class="headerlink" title="2.1游戏引擎分层简介 5+1"></a>2.1游戏引擎分层简介 5+1</h2><ol><li>工具层<strong>Tool Layer</strong>：各种编辑器</li><li>功能层<strong>Function Layer</strong>：让游戏Visible(渲染)、Movable(物理系统)、Playable(状态机&amp;人机交互)</li><li>资源层<strong>Resource Layer</strong>：各种数据文件，如图形、几何、声音、视频、场景等等</li><li>核心层<strong>Core Layer</strong>：引擎的工具箱，如内存管理、容器分配、数学运算等等</li><li>平台层<strong>Platform Layer</strong>：隐藏不同平台的不同接口</li></ol><p>第三方库文件<strong>3nd Party Libraries</strong>，与各个层都会有关系</p><h2 id="2-2资源层"><a href="#2-2资源层" class="headerlink" title="2.2资源层"></a>2.2资源层</h2><ol><li>将各种资源文件，转化成引擎统一的格式，如**.uasset**</li><li>这一步会将很多冗余信息清除，将文件的格式转化为GPU可以高效绘制的格式</li><li>还需要生成一些资源文件，用于表示不同资源文件之间的关联</li><li>需要负责管理所有资产的<strong>生命周期</strong>：垃圾回收GC、延迟加载</li></ol><h2 id="2-3功能层"><a href="#2-3功能层" class="headerlink" title="2.3功能层"></a>2.3功能层</h2><ol><li>每经过一个<strong>Tick</strong>，会将整个游戏的逻辑和渲染运行一遍</li><li><strong>tick</strong>会分为两个步骤：<strong>tickLogic()</strong> &#x3D;&gt; <strong>tickRender()</strong><ol><li>**tickLogic()**：对世界的模拟，如输入输出、物理系统、碰撞检测</li><li>**tickRender()**：对世界的渲染</li></ol></li><li>功能层是整个引擎中最多的部分，会跟具体游戏有关联</li><li>功能层的某些模块既可以当作是引擎的模块，也可以当作是游戏的模块，如：相机的移动</li></ol><img src="/images/AssetMarkdown/image-20230425210150246.png" alt="image-20230425210150246" style="zoom:80%;" /><p>多线程计算：</p><img src="/images/AssetMarkdown/image-20230425210452719.png" alt="image-20230425210452719" style="zoom:80%;" /><h2 id="2-4核心层"><a href="#2-4核心层" class="headerlink" title="2.4核心层"></a>2.4核心层</h2><ol><li>数学库：<ol><li>为了提高效率，因此会在核心层中，重写数学库</li><li>如用SIMD实现矩阵乘法</li></ol></li><li>数据结构和容器：<ol><li>也是为了提高效率，因此会在核心层中，重写数据结构，而不是直接使用STL容器</li></ol></li><li>内存管理<ol><li>游戏引擎会提前申请一大块内存，由引擎管理</li><li>三个原则：尽可能将数据放到一起、按顺序访问数据、一次申请&#x2F;释放一整块数据</li></ol></li><li>一般来说，核心层的代码质量最高，轻易不会修改</li></ol><h2 id="2-5平台层"><a href="#2-5平台层" class="headerlink" title="2.5平台层"></a>2.5平台层</h2><ol><li><p>掩盖掉不同平台之间的差异</p><ol><li><p>文件的路径</p></li><li><p>图形学API：用Render Hardware Interface(RHI)隐藏起来</p><img src="/images/AssetMarkdown/image-20230425211749281.png" alt="image-20230425211749281" style="zoom:80%;" /></li><li><p>硬件架构</p></li></ol></li><li><p>平台层的好坏影响了游戏在不同平台上的性能优劣</p></li></ol><h2 id="2-6工具层"><a href="#2-6工具层" class="headerlink" title="2.6工具层"></a>2.6工具层</h2><p>允许所有人用引擎创建游戏</p><ol><li>保证工具层展示的结果和最终游戏的结果是一样的</li><li>以开发效率为优先，而不是以运行效率为优先</li></ol><p>DCC：Digital Content Creation</p><ol><li>将其他工具产生的数字资产，转化为引擎统一的数字资产</li></ol><h2 id="2-7为什么要分层架构"><a href="#2-7为什么要分层架构" class="headerlink" title="2.7为什么要分层架构"></a>2.7为什么要分层架构</h2><ol><li>降低问题的复杂度，让每一层只需要考虑自己的任务<ol><li>越底层的东西越不会轻易改变</li><li>越往上，越灵活；越往下，越稳定</li></ol></li><li>要先将问题划分为不同层次的任务，然后再进行开发</li><li>只允许上层调用下层，下层不能调用上层</li></ol><h1 id="三、如何构建游戏世界"><a href="#三、如何构建游戏世界" class="headerlink" title="三、如何构建游戏世界"></a>三、如何构建游戏世界</h1><h1 id="十八、网络游戏的架构基础"><a href="#十八、网络游戏的架构基础" class="headerlink" title="十八、网络游戏的架构基础"></a>十八、网络游戏的架构基础</h1><h2 id="18-1同步算法"><a href="#18-1同步算法" class="headerlink" title="18.1同步算法"></a>18.1同步算法</h2><h3 id="18-1-1快照同步Snapshot"><a href="#18-1-1快照同步Snapshot" class="headerlink" title="18.1.1快照同步Snapshot"></a>18.1.1快照同步Snapshot</h3><blockquote><p>如Quake</p></blockquote><ol><li>步骤：<ol><li>客户端：把<strong>输入</strong>发送给服务器</li><li>服务器：将所有客户的输入集合起来，在服务器中进行<strong>游戏世界的模拟</strong>，然后将<strong>游戏世界的状态</strong>生成<strong>快照</strong>返回给客户端</li><li>客户端：拿到服务器给的快照后，将所有对象设置为对应的状态，然后进行<strong>渲染</strong></li></ol></li><li>优点：<ol><li>结构清晰，保证了绝<strong>对的一致性</strong>，无法作弊</li><li>不用担心同步的问题</li><li>客户端只负责输入和最后的渲染</li><li>当客户端非常多时，服务器的计算量是最低的，因为只需要对世界模拟一次即可</li></ol></li><li>针对实际情况的改进：<ol><li>服务器端的帧率通常会很低，需要客户端进行插值</li><li>快照可能包含非常多的信息，但是相邻两帧通常差距不大，因此可以只传delta，从而降低信息量</li></ol></li><li>缺点：<ol><li>浪费了客户端的算力</li><li>服务器生成快照传递给每一个客户端，会占用非常大的服务器处的上行带宽</li></ol></li></ol><h3 id="18-1-2帧同步Lockstep"><a href="#18-1-2帧同步Lockstep" class="headerlink" title="18.1.2帧同步Lockstep"></a>18.1.2帧同步Lockstep</h3><blockquote><p>如DOOM、王者荣耀</p></blockquote><ol><li>步骤：<ol><li>每一帧：客户端把输入统一交给服务器</li><li>服务器等待所有服务器提交输入，然后把所有输入分发给客户端</li><li>客户端得到服务器的指令，做一致的游戏逻辑模拟，得到的结果一定相同</li><li>要求所有客户端进行初始化，初始条件必须相同</li></ol></li><li>针对实际情况的改进：<ol><li>如果有一个客户端发送输入总是很慢，就需要其他客户端等待它<ol><li><strong>Bucket Synchronization</strong>：每隔固定的时间收集一次信息，服务器没收到的就当没发生</li></ol></li></ol></li><li>缺点：<ol><li>一样的输入，得到的结果<strong>不一定</strong>相同，因为会有随机数、浮点数等<strong>不确定</strong>的因素<ol><li>浮点数：要求满足IEE754标准</li><li>随机数：要求随机数种子、随机数算法严格相同</li></ol></li></ol></li></ol><h3 id="18-1-3状态同步State-Synchornization"><a href="#18-1-3状态同步State-Synchornization" class="headerlink" title="18.1.3状态同步State Synchornization"></a>18.1.3状态同步State Synchornization</h3><blockquote><p>如CS</p></blockquote><ol><li>步骤：<ol><li>客户端：Authorized将命令发送给服务器(如向某个方向发射一个炮弹)</li><li>服务器：接收客户端的命令，模拟操作(如打中某个对象)，然后将改变的状态广播给所有客户端</li><li>客户端：接收服务器的对场景状态的改变，模拟出整个世界</li></ol></li><li>针对实际情况的改进：<ol><li>客户端发送指令，服务器接受指令并确返回结果，会存在延迟<ol><li><strong>Client-side prediction</strong>：客户端要进行预测操作，即先将客户的指令执行，然后再和服务器对齐<ol><li>守望先锋：预测半个RTT+一个命令帧时间</li></ol></li><li><strong>Server Reconciliation</strong>：预测与服务器的返回不一致时，客户端要与服务器对齐<ol><li>平滑的差值对齐</li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/12/hello-world/"/>
      <url>/2023/07/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
