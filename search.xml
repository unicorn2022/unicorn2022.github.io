<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/07/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="chapter-1introduction">Chapter 1：Introduction</h1><h2 id="操作系统在做什么">1.1 操作系统在做什么</h2><h3 id="操作系统的作用">1.1.1 操作系统的作用</h3><p>Operating System的作用：</p><ol type="1"><li>作为用户与计算机硬件交互的中间层</li></ol><p>Operating System的目标：</p><ol type="1"><li>更加容易的执行/实现用户的程序</li><li>更加方便的使用计算机：交互</li><li>更有效率的使用硬件</li></ol><p><img src="/images/AssetMarkdown/image-20220912145316946.png" alt="image-20220912145316946" style="zoom:80%;" /></p><p>Computer System的结构：</p><ol type="1"><li>硬件<strong>Hardware</strong>：提供基础的计算资源<ol type="1"><li>CPU、memory、I/O devices</li></ol></li><li>操作系统<strong>OperatingSystem</strong>：控制在不同程序、不同用户间的硬件的使用</li><li>应用程序<strong>ApplicationPrograms</strong>：定义如何使用系统资源来解决问题<ol type="1"><li>Word processors、compilers、web browsers、database systems、videogames</li></ol></li><li>用户<strong>Users</strong>：<ol type="1"><li>People、machines、other computers</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220912145600410.png" alt="image-20220912145600410" style="zoom:80%;" /></p><h3 id="什么是操作系统">1.1.2 什么是操作系统</h3><h4 id="计算机系统组成角度操作系统是系统软件">1.1.2.1计算机系统组成角度：操作系统是系统软件</h4><ol type="1"><li>计算机系统组成：<ol type="1"><li>软件：应用软件、系统软件(操作系统等)</li><li>硬件：输入/输出(I/O)设备、存储器(内存) 、中央处理器(CPU)</li></ol></li></ol><h4 id="用户角度操作系统是用户与计算机硬件之间接口">1.1.2.2用户角度：操作系统是用户与计算机硬件之间接口</h4><ol type="1"><li>Computer计算机硬件<ol type="1"><li>PC</li><li>mainframe, or minicomputer</li><li>mobile computers</li></ol></li><li>操作系统提供的接口有：<ol type="1"><li>命令级接口<ol type="1"><li>键盘或鼠标等命令。</li><li>Mobile user interfaces such as touch screens, voice recognition</li></ol></li><li>程序级接口<ol type="1"><li>它提供一组系统调用System calls，即操作系统服务，供用户程序和其它程序调用</li></ol></li></ol></li></ol><h4 id="系统角度操作系统是计算机系统资源的管理者">1.1.2.3系统角度：操作系统是计算机系统资源的管理者</h4><ol type="1"><li>OS是资源的分配者<ol type="1"><li>管理所有资源</li><li>处理冲突的需求，有效而公平</li></ol></li><li>OS是一个控制程序<ol type="1"><li>控制程序的执行，阻止错误、不正确的使用</li></ol></li></ol><h4id="软件分层扩充机器的角度操作系统是扩充裸机的第一层系统软件">1.1.2.4软件分层、扩充机器的角度：操作系统是扩充裸机的第一层系统软件</h4><p><img src="/images/AssetMarkdown/image-20220912151451846.png" alt="image-20220912151451846" style="zoom:80%;" /></p><h4 id="综合考虑">1.1.2.5 综合考虑</h4><p><strong>操作系统</strong>是一组：有效控制和管理计算机各种硬件和软件资源，合理的组织计算机的工作流程，以及方便用户的程序的集合</p><ol type="1"><li><strong>有效（efficient）</strong>：系统效率高，资源利用率高（如：CPU使用率，内存、外部设备是否忙）</li><li><strong>合理</strong>：公平，如果不公平则会产生“死锁”或“饥饿”</li><li><strong>方便（convenience）</strong>：用户界面，编程接口</li></ol><h2 id="computer-system-organization">1.2 Computer SystemOrganization</h2><h3 id="总线结构">1.2.1 总线结构</h3><p><strong>总线结构</strong>：微型计算机是以总线为纽带来构成计算机系统，中央处理机（CPU）、存储器、I/O设备（包括外存磁盘、磁带）都挂接在总线</p><p><img src="/images/AssetMarkdown/image-20220912152133550.png" alt="image-20220912152133550" style="zoom:80%;" /></p><ol type="1"><li>I/O设备和CPU可以并行运行<strong>execute concurrently</strong></li><li>每一个设备控制器控制一个特定的设备</li><li>每一个设备控制器均有一个存储单元<strong>local buffer</strong></li><li>每一个设备控制器均有一个操作系统的驱动器<strong>devicedriver</strong>，让操作系统管理它</li><li>CPU在内存<strong>mainmemory</strong>和<strong>buffer</strong>之间进行数据的移动</li><li>I/O本质上是<strong>device</strong>到<strong>localbuffer</strong>之间的数据交互</li><li>设备通过提出中断<strong>interrupt</strong>的方式，告诉CPU它已经完成了操作</li></ol><h3 id="计算机启动-startup">1.2.2 计算机启动 Startup</h3><p><strong>bootstrap program</strong></p><ol type="1"><li>存放在<strong>ROM/EEPROM</strong>中，也被称为<strong>firmware</strong></li><li>在电源启动/重启的时候，这个程序被加载到内存中</li><li>会初始化操作系统的必须部分</li><li>然后将操作系统加载到内存中，开始执行</li></ol><h3 id="中断">1.2.3 中断</h3><p><strong>中断(Interrupt)</strong>：指系统发生某个异步/同步事件后，处理器暂停正在执行的程序，转去执行处理该事件程序的过程</p><ol type="1"><li>硬件中断</li><li>软件中断：<strong>陷入(trap)</strong></li></ol><p>操作系统是中断驱动的<strong>interrupt driven</strong></p><p><img src="/images/AssetMarkdown/image-20220912154757435.png" alt="image-20220912154757435" style="zoom:80%;" /></p><p><strong>外部中断(interrupt)，异步中断</strong>：</p><ol type="1"><li>外部设备所发出的I/O请求</li><li>分为可屏蔽的和不可屏蔽的两类，由一些硬件设备产生，<font color = “blue">可以在指令执行的任意时刻产生</font></li></ol><p><strong>异常(exception)，内部中断，同步中断</strong>：</p><ol type="1"><li>由正在执行的进程产生，<font color = “blue">一条指令终止执行后才会发出中断</font></li><li>常见的异常有除零、溢出及页面异常(<strong>fault出错</strong>)等。另一种情况是使用int指令(<strong>trap陷入</strong>)，Linux使用该指令来实现系统调用。fault与trap区别</li></ol><p><strong>中断处理</strong></p><ol type="1"><li>操作系统保存当前CPU状态：存储register、PC(program counter)</li><li>判断发生了哪一种中断：<ol type="1"><li>Polling：轮询</li><li>Vectored interrupt system：向量化中断系统</li></ol></li><li>单独的代码段决定了每种类型的中断应采取的操作(中断服务程序)</li></ol><p><strong>Interrupt Time line</strong></p><p><img src="/images/AssetMarkdown/image-20220915164048443.png" alt="image-20220915164048443" style="zoom:80%;" /></p><h3 id="存储结构">1.2.4 存储结构</h3><p><strong>Main Memory(主存)</strong></p><ol type="1"><li>CPU能够直接访问的最大存储空间</li></ol><p><strong>Secondary Storage(赋存)</strong></p><ol type="1"><li>主存的拓展，提供大量非易失型的存储空间</li></ol><p><strong>Hard Disk Drives(HDD, 硬盘)</strong>：</p><ol type="1"><li>覆盖有磁记录材料的刚性金属或玻璃盘</li><li>磁盘表面按逻辑划分为磁道，磁道又细分为扇区</li><li>磁盘控制器确定设备和计算机之间的逻辑交互</li></ol><p><strong>Caching(高速缓存技术)</strong>：将信息复制到更快的存储系统中</p><ol type="1"><li><strong>Main Memory</strong>可以被视为<strong>SecondaryStorage</strong>的一个缓存(cache)</li><li>重要原理：在计算机（硬件、操作系统、软件）的多个级别执行<ol type="1"><li>正在使用的信息临时从较慢的存储复制到较快的存储</li><li>更快的存储（缓存）首先检查，判断信息是否存在<ol type="1"><li>如果是，则直接从缓存中使用信息（fast）</li><li>如果不是，则将数据复制到缓存并在其中使用</li></ol></li><li>缓存小于正在缓存的存储<ol type="1"><li>缓存管理是一个重要的设计问题</li><li>缓存大小和替换策略</li></ol></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220915164955425.png" alt="image-20220915164955425" style="zoom:80%;" /></p><h3 id="io结构">1.2.5 IO结构</h3><p><strong>I/O方式</strong>：</p><ol type="1"><li><p>程序I/O (<strong>Programmed I/O</strong>)</p></li><li><p>中断 I/O (<strong>Interrupt I/O</strong>)</p><ol type="1"><li>同步I/O：IO开始后，控制权只有当IO结束才会返回给程序</li><li>异步I/O：IO开始后，控制权立即返回给程序<ol type="1"><li>设备状态表Device-statustable：包含每个I/O设备的条目，指示其类型、地址和状态</li><li>操作系统索引到I/O设备表中，以确定设备状态并修改表条目以包括中断</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220915171013758.png" alt="image-20220915171013758" style="zoom:80%;" /></p></li><li><p><strong>DMA</strong>方式：Direct Memory AccessStructure直接内存访问</p><ol type="1"><li>用于能够以接近内存速度传输信息的<strong>高速I/O设备</strong></li><li>设备控制器将数据块从缓冲存储器直接传输到主存储器，无需CPU干预</li><li><strong>每个块</strong>只生成一个中断，而不是每个字节一个中断</li></ol></li><li><p>通道方式</p></li></ol><h2 id="computer-system-architecture">1.3 Computer SystemArchitecture</h2><h3 id="单处理器系统">1.3.1 单处理器系统</h3><ol type="1"><li>只有一个CPU和一个计算单元</li></ol><h3 id="多处理器系统">1.3.2 多处理器系统</h3><ol type="1"><li><strong>MultiprocessorSystems</strong>多处理器系统：也称为并行系统parallelsystems、紧密耦合系统tightly-coupled systems</li><li>优点：<ol type="1"><li>增加吞吐量</li><li>规模经济</li><li>提高可靠性——性能下降或容错</li></ol></li><li>两种类型：<ol type="1"><li>非对称多重处理</li><li>对称多重处理</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220915172235110.png" alt="image-20220915172235110" style="zoom:80%;" /></p><p><strong>Multi-processor（多个芯片） andmulticore（多核）</strong></p><ol type="1"><li>System（系统）包含所有的芯片</li><li>Chassis（主板）包含多个独立的处理器</li></ol><p><img src="/images/AssetMarkdown/image-20220915172456054.png" alt="image-20220915172456054" style="zoom:80%;" /></p><h3 id="计算机系统组件的定义">1.3.3 计算机系统组件的定义</h3><ol type="1"><li>CPU：执行指令的硬件</li><li>Processor处理器：包含一个或多个CPU的物理芯片</li><li>Core核：CPU里面最基本的计算单元</li><li>Multicore多核：在一块CPU里面有多个计算单元</li><li>Multiprocessor多处理器：包含多个处理器</li></ol><h3 id="clustered-systems集群系统">1.3.4 Clustered Systems集群系统</h3><ol type="1"><li><p>集群系统(<strong>Cluster</strong>)：是由一组互联的主机（节点）构成统一的计算机资源，通过相应软件协调工作的计算机机群，给人以一台机器的感觉</p></li><li><p>通常通过存储区域网络（storage-areanetwork，<strong>SAN</strong>）共享存储</p></li><li><p>提供高可用性（high-availability）服务，可在故障中生存</p><ol type="1"><li><strong>Asymmetricclustering</strong>（非对称集群）：有一台机器处于热备用模式</li><li><strong>Symmetric clustering</strong> （对称集群）：有多个运行应用程序的节点，相互监视</li></ol><p><img src="/images/AssetMarkdown/image-20220915172909011.png" alt="image-20220915172909011" style="zoom:80%;" /></p></li><li><p>一些集群用于高性能计算（<strong>HPC</strong>，high-performancecomputing)</p><ol type="1"><li>必须编写应用程序以使用<strong>并行化(parallelization)</strong></li></ol></li><li><p>一些具有分布式锁管理器（<strong>DLM</strong>分布式锁管理器)避免冲突操作</p></li><li><p>其他形式的集群：并行集群、WAN上的集群</p></li><li><p>集群技术正在迅速变化</p><ol type="1"><li>一些集群产品支持集群中的数千个系统，以及相隔数英里的集群节点</li><li>Storage-Area Network，<strong>SAN</strong>，存储区域网</li></ol></li></ol><h2 id="operating-system-operations操作系统的执行">1.4 Operating SystemOperations操作系统的执行</h2><ol type="1"><li>硬件驱动的中断</li><li>软件错误或请求创建exception(异常） 或trap(陷入）<ol type="1"><li>除以零，请求操作系统服务</li></ol></li><li>其他进程问题包括无限循环、进程相互修改或操作系统</li></ol><h3 id="两种操作模式">1.4.1 两种操作模式：</h3><ol type="1"><li><strong>User mode(用户态)</strong>：执行用户程序时<ol type="1"><li>只能访问属于它的存储空间和普通寄存器，只能执行普通指令</li><li>用户程序以及操作系统核外服务程序运行在用户态下</li><li>使用用户栈</li><li><strong>非特权指令</strong>：用户程序中所使用的指令</li></ol></li><li><strong>Kernel mode(内核态)</strong>：执行操作系统程序时<ol type="1"><li>也称为：monitor mode管态、system mode系统态、supervisor mode管态、privileged mode特权模式</li><li>能够访问所有系统资源，可以执行特权指令，可以直接操作和管理硬件设备</li><li>操作系统内核程序运行在内核态下</li><li>使用内核栈</li><li><strong>特权指令</strong>：不允许用户程序中直接使用的指令。例如：I/O指令、设置时钟、设置控制寄存器等指令都是特权指令</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220915174344904.png" alt="image-20220915174344904" style="zoom:80%;" /></p><h3 id="timer定时器防止无限循环进程占用资源">1.4.2Timer(定时器)：防止无限循环/进程占用资源</h3><ol type="1"><li>在特定时间段后设置中断</li><li>操作系统递减计数器</li><li>当计数器为零时，生成中断</li><li>在调度进程之前设置，以重新控制或终止超过分配时间的程序</li></ol><h2 id="resource-management资源管理">1.5 ResourceManagement资源管理</h2><ol type="1"><li>进程管理 Process Management</li><li>主存管理 Main Memory Management</li><li>文件系统管理 File-System Management</li><li>大容量储存管理 Mass-Storage Management</li><li>高速缓存管理机制 Caching</li><li>I/O系统管理 I/O System Management</li></ol><h3 id="进程管理">1.5.1 进程管理</h3><ol type="1"><li>进程<strong>Process</strong>：所有处于<strong>执行中</strong>的程序<ol type="1"><li>进程是一个最基本的单元</li><li>不同进程之间可以共享一些数据，但不会相互依赖</li><li>程序是<strong>passiveentity(静态实体)</strong>，进程是<strong>activeentity(活动实体)</strong></li></ol></li><li>进程需要获得一些资源以完成任务<ol type="1"><li>CPU、内存、IO、文件、初始化数据</li></ol></li><li>进程终止需要回收任何可重用资源</li><li>单线程进程(<strong>Single-threaded process</strong>)<ol type="1"><li>有一个程序计数器(<strong>PC，programcounter</strong>)，指定要执行的下一条指令的位置</li><li>进程按顺序执行指令，一次一个，直到完成</li></ol></li><li>多线程进程(<strong>Multi-threaded process</strong>)<ol type="1"><li>每个线程有一个程序计数器(<strong>PC</strong>)</li></ol></li><li>通常，系统有许多进程，一些用户，一些操作系统在一个或多个CPU上并发运行<ol type="1"><li>通过在进程/线程之间<strong>复用CPU(multiplexing)</strong>实现并发(concurrency)</li><li>时间片：多个时钟周期的组合</li><li>轮转的调度方法：每一个进程执行一段时间后，暂停当前进程，执行下一个进程</li><li>每一次切换时，由于需要将当前进程的相关信息保存下来，所有会造成浪费</li></ol></li><li><strong>Process Management</strong>的任务：<ol type="1"><li>创建和删除用户和系统进程</li><li>暂停和恢复进程</li><li>提供进程同步机制</li><li>提供过程通信机制</li><li>提供死锁处理机制</li></ol></li></ol><h3 id="内存管理">1.5.2 内存管理</h3><ol type="1"><li>要执行程序，所有（或部分）<strong>指令</strong>必须在内存中</li><li>程序所需的所有（或部分）<strong>数据</strong>必须在内存中</li><li>内存管理确定内存中的内容和时间<ol type="1"><li>优化CPU利用率和计算机对用户的响应</li></ol></li><li><strong>Memory Management</strong>的任务：<ol type="1"><li>跟踪当前正在使用内存的哪些部分以及由谁使用</li><li>决定哪些进程（或其部分）和数据要移入和移出内存</li><li>根据需要分配和释放内存空间</li></ol></li></ol><h3 id="文件系统管理">1.5.3 文件系统管理</h3><ol type="1"><li>操作系统提供信息存储的统一逻辑视图<ol type="1"><li>将物理属性抽象为逻辑存储单元文件<strong>file</strong></li><li>每个介质由设备（如磁盘驱动器、磁带驱动器）控制<ol type="1"><li>不同的属性包括访问速度、容量、数据传输速率、访问方法（顺序或随机）</li></ol></li></ol></li><li>文件系统管理<ol type="1"><li>文件通常被组织到目录中</li><li>大多数系统上的访问控制，以确定谁可以访问什么</li></ol></li><li><strong>File-system Management</strong>的任务：<ol type="1"><li>创建和删除文件和目录</li><li>用于操作文件和目录的原语primitives</li><li>将文件映射到辅助存储</li><li>将文件备份到稳定（非易失性）存储介质上</li></ol></li></ol><h3 id="大容量储存管理">1.5.4 大容量储存管理</h3><ol type="1"><li>通常，磁盘用于存储不适合主内存的数据或必须保存“长”一段时间的数据</li><li>适当的管理至关重要</li><li>计算机操作的整体速度取决于磁盘子系统及其算法</li><li><strong>Mass-Storage Management</strong>的任务<ol type="1"><li>安装mounting和拆卸unmounting</li><li>空闲空间管理</li><li>存储分配</li><li>磁盘调度</li><li>分区Partition</li><li>保护Protection</li></ol></li><li>有些存储不需要很快<ol type="1"><li>三级存储包括光盘、磁带</li><li>仍然必须由操作系统或应用程序进行管理</li></ol></li></ol><h3 id="高速缓存机制caching">1.5.5 高速缓存机制Caching</h3><ol type="1"><li><p>重要原理，在计算机（硬件、操作系统、软件）的多个级别执行</p></li><li><p>将正在使用的信息临时从较慢的存储复制到较快的存储</p></li><li><p>Faster Storage（cache）首先检查，判断信息是否存在</p><ol type="1"><li>如果存在，则直接从缓存中使用信息（fast）</li><li>如果不存在，则将数据复制到缓存并在其中使用</li></ol></li><li><p>缓存小于正在缓存的存储</p><ol type="1"><li>缓存管理是一个重要的设计问题</li><li>缓存大小和替换策略</li></ol></li><li><p>多任务环境必须小心使用最新的值，无论它存储在存储层次结构中的何处</p><p><img src="/images/AssetMarkdown/image-20220919151453353.png" alt="image-20220919151453353" style="zoom:80%;" /></p></li><li><p>多处理器环境必须在硬件中提供缓存一致性，以便所有CPU在其缓存中都具有最新的值</p></li><li><p>分布式环境情况更加复杂</p><ol type="1"><li>一个基准可以有多个副本</li><li>第19章涵盖的各种解决方案</li></ol></li></ol><h3 id="io子系统">1.5.6 I/O子系统</h3><ol type="1"><li>操作系统的一个目的是向用户隐藏硬件设备的特性</li><li><strong>I/O Subsystem</strong>的任务：<ol type="1"><li>I/O的内存管理，包括缓冲（在传输数据时临时存储数据）、缓存（将部分数据存储在更快的存储中以提高性能）、假脱机（一个作业的输出与其他作业的输入重叠）</li><li>通用设备驱动程序接口</li><li>特定硬件设备的驱动程序</li></ol></li></ol><h2 id="security-and-protection安全和保护">1.6 Security andProtection安全和保护</h2><ol type="1"><li>保护<strong>Protection</strong>：控制进程或用户访问操作系统定义的资源 的机制</li><li>安全性<strong>Security</strong>：防御系统内部和外部攻击<ol type="1"><li>范围广泛，包括拒绝服务(denial-of-service)、蠕虫(worms)、病毒(viruses)、身份盗窃(identitytheft)、服务盗窃(theft of service)</li></ol></li><li>系统通常首先区分用户，以确定谁可以做什么<ol type="1"><li>用户身份(<strong>user IDs、securityIDs</strong>)：包括姓名和相关号码，每个用户一个</li><li>user ID与该用户的所有文件、进程关联，以确定访问控制</li><li>组标识符(<strong>groupID</strong>)：允许定义和管理用户集，然后还可以与每个进程、文件关联</li><li><strong>权限提升Privilegeescalation</strong>：允许用户更改为具有更多权限的有效ID</li></ol></li></ol><h2 id="virtualization虚拟化">1.7 Virtualization虚拟化</h2><ol type="1"><li>允许操作系统在其他操作系统中运行应用程序</li><li><strong>仿真Emulation</strong>：当源CPU类型与目标CPU类型不一样时使用该技术<ol type="1"><li>通常是最慢的方法</li><li>当计算机语言未编译为本机代码时：<strong>Interpretation翻译</strong></li></ol></li><li>虚拟化<strong>Virtualization</strong>：为CPU本机编译的OS，运行本机也编译过的guestOS<ol type="1"><li>考虑运行WinXP客户机的VMware，每个客户机都运行本机WinXP主机操作系统上的应用程序</li><li><strong>VMM</strong>(虚拟机管理器 virtual machineManager)提供虚拟化服务</li></ol></li><li><strong>VMM</strong>可以本地化运行，在这种情况下，它们也是主机<ol type="1"><li>因此，没有通用主机（VMware ESX和Citrix XenServer）</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220919153643248.png" alt="image-20220919153643248" style="zoom:80%;" /></p><h2 id="distribute-system分布式系统">1.8 DistributeSystem分布式系统</h2><ol type="1"><li>分布式计算<ol type="1"><li>独立的、可能异构的、联网在一起的系统的集合</li><li>网络(<strong>Network</strong>)是通信路径，TCP/IP最常见<ol type="1"><li>局域网（LAN）</li><li>广域网（WAN）</li><li>城域网（MAN）</li><li>个人局域网（PAN）</li></ol></li></ol></li><li>网络操作系统(<strong>Network OperatingSystem</strong>)：提供跨网络的系统之间的功能<ol type="1"><li>通信方案允许系统交换消息</li><li>看起来是单一系统</li></ol></li></ol><h2 id="kernel-data-structures内核数据结构">1.9 Kernel DataStructures内核数据结构</h2><ol type="1"><li><p>Linked List</p><p><img src="/images/AssetMarkdown/image-20220919154221402.png" alt="image-20220919154221402" style="zoom:80%;" /></p></li><li><p>Binary Search Tree</p><p><img src="/images/AssetMarkdown/image-20220919154534541.png" alt="image-20220919154534541" style="zoom:80%;" /></p></li><li><p>Hash Map</p><p><img src="/images/AssetMarkdown/image-20220919154737046.png" alt="image-20220919154737046" style="zoom:80%;" /></p></li></ol><h2 id="computing-environments计算环境">1.10 ComputingEnvironments计算环境</h2><h3 id="传统计算-traditional">1.10.1 传统计算 Traditional</h3><ol type="1"><li>独立通用机器</li><li>但由于大多数系统与其他系统（即互联网）互连，因此变得模糊</li><li>门户<strong>Portals</strong>提供对内部系统的web访问</li><li>网络计算机（thin clients）就像Web终端</li><li>移动计算机通过无线网络互连</li><li>网络无处不在，甚至家庭系统也使用防火墙保护家庭计算机免受互联网攻击</li></ol><p><strong>Mainfram Systems大型机系统</strong>：</p><ol type="1"><li><p>Batch System：批处理系统</p><ol type="1"><li><p>Multiprogramming：多道程序，多个作业同时保存在主存中，CPU在其中多路复用</p><p><img src="/images/AssetMarkdown/image-20220922162547276.png" alt="image-20220922162547276" style="zoom:50%;" /></p></li></ol></li><li><p>Time-Sharing Systems：分时系统</p><ol type="1"><li><strong>分时</strong>：多个用户分时共享使用同一台计算机<ol type="1"><li>也就是说把计算机的系统资源（尤其是CPU时间）进行时间上分割，即将整个工作时间分成一个个的时间片，每个时间片分给一个用户使用</li><li>这样将CPU工作时间分别提供给多个用户使用，每个用户依次地轮流且使用一个时间片</li></ol></li><li><strong>响应时间</strong>：是分时系统的重要指标，它是用户发出终端命令到系统作出响应的时间间隔。<ol type="1"><li>系统的响应时间主要是根据用户所能接受的等待时间确定的。</li><li>假设分时系统中进程数(用户数)为n，每个进程的运行时间片为q，则系统的最大响应时间为：<spanclass="math inline">\(S=(n-1)×q\)</span></li><li>响应时间仅计算第一次被运行的时间点</li></ol></li></ol></li><li><p>Desktop Systems：桌面系统</p><ol type="1"><li>个人计算机：专用于单个用户的计算机系统</li><li>I/O设备：键盘、鼠标、显示屏、小型打印机</li><li>重点：用户的便利性和响应能力</li><li>可以采用为大型操作系统开发的技术，通常个人只使用计算机，不需要高级CPU利用率的保护功能</li><li>可以运行多种不同类型的操作系统</li></ol></li></ol><h3 id="移动计算-mobile">1.10.2 移动计算 Mobile</h3><ol type="1"><li>手持智能手机、平板电脑等</li><li>它们与“传统”笔记本电脑的功能区别是什么？<ol type="1"><li>附加功能–更多操作系统功能（GPS、gyroscope陀螺仪)</li><li>允许新类型的应用程序，如增强现实</li><li>使用IEEE 802.11无线或蜂窝数据网络进行连接</li></ol></li></ol><p><strong>计算应用领域</strong>：</p><p><img src="/images/AssetMarkdown/image-20220922163724580.png" alt="image-20220922163724580" style="zoom:80%;" /></p><h3 id="客户机client-服务器server计算">1.10.3客户机Client-服务器Server计算</h3><ol type="1"><li><p>智能PC取代了无人机终端</p></li><li><p>现在许多系统都是服务器，响应客户端生成的请求</p><ol type="1"><li>计算服务器系统compute-serversystem：为客户端提供请求服务（即数据库）的接口</li><li>文件服务器系统file-serversystem：为客户端提供存储和检索文件的接口</li></ol><p><img src="/images/AssetMarkdown/image-20220922163943559.png" alt="image-20220922163943559" style="zoom: 80%;" /></p></li></ol><h3 id="点对点计算-peer-to-peer">1.10.4 点对点计算 Peer-to-Peer</h3><ol type="1"><li><p>分布式系统的另一种模型</p></li><li><p>P2P无法区分客户端和服务器</p><ol type="1"><li>相反，所有节点都被视为对等节点</li><li>可以分别充当客户端、服务器或两者<ol type="1"><li>节点必须加入P2P网络</li><li>在网络上向中央查找服务注册其服务，或</li></ol></li><li>广播服务请求并通过发现协议响应服务请求</li></ol></li><li><p>示例包括Napster和Gnutella、Voice overIP（VoIP），如Skype</p></li><li><p>Blockchain technology 区块链技术</p><p><img src="/images/AssetMarkdown/image-20220922164125326.png" alt="image-20220922164125326" style="zoom:80%;" /></p></li></ol><h3 id="虚拟化计算-virtualization">1.10.5 虚拟化计算 Virtualization</h3><h3 id="云计算-cloud-computing">1.10.6 云计算 Cloud Computing</h3><ol type="1"><li>通过网络将计算、存储甚至应用程序作为服务提供</li><li>基于虚拟化的虚拟化逻辑扩展<ol type="1"><li>AmazonEC2拥有数千台服务器、数百万台虚拟机、PB存储空间，可在互联网上使用，根据使用情况付费</li></ol></li><li>Many types<ol type="1"><li>Public cloud(公有云)：任何愿意付费的人都可以通过互联网获得</li><li>Private cloud(私有云)：由公司运营供公司自用</li><li>Hybrid cloud(混合云)：包括公共云组件和私有云组件</li><li>Software as a Service (<strong>SaaS</strong>，软件即服务)：通过互联网提供的一个或多个应用程序(即文字处理器)</li><li>Platform as a Service (<strong>PaaS</strong>，平台即服务)：软件堆栈可通过Internet(即数据库服务器)供应用程序使用</li><li>Infrastructure as a Service (<strong>IaaS</strong>，基础设施即服务)：通过Internet可用的服务器或存储(即可用于备份的存储)</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220922165454650.png" alt="image-20220922165454650" style="zoom:80%;" /></p><h3 id="实时嵌入式系统-real-time-embedded-systems">1.10.7 实时嵌入式系统Real-Time Embedded Systems</h3><ol type="1"><li>实时嵌入式系统——最流行的计算机形式<ol type="1"><li>各种相当大的、特殊用途的、有限用途的操作系统、实时操作系统</li><li>使用扩展</li></ol></li><li>还有许多其他特殊的计算环境<ol type="1"><li>有些有操作系统，有些在没有操作系统的情况下执行任务</li></ol></li><li>实时操作系统具有<strong>明确定义的固定时间限制</strong>，运行顺序与要求的顺序一定相同<ol type="1"><li>处理必须在约束内完成</li><li>只有在满足约束条件时才能正确操作</li></ol></li><li><strong>嵌入式系统</strong>：是以应用为中心，以计算机技术为基础，采用<strong>可剪裁软硬件</strong>，适用于对功能、可靠性、成本、体积、功耗等有严格要求的<strong>专用计算机系统</strong>，用于实现对其他设备的控制、监视或管理等功能</li><li><strong>嵌入式操作系统</strong>：运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等资源进行统一协调、调度和控制的系统软件</li></ol><h2 id="总结">1.10 总结</h2><p><img src="/images/AssetMarkdown/image-20220922170942935.png" alt="image-20220922170942935" style="zoom:80%;" /></p><h1 id="chapter-2operating-system-structures">Chapter2：Operating-System Structures</h1><h2 id="操作系统提供的服务">2.1 操作系统提供的服务</h2><p><img src="/images/AssetMarkdown/image-20220922171943398.png" alt="image-20220922171943398" style="zoom:80%;" /></p><ol type="1"><li>用户界面<strong>User Interface</strong>：<ol type="1"><li>几乎所有操作系统都有用户界面（UI）</li><li>在命令行界面（CLI）、图形用户界面（GUI）和批处理之间有所不同</li></ol></li><li>程序执行<strong>Program Execution</strong>：<ol type="1"><li>系统必须能够将程序加载到内存并运行该程序，正常或异常结束执行（指示错误）</li></ol></li><li>I/O操作<strong>I/O operations</strong>：<ol type="1"><li>正在运行的程序可能需要I/O，这可能涉及文件或I/O设备</li></ol></li><li>文件系统操作<strong>File-System Manipulation</strong>：<ol type="1"><li>程序需要读取和写入文件和目录，创建和删除它们，搜索它们，列出文件信息，权限管理</li></ol></li><li>通信<strong>Communication</strong>：<ol type="1"><li>进程可以在同一台计算机上或在网络上的计算机之间交换信息</li><li>通信可以通过共享内存或消息传递（数据包由操作系统移动）</li></ol></li><li>错误检测<strong>Error Detection</strong>：<ol type="1"><li>操作系统需要不断意识到可能的错误</li><li>错误可能出现在CPU和内存硬件、I/O设备、用户程序中</li><li>对于每种类型的错误，操作系统都应该采取适当的措施来确保正确和一致的计算</li><li>调试设施可以大大提高用户和程序员有效使用系统的能力</li></ol></li><li>资源分配<strong>Resource allocation</strong>：<ol type="1"><li>当多个用户或多个作业同时运行时，必须将资源分配给每个用户或作业</li><li>许多类型的资源（如CPU周期、主内存和文件存储）可能有特殊的分配代码，其他（如I/O设备）可能有一般的请求和发布代码。</li></ol></li><li><strong>Accounting</strong>：<ol type="1"><li>跟踪哪些用户使用了多少和什么类型的计算机资源</li></ol></li><li>保护和安全<strong>Protection and Security</strong>：<ol type="1"><li>存储在多用户或联网计算机系统中的信息的所有者可能希望控制该信息的使用，并发进程不应相互干扰</li><li>保护包括确保控制对系统资源的所有访问</li><li>来自外部的系统安全需要用户身份验证，扩展到保护外部I/O设备免受无效访问尝试</li><li>如果要保护系统，必须在整个系统中采取预防措施。链条的坚固程度取决于它最薄弱的环节</li></ol></li></ol><h2 id="user-operating-system-interface">2.2 User Operating SystemInterface</h2><ol type="1"><li><strong>Operating System Interface</strong>操作系统的接口：<ol type="1"><li>User Interface （用户接口）</li><li>Program Interface （程序接口，system call）</li></ol></li><li><strong>User interface</strong>：用户接口，Almost all operatingsystems have a user interface (UI)<ol type="1"><li><strong>Command-Line Interface(CLI)</strong>：命令行用户接口，文本界面</li><li><strong>Graphics User Interface (GUI)</strong>：图形用户接口</li><li><strong>Touch-Screen Interface</strong>：触摸屏接口</li><li><strong>Choice of Interface</strong>：语音接口</li></ol></li></ol><h2 id="system-calls">2.3 System Calls</h2><ol type="1"><li><p>系统调用<strong>SystemCall</strong>：操作系统提供的服务的编程接口</p><ol type="1"><li>系统调用：进程和操作系统内核之间的编程接口</li><li>通常用高级语言（C或C++）编写</li><li>通常由程序通过高级应用程序接口(<strong>API</strong>)访问，而不是直接使用系统调用<ol type="1"><li>系统调用过于复杂，不适于编程</li><li>通过<strong>API</strong>将系统调用封装起来，便于编程</li></ol></li><li>三种最常见的API：<ol type="1"><li>用于Windows的Win32 API</li><li>用于基于POSIX的系统的POSIX API（包括几乎所有版本的UNIX、Linux和MacOS X）</li><li>用于Java虚拟机（JVM）的Java API</li></ol></li></ol></li><li><p>API与系统调用的区别</p><ol type="1"><li><p><strong>应用编程接口(API)</strong>：其实是一组函数定义，这些函数说明了如何获得一个给定的服务</p></li><li><p><strong>系统调用</strong>：是通过软中断向内核发出一个明确的请求，每个系统调用对应一个封装例程（wrapperroutine，唯一目的就是发布系统调用），一些API应用了封装例程</p></li><li><p><strong>API还包含各种编程接口</strong>，如：C库函数、OpenGL编程接口等</p></li><li><p><strong>系统调用的实现是在内核完成的，而用户态的函数是在函数库中实现的</strong></p><p><img src="/images/AssetMarkdown/image-20220922173955455.png" alt="image-20220922173955455" style="zoom:80%;" /></p></li></ol></li><li><p>参数的传递：</p><ol type="1"><li><p>放到register</p></li><li><p>放到内存中，用register传递指针</p><p><img src="/images/AssetMarkdown/image-20220922174933864.png" alt="image-20220922174933864" style="zoom:50%;" /></p></li><li><p>放到栈中，使用时从栈中pop出来</p></li></ol></li><li><p>系统调用的种类</p><ol type="1"><li>Process control：进程控制<ol type="1"><li>创建/终止/结束/中止/加载/执行 进程</li><li>获取/设置 进程属性</li><li>等待 一段时间/某个事件的发生</li><li>分配/释放/出错时转储 内存</li><li>用于确定错误的调试器<strong>Debugger</strong>，单步执行</li><li>用于管理进程之间共享数据访问的锁<strong>Locks</strong></li></ol></li><li>File management：文件管理<ol type="1"><li>创建/删除/打开/关闭/读/写/重定位 文件</li><li>获取/设置 文件属性</li></ol></li><li>Device management：设备管理<ol type="1"><li>访问/释放/读/写/重定位 设备</li><li>获取/设置 设备属性</li><li>逻辑挂载/逻辑接触挂载 设备</li></ol></li><li>Information maintenance：信息维护<ol type="1"><li>获取/设置 时间/日期/系统数据/进程属性/文件属性/设备属性</li></ol></li><li>Communications：通信<ol type="1"><li>创建/删除 通信联系</li><li>如果是<strong>message passingmodel</strong>，则需要发送/接受信息</li><li>如果是<strong>shared-memorymodel</strong>，则需要创建/访问共享空间</li><li>传递状态信息</li><li>远程连接</li></ol></li><li>Protection：安全保护<ol type="1"><li>对资源/文件的访问权限</li><li>用户的权限</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220926144126518.png" alt="image-20220926144126518" style="zoom:80%;" /></p></li></ol><h2 id="system-services">2.4 System Services</h2><p>系统程序<strong>Systemprograms</strong>为程序开发和执行提供了方便的环境。它们可以分为：</p><ol type="1"><li>文件操作：创建、删除、复制、重命名、打印、转储、列出并通常操作文件和目录</li><li>状态信息</li><li>文件修改：文本编辑器</li><li>编程语言支持：编译器、汇编器、调试器、解释器</li><li>程序加载和执行：加载/重新加载</li><li>通信：创建进程之间的连接，允许用户对另外一个用户进行传输文件/发送信息/远程控制</li><li>后台服务：启动时启动某些程序，打印错误日志，用户文本操作</li><li>应用程序</li></ol><p>大多数用户对操作系统的认知是由系统程序<strong>Systemprograms</strong>定义的，而不是实际的系统调用<strong>Systemcalls</strong></p><h2 id="linkers-and-loaders">2.5 Linkers and Loaders</h2><ol type="1"><li><p>编译成目标文件的源代码，可加载到任何物理内存位置：可重定位的目标文件<strong>relocatableobject file</strong></p></li><li><p>链接器<strong>Linker</strong>将这些<strong>obj</strong>文件，合并为单个二进制可执行文件<strong>executablefile</strong></p><ol type="1"><li>引入了库</li></ol></li><li><p>程序作为二进制可执行文件加载<strong>load</strong>在辅助存储上</p></li><li><p>必须由要执行的加载程序带入内存</p><ol type="1"><li>重新定位<strong>Relocation</strong>将最终地址分配给程序部件，并调整程序中的代码和数据以匹配这些地址</li></ol></li><li><p>现代操作系统不会将库链接到可执行文件中</p><ol type="1"><li>相反，动态链接库(<strong>DLL</strong>)是根据需要加载的，由所有使用同一版本库的用户共享</li><li>在程序运行时，按照需要加载一次</li></ol></li><li><p>对象，可执行文件具有标准格式，因此操作系统知道如何加载和启动它们</p><p><img src="/images/AssetMarkdown/image-20220926150251040.png" alt="image-20220926150251040" style="zoom:80%;" /></p></li></ol><h2 id="为什么应用程序只运行在特定的操作系统上">2.6为什么应用程序只运行在特定的操作系统上</h2><ol type="1"><li>在一个系统上编译的应用程序通常不能在其他操作系统上执行</li><li>每个操作系统都提供自己独特的系统调用、自己的文件格式等</li><li>应用程序可以是多操作系统<ol type="1"><li>用解释语言编写，如Python、Ruby和多个操作系统上可用的解释器</li><li>以包含包含运行应用程序的VM的语言编写的应用程序（如Java）</li><li>使用标准语言（如C），在每个操作系统上分别编译，以便在每个系统上运行</li></ol></li><li>应用程序二进制接口(<strong>Application BinaryInterface，ABI</strong>)：是API的体系结构等价物<ol type="1"><li>定义了二进制代码的不同组件如何在给定的体系结构、CPU等上与给定的操作系统交互</li></ol></li></ol><h2 id="operating-system-design-and-implementation">2.7 Operating-SystemDesign and Implementation</h2><ol type="1"><li>操作系统的设计和实现不是“可解决的”，但一些方法已经证明是成功的</li><li>不同操作系统的内部结构可能有很大差异</li><li>从定义目标和规范开始</li><li>受硬件选择、系统类型的影响</li><li>用户目标和系统目标<ol type="1"><li>用户目标：操作系统应便于使用、易于学习、可靠、安全和快速</li><li>系统目标：操作系统应易于设计、实施和维护，并且灵活、可靠、无错误和高效</li></ol></li></ol><p>操作系统的设计考虑</p><ol type="1"><li>功能设计：操作系统应具备哪些功能</li><li>算法设计：选择和设计满足系统功能的算法和策略，并分析和估算其效能</li><li>结构设计：选择合适的操作系统结构</li><li>按照系统的功能和特性要求，选择合适的结构，使用相应的结构设计方法将系统逐步地分解、抽象和综合，使操作系统结构清晰、简单、可靠、易读、易修改，而且使用方便，适应性强</li></ol><p>具体实现</p><ol type="1"><li>变化很大<ol type="1"><li>早期操作系统：汇编语言</li><li>然后：系统编程语言，如Algol、PL/1</li><li>现在：C，C++</li></ol></li><li>实际上通常是多种语言的混合<ol type="1"><li>组件中的最低级别</li><li>主体用C表示</li><li>用C、C++、脚本语言（如PERL、Python、shell脚本）编写的系统程序</li></ol></li><li>更高级的语言更容易移植到其他硬件，但速度较慢</li><li>仿真可以允许操作系统在非本机硬件上运行</li></ol><h2 id="operating-system-structure">2.8 Operating-System Structure</h2><ol type="1"><li><p>Simple Structure：简单结构</p><ol type="1"><li>MS-DOS：以最少的空间提供最多的功能</li><li>未划分为模块</li><li>虽然MS-DOS有一些结构，但其接口和功能级别没有很好地分离</li></ol><p><img src="/images/AssetMarkdown/image-20220926154200710.png" alt="image-20220926154200710" style="zoom:50%;" /></p></li><li><p>Layered Approach：层次化结构</p><ol type="1"><li>操作系统被划分为若干层（级别），每一层都构建在较低层之上</li><li>底层（第0层）是硬件；最高的（N层）是用户界面</li><li>通过模块化，层的选择使得每个层只使用较低层的功能（操作）和服务<ol type="1"><li>上一层只能使用下一层的功能</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220926154322875.png" alt="image-20220926154322875" style="zoom:50%;"/></p></li><li><p>Monolithic Kernels Structure：单/宏内核结构</p><p><img src="/images/AssetMarkdown/image-20220926154624778.png" alt="image-20220926154624778" style="zoom:80%;" /></p><ol type="1"><li>内核的整个代码都打包到一个文件中</li><li>每个函数都可以访问内核的所有其他部分</li><li>最早和最常见的操作系统体系结构（UNIX）</li><li>操作系统的每个组件都包含在内核中</li><li>示例：OS/360、VMS和Linux</li><li>优点：高效</li><li>缺点：很难定位问题，很难修改和维护，内核会变得越来越大</li></ol><p><img src="/images/AssetMarkdown/image-20220926155006512.png" alt="image-20220926155006512" style="zoom:80%;" /></p></li><li><p>Microkernel：微内核，只保留必要的程序，在内核模式中运行的程序</p><ol type="1"><li><p>只有最基本的功能由内核实现</p></li><li><p>所有其它功能委托给一些独立进程实现，这些进程通过明确定义的通信接口与中心内核通信</p></li><li><p>系统的各个部分彼此都很清楚的划分开来，同时也迫使程序员使用“清洁的”程序设计技术</p></li><li><p>优点：动态可扩展性、在运行时切换重要组件</p></li><li><p>缺点：在各个组件之间支持复杂通信需要额外的CPU时间</p><p><img src="/images/AssetMarkdown/image-20220929163127806.png" alt="image-20220929163127806" style="zoom:80%;" /></p></li><li><p>现有的系统多使用微内核结构</p><p><img src="/images/AssetMarkdown/image-20220929163258312.png" alt="image-20220929163258312" style="zoom:80%;" /></p></li></ol></li><li><p>Modules：模块</p><ol type="1"><li>大多数现代操作系统实现kernel modules(内核模块）<ol type="1"><li>使用面向对象的方法</li><li>每个核心组件都是独立的</li><li>每个人都通过已知接口与其他人交谈</li><li>每个都可以根据需要在内核中加载</li></ol></li><li>总体而言，与层相似，但更灵活</li></ol></li><li><p>Hybrid Systems：混合结构</p><ol type="1"><li>大多数现代操作系统实际上不是一个纯模型</li><li>Hybrid System结合了多种方法来满足性能、安全性和可用性需求</li></ol></li><li><p>Virtual Machines：虚拟机</p><ol type="1"><li>虚拟机采用分层方法得出其逻辑结论。它将硬件和操作系统内核视为硬件</li><li>虚拟机提供与底层裸硬件相同的接口</li><li>操作系统主机会产生一种错觉，认为进程有自己的处理器和（虚拟内存）</li><li>为每位host提供一份底层计算机的（虚拟）副本</li><li>虚拟机软件：VMWARE、VirtualBox、Microsoft virtual PC</li><li>开放堆栈云计算平台</li></ol></li></ol><h1 id="chapter-3processes">Chapter 3：Processes</h1><h2 id="进程的概念">3.1 进程的概念</h2><h3 id="进程">3.1.1 进程</h3><p>进程：一个正在执行的程序，独立的，有权获取资源的</p><ol type="1"><li>计算机的基本工作单位</li><li>jobs作业=user programs用户程序=tasks任务=process进程</li><li>包含一些资源的指令容器：例如CPU时间（CPU执行指令）、内存、文件、完成其任务的I/O设备</li><li>示例：<ol type="1"><li>编译进程</li><li>字处理进程</li><li>调度程序进程(scheduler processes)：sched、swapper</li><li>守护进程(daemon process)：ftpd、httpd</li></ol></li></ol><h3 id="内存中的进程">3.1.2 内存中的进程</h3><ol type="1"><li>程序代码，也被称为text section</li><li>PC：Program Counter</li><li>Register</li><li>Data section：全局变量</li><li>Stack：临时变量</li><li>Heap：动态开辟的内存</li></ol><p><img src="/images/AssetMarkdown/image-20220929172319297.png" alt="image-20220929172319297" style="zoom:80%;" /></p><h3 id="进程状态">3.1.3 进程状态</h3><ol type="1"><li><strong>New</strong>(新)：创建进程，在内存中开辟一段空间给进程</li><li><strong>Running</strong>(运行、执行)： 进程正在使用CPU</li><li><strong>Ready</strong>(就绪)：进程可以使用CPU</li><li><strong>Waiting</strong>(等待、blocked阻塞)：进程等待一些事件的发生</li><li><strong>Terminated</strong>(终止)：进程停止执行</li></ol><h3 id="进程状态的切换">3.1.4 进程状态的切换</h3><ol type="1"><li>程序：系统调用</li><li>操作系统：调度</li><li>外部程序：中断</li><li>只有ready状态才能转换到running状态</li><li>三个基本状态之间可能转换和转换原因如下：<ol type="1"><li>ready→running：当<strong>处理器空闲</strong>时，进程调度程序必将处理机分配给一个处于ready状态的进程，该进程便由ready状态转换为running状态</li><li>running→waiting：处于running状态的进程在运行过程中需要<strong>等待某一事件</strong>发生后（例如因I/O请求等待I/O完成后），才能继续运行，则该进程放弃处理器，从running状态转换为waiting状态</li><li>waiting→ready：处于waiting状态的进程，若其<strong>等待的事件已经发生</strong>，于是进程由waiting状态转换为ready状态。</li><li>running→ready：处于running状态的进程在其运行过程中，因分给它的<strong>处理器时间片已用完</strong>，而不得不让出（被抢占）处理器，于是进程由running态转换为ready态。</li><li>waiting→running，ready→waiting这二种状态转换一般不可能发生</li></ol></li><li>处于running状态进程：如系统有一个处理器，则在任何一时刻，最多只有一个进程处于运行状态。</li><li>处于ready状态进程：一般处于就绪状态的进程按照一定的算法（如先来的进程排在前面，或采用优先权高的进程排在前面）排成一个就绪队列。</li><li>处于waiting状态进程：处于等待状态的进程排在等待队列中。由于等待事件原因不同，等待队列也可以按事件分成几个队列。</li></ol><p><img src="/images/AssetMarkdown/image-20220929172953173.png" alt="image-20220929172953173" style="zoom:80%;" /></p><p>例：</p><p><img src="/images/AssetMarkdown/image-20220929174356541.png" alt="image-20220929174356541" style="zoom:80%;" /></p><h3 id="进程与程序的区别">3.1.5 进程与程序的区别</h3><ol type="1"><li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行</li><li><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存</li><li><strong>进程与程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（即进程状态信息）</li><li><strong>进程与程序的对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li></ol><h3 id="pcb-进程控制块">3.1.6 PCB 进程控制块</h3><ol type="1"><li>每个进程在操作系统内用<strong>进程控制块(Process ControlBlock)</strong>来表示，它包含与特定进程相关的许多信息：<ol type="1"><li>Process state：进程状态</li><li>Program counter：当前进程执行到的位置</li><li>CPU registers：CPU中的寄存器</li><li>CPU scheduling information：CPU的调度信息</li><li>Memory-management information：内存管理信息</li><li>Accounting information：统计信息</li><li>File management ：文件管理信息</li><li>I/O status information：输入/输出状态信息</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20220929174647830.png" alt="image-20220929174647830" style="zoom:80%;" /></p><h2 id="process-scheduling-进程调度">3.2 Process Scheduling进程调度</h2><h3 id="scheduling-queue-调度队列">3.2.1 Scheduling Queue 调度队列</h3><ol type="1"><li><strong>Job queue</strong>作业队列：系统中所有进程的集合</li><li><strong>Readyqueue</strong>就绪队列：驻留在主存中、就绪并等待执行的所有进程的集合</li><li><strong>Device queue</strong>设备队列：等待I/O设备的一组进程</li></ol><blockquote><p>进程会在不同队列之间迁移</p></blockquote><p><img src="/images/AssetMarkdown/image-20221008164644057.png" alt="image-20221008164644057" style="zoom:80%;" /></p><blockquote><p>进程调度的表示</p></blockquote><p><img src="/images/AssetMarkdown/image-20221008165059638.png" alt="image-20221008165059638" style="zoom:80%;" /></p><h3 id="schedulers-调度器">3.2.2 Schedulers 调度器</h3><ol type="1"><li><strong>Long-term scheduler / job scheduler</strong>：长程调度 /作业调度<ol type="1"><li>控制ready queue的长度：选择应加入ready queue的进程</li><li>调用的频率很低，基本上以秒/分钟为单位</li><li>控制多道程序设计<strong>multiprogramming</strong>的程度</li><li>大多数现代操作系统没有长期调度程序（如Windows、UNIX、Linux）</li></ol></li><li><strong>Short-term scheduler / CPU scheduler</strong>：短程调度 /CPU调度<ol type="1"><li>选择ready queue中的哪一个进程能够进入CPU</li><li>调用的频率很好高，基本上以毫秒为单位</li></ol></li><li><strong>Medium-Term Scheduler</strong>：中程调度<ol type="1"><li>将一些进程从内存中临时移出，从而减少调度器须要处理进程的数目</li><li>这样将进程移出内存的机制叫做<strong>换出(Swapping)</strong></li><li>按需调用，可以关闭中程调度</li></ol></li><li>进程可以被分为：<ol type="1"><li>I/O-boundprocess：I/O型进程，需要做很多的I/O操作，有很多的CPU中断</li><li>CPU-bound process：CPU型进程，需要很多的计算</li></ol></li></ol><h3 id="context-switch-上下文切换">3.2.3 Context Switch 上下文切换</h3><ol type="1"><li>当CPU切换到另一个进程时，系统必须保存旧进程的状态，并通过<strong>上下文切换(ContextSwitch)</strong>加载新进程的保存状态</li><li>上下文切换时间开销大；系统在切换时没有任何有用的工作</li><li>时间取决于硬件支持</li></ol><p><img src="/images/AssetMarkdown/image-20221008170551322.png" alt="image-20221008170551322" style="zoom:80%;" /></p><h3 id="移动端的多任务">3.2.4 移动端的多任务</h3><ol type="1"><li>由于屏幕的实际情况，iOS的用户界面限制了<ol type="1"><li>单个前台进程：通过用户界面控制</li><li>多个后台进程：内存中、正在运行，但不在显示器上，并且有限制</li><li>限制包括单个、短任务、接收事件通知、特定的长时间运行任务，如音频播放</li></ol></li><li>Android运行前台和后台，限制更少<ol type="1"><li>后台进程使用服务执行任务</li><li>即使后台进程挂起，服务也可以继续运行</li><li>服务没有用户界面，占用内存少</li></ol></li></ol><h2 id="operations-on-process-进程的操作">3.3 Operations on Process进程的操作</h2><h3 id="process-creation-进程创建">3.3.1 Process Creation 进程创建</h3><ol type="1"><li><p>父进程创建子进程，子进程又创建其他进程，形成进程树</p></li><li><p>通常，通过进程标识符(<strong>processidentifier，pid</strong>)识别和管理进程</p></li><li><p>资源共享：</p><ol type="1"><li>父进程和子进程共享所有资源</li><li>子进程共享父进程资源的子集</li><li>父进程和子进程不共享资源</li></ol></li><li><p>执行：</p><ol type="1"><li>父进程和子进程同时执行</li><li>父进程一直等到子进程结束</li></ol></li><li><p>地址空间：</p><ol type="1"><li>子进程是父进程的副本</li><li>子进程已经加载进了一段程序</li></ol></li><li><p>例：UNIX</p><ol type="1"><li><strong>fork()</strong>：系统调用，用于创建一个新的进程<ol type="1"><li>int pid1 = fork();</li><li>父进程使用fork创建子进程时，子进程会生成一份父进程的备份，除了返回值之外，两者完全一样</li><li>从系统调用fork中返回时，两个进程除了返回值pid1不同外，具有完全一样的用户级上下文</li><li><strong>在子进程中，pid1的值为0</strong></li><li><strong>在父进程中， pid1的值为子进程的进程号</strong></li></ol></li><li><strong>exec()</strong>：系统调用，用于在fork之后调用新程序，替换进程的内存空间</li><li><strong>exit()</strong>：系统调用，终止子进程，并给父进程返回参数</li></ol><p><img src="/images/AssetMarkdown/image-20221008172736560.png" alt="image-20221008172736560" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221008172903009.png" alt="image-20221008172903009" style="zoom:80%;" /></p></li></ol><blockquote><p>C语言代码示例：进程的创建过程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[ ])</span>&#123; </span><br><span class="line">    <span class="type">int</span> pid1 = fork();  <span class="comment">// fork一个子进程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid1 &lt; <span class="number">0</span>)&#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid1==<span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 子进程执行, 因为子进程的fork返回的是0</span></span><br><span class="line">        execlp(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 父进程执行, 因为父进程的fork返回的是子进程的pid</span></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 阻塞父进程, 直到子进程执行完成</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child Complete&quot;</span>);                      </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="process-termination-进程终止">3.3.2 Process Termination进程终止</h3><ol type="1"><li>引起进程终止的事件<ol type="1"><li>正常结束</li><li>异常结束</li><li>外界干预</li></ol></li><li>进程执行完最后一条指令后，会询问操作系统如何终止它<ol type="1"><li>从子进程向父进程输出数据</li><li>操作系统释放该进程的数据</li></ol></li><li>如果父进程被终止，那么子进程会发生：<ol type="1"><li>有些操作系统不会让子进程继续运行</li><li>子进程通过<strong>cascading termination</strong>终止运行</li><li>子进程被过继到另一个父进程</li></ol></li><li>移动端操作系统<ol type="1"><li>会因为系统资源不够，而终止一些进程</li><li>此时要有一个进程的优先级排序，从重要到不重要，排序如下：<ol type="1"><li>前端进程</li><li>可见进程</li><li>服务进程</li><li>后台进程</li><li>空进程</li></ol></li><li>Android会优先终止最不重的进程</li></ol></li></ol><h2 id="ipcinterprocess-communication-进程通信">3.4 IPC：InterprocessCommunication 进程通信</h2><ol type="1"><li><p><strong>IndependentProcess</strong>：独立进程，不被其它进程的执行影响，也不能影响其它进程的执行</p></li><li><p><strong>CooperatingProcess</strong>：合作进程，可以其它进程的执行影响，也可以影响其它进程的执行</p><ol type="1"><li>优点：<ol type="1"><li>信息共享</li><li>加速计算</li><li>模块化</li><li>更加便捷</li></ol></li><li>需要<strong>IPC</strong>：Interprocess Communication，进程通信</li></ol></li><li><p><strong>IPC</strong>的两种模式</p><ol type="1"><li>共享内存</li><li>消息传递</li></ol><p><img src="/images/AssetMarkdown/image-20221008174950771.png" alt="image-20221008174950771" style="zoom:80%;" /></p></li><li><p>通信类型：</p><ol type="1"><li>直接通信<ol type="1"><li><strong>send(P, message)</strong>：直接发消息给进程P</li><li><strong>receive(Q, message)</strong>：直接接收来自进程Q的消息</li></ol></li><li>间接通信<ol type="1"><li><strong>send(A, message)</strong>：发送消息给邮件服务器A</li><li><strong>receive(A, message)</strong>：从邮件服务器A接收消息</li></ol></li></ol></li><li><p>常用通信机制：</p><ol type="1"><li>信号(signal)：进程发送信号</li><li>共享存储区(shared memory)：不同进程共享一段空间，进行通信</li><li>管道(pipe)：进程间通过一种操作将结果传输过去</li><li>消息(message)</li><li>套接字(socket)</li></ol></li></ol><h3 id="linux进程通信机制">3.4.1 Linux进程通信机制</h3><p>Linux实现进程间通信(<strong>IPC</strong> Inter ProcessCommunication)：</p><ol type="1"><li>System V IPC机制:<ol type="1"><li>信号量：保证不同进程得到的信息是一样的</li><li>消息队列、</li><li>共享内存</li></ol></li><li>管道（pipe）、命名管道</li><li>套接字（socket）</li><li>信号( signal )</li><li>文件锁(file lock)</li><li>POSIX线程：<ol type="1"><li>互斥锁(互斥体、互斥量)（mutex）、条件变量(condition variables)</li></ol></li><li>POSIX：<ol type="1"><li>消息队列、信号、共享内存</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221010144032973.png" alt="image-20221010144032973" style="zoom:80%;" /></p><h3 id="windows-进程线程通信机制">3.4.2 Windows 进程线程通信机制</h3><ol type="1"><li>基于文件映射的共享存储区</li><li>无名管道和命名管道<ol type="1"><li>server32pipe.c、client32pipe.c</li><li>启动多个client进程进行通信</li></ol></li><li>邮件槽</li><li>套接字</li><li>剪帖板(Clipboard)</li><li>信号</li><li>其他同步机制</li></ol><h2 id="ipcin-shared-memory-systems">3.5 IPC：in Shared-MemorySystems</h2><ol type="1"><li>希望通信的进程之间共享的内存区域</li><li>通信受用户进程的控制，而不是操作系统的控制</li><li>主要问题是：提供允许用户进程在访问共享内存时同步其操作的机制<ol type="1"><li>在第6、7章会讨论同步</li></ol></li><li>协同进程的并发执行需要允许进程相互通信并同步其操作的机制（第6章）。</li><li>合作过程的共同范式：Producer-ConsumerProblem(生产者-消费者问题）</li><li>生产者进程生成消费者进程使用的信息<ol type="1"><li>unbounded-buffer(无限缓冲区)：对缓冲区的大小没有实际限制。</li><li>bounded-buffer(有限缓冲区)：假设存在固定的缓冲区大小。</li></ol></li></ol><h3 id="bounded-buffershared-memory-solution">3.5.1Bounded-Buffer：Shared-Memory Solution</h3><ol type="1"><li><p><strong>Shared data</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;item;</span><br><span class="line"></span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>为了保证进程对共享空间的正确操作，只能使用<strong>BUFFER_SIZE-1</strong>的空间</p><ol type="1"><li>空间是一个循环队列</li></ol></li><li><p><strong>Producer</strong>：生产者，生成数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">item nextProduced;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    produce an item in nextProduced;</span><br><span class="line">    <span class="comment">// buffer中没有空位, 什么都不做</span></span><br><span class="line">    <span class="keyword">while</span> ((in + <span class="number">1</span>) % BUFFER_SIZE == out);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向buffer中添加一个item</span></span><br><span class="line">    buffer[in] = nextProduced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Consumer</strong>：消费者，使用数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">item nextConsumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// buffer中没有item, 什么都不做</span></span><br><span class="line">    <span class="keyword">while</span> (in == out);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从buffer中拿走一个item</span></span><br><span class="line">    nextConsumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    consume the item in nextConsumed ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="ipcin-message-passing-systems">3.6 IPC：in Message-PassingSystems</h2><ol type="1"><li>进程通信和同步其操作的机制</li><li>消息系统：流程之间无需借助共享变量即可进行通信</li><li>IPC设施提供两种操作：<ol type="1"><li><strong>send(message)</strong></li><li><strong>receive(message)</strong></li></ol></li><li>message的大小是固定的或可变的</li><li>如果进程P和Q想要沟通，他们需要：<ol type="1"><li>在他们之间建立通信联系</li><li>通过发送/接收交换message</li></ol></li><li>实现的任务：<ol type="1"><li>如何建立链接？</li><li>一个链接可以与两个以上的进程关联吗？</li><li>每对通信进程之间可以有多少个链接？</li><li>链路的容量是多少？</li><li>链接可以容纳的消息大小是固定的还是可变的？</li><li>链路是单向的还是双向的？</li></ol></li><li>通信链路的实现<ol type="1"><li>物理：<ol type="1"><li>共享内存</li><li>硬件总线</li><li>网络</li></ol></li><li>逻辑：<ol type="1"><li>直接或间接</li><li>同步或异步</li><li>自动或显式缓冲</li></ol></li></ol></li></ol><h3 id="direct-communication直接通信">3.6.1 DirectCommunication（直接通信）</h3><ol type="1"><li>进程必须明确命名：<ol type="1"><li><strong>send(P, message)</strong>：向进程P发送消息</li><li><strong>receive(Q, message)</strong>：从进程Q接收消息</li></ol></li><li>通信链路的属性<ol type="1"><li>自动建立链接</li><li>链接只与一对通信进程相关联</li><li>每对之间只有一条链路</li><li>链接可能是单向的，但通常是双向的</li></ol></li></ol><h3 id="indirect-communication间接通信">3.6.2 IndirectCommunication（间接通信）</h3><ol type="1"><li>message从mailbox（也称为port）定向和接收<ol type="1"><li>每个mailbox都有唯一的id</li><li>进程只有在共享mailbox时才能通信</li></ol></li><li>通信链路的属性<ol type="1"><li>仅当进程共享common mailbox时才建立链接</li><li>链接可能与许多进程关联</li><li>每对进程可以共享多个通信链路</li><li>链接可以是单向的或双向的</li></ol></li><li>操作<ol type="1"><li>创建新的mailbox(port)</li><li>通过mailbox发送和接收message</li><li>销毁mailbox</li></ol></li><li>基本操作：<ol type="1"><li><strong>send(A, message)</strong>：将消息发送到邮箱A</li><li><strong>receive(A, message)</strong>：从邮箱A接收消息</li></ol></li></ol><h3 id="synchronization同步">3.6.3 Synchronization同步</h3><ol type="1"><li>消息传递可以是阻塞的或非阻塞的</li><li>Blocking(阻塞)被认为是同步的<ol type="1"><li>Blocking send：发送方被阻止，直到确认消息被收到</li><li>Blocking receive：在消息可用之前，接收器被阻止</li></ol></li><li>Non-blocking(非阻塞)被认为是异步的<ol type="1"><li>Non-blocking send：发送方不断发送消息</li><li>Non-blockingreceive：接收器不断接收消息，可能是有效消息，也可能是Null消息</li></ol></li><li>可能的不同组合<ol type="1"><li>如果发送和接收都被是Blocking，称为完整性过程<strong>have arendezvous</strong></li></ol></li></ol><h3 id="buffering">3.6.4 Buffering</h3><ol type="1"><li>附加到链接的消息队列，以三种方式之一实施<ol type="1"><li>零容量<ol type="1"><li>链路上没有消息排队</li><li>发送方必须等待接收方接收完成后，才能再次发送消息</li></ol></li><li>容量有限<ol type="1"><li>n条消息的有限长度</li><li>如果链接已满，发送方必须等待</li></ol></li><li>无限容量<ol type="1"><li>无限长度</li><li>发送程序从不等待</li></ol></li></ol></li></ol><h3 id="实例">3.6.5 实例</h3><ol type="1"><li>例： 设计一个程序，要求<ol type="1"><li>用函数msgget创建消息队列</li><li>从键盘输入的字符串添加到消息队列</li><li>创建一个进程，使用函数msgrcv读取队列中的消息并在计算机屏幕上输出</li></ol></li><li>分析 ：<ol type="1"><li>程序先调用msgget函数创建、打开消息队列</li><li>接着调用msgsnd函数，把输入的字符串添加到消息队列中</li><li>子进程调用msgrcv函数，读取消息队列中的消息并打印输出</li><li>最后调用msgctl函数，删除系统内核中的消息队列</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msgfork.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体，定义消息的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msgmbuf</span>&#123;</span><br><span class="line">    <span class="type">long</span> msg_type;<span class="comment">//消息类型</span></span><br><span class="line">    <span class="type">char</span> msg_text[<span class="number">512</span>]; <span class="comment">//消息内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> qid,len;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msgmbuf</span> msg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用ftok函数，根据当前文件的目录，产生标准的key</span></span><br><span class="line">    <span class="keyword">if</span>((key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;a&#x27;</span>)) == <span class="number">-1</span>) &#123;   </span><br><span class="line">     <span class="built_in">perror</span>(<span class="string">&quot;产生标准key出错&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用msgget函数，创建、打开消息队列</span></span><br><span class="line">    <span class="keyword">if</span>((qid = <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;创建消息队列出错&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印输出队列号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建、打开的队列号是：%d\n&quot;</span>,qid);  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程PID=: %d 发送消息\n&quot;</span>,<span class="built_in">getpid</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;请输入要加入队列的消息：&quot;</span>); </span><br><span class="line">        <span class="comment">// 键盘输入的消息存入变量msg_text</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">fgets</span>((&amp;msg)-&gt;msg_text, <span class="number">512</span>, stdin)) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;没有消息&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.msg_type=<span class="built_in">getpid</span>();</span><br><span class="line">        len=<span class="built_in">strlen</span>(msg.msg_text);</span><br><span class="line">        <span class="comment">// 调用msgsnd函数，添加消息到消息队列</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">msgsnd</span>(qid,&amp;msg,len,<span class="number">0</span>))&lt;<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;添加消息出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程PID=：%d 接收消息\n&quot;</span>,<span class="built_in">getpid</span>())</span><br><span class="line">        <span class="comment">// 调用msgrcv函数，从消息队列读取消息</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">msgrcv</span>(qid,&amp;msg,<span class="number">512</span>,<span class="number">0</span>,<span class="number">0</span>))&lt;<span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;读取消息出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 打印输出消息内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取的消息是：%s\n&quot;</span>,(&amp;msg)-&gt;msg_text); </span><br><span class="line">        <span class="comment">// 调用msgctl函数，删除系统中的消息队列</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">msgctl</span>(qid,IPC_RMID,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;删除消息队列出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分成两个独立的程序：msgsnd.c,msgrcv.c。分别编译和运行</p></blockquote><p><img src="/images/AssetMarkdown/image-20221010154723335.png" alt="image-20221010154723335" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221010154729917.png" alt="image-20221010154729917" style="zoom:80%;" /></p><h2 id="ipcexample">3.7 IPC：example</h2><h3 id="windows">3.7.1 Windows</h3><ol type="1"><li>通过高级本地过程调用（LPC）功能以消息传递为中心<ol type="1"><li>仅在同一系统上的进程之间工作</li><li>使用端口（如邮箱）建立和维护通信通道</li><li>通信工作如下：<ol type="1"><li>客户端打开子系统连接端口对象的句柄</li><li>客户端发送连接请求</li><li>服务器创建两个专用通信端口，并将其中一个端口的句柄返回客户端</li><li>客户端和服务器使用相应的端口句柄发送消息或回调，并侦听回复</li></ol></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221013162834236.png" alt="image-20221013162834236" style="zoom:80%;" /></p><h3 id="pipe-管道通信">3.7.2 Pipe 管道通信</h3><ol type="1"><li>充当允许两个进程通信的管道</li><li>问题：<ol type="1"><li>通信是单向的还是双向的？</li><li>在双向通信的情况下，是半双工还是全双工？（在工作时是否有一端读或写？）</li><li>沟通过程之间必须存在关系（即父子关系）吗？</li><li>管道可以通过网络使用吗？</li></ol></li><li><strong>Ordinarypipes</strong>普通管道：无法从创建它的流程外部访问。通常，父进程创建个管道，并使用它与它创建的子进程通信。</li><li><strong>Namedpipes</strong>命名管道：可以在没有父子关系的情况下访问。</li></ol><h4 id="ordinary-pipes">3.7.2.1 Ordinary pipes</h4><ol type="1"><li>普通管道允许以标准 <strong>生产者-消费者</strong> 的形式进行通信<ol type="1"><li>生产者写入一端（管道的写入端<strong>write-end</strong>）</li><li>消费者从另一端（管道的读取端<strong>read-end</strong>）读取</li></ol></li><li>因此，普通管道是<strong>单向的</strong></li><li>需要沟通流程之间的<strong>父子关系</strong></li><li>Windows调用这些匿名管道<strong>anoymous pipes</strong></li></ol><h4 id="named-pipes">3.7.2.2 Named pipes</h4><ol type="1"><li>命名管道比普通管道更强大</li><li>通信是<strong>双向的</strong></li><li>沟通过程之间<strong>不需要父子关系</strong></li><li>多个进程可以使用命名管道进行通信</li><li>在UNIX和Windows系统上提供</li></ol><h2 id="communication-in-clientserver-systems">3.8 Communication inClient–Server Systems</h2><h3 id="socket-套接字">3.8.1 Socket 套接字</h3><ol type="1"><li><strong>Socket</strong>被定义为通信的端点</li><li>IP地址和端口串联：消息包开头包含的数字，用于区分主机上的网络服务</li><li><strong>socket</strong><strong>161.25.19.8:1625</strong>指：主机<strong>161.25.119.8</strong>上的端口<strong>1625</strong></li><li>通信由一对<strong>socket</strong>组成</li><li><strong>1024</strong>以下的所有端口都是众所周知的，用于标准服务</li><li>特殊IP地址<strong>127.0.0.1</strong>（loopback），用于指运行进程的系统</li></ol><p><img src="/images/AssetMarkdown/image-20221013163733736.png" alt="image-20221013163733736" style="zoom:67%;" /></p><h3 id="remote-procedure-calls-远过程调用">3.8.2 Remote Procedure Calls远过程调用</h3><ol type="1"><li><strong>Remote ProcedureCalls</strong>(<strong>RPC</strong>，远过程调用)：抽象网络系统上进程之间的过程调用<ol type="1"><li>再次使用端口来区分服务</li></ol></li><li>存根<strong>stubs</strong>：服务器上实际过程的客户端代理</li><li>客户端存根<strong>The client-sidestub</strong>：定位服务器并整理(marshalls)参数</li><li>服务器端存根<strong>The server-sidestub</strong>：接收此消息，解压缩编组参数，并在服务器上执行过程</li><li>在Windows上，stub代码根据用Microsoft接口定义语言(<strong>MIDL</strong>)编写的规范编译</li><li>通过外部数据表示(<strong>XDL</strong>，External DataRepresentation)格式处理数据表示，以考虑不同的体系结构<ol type="1"><li>大端和小端</li></ol></li><li>远程通信比本地通信有更多的故障情况<ol type="1"><li>消息只能传递确定的一次，而不能最多传递一次</li></ol></li><li>操作系统通常提供<strong>rendezvous /matchmaker</strong>服务来连接客户端和服务器</li><li>Android RPC的执行过程：</li></ol><p><img src="/images/AssetMarkdown/image-20221013164324392.png" alt="image-20221013164324392" style="zoom:80%;" /></p><h1 id="chapter-4threads-concurrency">Chapter 4：Threads &amp;Concurrency</h1><h2 id="overview">4.1 Overview</h2><p><img src="/images/AssetMarkdown/image-20221013165603587.png" alt="image-20221013165603587" style="zoom:67%;" /></p><p>进程：</p><ol type="1"><li>资源拥有单位：<ol type="1"><li>给每个进程分配一虚拟地址空间</li><li>保存进程映像</li><li>控制一些资源（文件，I/O设备）</li><li>有状态、优先级、调度</li></ol></li><li>调度单位：<ol type="1"><li>进程是由一个或多个程序的一次执行</li><li>可能会与其他进程交替执行</li></ol></li></ol><h3 id="线程thread的概念">4.1.1 线程Thread的概念</h3><ol type="1"><li><strong>进程</strong>：资源的<strong>拥有单元</strong>称为进程 /任务</li><li><strong>线程</strong>：资源的<strong>调度单位</strong>称为线程 /轻型进程(light weight process)<ol type="1"><li>线程只拥有在运行中必不可省的资源(PC、register、stack)</li><li>但它可与同属一个进程的其它线程共享进程拥有的全部资源</li></ol></li></ol><p>线程定义为：进程内一个<strong>执行单元</strong>或一个<strong>可调度实体</strong></p><ol type="1"><li>有执行状态（状态转换）</li><li>不运行时保存上下文</li><li>有一个执行栈</li><li>有一些局部变量的静态存储</li><li>可存取所在进程的内存和其他资源</li><li>可以创建、撤消另一个线程</li></ol><h3 id="线程的特点">4.1.2 线程的特点</h3><ol type="1"><li>不拥有<strong>系统资源</strong>（只拥有少量的资源，资源是分配给进程）</li><li>一个进程中的多个线程可并发执行（进程可创建线程执行同一程序的不同部分）</li><li>系统开销小、切换快。（进程的多个线程都在进程的地址空间活动）</li></ol><h3 id="线程的优点">4.1.3 线程的优点</h3><ol type="1"><li><strong>创建一个新线程</strong>花费时间少（结束亦如此）</li><li><strong>两个线程的切换</strong>花费时间少<ol type="1"><li>如果机器设有 “存储[恢复]所有寄存器”指令，则整个切换过程用几条指令即可完成</li></ol></li><li>因为同一进程内的<strong>线程共享内存和文件</strong>，因此它们之间相互通信无须调用内核</li><li>适合<strong>多处理机</strong>系统</li></ol><h3 id="线程的使用案例">4.1.4 线程的使用案例</h3><ol type="1"><li>LAN中的一个文件服务器，在一段时间内需要处理几个文件请求<ol type="1"><li>有效的方法是：为每一个请求创建一个线程</li><li>在一个SMP机器上：多个线程可以同时在不同的处理器上运行</li></ol></li><li>一个线程显示菜单，并读入用户输入；另一个线程执行用户命令<ol type="1"><li>考虑一个应用：由几个独立部分组成，这几个部分不需要顺序执行，则每个部分可以以线程方式实现</li><li>当一个线程因I/O阻塞时，可以切换到同一应用的另一个线程</li></ol></li></ol><h2 id="多核编程">4.2 多核编程</h2><ol type="1"><li><p>多核系统给程序员带来新的挑战：</p><ol type="1"><li>划分活动</li><li>负载均衡：保证任务的计算量尽量均衡</li><li>数据拆分</li><li>数据依赖性</li><li>测试和调试</li></ol></li><li><p>多线程服务端结构</p><ol type="1"><li>服务端、客户端各自是一个进程</li><li>当有请求时，服务端创建一个线程，处理请求</li></ol><p><img src="/images/AssetMarkdown/image-20221013173723379.png" alt="image-20221013173723379" style="zoom:67%;" /></p></li><li><p>多核系统的并行执行：</p><p><img src="/images/AssetMarkdown/image-20221013173753691.png" alt="image-20221013173753691" style="zoom:67%;" /></p></li></ol><h2 id="multithreading-models">4.3 Multithreading Models</h2><p>线程的实现机制：</p><ol type="1"><li>用户级线程 user-level thread</li><li>内核级线程 kernel-level thread</li><li>两者结合方法</li></ol><h3 id="user-threads-用户级线程">4.3.1 User Threads 用户级线程</h3><ol type="1"><li>用户级线程：<ol type="1"><li>不依赖于OS核心（内核不了解用户线程的存在）</li><li>应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程</li><li>如：数据库系统informix、图形处理Aldus PageMaker</li><li><strong>调度</strong>由<strong>应用软件</strong>内部进行，通常采用非抢先式和更简单的规则，也无需用户态/核心态切换，所以速度特别快</li><li>一个线程发起系统调用而阻塞，则整个进程在等待。</li></ol></li><li>特点：<ol type="1"><li>用户线程的维护由应用进程完成</li><li>内核不了解用户线程的存在</li><li>用户线程切换不需要内核特权</li><li>用户线程调度算法可针对应用优化</li><li>一个线程发起系统调用而阻塞，则整个进程在等待（多对一模型中）</li></ol></li><li>三个主要的线程库(创建用户级线程)<ol type="1"><li>POSIX Pthreads 、 Win32 threads、 Java threads</li></ol></li></ol><h3 id="kernel-threads-内核级线程">4.3.2 Kernel Threads 内核级线程</h3><ol type="1"><li>内核级线程：<ol type="1"><li>依赖于OS内核，由内核的内部需求进行创建和撤销，用来执行一个指定的函数</li><li>一个线程发起系统调用而阻塞，不会影响其他线程</li><li>时间片分配给线程，所以多线程的进程获得更多CPU时间</li></ol></li><li>特点：<ol type="1"><li>内核维护进程和线程的上下文信息</li><li><strong>线程切换由内核完成</strong></li><li>时间片分配给线程，所以多线程的进程获得更多CPU时间<ol type="1"><li>如1个进程拥有10个线程，4个进程各自拥有1个线程，则CPU会对这14个线程进行分配资源</li></ol></li><li>一个线程发起系统调用而阻塞，不会影响其他线程的运行</li></ol></li><li>Examples<ol type="1"><li>Windows XP/2000 及以后</li><li>Solaris</li><li>Linux</li><li>Mac OS X</li></ol></li></ol><h3 id="many-to-one-多个用户线程-一个内核线程">4.3.3 Many-to-One多个用户线程, 一个内核线程</h3><p>多个用户级线程 映射到 单个内核线程</p><ol type="1"><li><p>由用户级运行库实现</p><ol type="1"><li>在用户级别创建、调度和同步线程</li></ol></li><li><p>操作系统不知道用户级线程</p><ol type="1"><li>操作系统认为<strong>每个进程</strong>只包含<strong>一个控制线程</strong></li></ol></li><li><p>示例：</p><ol type="1"><li>Solaris Green Threads</li><li>GNU Portable Threads</li></ol></li><li><p>优点：</p><ol type="1"><li>不需要操作系统支持，全部在用户态模式进行</li><li>可以由用户自己设定调整调度策略，以满足应用程序需求</li><li>由于没有系统调用，因此降低了线程操作的开销</li></ol></li><li><p>缺点：</p><ol type="1"><li>无法利用多处理器，不是没有真正并行，而是在多个用户级线程之间进行轮转</li><li>当一个线程阻塞时，整个进程块也会阻塞</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221013174811066.png" alt="image-20221013174811066" style="zoom:50%;" /></p><h3 id="one-to-one-一个用户线程-一个内核线程">4.3.4 One-to-One一个用户线程, 一个内核线程</h3><p>每个用户级线程 都映射到 内核线程</p><ol type="1"><li>操作系统为每个用户级线程提供一个内核线程</li><li>每个内核线程独立调度</li><li>操作系统执行的线程操作（创建、调度、同步）</li><li>示例<ol type="1"><li>Windows NT/XP/2000操作系统</li><li>Linux操作系统</li><li>Solaris 9及更高版本</li></ol></li><li>优点：<ol type="1"><li>每个内核线程在多处理器中，均可平行执行</li><li>当一个线程阻塞时，其它线程还能被正常调度</li></ol></li><li>缺点：<ol type="1"><li>线程间的操作消耗过大</li><li>操作系统会随着线程数目的增加而变大</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221017143430515.png" alt="image-20221017143430515" style="zoom: 50%;" /></p><h3 id="many-to-many-多个用户线程-多个内核线程">4.3.5 Many-to-Many多个用户线程, 多个内核线程</h3><p>将多个用户级线程 映射到 多个内核线程</p><ol type="1"><li>允许操作系统创建足够数量的内核线程</li><li>示例：<ol type="1"><li>Solaris版本9之前的版本</li><li>带有ThreadFiber软件包的Windows NT/2000</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221017143735468.png" alt="image-20221017143735468" style="zoom:50%;" /></p><h3 id="two-level-model-两级模型">4.3.6 Two-level Model 两级模型</h3><p><img src="/images/AssetMarkdown/image-20221017143852109.png" alt="image-20221017143852109" style="zoom:80%;" /></p><ol type="1"><li><strong>Solaris</strong>的多线程是与传统UNIX调度模型相区别的主要特征</li><li><strong>LWP</strong>：每个进程内的内核线程的虚拟执行环境<ol type="1"><li><strong>LWP</strong>允许进程内的内核线程互相独立地进行系统调用</li><li>如果没有<strong>LWP</strong>，一次就只能进行一次系统调用</li><li>每次的系统调用由一个线程来引发，它的寄存器会被放在<strong>LWP</strong>的堆栈里面，等它返回的时候，系统调用返回代码也会被放在<strong>LWP</strong>里面</li></ol></li><li><strong>M-N</strong>的<strong>优点</strong>：<ol type="1"><li>快速的用户线程创建和删除</li><li>线程同步不需要系统调用</li><li>快速的用户线程上下文切换</li></ol></li><li><strong>M-N</strong>的<strong>缺点</strong>：<ol type="1"><li>复杂的编程模型</li><li>信号处理的问题</li></ol></li><li><strong>1-1</strong>模型的<strong>优点</strong>：<ol type="1"><li>每个用户级线程都有一个lwp和一个 kthread 相对应</li><li>只有内核级的线程调度</li><li>线程创建和删除、线程同步的开销大</li><li>线程调度和同步更到位</li></ol></li></ol><h3 id="solaris用户线程内核线程lwp三者之间的关系">4.3.7Solaris用户线程、内核线程、LWP三者之间的关系</h3><p><img src="/images/AssetMarkdown/image-20221017144240018.png" alt="image-20221017144240018" style="zoom:80%;" /></p><ol type="1"><li>对于一个用户进程来说，它的每个线程分成两个部分，一个部分是用户态下的部分，一个是系统态下的部分，也就是用户线程和内核线程</li><li>一个线程在用户态下执行的时候，运行的是用户线程的代码，而当发生系统调用的时候，就由内核线程来执行内核代码</li><li>在<strong>Solaris</strong>的线程模型中，<strong>每一个用户线程对应一个内核线程</strong>，这种对应通过<strong>lwp</strong>来体现。</li><li>所用的内核线程串成一个双向循环链表，可以通过进程的<strong>proc</strong>结构中的<strong>p_tlist</strong>字段找到这个链表</li><li>每一个<strong>lwp</strong>用<strong>_klwp</strong>数据结构表示，每个内核线程用一个<strong>_kthread</strong>结构表示，<strong>_kthread</strong>结构中有一个字段<strong>t_lwp</strong>指向它所对应的**_klwp**结构。</li><li>用户线程用<strong>ulwp</strong>表示，<strong>ulwp</strong>与**_kthread<strong>的对应不是用指针来表示的，而是通过</strong>线程id**<ol type="1"><li><strong>ulwp</strong>，**_kthread<strong>和</strong>_klwp<strong>中都有一个字段表示</strong>线程的id<strong>，通过</strong>id**它们就可以一一对应起来</li></ol></li></ol><h2 id="thread-libraries-线程库">4.4 Thread Libraries 线程库</h2><ol type="1"><li>线程库为程序员提供了创建和管理线程的API</li><li>实施的两种主要方式<ol type="1"><li><strong>没有内核支持的库</strong>：代码和数据结构都在用户空间，只导致用户空间中本地函数调用（而不是系统调用）</li><li><strong>由操作系统直接支持的内核级库</strong>：代码和数据结构都在内核空间，通常导致系统调用</li></ol></li></ol><h3 id="pthread">4.4.1 Pthread</h3><ol type="1"><li><p>可以作为用户级或内核级提供</p></li><li><p>用于线程创建和同步的<strong>POSIX</strong>(Portable OperatingSystem Interface，便携式操作系统接口)标准（IEEE 1003.1c）API</p><p>http://standards.ieee.org/reading/ieee/stad_public/description/posix</p></li><li><p>API指定线程库的行为，实现取决于库的开发</p></li><li><p>在UNIX操作系统（Solaris、Linux、Mac OS X）中常见</p></li></ol><h3 id="java-threads">4.4.2 Java Threads</h3><ol type="1"><li><strong>Java</strong>线程由<strong>JVM</strong>管理</li><li>通常使用底层OS提供的线程模型实现</li><li><strong>Java线程</strong>可以通过以下方式创建：<ol type="1"><li><strong>extend</strong> 线程类</li><li>实现<strong>Runnable</strong>接口</li></ol></li></ol><h2 id="implicit-threading-隐私多线程">4.5 Implicit Threading隐私多线程</h2><ol type="1"><li>多核系统多线程编程，一个应用程序有可能有几百个甚至上千的线程，这样的程序面临许多挑战<ol type="1"><li>编程挑战：任务分解、任务的工作量平衡、数据分割、数据依赖、测试与调试</li><li>程序执行顺序的正确性问题：同步、互斥</li></ol></li><li><strong>策略</strong>：隐私线程<strong>ImplicitThreading</strong>，当前一种流行趋势<ol type="1"><li>将线程的创建与管理交给编译器和运行时库来完成</li></ol></li><li>几种隐私线程的设计方法：<ol type="1"><li><strong>Thread Pools</strong>：线程池</li><li><strong>Fork Join</strong></li><li><strong>OpenMP</strong>：用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案<ol type="1"><li>OpenMP支持的编程语言包括C、C++和Fortran。</li></ol></li><li><strong>Grand Central Dispatch</strong>(GCD，大中央调度)<ol type="1"><li>Apple for its macOS and iOS operating systems.</li></ol></li><li><strong>Intel Thread Building Blocks</strong>(TBB)：<ol type="1"><li>Intel开发的构建多线程库，open source</li><li>TBB是一个可移植的C++库，能够运行在Windows、Linux、Macintosh以及UNIX等系统上</li></ol></li><li>Java</li></ol></li></ol><h3 id="thread-pool-线程池">4.5.1 Thread Pool 线程池</h3><ol type="1"><li>预先创建出一系列线程，然后分配</li><li>线程池中如果没有空余线程，则需要等待</li></ol><h3 id="fork-join-parallelism">4.5.2 Fork-Join Parallelism</h3><p><img src="/images/AssetMarkdown/image-20221017145526083.png" alt="image-20221017145526083" style="zoom:80%;" /></p><ol type="1"><li><p>主线程将任务分为多个子任务<strong>fork</strong>，然后再合并到主线程<strong>join</strong></p></li><li><p>伪代码</p><p><img src="/images/AssetMarkdown/image-20221017145725008.png" alt="image-20221017145725008" style="zoom:67%;" /></p></li><li><p>这一过程可以递归的进行</p><p><img src="/images/AssetMarkdown/image-20221017145747384.png" alt="image-20221017145747384" style="zoom: 67%;" /></p></li><li><p>示例：</p><blockquote><ol type="1"><li>The <strong>ForkJoinTask</strong> is an abstract base class</li><li><strong>RecursiveTask</strong> and <strong>RecursiveAction</strong>classes extend <strong>ForkJoinTask</strong></li><li><strong>RecursiveTask</strong> returns a result (via the returnvalue from the <strong>compute()</strong> method)</li><li><strong>RecursiveAction</strong> does not return a result</li></ol><p><img src="/images/AssetMarkdown/image-20221017150037418.png" alt="image-20221017150037418" style="zoom: 67%;" /></p></blockquote><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221017145914802.png" alt="image-20221017145914802" style="zoom: 40%;" /></th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221017145918468.png" alt="image-20221017145918468" style="zoom: 80%;" /></td></tr></tbody></table></li></ol><h3 id="openmp">4.5.3 OpenMP</h3><ol type="1"><li><p>编译器指令集和C、C++、FORTRAN的API</p></li><li><p>为共享内存环境中的并行编程提供支持</p></li><li><p>标识并行区域–可以并行运行的代码块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/* 串行代码 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">//创建尽可能多的线程</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am a parallel region.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 串行代码 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="grand-central-dispatch">4.5.4 Grand Central Dispatch</h3><ol type="1"><li><p>用于macOS和iOS操作系统的Apple技术</p></li><li><p>C、C++和Objective-C语言、API和运行时库的扩展</p></li><li><p>允许识别平行部分</p></li><li><p>管理线程的大部分细节</p></li><li><p>块位于“^{}”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123;<span class="built_in">printf</span>(<span class="string">&quot;I am a block&quot;</span>);&#125;</span><br></pre></td></tr></table></figure></li><li><p>Block放置在调度队列中</p><ol type="1"><li>从队列中移除时，分配给线程池中的可用线程</li></ol></li><li><p>两种类型的调度队列：</p><ol type="1"><li>串行：按<strong>FIFO</strong>的顺序删除块，队列按进程，称为主队列<ol type="1"><li>程序员可以在程序中创建额外的串行队列</li></ol></li><li>并行：按<strong>FIFO</strong>的顺序删除块，但一次可以删除多个</li><li>按服务质量划分的四个全系统队列：<ol type="1"><li>QOS_CLASS_USER_INTERACTIVE</li><li>QOS_CLASS_USER_INITIATED</li><li>QOS_CLASS_USER_UTILITY</li><li>QOS_CLASS_USER_BACKGROUND</li></ol></li></ol></li><li><p>对于Swift语言，任务定义为闭包，类似于块，减去插入符号</p><ol type="1"><li>使用dispatch_async()函数将闭包提交到队列</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> dispatch.get.global.queue(<span class="type">QOS</span>.<span class="type">CLASS</span>.<span class="type">USER</span><span class="operator">/</span><span class="type">INITIATED</span>, <span class="number">0</span>)</span><br><span class="line">dispatch.async(queue, &#123;<span class="built_in">print</span>(<span class="string">&quot;I am a closure.&quot;</span>)&#125; )</span><br></pre></td></tr></table></figure></li></ol><h3 id="intel-threading-building-blocks-tbb">4.5.5 Intel ThreadingBuilding Blocks (TBB)</h3><ol type="1"><li><p>用于设计并行C++程序的模板库</p></li><li><p>简单for循环的串行版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">apply</span>(v[i]);</span><br></pre></td></tr></table></figure></li><li><p>使用TBB的<strong>parallel_for</strong>语句编写的for循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), n, [=](<span class="type">size_t</span> i)&#123; <span class="built_in">apply</span>(v[i]); &#125; );</span><br></pre></td></tr></table></figure></li></ol><h2 id="threading-issues">4.6 Threading Issues</h2><ol type="1"><li>fork()和exec()系统调用的语义</li><li>目标线程的线程删除<ol type="1"><li>异步或延迟</li></ol></li><li>信号处理</li><li>线程池<ol type="1"><li>线程特定数据</li></ol></li><li>调度器激活</li></ol><h3 id="fork和exec的语义">4.6.1 fork()和exec()的语义</h3><ol type="1"><li>fork()：有的Unix系统有两种形式的fork()，与应用程序有关<ol type="1"><li>复制所有线程：如果调用fork()后不调用exec()，复制所有线程</li><li>只复制调用fork()的线程：如果调用fork()后立即调用exec()，操作系统只需复制调用fork()的线程</li></ol></li><li>exec()：如果一个线程调用exec()，exec()参数指定的程序会替换整个进程（包括所有线程）</li></ol><h3 id="thread的删除">4.6.2 Thread的删除</h3><ol type="1"><li><strong>线程取消</strong>(threadcancellation)：在线程完成之前终止线程的任务，要取消的线程称为<strong>目标线程</strong></li><li>线程取消的两种情况：<ol type="1"><li><strong>异步取消</strong>(asynchronouscancellation)：由一个线程<strong>立即终止</strong>目标线程。<ol type="1"><li>对于异步取消，因为如果在已经给目标线程分配资源或目标线程正在更新与其他线程共享的数据的情况下，操作系统从回收系统资源时不能将所有资源全部回收。</li></ol></li><li><strong>延迟取消</strong>(deferredcancellation)：目标线程<strong>周期性</strong>地检查其是否应该终止，允许目标线程以有序方式终止自己</li></ol></li></ol><h3 id="signal-handling-信号处理">4.6.3 Signal Handling 信号处理</h3><ol type="1"><li>UNIX系统中使用信号通知进程发生了特定事件</li><li>信号处理器用于处理信号<ol type="1"><li>信号由特定事件生成</li><li>信号被传递到进程</li><li>信号已处理</li></ol></li><li>Options：<ol type="1"><li>将信号传递给信号适用的线程</li><li>将信号传递给进程中的每个线程</li><li>将信号传递给进程中的某些线程</li><li>分配特定线程以接收进程的所有信号</li></ol></li><li>信号可分为同步和异步：<ol type="1"><li><strong>同步信号</strong>：被发送到产生信号的同一进程<ol type="1"><li>E.g. 非法访问内存、被0所除</li></ol></li><li><strong>异步信号</strong>：由运行进程之外的事件产生，通常被发送到另一进程<ol type="1"><li>E.g. 使用特殊键、定时器到期</li></ol></li></ol></li></ol><h3 id="thread-pool-线程池-1">4.6.4 Thread Pool 线程池</h3><ol type="1"><li>多线程服务器的潜在问题：<ol type="1"><li>处理请求前创建线程需要时间，线程完成工作后要被丢弃；</li><li>如果允许所有并发请求都用新线程处理，则无法限制系统中并发执行的线程数量，大量消耗系统资源</li></ol></li><li>在等待工作的池中创建多个线程</li><li>优点：<ol type="1"><li>使用现有线程服务请求通常比创建新线程稍快</li><li>允许将应用程序中的线程数绑定到池的大小</li></ol></li></ol><h3 id="thread-specific-data-线程特有数据">4.6.5 Thread Specific Data线程特有数据</h3><ol type="1"><li>允许每个线程拥有自己的数据副本</li><li>当您无法控制线程创建过程时(即使用线程池时)，此功能非常有用</li></ol><h3 id="scheduler-activations-调度器激活">4.6.5 Scheduler Activations调度器激活</h3><ol type="1"><li>M:N和两级模型都需要通信来维护分配给应用程序的适当数量的内核线程<ol type="1"><li>轻量级进程(Lightweight process,<strong>LWP</strong>)：实现多对多模型或二级模型的系统在用户线程和内核线程之间通常设置一种中间数据结构，通常为LWP。</li><li>对于用户线程库，LWP表现为一种应用程序可以调度用户线程来运行的虚拟处理器。每个LWP与内核线程相连，该内核线程被操作系统调度到物理处理器上运行。如果物理处理器上运行的内核线程阻塞，则与其相连的LWP也阻塞，关系链顶端与LWP相连的用户线程也阻塞</li></ol></li><li>调度程序激活提供了向上调用：一种从内核到线程库的通信机制<ol type="1"><li>upcall：内核通知应用程序与其有关的特定事件的过程；</li><li>upcallhandler：upcall处理句柄，在虚拟处理器(<strong>LWP</strong>)上运行。</li></ol></li><li>此通信允许应用程序维护正确数量的内核线程</li></ol><p>调度器激活（scheduleractivation）：一种解决用户线程与内核间通信的方法。</p><ol type="1"><li>工作方式：内核提供一组LWP给应用程序，应用程序可调度用户线程到一个可用的LWP上。</li><li>当一个应用线程将要阻塞时，事件引发内核发送<strong>upcall</strong>到应用程序，通知应用程序线程阻塞并标识特殊线程</li><li>内核分配一个新的LWP给应用程序</li><li>应用程序在该新LWP上运行<strong>upcall handler</strong>：<ol type="1"><li>保存该阻塞线程的状态</li><li>放弃阻塞线程运行的原虚拟处理器</li></ol></li><li><strong>upcallhandler</strong>调度另一个适合在新LWP上运行的线程</li><li>当原先阻塞的线程准备好执行时，内核发送另一个<strong>upcall</strong>到线程库，通知线程库原先阻塞的线程已经能够运行了<ol type="1"><li>内核可能分配一个新的LWP</li><li>或抢占一个用户线程并在其LWP用于运行处理该事件的upcall handler</li></ol></li><li>应用程序将已处于未堵塞状态的线程标记为“能够运行”，调度一条合适的线程到可用LWP上运行</li></ol><h2 id="operating-system-examples">4.7 Operating-System Examples</h2><h3 id="windows-xp-thread">4.7.1 Windows XP Thread</h3><p><img src="/images/AssetMarkdown/image-20221017153825431.png" alt="image-20221017153825431" style="zoom:80%;" /></p><ol type="1"><li>应用程序以独立进程方式运行，每个进程可包括一个或多个线程</li><li>使用<strong>一对一映射</strong>，也提供对fiber库的支持（多对多模型）</li><li>每个线程包含<ol type="1"><li>线程id</li><li>寄存器集</li><li>独立的用户堆栈和内核堆栈</li><li>专用数据存储区</li></ol></li><li>寄存器集、堆栈和专用存储区域称为线程的上下文</li><li>同属一个进程的每个线程都能访问进程的地址空间</li><li>线程的主要数据结构包括：<ol type="1"><li><strong>ETHREAD</strong>(executive threadblock)：执行线程块，包括指向线程所属进程的指针、线程开始控制的子程序的地址、指向KTHREAD的指针</li><li><strong>KTHREAD</strong>(kernel threadblock)：内核线程块，包括线程的调度和同步信息、指向内核栈的指针、指向TEB的指针</li><li><strong>TEB</strong>(thread environmentblock)：用户空间的数据结构，供线程在用户模式下运行时访问，包含许多其他域、用户模式栈、用于线程特定数据的数组</li></ol></li></ol><h3 id="linux-threads">4.7.2 Linux Threads</h3><ol type="1"><li><p>Linux不区分进程和线程，通常称之为任务（task）</p><ol type="1"><li><strong>Task_struct</strong>：Linux系统中每个任务都有一个唯一的内核数据结构structtask_struct，它并不保存任务本身的数据，而是指向其他存储这些数据的数据结构（e.g.打开文件列表、信号处理信息、虚拟内存等）的指针</li></ol></li><li><p>系统调用fork()提供传统进程复制功能，系统调用clone()提供创建线程功能。</p><ol type="1"><li><p>调用fork()时，所创建的新任务具有父进程所有数据的副本</p></li><li><p>调用clone()时，所创建新任务根据所传递标志集指向父任务的数据结构。</p></li><li><p>调用clone()时传递一组标志，决定父任务与子任务之间发生多少共享</p><p><img src="/images/AssetMarkdown/image-20221017154347587.png" alt="image-20221017154347587" style="zoom:80%;" /></p></li></ol></li></ol><h1 id="chapte-5cpu-scheduling">Chapte 5：CPU Scheduling</h1><h2 id="基础概念-basic-concepts">5.1 基础概念 Basic Concepts</h2><h3 id="cpu调度">5.1.1 CPU调度</h3><ol type="1"><li><p>CPU调度 == 处理器调度 == 进程调度</p></li><li><p>最大化CPU的利用率</p></li><li><p>进程执行的特点：CPU Burst 和 I/O Burst交替进行</p><ol type="1"><li>CPU Burst Time，I/O Burst Time</li><li>CPU-bound program：以CPU计算为主的程序</li><li>I/O-bound program：以I/O为主的程序</li><li>只考虑进程的CPU Burst Time</li></ol><p><img src="/images/AssetMarkdown/image-20221020162923271.png" alt="image-20221020162923271" style="zoom: 30%;" /></p></li><li><p>进程的CPU Burst Time的统计规律</p><ol type="1"><li>短时间的CPU Burst Time占据绝大部分</li><li>因此CPU调度是高频调度</li></ol><p><img src="/images/AssetMarkdown/image-20221020163157981.png" alt="image-20221020163157981" style="zoom: 50%;" /></p></li></ol><h3 id="cpu调度器-scheduler">5.1.2 CPU调度器 Scheduler</h3><ol type="1"><li>调度器起作用的时机：<ol type="1"><li>进程从running到waiting状态</li><li>进程从running到ready状态</li><li>进程从waiting到ready状态</li><li>进程终止</li></ol></li><li>调度方式：<ol type="1"><li><strong>Nonpreemptive</strong>非抢占式调度：<ol type="1"><li>调度程序一旦把处理器分配给某进程后，它便会一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理器分配给另一个进程</li><li>调度时机：上述1、4</li></ol></li><li><strong>Preemptive</strong>抢占式调度：<ol type="1"><li>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程</li><li>剥夺原则有：优先权原则、短进程优先原则、时间片原则</li><li>调度时机：上述2、3</li></ol></li></ol></li></ol><h3 id="调度程序-dispatcher">5.1.3 调度程序 Dispatcher</h3><ol type="1"><li>实际执行调度的模块，任务如下：<ol type="1"><li>切换上下文</li><li>切换到user mode</li><li>跳转到user program中正确的位置，并且重新启动program</li></ol></li><li><strong>DispatcherLatency</strong>调度延迟：调度程序停止一个进程到启动一个进程所需要的时间</li></ol><h2 id="调度标准-scheduling-criteria">5.2 调度标准 SchedulingCriteria</h2><h3 id="调度算法的选择准则和评价">5.2.1 调度算法的选择准则和评价</h3><ol type="1"><li>面向用户(User-oriented)的准则和评价<ol type="1"><li>周转时间<strong>Turnaroundtime</strong>：进程从<strong>提交</strong>到<strong>完成</strong>所经历的时间。包括：在CPU上执行，就绪列和阻塞队列中等待。<ol type="1"><li>周转时间 <strong>T</strong> = 完成时间 - 提交时间</li><li>平均周转时间 = <span class="math inline">\(\sum\)</span>周转时间/进程数</li><li>带权周转时间<strong>W</strong> =<strong>T</strong>(周转时间)/<strong>t</strong>(CPU执行时间)</li><li>平均带权周转时间 = <span class="math inline">\(\sum\)</span><strong>W</strong>/进程数</li></ol></li><li>响应时间<strong>Responsetime</strong>：从进程<strong>提出请求</strong>到<strong>首次被响应</strong>的时间段<ol type="1"><li>第一次被调度到，而不是输出结果</li><li>在分时系统环境下</li></ol></li><li>等待时间<strong>Waitingtime</strong>：进程在<strong>就绪队列</strong>中<strong>等待</strong>的时间总和</li><li>截止时间：开始截止时间和完成截止时间<ol type="1"><li>实时系统，与周转时间有些相似</li><li>开始截止时间：在某个时间点之前必须开始</li><li>完成截止时间：在某个时间点之前必须完成</li></ol></li><li>公平性：不因作业或进程本身的特性而使上述指标过分恶化<ol type="1"><li>如长进程等待很长时间</li><li>不同进程之间的上述指标不能差异过大</li></ol></li><li>优先级：可以使关键任务达到更好的指标</li></ol></li><li>面向系统的调度性能准则<ol type="1"><li>吞吐量<strong>Throughput</strong>：单位时间内所完成的进程数<ol type="1"><li>跟进程本身特性和调度算法都有关系</li><li>批处理系统</li><li>平均周转时间不是吞吐量的倒数，因为并发执行的进程在时间上可以重叠</li><li>如：在2小时内完成4个进程，而每个周转时间是1小时，则吞吐量是2个进程/小时</li></ol></li><li>处理器利用率<strong>CPU utilization</strong>：使CPU尽可能的忙碌</li><li>各种设备的均衡利用：<ol type="1"><li>如CPU繁忙的进程和I/O繁忙的进程搭配</li><li>大中型主机</li></ol></li></ol></li><li>调度算法本身的调度性能准则</li><li>易于实现</li><li>执行开销比较小</li></ol><h3 id="最优准则-optimization-criteria">5.2.4 最优准则 OptimizationCriteria</h3><ol type="1"><li>最大的CPU利用率 Max CPU utilization　</li><li>最大的吞吐量 Max throughput</li><li>最短的周转时间 Min turnaround time</li><li>最短的等待时间 Min waiting time</li><li>最短的响应时间 Min response time</li><li>公平</li></ol><h2 id="调度算法-scheduling-algorithms-计算">5.3 调度算法 SchedulingAlgorithms (<strong>计算</strong>)</h2><table><thead><tr class="header"><th style="text-align: center;">算法名</th><th style="text-align: center;">注释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>First-Come, First-Served(FCFS)</strong> Scheduling</td><td style="text-align: center;">先来先服务调度</td></tr><tr class="even"><td style="text-align: center;"><strong>Shortest-Job-First(SJF)</strong> Scheduling</td><td style="text-align: center;">短作业优先调度</td></tr><tr class="odd"><td style="text-align: center;"><strong>Priority</strong>Scheduling</td><td style="text-align: center;">优先权调度</td></tr><tr class="even"><td style="text-align: center;"><strong>Round Robin</strong> (RR)</td><td style="text-align: center;">时间片轮转调度</td></tr><tr class="odd"><td style="text-align: center;"><strong>Multilevel Queue</strong>Scheduling</td><td style="text-align: center;">多级队列调度</td></tr><tr class="even"><td style="text-align: center;"><strong>Multilevel Feedback</strong>Queue Scheduling</td><td style="text-align: center;">多级反馈队列调度</td></tr></tbody></table><ol type="1"><li>高响应比优先调度算法：<strong>Highest Response RatioNext(HRRN)</strong><ol type="1"><li>响应比<strong>R</strong> = (等待时间 + 要求执行时间) /要求执行时间</li></ol></li></ol><h3 id="先来先服务调度-fcfs">5.3.1 先来先服务调度 FCFS</h3><h4 id="算法内容">5.3.1.1 算法内容</h4><ol type="1"><li><p><strong>FCFS</strong>算法：First-Come, First-ServedScheduling</p><ol type="1"><li>按照<strong>进程或作业提交顺序</strong>形成就绪状态的先后次序，分派CPU</li><li>当前进程或作业占用CPU，直到执行完或阻塞，才出让CPU(<strong>非抢占方式</strong>)</li><li>在进程或作业唤醒后(如I/O完成)，并不立即恢复执行，通常等到当前作业或进程出让CPU</li><li>最简单的算法</li></ol></li><li><p>FCFS的特点</p><ol type="1"><li>比较有利于长进程，而不利于短进程</li><li>有利于CPU Bound的进程，而不利于I/O Bound的进程</li></ol></li></ol><h4 id="示例">5.3.1.2 示例</h4><table><thead><tr class="header"><th style="text-align: center;">Process</th><th style="text-align: center;">Burst Time</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">24</td></tr><tr class="even"><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">3</td></tr></tbody></table><ol type="1"><li><p><strong>GanttChart</strong>：根据进程的顺序排列，下标画时间点</p><p><img src="/images/AssetMarkdown/image-20221020171350881.png" alt="image-20221020171350881" style="zoom: 67%;" /></p></li><li><p><strong>Turnaround Time</strong>：终止时间 - 到达时间</p><ol type="1"><li>P<sub>1</sub> = 24，P<sub>2</sub> = 27，P<sub>3</sub> = 30</li><li>Average Turnaround Time = (24 + 27 + 30) / 3 = 27</li></ol></li><li><p><strong>Waiting Time</strong>：Turnaround Time -实际运行的时间</p><ol type="1"><li>P<sub>1</sub> = 24 - 24 = 0，P<sub>2</sub> = 27 - 3 =24，P<sub>3</sub> = 30 - 3 = 27</li><li>Average Waiting Time = (0 + 24 + 27) / 3 = 17</li></ol></li></ol><h3 id="短作业优先调度-sjf">5.3.2 短作业优先调度 SJF</h3><h4 id="算法内容-1">5.3.2.1 算法内容</h4><ol type="1"><li><p><strong>SJF</strong>算法：Shortest-Job-First (SJF) Scheduling</p><ol type="1"><li>对<strong>预计执行时间</strong>短的作业（进程）优先分派处理器</li><li>又称为“短进程优先”<strong>SPF(Shortest ProcessFirst)</strong>，这是对FCFS算法的改进，其目标是减少平均周转时间</li></ol></li><li><p>两种模式</p><ol type="1"><li>非抢占<strong>nonpreemptive</strong>：一旦CPU被赋予进程，它就不能被抢占，直到完成其CPUBurst</li><li>抢占<strong>preemptive</strong>：如果新进程到达时CPUBurst长度小于当前执行进程的剩余时间，则抢占<ol type="1"><li>该方案被称为最短剩余时间优先（SRTF，Shortest-Remaining-Time-First）</li></ol></li></ol></li><li><p>优点：平均等待时间最小</p></li></ol><h4 id="最短剩余时间优先-srtf">5.3.2.2 最短剩余时间优先 SRTF</h4><ol type="1"><li><p>最短剩余时间优先<strong>SRTF</strong>(Shortest Remaining TimeFirst)：基于抢占的<strong>SJF</strong>算法</p></li><li><p>允许比当前进程剩余时间更短的进程来抢占</p></li></ol><h4 id="最高响应比优先-hrrn">5.3.2.3 最高响应比优先 HRRN</h4><ol type="1"><li>最高响应比优先<strong>HRRN</strong>(Highest Response RatioNext)</li><li>响应比R = (等待时间 + 要求执行时间) / 要求执行时间</li><li>是<strong>FCFS</strong>和<strong>SJF</strong>的折中</li></ol><h4 id="示例-1">5.3.2.4 示例</h4><table><thead><tr class="header"><th style="text-align: center;">Process</th><th style="text-align: center;">Arrival Time</th><th style="text-align: center;">Burst Time</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">0</td><td style="text-align: center;">7</td></tr><tr class="even"><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">2</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">4</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">P<sub>4</sub></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td></tr></tbody></table><ol type="1"><li><strong>SJF (non-preemptive)</strong>：<ol type="1"><li><img src="/images/AssetMarkdown/image-20221020173141442.png" alt="image-20221020173141442" style="zoom:80%;" /><ol type="1"><li>第0时刻只有P<sub>1</sub>到来，因此先执行P<sub>1</sub></li><li>P<sub>1</sub>结束后为第7时刻，此时的进程有P<sub>2</sub>,P<sub>3</sub>, P<sub>4</sub>，P<sub>3</sub>的BurstTime最短，因此执行P<sub>3</sub></li></ol></li><li><strong>Turnaround Time</strong><ol type="1"><li>P<sub>1</sub> = 7 - 0 = 7，P<sub>2</sub> = 12 - 2 =10，P<sub>3</sub> = 8 - 4 = 4，P<sub>4</sub> = 16 - 5 = 11</li><li>Average Turnaround Time = (7 + 10 + 4 + 11) / 4 = 8</li></ol></li><li><strong>Waiting Time</strong><ol type="1"><li>P<sub>1</sub> = 0 - 0 = 0，P<sub>2</sub> = 8 - 2 = 6，P<sub>3</sub>= 7 - 4 = 3，P<sub>4</sub> = 12 - 5 = 7</li><li>Average Waiting Time = (0 + 6 + 3 + 7) / 4 = 4</li></ol></li></ol></li><li><strong>SJF (preemptive)</strong>：<ol type="1"><li><img src="/images/AssetMarkdown/image-20221020173744162.png" alt="image-20221020173744162" style="zoom:67%;" /><ol type="1"><li>第2时刻，P<sub>2</sub>到来，其时间比P<sub>1</sub>剩余时间短，因此打断P<sub>1</sub>，执行P<sub>2</sub></li><li>第4时刻，P<sub>3</sub>到来，其时间比P<sub>2</sub>剩余时间短，因此打断P<sub>2</sub>，执行P<sub>3</sub></li><li>第5时刻，P<sub>3</sub>结束，此时等待队列如下，因此执行P<sub>2</sub><ol type="1"><li>P<sub>1</sub>：5s</li><li>P<sub>2</sub>：2s</li></ol></li><li>第7时刻，P<sub>2</sub>结束，P<sub>4</sub>到来，此时等待队列如下，因此执行P<sub>4</sub><ol type="1"><li>P<sub>1</sub>：5s</li><li>P<sub>4</sub>：4s</li></ol></li><li>第11时刻，P<sub>4</sub>结束，执行P<sub>1</sub></li></ol></li><li><strong>Turnaround Time</strong><ol type="1"><li>P<sub>1</sub> = 16 - 0 = 16，P<sub>2</sub> = 7 - 2 =5，P<sub>3</sub> = 5 - 4 = 1，P<sub>4</sub> = 11 - 5 = 6</li><li>Average Turnaround Time = (16 + 5 + 1 + 6) / 4 = 7</li></ol></li><li><strong>Waiting Time</strong><ol type="1"><li>P<sub>1</sub> = (0 - 0) + (11 - 2) = 9，P<sub>2</sub> = (2 - 2) + (5- 4) = 1，P<sub>3</sub> = 4 - 4 = 0，P<sub>4</sub> = 7 - 5 = 2</li><li>Average Waiting Time = (9 + 1 + 0 + 2) / 4 = 4</li></ol></li></ol></li></ol><h4 id="预测cpu-burst-time指数平均法">5.3.3.5 预测CPU BurstTime：指数平均法</h4><ol type="1"><li><p>只能估计长度</p></li><li><p>可以通过使用以前CPU突发的长度，使用指数平均来完成</p><ol type="1"><li><span class="math inline">\(t_n\)</span> = 第n次CPUburst的真实值</li><li><span class="math inline">\(\tau_n\)</span> = 第n次CPUburst的预测值</li><li><span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(0 \le \alpha \le 1\)</span></li><li>定义：<span class="math inline">\(\tau_{n+1}=\alphat_n+(1-\alpha)\tau_n\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20221020174921849.png" alt="image-20221020174921849" style="zoom:67%;" /></p></li><li><p>几种<span class="math inline">\(\alpha\)</span>的取值</p><ol type="1"><li><span class="math inline">\(\alpha=0\)</span>：<spanclass="math inline">\(\tau_{n+1} = \tau_{n}\)</span>，只考虑预测值</li><li><span class="math inline">\(\alpha=1\)</span>：<spanclass="math inline">\(\tau_{n+1} = t_{n}\)</span>，只考虑实际值</li></ol></li><li><p>展开<span class="math inline">\(\tau_{n+1}\)</span> <spanclass="math display">\[\begin{aligned}\tau_{n+1}=    &amp;\ \ \ \ \ \ \alpha t_n \\           &amp;+ (1-\alpha)\ t_{n-1} \\           &amp;+ \ ...\\           &amp;+(1-\alpha)^i\ \alpha t_{n-i} \\           &amp;+ \ ...\\           &amp;+(1-\alpha)^{n+1} \tau_{0}\end{aligned}\]</span></p></li></ol><h3 id="优先级调度-priority-scheduling">5.3.3 优先级调度 PriorityScheduling</h3><h4 id="算法内容-2">5.3.3.1 算法内容</h4><ol type="1"><li>该算法总是把处理机分配给就绪队列中具有<strong>最高优先权</strong>的进程<ol type="1"><li><strong>SJF</strong>是以下一次CPU脉冲长度作为优先数的优先级调度</li></ol></li><li>常用以下两种方法来确定进程的优先权：<ol type="1"><li><strong>静态优先权</strong>：静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型、进程对资源的要求、用户要求的优先权。</li><li><strong>动态优先权</strong>：动态优先权是基于某种原则，使进程的优先权随时间改变而改变。</li></ol></li><li>假定：最小的整数 &lt;=&gt; 最高的优先级.</li><li>两种模式<ol type="1"><li>非抢占式<strong>Non-preemptive priorityscheduling</strong>：将优先级较高的进程置于队列的前端<ol type="1"><li>默认所有进程一起到来</li></ol></li><li>抢占式<strong>Preemptive priorityscheduling</strong>：在较高优先级进程到达时中断并抢占正在运行的进程<ol type="1"><li>默认所有进程的到达时间有前后区别</li></ol></li></ol></li><li>问题：饥饿<strong>Starvation</strong>，低优先级的进程永远不会被执行</li><li>解决方法：老化<strong>Aging</strong>，随着进程运行时间的增长，其优先级会降低</li></ol><h4 id="示例-2">5.3.3.2 示例</h4><blockquote><p><strong>非抢占式</strong>：non-preemptive</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">Process</th><th style="text-align: center;">Burst Time</th><th style="text-align: center;">Priority</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">10</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">2</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;">P<sub>4</sub></td><td style="text-align: center;">1</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">P<sub>5</sub></td><td style="text-align: center;">5</td><td style="text-align: center;">2</td></tr></tbody></table><p><img src="/images/AssetMarkdown/image-20221024144014656.png" alt="image-20221024144014656" style="zoom:80%;" /></p><ol type="1"><li>平均Turnaround time：(16+1+18+19+6) / 5 = 12</li><li>平均waiting time：(6+0+16+18+1) / 5 = 8.2</li></ol><blockquote><p><strong>抢占式</strong>：preemptive</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">Process</th><th style="text-align: center;">Arrival Time</th><th style="text-align: center;">Burst Time</th><th style="text-align: center;">Priority</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">0</td><td style="text-align: center;">10</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;">P<sub>4</sub></td><td style="text-align: center;">5</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td></tr><tr class="odd"><td style="text-align: center;">P<sub>5</sub></td><td style="text-align: center;">8</td><td style="text-align: center;">5</td><td style="text-align: center;">2</td></tr></tbody></table><p><img src="/images/AssetMarkdown/image-20221024144435400.png" alt="image-20221024144435400" style="zoom:80%;" /></p><ol type="1"><li>平均Turnaround time：(17+1+15+1+5) / 5 = 7.8</li><li>平均waiting time：(7+0+13+0+0) / 5 = 4</li></ol><h3 id="时间片轮转调度-rr">5.3.4 时间片轮转调度 RR</h3><h4 id="算法内容-3">5.3.4.1 算法内容</h4><ol type="1"><li>基本思路：通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率。</li><li><strong>RR</strong>算法：Round Robin<ol type="1"><li>将系统中所有的就绪进程按照<strong>FCFS</strong>原则，排成一个队列</li><li>每次调度时将CPU分派给队首进程，让其执行一个<strong>时间片(timeslice)</strong><ol type="1"><li>时间片的长度从几个ms到几百ms</li></ol></li><li>在一个时间片结束时，发生时钟中断</li><li>调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程</li><li>进程可以未使用完一个时间片，就出让CPU（如阻塞）</li></ol></li><li>每个进程都有一小单位的CPU时间(<strong>timequantum</strong>)，通常为10-100毫秒。经过这段时间后，进程被抢占并添加到就绪队列的末尾</li><li>如果<strong>readyqueue</strong>中有<strong>n</strong>个进程，并且<strong>timequantum</strong>为<strong>q</strong>，那么每个进程一次获得最多为<strong>q</strong>个时间单位的<strong>CPU</strong>时间的<strong>1/n</strong>，进程最大等待<strong>(n-1)q</strong>个时间单位<ol type="1"><li>当q很大时，变为了FIFO</li><li>当q很小时，上下文切换的开销过高</li></ol></li><li>时间片长度的影响因素：<ol type="1"><li>就绪进程的数目：当响应时间一定时，<strong>数目越多，时间片越小</strong></li><li>系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间、平均周转时间、平均带权周转时间过长</li></ol></li><li>优点：response更好</li><li>缺点：比<strong>SJF</strong>的average turnaround time长</li></ol><h4 id="示例-3">5.3.4.2 示例</h4><table><thead><tr class="header"><th style="text-align: center;">Process</th><th style="text-align: center;">Burst Time</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">53</td></tr><tr class="even"><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">17</td></tr><tr class="odd"><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">68</td></tr><tr class="even"><td style="text-align: center;">P<sub>4</sub></td><td style="text-align: center;">24</td></tr></tbody></table><p><img src="/images/AssetMarkdown/image-20221024150527509.png" alt="image-20221024150527509" style="zoom:80%;" /></p><ol type="1"><li>平均Turnaround time：(134+37+162+121) / 4 = 113.5</li><li>平均waiting time：(81+20+94+97) / 4 = 70.5</li></ol><h4 id="time-quantum-时间片的选择">5.3.4.3 Time Quantum时间片的选择</h4><ol type="1"><li>要求80%的CPU burst time应该小于q</li></ol><h3 id="多级队列调度">5.3.5 多级队列调度</h3><p><img src="/images/AssetMarkdown/image-20221024152844819.png" alt="image-20221024152844819" style="zoom: 67%;" /></p><p>本算法引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标</p><ol type="1"><li>根据进程的性质或类型的不同，将Ready队列再分为若干个子队列</li><li>每个作业固定归入一个队列</li><li>各队列的不同处理：不同队列可有不同的优先级、时间片长度、调度策略等<ol type="1"><li>如：系统进程、用户交互进程、批处理进程等</li></ol></li><li>Ready Queue的分类<ol type="1"><li>foreground (interactive) 前台（交互式）— RR，时间片轮转调度</li><li>background (batch) 　　后台 （批处理）— FCFS，先来先服务调度</li></ol></li><li>多级队列算法调度须在队列间进行<ol type="1"><li><strong>固定优先级调度</strong>：即前台运行完后再运行后台<ol type="1"><li>有可能产生饥饿</li></ol></li><li><strong>给定时间片调度</strong>：即每个队列得到一定的CPU时间，进程在给定时间内执行<ol type="1"><li>不同队列的时间片长度不一样</li><li>如，80%的时间执行前台的RR调度，20%的时间执行后台的FCFS调度</li></ol></li></ol></li></ol><h3 id="多级反馈队列">5.3.6 多级反馈队列</h3><ol type="1"><li>多级反馈队列算法：Multilevel Feedback Queue Scheduling<ol type="1"><li>是时间片轮转算法和优先级算法的综合和发展</li><li>同一个进程可以在不同队列之间转移</li></ol></li><li>优点：<ol type="1"><li>为提高系统吞吐量和缩短平均周转时间而照顾短进程</li><li>为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li><li>不必估计进程的执行时间，动态调节</li></ol></li><li>方法：<ol type="1"><li>设置<strong>多个就绪队列</strong>，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定<strong>优先级越低则时间片越长</strong>，如逐级加倍</li><li>新进程进入内存后，<strong>先投入队列1的末尾</strong>，按<strong>FCFS</strong>算法调度；<strong>若按队列1一个时间片未能执行完，则降低投入到队列2的末尾</strong>，同样按<strong>FCFS</strong>算法调度；如此下去，降低到最后的队列，则按"<strong>时间片轮转</strong>"算法调度直到完成</li><li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢占执行新进程，并把被抢占的进程投入原队列的末尾</li></ol></li><li>几点说明：<ol type="1"><li><strong>I/O型进程</strong>：让其进入最高优先级队列，以及时响应I/O交互。通常执行一个小时间片，要求可处理完一次I/O请求的数据，然后转入到阻塞队列</li><li><strong>计算型进程</strong>：每次执行完时间片，进入更低优先级级队列。最终采用最大时间片来执行，减少调度次数</li><li><strong>I/O次数不多，而主要是CPU处理的进程</strong>：在I/O完成后，优先放回I/O请求时离开的队列，以免每次都回到最高优先级队列后再逐次下降</li><li>为适应一个进程在不同时间段的运行特点，<strong>I/O完成时，提高优先级</strong>；<strong>时间片用完时，降低优先级</strong>；</li></ol></li></ol><h2 id="多处理器调度-multiple-processor-scheduling">5.4* 多处理器调度Multiple-Processor Scheduling</h2><ol type="1"><li>当多个CPU可用时，CPU调度更加复杂</li><li>多处理器中的 同构处理器Homogeneous processors<ol type="1"><li>负载分担</li></ol></li><li>非对称多处理Asymmetricmultiprocessing：只有一个处理器访问系统数据结构，减少了数据共享的需要</li></ol><h2 id="线程调度-thread-scheduling">5.5* 线程调度 Thread Scheduling</h2><ol type="1"><li>本地调度：线程库如何决定将哪个线程放入可用的LWP</li><li>全局调度：内核如何决定下一个运行哪个内核线程</li></ol><h2 id="操作系统示例-operating-systems-examples">5.6 操作系统示例Operating Systems Examples</h2><ol type="1"><li>两种算法：Time-sharing、Real-time</li><li>时间共享 Time-sharing<ol type="1"><li>基于credit的优先级：下一步执行拥有最高credit的进程</li><li>触发计时器中断时扣除credit</li><li>当credit=0时，选择另一个进程</li><li>当所有进程的credit均为0时，将重新编辑<ol type="1"><li>基于优先级和历史等因素</li></ol></li></ol></li><li>实时 Real-time<ol type="1"><li>软实时</li><li>Posix.1b compliant：两种<ol type="1"><li>FCFS和RR</li><li>优先级最高的进程总是首先运行</li></ol></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221027164612041.png" alt="image-20221027164612041" style="zoom:67%;" /></p><p><img src="/images/AssetMarkdown/image-20221027164619528.png" alt="image-20221027164619528" style="zoom:67%;" /></p><h2 id="总结-1">5.7 总结</h2><ol type="1"><li>CPU Burst Time 、I/O Burst Time</li><li>CPU-bound program（CPU型程序） 、I/O-bound program（I/O型程序）</li><li>long-term scheduler（长程调度）、medium-termscheduler（中程调度）short-term scheduler（短程调度）</li><li>time slicing（时间片）</li><li>response time（响应时间）、turnaround time（周转时间）、waitingtime（等待时间）、Average Turnaround time（平均周转时间）Average waitingtime（平均等待时间）</li><li>preemptive scheduling（抢占式调度）、Nonpreemptivescheduling（非抢占式调度）</li><li>throughput（吞吐量）：单位时间内完成的任务</li><li>从ready queue中选择一个进程，为它分配CPU</li><li>调度算法<ol type="1"><li>first-come, first served (<strong>FCFS</strong>)</li><li>shortest job first (<strong>SJF</strong>)<ol type="1"><li>provably optimal, but difficult to know CPU burst</li></ol></li><li>general <strong>priority</strong> scheduling<ol type="1"><li>starvation, and aging</li></ol></li><li>round-robin (<strong>RR</strong>)<ol type="1"><li>for time-sharing, interactive system</li><li>problem: how to select the time quantum?</li></ol></li><li><strong>Multilevel queue</strong><ol type="1"><li>different algorithms for different classes of processes</li></ol></li><li><strong>Multilevel feedback queue</strong><ol type="1"><li>allow process to move from one (ready) queue to another</li></ol></li></ol></li></ol><h1 id="chapter-6process-synchronization-进程同步">Chapter 6：ProcessSynchronization 进程同步</h1><h2 id="background">6.1 Background</h2><ol type="1"><li><p>对共享数据的并发访问可能导致数据不一致：datainconsistency</p></li><li><p>维护数据一致性需要有机制来确保合作流程的有序执行</p></li><li><p>有界缓冲区问题的共享内存解决方案(第3章)允许缓冲区中最多有n-1个项。使用所有N个缓冲区的解决方案并不简单</p></li><li><p>假设我们通过添加一个变量counter来修改生产者–消费者代码</p><ol type="1"><li>counter初始化为0，并在每次向缓冲区添加新项时递增</li><li>counter++和counter--必须被原子性的执行</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">. . .</span><br><span class="line">&#125; item;</span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer process(thread):</span></span><br><span class="line">item nextProduced;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (counter == BUFFER_SIZE) ;  <span class="comment">/* do nothing */</span></span><br><span class="line">    buffer[in] = nextProduced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer process (thread):</span></span><br><span class="line">item nextConsumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (counter == <span class="number">0</span>);  <span class="comment">/* do nothing */</span></span><br><span class="line">    nextConsumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="原子操作">6.1.1 原子操作</h3><ol type="1"><li><p><strong>原子操作 Atomicoperation</strong>：是指完整地完成而不中断的操作</p><ol type="1"><li><p>counter++和counter--均会被实现为三条指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> = counter;</span><br><span class="line"><span class="keyword">register</span> = <span class="keyword">register</span> +/- <span class="number">1</span>;</span><br><span class="line">counter = <span class="keyword">register</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果生产者和消费者都试图同时更新缓冲区，汇编语言语句可能会交错</p></li><li><p>交错取决于生产者和消费者流程的安排方式</p></li></ol></li></ol><h3 id="非原子操作冲突示例">6.1.2 非原子操作冲突示例</h3><blockquote><p>有两个进程P1、P2，它们分别执行下面的程序体，其中total是两个进程都能访问的共享变量，初值为0（可理解为共享存储段中的存储单元），count是每个进程的私有变量。假设这两个进程并发执行，并可自由交叉（interleave），则这两个进程都执行完后，变量total可能得到的最小取值是<code>3</code></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P1:&#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">for</span> (count =<span class="number">1</span>; count &lt;= <span class="number">50</span>; count++)</span><br><span class="line">total = total + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br><span class="line">P2: &#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">for</span> (count =<span class="number">1</span>; count &lt;= <span class="number">50</span>; count++)</span><br><span class="line">total = total + <span class="number">2</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ol type="1"><li><p>total = total + 1和total = total + 2经过编译后各为三条指令</p><p><img src="/images/AssetMarkdown/image-20221027171738434.png" alt="image-20221027171738434" style="zoom:67%;" /></p></li><li><p>P1和P2并发执行过程中，这些指令会交替运行。如果两个进程按如下顺序执行：</p><table><thead><tr class="header"><th style="text-align: center;">操作</th><th style="text-align: center;">对应指令</th><th style="text-align: center;">对应的值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">P1第1次循环</td><td style="text-align: center;">register1 = total</td><td style="text-align: center;">register1 = 0</td></tr><tr class="even"><td style="text-align: center;">P1第1次循环</td><td style="text-align: center;">register1 = register1 + 1</td><td style="text-align: center;">register1 = 1</td></tr><tr class="odd"><td style="text-align: center;">P2循环49次</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">P1第1次循环</td><td style="text-align: center;">total =register1</td><td style="text-align: center;">total =1</td></tr><tr class="odd"><td style="text-align: center;">P2第50次循环</td><td style="text-align: center;">register2 = total</td><td style="text-align: center;">register2 = 1</td></tr><tr class="even"><td style="text-align: center;">P2第50次循环</td><td style="text-align: center;">register2 = register2 + 2</td><td style="text-align: center;">register2 = 3</td></tr><tr class="odd"><td style="text-align: center;">P1循环48次</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">P1第50次循环</td><td style="text-align: center;">register1 = total</td><td style="text-align: center;">register1 = 49</td></tr><tr class="odd"><td style="text-align: center;">P1第50次循环</td><td style="text-align: center;">register1 = register1 + 1</td><td style="text-align: center;">register1 =50</td></tr><tr class="even"><td style="text-align: center;">P1第50次循环</td><td style="text-align: center;">total = register1</td><td style="text-align: center;">total = 50</td></tr><tr class="odd"><td style="text-align: center;">P2第50次循环</td><td style="text-align: center;">total = register2</td><td style="text-align: center;">total = 3</td></tr></tbody></table></li><li><p>两个进程运行结束后，变量total的值为3。</p></li></ol><h3 id="race-condition">6.1.3 Race Condition</h3><ol type="1"><li>RaceCondition(竞争条件)：多个进程同时访问和操作共享数据，共享数据的最终值取决于哪个进程最后完成，执行的结果取决于访问发生的特定顺序</li><li>为了防止出现争用情况，必须同步并发进程</li></ol><h3 id="进程同步的概念">6.1.4 进程同步的概念</h3><p>进程之间竞争资源面临三个控制问题：</p><ol type="1"><li><strong>互斥</strong>(mutualexclusion)：指多个进程不能同时使用同一个资源</li><li><strong>死锁</strong>(deadlock)：指多个进程互不相让，都得不到足够的资源<ol type="1"><li>永远得不到资源</li></ol></li><li><strong>饥饿</strong>(starvation)：指一个进程长时间得不到资源(其他进程可能轮流占用资源)<ol type="1"><li>资源分配不公平</li></ol></li></ol><h2 id="the-critical-section-problem重点">6.2 The Critical-SectionProblem(<strong>重点</strong>)</h2><h3 id="问题的定义">6.2.1 问题的定义</h3><ol type="1"><li>n个进程都在竞争使用某些共享数据</li><li>每个流程都有一个代码段，称为关键部分(临界区）,其中访问共享数据。</li><li>问题：确保当一个进程在其关键部分执行时，不允许其他进程在其重要部分执行</li></ol><h3 id="临界区临界资源">6.2.2 临界区&amp;临界资源</h3><ol type="1"><li><strong>临界资源</strong>：一次只允许一个进程使用(访问)的资源<ol type="1"><li>如：硬件打印机、磁带机等，软件的消息缓冲队列、变量、数组、缓冲区等。</li></ol></li><li><strong>临界区</strong>：访问临界资源的那段代码</li><li>对临界区问题的解法必须满足：<ol type="1"><li><strong>Mutual Exclusion</strong>(互斥)<ol type="1"><li>如果进程P<sub>i</sub>正在临界区中执行，则其他进程不能在临界区中执行</li></ol></li><li><strong>Progress</strong>(空闲让进)<ol type="1"><li>如果没有进程在临界区中执行，并且存在一些进程希望进入临界区，则不能无限期地推迟选择下一个将进入临界区的进程</li></ol></li><li><strong>Bounded Waiting</strong>(让权等待)<ol type="1"><li>在一个进程发出进入临界区的请求之后，在该请求被批准之前，其他进程被允许进入临界区的次数必须存在一个界限</li><li>不是必须的</li></ol></li></ol></li></ol><h3 id="一个进程的结构应该是">6.2.3 一个进程的结构应该是</h3><p><img src="/images/AssetMarkdown/image-20221031142201362.png" alt="image-20221031142201362" style="zoom:80%;" /></p><h2 id="多进程临界区问题的解决方法软件方法">6.3多进程临界区问题的解决方法：软件方法</h2><h3 id="peterson-solutions两个进程">6.3.1 PetersonSolutions：两个进程</h3><blockquote><ol type="1"><li>Software Solution：通过软件方法解决进程互斥</li><li>针对两个进程之间的同步</li><li>假设Load和Store均是原子操作</li></ol></blockquote><h4 id="算法1">6.3.1.1 算法1</h4><ol type="1"><li><p>只有两个进程P<sub>0</sub>，P<sub>1</sub></p></li><li><p>共享变量</p><ol type="1"><li>int turn = 0</li><li>turn = i：表示轮到P<sub>i</sub>进入临界区，i = 0/1</li></ol></li><li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p><p><img src="/images/AssetMarkdown/image-20221027173940774.png" alt="image-20221027173940774" style="zoom:80%;" /></p></li><li><p>满足<strong>互斥</strong>，但是不满足<strong>空闲让进</strong></p></li><li><p>缺点：</p><ol type="1"><li><strong>强制轮流</strong>进入临界区，没有考虑进程的实际需要。容易造成资源利用不充分</li><li>在P<sub>i</sub>出让临界区之后，P<sub>j</sub>使用临界区之前，P<sub>i</sub>不可能再次使用临界区</li></ol></li></ol><h4 id="算法2-1">6.3.1.2 算法2-1</h4><ol type="1"><li><p>共享变量</p><ol type="1"><li>bool flag[2] = false</li><li>flag[i] = true：表示P<sub>i</sub>想要进入临界区，i = 0/1</li></ol></li><li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p><p><img src="/images/AssetMarkdown/image-20221027174338587.png" alt="image-20221027174338587" style="zoom:80%;" /></p></li><li><p>满足<strong>互斥</strong>，但是不满足<strong>空闲让进</strong></p></li><li><p>缺点：</p><ol type="1"><li>P<sub>0</sub>和P<sub>1</sub>可能都进入不了临界区</li><li>当P<sub>0</sub>执行了flag[0] =true后，然后P<sub>1</sub>执行了flag[1] =true，这样两个进程都无法进入临界区</li></ol></li></ol><h4 id="算法2-2">6.3.1.3 算法2-2</h4><ol type="1"><li><p>共享变量</p><ol type="1"><li>bool flag[2] = false</li><li>flag[i] = true：表示P<sub>i</sub>想要进入临界区，i = 0/1</li></ol></li><li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p><p><img src="/images/AssetMarkdown/image-20221027174706683.png" alt="image-20221027174706683" style="zoom:80%;" /></p></li><li><p>满足<strong>空闲让进</strong>，但是不满足<strong>互斥</strong></p></li><li><p>缺点：</p><ol type="1"><li>P<sub>0</sub>和P<sub>1</sub>可能同时进入临界区</li><li>当flag [0] = flag [1] = false时， P<sub>0</sub>执行了while(flag[1])后，P<sub>1</sub>执行while (flag[0])，这样两个进程同时进入了临界区</li></ol></li></ol><h4 id="peterson算法">6.3.1.4 Peterson算法</h4><ol type="1"><li><p>共享变量</p><ol type="1"><li><strong>int turn = 0</strong></li><li><strong>bool flag[2] = false</strong></li><li>turn = i：表示<strong>轮到P<sub>i</sub></strong>进入临界区，i =0/1</li><li>flag[i] =true：表示<strong>P<sub>i</sub>准备好</strong>进入临界区，i = 0/1</li></ol></li><li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p><p><img src="/images/AssetMarkdown/image-20221027174954828.png" alt="image-20221027174954828" style="zoom:80%;" /></p></li><li><p>满足了三个要求，但是只能解决2个进程的临界区问题</p></li></ol><h3 id="bakery-algorithmn个进程">6.3.2 Bakery Algorithm：n个进程</h3><p>思想：</p><ol type="1"><li>进入临界区之前，进程会获得一个<strong>number</strong>，拥有最小<strong>number</strong>的进程可以进入临界区</li><li>如果<strong>P<sub>i</sub></strong>和<strong>P<sub>j</sub></strong>的<strong>number</strong>相同，则先执行进程<strong>id</strong>小的进程</li><li>编号方案总是按枚举的递增顺序生成数字，如1,2,3,3,3,3,4,5...</li></ol><p>定义：</p><ol type="1"><li><strong>order</strong>：(a, b)，a为number，b为进程id</li><li><strong>(a, b) &lt; (c, d)</strong>：当且仅当 a&lt;c 或者 a=c,b&lt;d</li></ol><p>共享数据：</p><ol type="1"><li><strong>bool choosing[n] = false;</strong></li><li><strong>int number[n] = 0;</strong></li><li>choosing[i] =true：表示<strong>P<sub>i</sub>正在获取</strong>它的<strong>number</strong></li><li>number[i]：是<strong>P<sub>i</sub>的当前number</strong>。如果值为0，表示P<sub>i</sub>未参加排队，不想获得该资源</li></ol><p>进程P<sub>i</sub>的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="comment">// 获取一个number</span></span><br><span class="line">choosing[i] = <span class="literal">true</span>;</span><br><span class="line">number[i] = <span class="built_in">max</span>(number[<span class="number">0</span>], number[<span class="number">1</span>], ... , number[n<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">choosing[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待其它优先级更高的进程进入临界区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; </span><br><span class="line">        <span class="comment">// 等待进程P[j]获取自己的number</span></span><br><span class="line">        <span class="keyword">while</span>(choosing[j]); </span><br><span class="line">        <span class="comment">// 进程P[j]参与排队, 并且比当前进程优先级高, 则等待P[j]执行完成</span></span><br><span class="line">       <span class="keyword">while</span>((number[j] != <span class="number">0</span>) &amp;&amp; (number[j],j) &lt; (number[i],i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">critical_section</span>();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">number[i] = <span class="number">0</span>;<span class="comment">// 从队列中出来, 不再等待进入临界区</span></span><br><span class="line"><span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="多进程临界区问题的解决方法硬件方法">6.4多进程临界区问题的解决方法：硬件方法</h2><ol type="1"><li>许多系统为关键部分代码提供硬件支持</li><li>单处理器：可以禁用中断<ol type="1"><li>当前运行的代码将在没有抢占的情况下执行</li><li>在多处理器系统上通常效率太低</li><li>使用此功能的操作系统不可广泛扩展</li></ol></li><li>特殊的原子硬件指令：原子 =&gt; 不可中断<ol type="1"><li>从内存中取一个变量并且设置为某个值：test and set</li><li>交换内存中两个变量的内容：swap</li></ol></li></ol><h3 id="test-and-set测试与设置">6.4.1 Test-and-Set：测试与设置</h3><ol type="1"><li><p>返回变量的原始值，并将其赋值为<strong>true</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> &amp;target)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> rv = target;</span><br><span class="line">    target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将其变为一条<strong>原子指令</strong>之后，进程与临界区的交互变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, 该指令返回false, 并将lock赋值为true</span></span><br><span class="line">    <span class="comment">// 其它进程再执行该指令时, 会由于返回值为true, 而停到这里</span></span><br><span class="line">    <span class="comment">// 进程执行完成后, 将lock赋值为false, 其它进程可以访问临界区</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(lock));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">lock = <span class="literal">false</span>;<span class="comment">// 之后的第一个进程可以进入临界区</span></span><br><span class="line"><span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="swap交换">6.4.2 Swap：交换</h3><ol type="1"><li><p>交换两个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span> <span class="params">(boolean *a, boolean *b)</span>&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将其变为一条<strong>原子指令</strong>之后，进程与临界区的交互变为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, key与lock交换, key变为false, lock变为true</span></span><br><span class="line">    <span class="comment">// 其它进程再执行该指令时, key与lock交换后均为true, 会停到这里</span></span><br><span class="line">    <span class="comment">// 进程执行完成后, 将lock赋值为false, 其它进程可以访问临界区</span></span><br><span class="line">    <span class="keyword">while</span>(key == <span class="literal">true</span>) Swap(&amp;lock, &amp;key);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    critical_section();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">lock = <span class="literal">false</span>;<span class="comment">// 之后的第一个进程可以进入临界区</span></span><br><span class="line">remainder_section();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="硬件方法的优缺点">6.4.3 硬件方法的优缺点</h3><ol type="1"><li><p>优点</p><ol type="1"><li>适用于<strong>任意数目的进程</strong>，在单处理器或多处理器上</li><li><strong>简单</strong>，容易验证其正确性</li><li>可以支持进程内存在<strong>多个临界区</strong>，只需为每个临界区设立一个布尔变量</li></ol></li><li><p>缺点</p><ol type="1"><li>不能实现<strong>让权等待</strong>：<ol type="1"><li>因为等待要耗费CPU时间</li></ol></li><li>可能<strong>饥饿</strong>：<ol type="1"><li>从等待进程中随机选择一个进入临界区，有的进程可能一直选不上</li></ol></li><li>可能<strong>死锁</strong>：<ol type="1"><li>单CPU情况下，P<sub>1</sub>执行特殊指令进入临界区，这时拥有更高优先级P2执行并中断P1</li><li>如果P<sub>2</sub>又要使用P<sub>1</sub>占用的资源，按照资源分配规则拒绝P<sub>2</sub>对资源的要求，P<sub>2</sub>陷入等待循环</li><li>然后P<sub>1</sub>也得不到CPU，因为P<sub>1</sub>比P<sub>2</sub>优先级低</li></ol></li></ol></li><li><p><strong>解决饥饿</strong></p><ol type="1"><li><strong>waiting[i]</strong>：进程P<sub>i</sub>正在等待进入临界区</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> waiting[n] = <span class="literal">false</span>, lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, 将lock变为true, 返回给key为false</span></span><br><span class="line">    <span class="comment">// 之后的进程始终为true, 也就是不能进入临界区</span></span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (waiting[i] &amp;&amp; key) key = <span class="built_in">TestAndSet</span>(lock);</span><br><span class="line">    waiting[i] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择下一个进入临界区的进程(下一个waiting[j] = true)</span></span><br><span class="line">    <span class="comment">// 让waiting[j] = false, 则被选中的进程跳出while循环, 可以进入临界区</span></span><br><span class="line">    <span class="comment">// lock的释放由进程P[j]执行</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = (i + <span class="number">1</span>) % n; j != i; j = (j + <span class="number">1</span>) % n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(waiting[j]) &#123;</span><br><span class="line">            waiting[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有进程等待进入临界区, 则直接释放lock</span></span><br><span class="line">    <span class="keyword">if</span> (j == i)  lock = <span class="literal">false</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>该算法满足所有关键部分的要求。</li><li>证明满足互斥要求：<ol type="1"><li>我们注意到，只有当<strong>waiting[i]=false</strong>或<strong>key=false</strong>时，进程<strong>Pi</strong>才能进入临界区</li><li>只有在执行<strong>TestAndSet</strong>时，<strong>key</strong>的值才能变为<strong>false</strong></li><li>执行<strong>TestAndSet</strong>的第一个进程将发现<strong>key==false</strong>；所有其他人都必须等待</li><li>只有当另一个进程离开临界区时，<strong>waiting[i]</strong>才能变为<strong>false</strong>；只有一个<strong>waiting[i]</strong>设置为<strong>false</strong>，保持互斥要求。</li></ol></li></ol></blockquote></li></ol><h3 id="自旋锁-spinlock">6.4.4 自旋锁 spinlock</h3><ol type="1"><li>Windows、Linux内核用来达到多处理器互斥的机制“自旋锁”，它类同于TestAndSet指令机制。自旋锁是一个与共用数据结构有关的锁定机制。</li><li>自旋锁像它们所保护的数据结构一样，储存在共用内存中。为了速度和使用任何在处理器体系下提供的锁定机构，获取和释放自旋锁的代码是用汇编语言写的。例如在Intel处理器上，Windows使用了一个只在486处理器或更高处理器上运行的指令。</li><li>当线程试图获得自旋锁时，在处理器上所有其它工作将终止。因此拥有自旋锁的线程永远不会被抢占，但允许它继续执行以便使它尽快把锁释放。内核对于使用自旋锁十分小心，当它拥有自旋锁时，它执行的指令数将减至最少。</li></ol><h2 id="semaphores-信号量">6.5 Semaphores 信号量</h2><h3 id="信号量">6.5.1 信号量</h3><p>信号量分类：</p><ol type="1"><li>整型信号量：integer semaphore</li><li>记录型信号量：record semaphore</li><li>AND型信号量，信号量集</li><li>二值信号量：binary semaphore</li></ol><p>信号量的任务：解决<strong>busywaiting</strong>，即之前进程中的while()语句</p><ol type="1"><li><p>整型信号量：<strong>S</strong></p></li><li><p>对S的两个标准操作：<strong>wait()</strong>、<strong>signal()</strong></p><ol type="1"><li>也成为<strong>P()</strong>、<strong>V()</strong></li><li>这两个操作是<strong>原子操作</strong></li></ol></li><li><p>两种信号量</p><ol type="1"><li>计数信号量 Counting semaphore：整数取值范围</li><li>二值信号量 Binary semaphore：只有0/1两个值</li></ol></li></ol><h3 id="用信号量解决冲突">6.5.2 用信号量解决冲突</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">// 共享数据, 初始值表示最多可以有多少个进程同时进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个进程将mutex--, mutex变为0</span></span><br><span class="line">    <span class="comment">// 其它进程会在当前wait(mutex)处等待</span></span><br><span class="line">    <span class="built_in">wait</span> (mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进程执行完成, 将mutex++</span></span><br><span class="line">    <span class="comment">// 其它进程可以通过wait(mutex)指令</span></span><br><span class="line">    <span class="built_in">signal</span> (mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure><ol type="1"><li>必须保证没有两个进程可以在同一信号量上同时执行wait()和signal()</li><li>没有解决busy waiting的问题</li><li>但是将解决临界区问题的代码简化了</li></ol><h3 id="没有busy-waiting的信号量实现">6.5.3 没有busywaiting的信号量实现</h3><ol type="1"><li><p>实现了一个waiting queue，等待队列中的每一个实体有2个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">// S: 记录型信号量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *list;<span class="comment">// 等待队列中的下一个进程</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li><li><p>2个操作</p><ol type="1"><li><strong>block()</strong>：将调用操作的进程放置在适当的等待队列中<ol type="1"><li>进程：running → waiting</li></ol></li><li><strong>wakeup()</strong>：删除等待队列中的一个进程，并将其置于就绪队列中<ol type="1"><li>进程：waiting → ready</li></ol></li></ol></li><li><p>具体实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(semaphore * S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 将这个进程加入S-&gt;list</span></span><br><span class="line">        <span class="built_in">block</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(semaphore *S) &#123; </span><br><span class="line">    S-&gt;value++; </span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 将进程P从S-&gt;list中移除</span></span><br><span class="line">        <span class="built_in">wakeup</span>(P); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><h3 id="waitsignal操作讨论">6.5.4 wait、signal操作讨论</h3><ol type="1"><li>通常用信号量表示资源或临界区</li><li>信号量的物理含义<ol type="1"><li><strong>S.value&gt;0</strong>：表示有S.value个资源可用；</li><li><strong>S.value=0</strong>：表示无资源可用或表示不允许进程再进入临界区；</li><li><strong>S.value&lt;0</strong>：则|S.value|表示在等待队列中进程的个数或表示等待进入临界区的进程个数</li></ol></li><li><strong>wait(S)≡P(S)≡down(S)</strong>：表示申请一个资源</li><li><strong>signal(S)≡V(S)≡up(S)</strong>： 表示释放一个资源</li><li>wait、signal操作必须成对出现，有一个wait操作就一定有一个signal操作<ol type="1"><li>当为互斥操作时(控制A, B不会同时访问临界区)，它们同处于同一进程</li><li>当为同步操作时(控制先让A执行, 再让B执行)，则不在同一进程中出现</li></ol></li><li>如果两个wait操作相邻，那么它们的顺序至关重要，而两个相邻的signal操作的顺序无关紧要</li><li>一个同步wait操作与一个互斥wait操作在一起时，同步wait操作在互斥wait操作前</li><li>wait、signal操作的优缺点<ol type="1"><li>优点：简单，而且表达能力强</li><li>缺点：不够安全；wait、signal操作使用不当会出现死锁；实现复杂</li></ol></li></ol><h3 id="信号量用于通用同步操作">6.5.5 信号量用于通用同步操作</h3><ol type="1"><li><p>先执行P<sub>i</sub>中的A操作，再执行P<sub>j</sub>中的B操作</p><ol type="1"><li>信号量<strong>flag初始化为0</strong></li></ol><table><thead><tr class="header"><th style="text-align: center;">P[i]</th><th style="text-align: center;">P[j]</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">…</td><td style="text-align: center;">…</td></tr><tr class="even"><td style="text-align: center;">A</td><td style="text-align: center;">wait(flag)</td></tr><tr class="odd"><td style="text-align: center;">signal(flag)</td><td style="text-align: center;">B</td></tr><tr class="even"><td style="text-align: center;">…</td><td style="text-align: center;">…</td></tr></tbody></table></li><li><p>一组合作进程，执行顺序如图。请用P(wait)、V(signal)操作实现进程间的同步操作</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221103165404062.png" alt="image-20221103165404062" style="zoom: 50%;" /></th><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221103165348103.png" alt="image-20221103165348103" style="zoom: 50%;" /></th></tr></thead><tbody></tbody></table><ol type="1"><li><p>设置8个信号量a~h，初始值均为0</p></li><li><p>各进程的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(a);</span><br><span class="line"><span class="built_in">signal</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(a);</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(c);</span><br><span class="line"><span class="built_in">signal</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P3</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(b);</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(e);</span><br><span class="line"><span class="built_in">signal</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P4</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(c);</span><br><span class="line"><span class="built_in">wait</span>(e);</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P5</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(d);</span><br><span class="line"><span class="built_in">wait</span>(f);</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P6</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(g);</span><br><span class="line"><span class="built_in">wait</span>(h);</span><br><span class="line">...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>两个进程互斥：信号量初始为1</p><p><img src="/images/AssetMarkdown/image-20221103170050338.png" alt="image-20221103170050338" style="zoom:80%;" /></p></li></ol><h3 id="死锁和饥饿">6.5.6 死锁和饥饿</h3><ol type="1"><li><p>死锁Deadlock：两个或多个进程无限期地等待一个事件，该事件只能由其中一个等待进程引起</p><p><img src="/images/AssetMarkdown/image-20221103170213479.png" alt="image-20221103170213479"  /></p></li><li><p>饥饿Starvation：无限期阻塞。进程可能永远不会从其挂起的信号量队列中删除</p></li><li><p>优先级反转PriorityInversion：低优先级进程持有高优先级进程所需的锁时的调度问题</p></li></ol><h2 id="同步的经典问题">6.6 同步的经典问题</h2><h3 id="有限缓冲区问题bounded-buffer-problem">6.6.1有限缓冲区问题：Bounded-Buffer Problem</h3><ol type="1"><li><p>有限缓冲区问题，也成为生产者-消费者问题，是最著名的同步问题</p><ol type="1"><li>它描述一组生产者(P<sub>1</sub>……P<sub>m</sub>)向一组消费者(C<sub>1</sub>……C<sub>q</sub>)提供消息</li><li>它们共享一个有限缓冲池(bounded buffer pool)</li><li>生产者向其中投放消息，消费者从中取得消息</li><li>生产者-消费者问题是许多相互合作进程的一种抽象</li></ol><p><img src="/images/AssetMarkdown/image-20221103171832558.png" alt="image-20221103171832558" style="zoom:67%;" /></p></li><li><p>N个buffer，每个可以存储1个item</p><ol type="1"><li>信号量<strong>full</strong>：初始化为0，表示已经使用的buffer个数</li><li>信号量<strong>empty</strong>：初始化为N，表示还未使用的buffer个数</li><li>信号量<strong>mutex</strong>：初始化为1，作为互斥信号量</li></ol></li><li><p>需要保证：</p><ol type="1"><li>对同一个buffer的操作是互斥操作</li></ol></li><li><p>生产者进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line"><span class="comment">// produce an item in nextp</span></span><br><span class="line">...;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">wait</span>(empty);<span class="comment">// 保证所有生产者插入的数量 &lt; 当前buffer的剩余空间的大小</span></span><br><span class="line"><span class="built_in">wait</span>(mutex);<span class="comment">// 保证互斥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add nextp to buffer</span></span><br><span class="line">...;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(mutex);<span class="comment">// 保证互斥</span></span><br><span class="line">    <span class="built_in">signal</span>(full);<span class="comment">// 声明有一个数据插入到buffer中, 便于消费者的使用</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>消费者进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="built_in">wait</span>(full);<span class="comment">// 保证所有消费者使用的数量 &lt; 当前buffer中存在的数据数量</span></span><br><span class="line"><span class="built_in">wait</span>(mutex);<span class="comment">// 保证互斥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove an item from buffer to nextc</span></span><br><span class="line">...;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(mutex);<span class="comment">// 保证互斥</span></span><br><span class="line">    <span class="built_in">signal</span>(empty);<span class="comment">// 声明有一个buffer已经为空, 便于生产者使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// consume the item in nextc</span></span><br><span class="line">...;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="读写问题readers-and-writers-problem">6.6.2 读写问题：Readers andWriters Problem</h3><ol type="1"><li>一个数据集（如文件）如果被几个并行进程所共享：<ol type="1"><li><strong>Reader</strong>：有些进程只要求读数据集内容，它称读者</li><li><strong>Writer</strong>：一些进程则要求修改数据集内容，它称写者</li><li>几个Reader可以同时读些数据集，而不需要互斥</li><li>一个Writer不能和其它进程（不管是写者或读者）同时访问些数据集，它们之间必须互斥</li></ol></li></ol><h4 id="第一readers-writers问题">6.6.2.1 第一Readers-Writers问题</h4><ol type="1"><li><p>读优先，要求：</p><ol type="1"><li>允许多个Reader同时阅读</li><li>同一时间只有一个写入程序可以访问共享数据</li><li>Writer能会挨饿</li></ol></li><li><p>共享数据：</p><ol type="1"><li>Data set</li><li>信号量<strong>mutex</strong>：初始化为1，作为互斥信号量</li><li>信号量<strong>wrt</strong>：初始化为1，作为不同Writer之间的互斥信号量</li><li>整数<strong>readcount</strong>：初始化为0</li></ol></li><li><p>Writer进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">wait</span> (wrt);<span class="comment">// 有wrt锁时, Writer不能写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// writing is performed</span></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span> (wrt);<span class="comment">// 释放wrt锁</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>Reader进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">wait</span>(mutex);<span class="comment">// 对readcount的互斥锁</span></span><br><span class="line">    readcount++;</span><br><span class="line">    <span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="built_in">wait</span>(wrt); <span class="comment">// 第一个Reader到时</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex);<span class="comment">// 释放对readcount的互斥锁</span></span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reading is performed</span></span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">wait</span>(mutex);<span class="comment">// 对readcount的互斥锁</span></span><br><span class="line">    readcount--;</span><br><span class="line">    <span class="keyword">if</span>(readcount == <span class="number">0</span>) <span class="built_in">signal</span>(wrt);<span class="comment">// 最后一个Reader离开时</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex);<span class="comment">// 释放对readcount的互斥锁</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="第二readers-writers问题">6.6.2.2 第二Readers-Writers问题</h4><ol type="1"><li>要求：<ol type="1"><li>一旦Writer准备好了，Writer就会尽快进行写作</li><li>Reader可能会饿死</li></ol></li></ol><h3 id="哲学家就餐问题dining-philosopher-problem">6.6.3哲学家就餐问题：Dining-Philosopher Problem</h3><blockquote><p>多进程、多资源的同步问题</p></blockquote><ol type="1"><li><p>问题说明：</p><ol type="1"><li>n个哲学家坐在一个圆桌旁</li><li>每个哲学家与邻居共用一根筷子</li><li>每个哲学家都必须有一双筷子才能吃</li><li>邻居不能同时吃饭</li><li>哲学家在思考和吃饭之间交替</li></ol><p><img src="/images/AssetMarkdown/image-20221103174703952.png" alt="image-20221103174703952" style="zoom:67%;" /></p></li><li><p>共享数据：</p><ol type="1"><li>信号量：chopstick[5]，初始值为1</li></ol></li><li><p>哲学家i：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 等待两只筷子的使用</span></span><br><span class="line">    <span class="built_in">wait</span>(chopstick[i]);</span><br><span class="line">    <span class="built_in">wait</span>(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用两只筷子</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">eat</span>();</span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明已经使用完两只筷子</span></span><br><span class="line">    <span class="built_in">signal</span>(chopstick[i]);</span><br><span class="line">    <span class="built_in">signal</span>(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不使用筷子的操作</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">think</span>();</span><br><span class="line">   ...;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>该方法很容易产生死锁</p><ol type="1"><li>原因：两个wait语句并不是原子操作</li><li>例如：每个哲学家均拿起了自己左边的一根筷子</li></ol></li><li><p>避免死锁的方法：</p><ol type="1"><li>同时只允许n-1个哲学家申请资源 ==&gt;至少有一个哲学家拿到了2个筷子</li><li>奇数编号的哲学家先拿左边再拿右边，偶数编号的哲学家先拿右边再拿左边</li><li>把哲学家分为三种状态：思考、饥饿、吃饭，并且一次拿到两只筷子，否则不拿<ol type="1"><li>hungry状态唯有保证自己能够拿到2只筷子，才能进入eat状态</li><li>本质上是保证了两句wait的原子性</li></ol></li><li>每个哲学家拿起第1根筷子一定时间后，若拿不到第2根筷子，再放下第1根筷子<ol type="1"><li>但是可能大家一起拿一起放</li></ol></li></ol></li></ol><h2 id="monitors管程">6.7* Monitors(管程)</h2><p>管程是一种高级同步机制</p><ol type="1"><li>管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程</li><li>管程可以函数库的形式实现</li><li>相比之下，管程比信号量好控制</li></ol><h3 id="信号量同步的缺点">6.7.1 信号量同步的缺点</h3><ol type="1"><li>同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如wait、signal操作的次序错误、重复或遗漏）</li><li>可读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序</li><li>不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局</li><li>正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误</li></ol><h3 id="管程的引入">6.7.2 管程的引入</h3><blockquote><p>1973年，Hoare和Hanson所提出；其基本思想是把信号量及其操作原语封装在一个对象内部。即：将共享变量以及对共享变量能够进行的所有操作集中在一个模块中。</p></blockquote><ol type="1"><li>管程的定义：管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块</li><li>管程可增强模块的独立性：系统按资源管理的观点分解成若干模块，用数据表示抽象系统资源，同时分析了共享资源和专用资源在管理上的差别，按不同的管理方式定义模块的类型和结构，使同步操作相对集中，从而增加了模块的相对独立性</li><li>引入管程可提高代码的可读性，便于修改和维护，正确性易于保证：采用集中式同步机制。一个操作系统或并发程序由若干个这样的模块所构成，一个模块通常较短，模块之间关系清晰</li></ol><h3 id="管程的主要特性">6.7.3 管程的主要特性</h3><ol type="1"><li>模块化：一个管程是一个基本程序单位，可以单独编译</li><li>抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码</li><li>信息封装：管程是半透明的，管程中的外部过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的</li></ol><h3 id="管程的实现要素">6.7.4 管程的实现要素</h3><ol type="1"><li>管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接地访问管程中的共享变量</li><li>为了保证管程共享变量的数据完整性，规定管程互斥进入</li><li>管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作</li></ol><h3 id="管程的的组成">6.7.5 管程的的组成</h3><ol type="1"><li><strong>名称</strong>：为每个共享资源设立一个管程</li><li><strong>数据结构说明</strong>：一组局部于管程的控制变量</li><li><strong>操作原语</strong>：对控制变量和临界资源进行操作的一组原语过程（程序代码），是访问该管程的唯一途径。这些原语本身是互斥的，任一时刻只允许一个进程去调用，其余需要访问的进程就等待</li><li><strong>初始化代码</strong>：对控制变量进行初始化的代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">monitor monitor-name&#123;</span><br><span class="line">shared variable declarations;</span><br><span class="line"><span class="function">procedure body <span class="title">P1</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">procedure body <span class="title">P2</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">procedure body <span class="title">Pn</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">initialization code</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/AssetMarkdown/image-20221107145057689.png" alt="image-20221107145057689" style="zoom:80%;" /></p><h3 id="管程中的多个进程进入">6.7.6 管程中的多个进程进入</h3><ol type="1"><li>当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权；当一个进入管程的进程执行唤醒操作时（如Ｐ唤醒Ｑ），管程中便存在两个同时处于活动状态的进程，如何处理？。</li><li>若进程P唤醒进程Q，则随后可有两种执行方式（进程P、Q都是管程中的进程）<ol type="1"><li>P等待，直到Q离开管程或下一次等待。Hoare采用。</li><li>Q等待，直到P离开管程或下一次等待。1980年，Lampson和Redell采用</li></ol></li><li><strong>入口等待队列(entryqueue)</strong>：因为管程是互斥进入的，所以当一个进程试图进入一个巳被占用的管程时它应当在管程的入口处等待，因而在管程的入口处应当有一个进程等待队列，称作入口等待队列</li><li><strong>紧急等待队列</strong>：如果进程Ｐ唤醒进程Ｑ，则Ｐ等待Ｑ继续，如果进程Ｑ在执行又唤醒进程Ｒ，则Ｑ等待Ｒ继续，...，如此，在管程内部，由于执行唤醒操作，可能会出现多个等待进程（已被唤醒，但由于管程的互斥进入而等待），因而还需要有一个进程等待队列，这个等待队列被称为紧急等待队列。它的优先级应当高于入口等待队列的优先级</li></ol><h3 id="条件变量condition">6.7.7 条件变量(condition)</h3><ol type="1"><li>由于管程通常是用于管理资源的，因而在管程内部，应当存在某种等待机制。当进入管程的进程因资源被占用等原因不能继续运行时使其等待。为此在管程内部可以说明和使用一种特殊类型的变量---条件变量</li><li>每个条件变量表示一种等待原因，并不取具体数值---相当于每个原因对应一个队列</li></ol><p><img src="/images/AssetMarkdown/image-20221107145621005.png" alt="image-20221107145621005" style="zoom:80%;" /></p><h3 id="同步操作原语">6.7.8 同步操作原语</h3><ol type="1"><li>同步操作原语wait和signal：针对条件变量x，x.wait()将自己阻塞在x队列中，x.signal()将x队列中的一个进程唤醒</li><li><strong>x.wait()</strong>：如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程排入x队列尾部<ol type="1"><li>紧急等待队列与x队列的关系：紧急等待队列是由于管程的互斥进入而等待的队列，而x队列是因资源被占用而等待的队列</li></ol></li><li><strong>x.signal()</strong>：如果x队列为空，则相当于空操作，执行此操作的进程继续；否则唤醒第一个等待者，执行x.signal()操作的进程排入紧急等待队列的尾部</li></ol><h3 id="用管程解决哲学家问题">6.7.9 用管程解决哲学家问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">monitor dp &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;thinking, hungry, eating&#125; state[<span class="number">5</span>];</span><br><span class="line">    condition self[<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickup</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// 哲学家i拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putdown</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// 哲学家i放下筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// 判断哲学家i是否可以拿起筷子</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化时, 所有哲学家均为thinking</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            state[i] = thinking;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哲学家i拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickup</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">state[i] = hungry;<span class="comment">// 将自己变为hungry状态</span></span><br><span class="line"><span class="built_in">test</span>(i);<span class="comment">// 判断自己是否能够拿起筷子</span></span><br><span class="line"><span class="keyword">if</span> (state[i] != eating)<span class="comment">// 如果不能, 把自己放进wait queue中</span></span><br><span class="line">self[i].<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哲学家i放下筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putdown</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">state[i] = thinking;<span class="comment">// 将自己变为thinking状态, 即释放资源</span></span><br><span class="line"><span class="built_in">test</span>((i+<span class="number">4</span>) % <span class="number">5</span>);<span class="comment">// 判断左邻居是否能够拿起筷子</span></span><br><span class="line"><span class="built_in">test</span>((i+<span class="number">1</span>) % <span class="number">5</span>);<span class="comment">// 判断右邻居是否能够拿起筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哲学家i是否可以拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( (state[(i + <span class="number">4</span>) % <span class="number">5</span>] != eating) &amp;&amp; <span class="comment">// 左边没有eating</span></span><br><span class="line">   (state[i] == hungry) &amp;&amp;<span class="comment">// 自己处于饥饿状态</span></span><br><span class="line">   (state[(i + <span class="number">1</span>) % <span class="number">5</span>] != eating)<span class="comment">// 右边没有eating</span></span><br><span class="line">           ) &#123;</span><br><span class="line">state[i] = eating;</span><br><span class="line">self[i].<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Philosopher i:</span></span><br><span class="line"><span class="keyword">do</span>&#123;  </span><br><span class="line">    dp.<span class="built_in">pickup</span>(i);</span><br><span class="line">    eat;</span><br><span class="line">    dp.<span class="built_in">putdown</span>(i);</span><br><span class="line">    think;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="总结-2">6.8 总结</h2><p><img src="/images/AssetMarkdown/image-20221107151133964.png" alt="image-20221107151133964" style="zoom:80%;" /></p><h1 id="chapter-7deadlocks死锁">Chapter 7：Deadlocks死锁</h1><h2 id="system-model">7.1 System Model</h2><p><img src="/images/AssetMarkdown/image-20221107152551989.png" alt="image-20221107152551989" style="zoom:80%;" /></p><ol type="1"><li><strong>死锁</strong>：<ol type="1"><li>一组被阻塞的进程，每个进程持有一个资源，并等待获取该组中另一个进程持有的资源</li><li>指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</li></ol></li><li>系统模型<ol type="1"><li>资源类型<span class="math inline">\(R_1,R_2,...R_m\)</span><ol type="1"><li>CPU时钟、内存空间、I/O设备</li></ol></li><li>每个资源类型<span class="math inline">\(R_i\)</span>可以有<spanclass="math inline">\(W_i\)</span>个实例<ol type="1"><li>每种资源类型可以有多个实例</li><li>实例对应着实际能够分配的资源类型</li></ol></li><li>进程对资源的使用有以下三种类型<ol type="1"><li>Request 申请</li><li>Use 使用</li><li>Release 释放</li></ol></li></ol></li></ol><h2 id="死锁的特征">7.2 死锁的特征</h2><h3 id="产生死锁的4个必要条件">7.2.1 产生死锁的4个必要条件</h3><ol type="1"><li><strong>Mutual exclusion</strong>互斥：<ol type="1"><li>同一时间只有一个进程能够使用一个资源实例</li></ol></li><li><strong>Hold and wait</strong>占有并等待、请求和保持：<ol type="1"><li>进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放</li></ol></li><li><strong>No preemption</strong>不可抢占、不剥夺：<ol type="1"><li>资源只能由持有该资源的进程在该进程完成任务后自愿释放</li></ol></li><li><strong>Circular wait</strong>循环等待：<ol type="1"><li>存在一组{P<sub>0</sub>，P<sub>1</sub>，…，P<sub>n</sub>}等待进程，使得P<sub>0</sub>正在等待P<sub>1</sub>所持有的资源，P<sub>1</sub>正在等待P<sub>2</sub>持有的资源，…，P<sub>n–1</sub>正在等待P<sub>n</sub>持有的资源，P<sub>n</sub>正在等待P<sub>0</sub>持有的</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221107153603565.png" alt="image-20221107153603565" style="zoom: 67%;" /></p><h3 id="资源分配图-resource-allocation-graph">7.2.2 资源分配图Resource-Allocation Graph</h3><ol type="1"><li><p>节点<span class="math inline">\(V\)</span>：</p><ol type="1"><li>进程节点：P = {P<sub>1</sub>, P<sub>2</sub>, …, P<sub>n</sub>}</li><li>资源节点：R = {R<sub>1</sub>, R<sub>2</sub>, …, R<sub>m</sub>}</li></ol></li><li><p>边<span class="math inline">\(E\)</span>：</p><ol type="1"><li>请求边：P<sub>i</sub> → R<sub>j</sub></li><li>分配边：R<sub>j</sub> → P<sub>i</sub></li></ol></li><li><p>节点&amp;边的图例</p><p><img src="/images/AssetMarkdown/image-20221107153842238.png" alt="image-20221107153842238" style="zoom: 67%;" /></p></li><li><p>例：</p><ol type="1"><li>P<sub>1</sub>获取了R<sub>2</sub>资源，请求R<sub>1</sub>的资源</li><li>P<sub>2</sub>获取了R<sub>1</sub>、R<sub>2</sub>资源，请求R<sub>3</sub>资源</li><li>P<sub>3</sub>获取了R<sub>3</sub>资源</li></ol><p><img src="/images/AssetMarkdown/image-20221107153922149.png" alt="image-20221107153922149" style="zoom:67%;" /></p></li><li><p><img src="/images/AssetMarkdown/image-20221107154315836.png" alt="image-20221107154315836" style="zoom:80%;" /></p></li><li><p><img src="/images/AssetMarkdown/image-20221107154449530.png" alt="image-20221107154449530" style="zoom:80%;" /></p></li><li><p>判断条件</p><ol type="1"><li>如果图中没有环 ==&gt; 没有死锁</li><li>如果图中有环<ol type="1"><li>如果每个资源只有一个实例 ==&gt; 死锁</li><li>如果每个资源拥有多个实例 ==&gt; 有可能死锁，也可能不死锁</li></ol></li></ol></li><li><p>死锁定理：</p><ol type="1"><li><span class="math inline">\(S\)</span>为死锁状态的充分条件是：<spanclass="math inline">\(S\)</span>状态的资源分配图是不可完全简化的</li><li>资源分配图（有向图）的简化：离散数学算法</li></ol></li></ol><h2 id="处理死锁的方法">7.3 处理死锁的方法</h2><ol type="1"><li>保证系统不进入死锁状态<ol type="1"><li>Prevention死锁预防</li><li>Avoidance死锁避免</li></ol></li><li>允许系统进入死锁状态，然后恢复<ol type="1"><li>Detection死锁检测</li><li>Recovery死锁解除</li></ol></li><li>忽略死锁状态，操作系统假装不发生死锁，人为解决死锁状态</li></ol><h2 id="死锁预防-deadlock-prevention">7.4 死锁预防 DeadlockPrevention</h2><ol type="1"><li>不保证相互排斥(<strong>Mutual Exclusion</strong>)<ol type="1"><li>不需要可共享资源；必须保留不可分割的资源</li><li>虚拟化</li></ol></li><li>不保证保持等待(<strong>Hold and Wait</strong>)<ol type="1"><li>必须确保无论进程何时请求资源，它都不会保留任何其他资源</li><li>要求进程在开始执行之前请求并分配其所有资源，或者仅当进程没有资源时才允许进程请求资源</li><li>资源静态预分配方式</li><li>资源利用率低；可能导致饥饿</li></ol></li><li>允许抢占(<strong>No Preemption</strong>)<ol type="1"><li>如果持有某些资源的进程请求另一个无法立即分配给它的资源，那么当前持有的所有资源都将被释放</li><li>抢占的资源将添加到进程正在等待的资源列表中</li><li>只有当进程能够重新获得它的旧资源以及它所请求的新资源时，它才会重新启动</li></ol></li><li>保证不出现循环等待(<strong>Circular Wait</strong>)<ol type="1"><li>给所有资源类型的编号，并要求每个进程以递增的顺序请求资源</li><li>F(磁带驱动器)=1，F(磁盘驱动器)=5，F(打印机)=12</li><li>资源的有序申请破坏了循环等待条件</li></ol></li></ol><h2 id="死锁避免-deadlock-avoidance">7.5 死锁避免 DeadlockAvoidance</h2><ol type="1"><li>要求每个进程声明其可能需要的每种类型的最大资源数量</li><li>死锁避免算法动态检查资源分配状态，以确保永远不会出现循环等待条件</li><li>资源分配状态由可用和已分配资源的数量以及进程的最大需求来定义</li></ol><h3 id="安全状态-safe-state">7.5.1 安全状态 Safe State</h3><ol type="1"><li><p>当进程请求可用资源时，系统必须决定立即分配是否使系统处于安全状态</p></li><li><p>安全状态是指系统的一种状态，在此状态开始系统能按某种顺序（如P<sub>1</sub>、P<sub>2</sub>……P<sub>n</sub>）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。</p><ol type="1"><li>这个序列（P<sub>1</sub>、P<sub>2</sub>…….P<sub>n</sub>）称为安全序列</li><li>若系统此状态不存在一个安全序列，则称系统处于不安全状态</li><li>如果存在所有进程的安全序列，则系统处于安全状态</li></ol></li><li><p>序列（P<sub>1</sub>、P<sub>2</sub>……P<sub>n</sub>）是安全的，满足：对于每个P<sub>i</sub>，P<sub>i</sub>仍然可以请求的资源，可以由<strong>当前可用资源+所有P<sub>j</sub>所持有的资源</strong>来满足，其中<strong>j＜i</strong>。</p><ol type="1"><li>如果P<sub>i</sub>资源需求不立即可用，则P<sub>i</sub>可以等到所有P<sub>j</sub>完成</li><li>当P<sub>j</sub>完成时，P<sub>i</sub>可以获得所需的资源、执行、返回分配的资源并终止</li><li>当P<sub>i</sub>终止时，P<sub>i+1</sub>可以获得其所需的资源，依此类推</li></ol></li><li><p>定理</p><ol type="1"><li>系统处于安全状态 ==&gt; 没有死锁</li><li>系统处于不安全状态 ==&gt; 可能死锁</li><li>死锁避免：保证系统不会进入不安全状态</li></ol><p><img src="/images/AssetMarkdown/image-20221110165653047.png" alt="image-20221110165653047" style="zoom:50%;" /></p></li><li><p>避免算法</p><ol type="1"><li>每个资源只有一个实例：resource-allocation graph</li><li>每个资源有多个实例：banker’s algorithm</li></ol></li></ol><h3 id="resource-allocation-graph-algorithm-资源分配图算法">7.5.3Resource-Allocation Graph Algorithm 资源分配图算法</h3><ol type="1"><li><strong>需求边</strong>P<sub>i</sub>→R<sub>j</sub>：P<sub>i</sub>可能会请求资源R<sub>j</sub>，用虚线表示</li><li><strong>需求边</strong>转化为<strong>请求边</strong>：当且仅当该进程请求了该资源</li><li><strong>请求边</strong>转化为<strong>分配边</strong>：当且仅当资源被分配给了这个进程</li><li><strong>分配边</strong>转化为<strong>请求边</strong>：当且仅当资源被进程释放</li><li>资源必须在系统中声明优先级</li></ol><p><img src="/images/AssetMarkdown/image-20221110171751275.png" alt="image-20221110171751275" style="zoom:80%;" /></p><ol type="1"><li>算法：假设进程P<sub>i</sub>申请资源R<sub>j</sub>。只有在需求边P<sub>i</sub>→R<sub>j</sub>变成分配边R<sub>j</sub>→P<sub>i</sub>而不会导致资源分配图形成环时，才允许申请。</li><li>用算法循环检测，如果没有环存在，那么资源分配会使系统处于安全状态。如果存在环，资源分配会使系统不安全。进程P<sub>i</sub>必须等待。</li></ol><p><img src="/images/AssetMarkdown/image-20221110172013247.png" alt="image-20221110172013247" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221110172028197.png" alt="image-20221110172028197" style="zoom:80%;" /></p><h3 id="bankers-algorithm-银行家算法">7.5.3 Banker’s Algorithm银行家算法</h3><ol type="1"><li>每个过程必须事先声明最大使用量</li><li>当进程请求资源时，它可能需要等待</li><li>当一个进程获得其所有资源时，它必须在有限的时间内返回这些资源</li><li>参数定义<ol type="1"><li><strong>n</strong>：进程数目</li><li><strong>m</strong>：资源的种类</li><li><strong>Available</strong>：长度为m的向量。如果Availabe[j]=k，表示R<sub>j</sub>有k个实例可以使用</li><li><strong>Max</strong>：n×m的矩阵。如果Max[i][j]=k，那么P<sub>i</sub>会申请至多k个R<sub>j</sub>资源</li><li><strong>Allocation</strong>：n×m的矩阵。如果Allocation[i][j]=k，那么P<sub>i</sub>已经申请了k个R<sub>j</sub>资源</li><li><strong>Need</strong>：n×m的矩阵。如果Need[i][j]=k，那么P<sub>i</sub>还需要k个R<sub>j</sub>资源来完成任务<ol type="1"><li>Need[i] [j] = Max[i] [j] - Allocation[i] [j]</li></ol></li></ol></li></ol><h4 id="safety-algorithm-安全算法">7.5.3.1 Safety Algorithm安全算法</h4><ol type="1"><li>令<strong>Work</strong>为一个长度为<strong>m</strong>的向量，<strong>Finish</strong>为一个长度为<strong>n</strong>的向量，初始化为：<ol type="1"><li>Work = Availabe</li><li>Finish[i] = { false }</li></ol></li><li>找到一个序号<strong>i</strong>，满足<ol type="1"><li>Finish[i] = false</li><li>Need[i] <span class="math inline">\(\le\)</span> Work</li><li>如果不存在，进入步骤4</li></ol></li><li><strong>Work = Work + Allocation[i]</strong><ol type="1"><li>Finish[i] = true</li><li>返回步骤2</li></ol></li><li>如果<strong>Finish = { true }</strong>，则系统已经在安全状态</li></ol><h4 id="resource-request-algorithm-资源-请求算法">7.5.3.2Resource-Request Algorithm 资源-请求算法</h4><p><strong>Request[i]</strong>：进程P<sub>i</sub>的请求向量，如果Request[i][j]=k，那么P<sub>i</sub>想要申请k个R<sub>j</sub>资源</p><ol type="1"><li><p>如果Request[i] <span class="math inline">\(\le\)</span>Need[i]，则进入步骤2。否则，引发错误条件，因为进程已超过其最大声明</p></li><li><p>如果Request[i] <span class="math inline">\(\le\)</span>Availabe，则进入步骤3。否则，P<sub>i</sub>必须等待，因为资源不能满足需求</p></li><li><p>通过如下修改状态，尝试将请求的资源分配给P<sub>i</sub></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available = Available - Request[i];</span><br><span class="line">Allocation[i] = Allocation[i] + Request[i];</span><br><span class="line">Need[i] = Need[i] - Request[i];</span><br></pre></td></tr></table></figure><ol type="1"><li>调用<strong>Safety Algorithm</strong></li><li>如果安全，则可以分配给P<sub>i</sub></li><li>如果不安全，则P<sub>i</sub>必须等待，并恢复旧的资源分配状态</li></ol></li></ol><h4 id="例">7.5.3.3 例</h4><p><img src="/images/AssetMarkdown/image-20221110174813937.png" alt="image-20221110174813937" style="zoom:80%;" /></p><ol type="1"><li><p>系统的状态（是否安全）？</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221110174824533.png" alt="image-20221110174824533" style="zoom:80%;" /></th></tr></thead><tbody></tbody></table></li><li><p>P1的请求(1,0,2)是否通过？</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221114144616824.png" alt="image-20221114144616824" style="zoom:80%;" /></th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221114145030851.png" alt="image-20221114145030851" style="zoom: 80%;" /></td></tr></tbody></table></li><li><p>P4的请求(3,3,0)是否通过？</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221114150016856.png" alt="image-20221114150016856" style="zoom:80%;" /></th></tr></thead><tbody></tbody></table></li><li><p>P0的请求(0,2,0)是否通过？</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221114150041457.png" alt="image-20221114150041457" style="zoom:80%;" /></th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221114150056267.png" alt="image-20221114150056267" style="zoom:80%;" /></td></tr></tbody></table></li></ol><h2 id="死锁检测-deadlock-detection">7.6 死锁检测 DeadlockDetection</h2><h3 id="每个资源只有一个实例">7.6.1 每个资源只有一个实例</h3><ol type="1"><li>维护一个等待图wait-for-graph：资源分配图的变形<ol type="1"><li>节点：进程</li><li>边：P<sub>i</sub>→P<sub>j</sub>表示P<sub>i</sub>正在等待P<sub>j</sub>释放资源</li></ol></li><li>定期调用检测图中是否存在环的算法</li><li>检测图中是否存在环的算法为O(n<sup>2</sup>)，其中n是图中顶点的数量</li></ol><p><img src="/images/AssetMarkdown/image-20221114151401765.png" alt="image-20221114151401765" style="zoom:80%;" /></p><h3 id="每个资源有多个实例">7.6.2 每个资源有多个实例</h3><ol type="1"><li>数据结构：<ol type="1"><li><strong>Available</strong>：长度为m的向量。如果Availabe[j]=k，表示R<sub>j</sub>有k个实例可以使用</li><li><strong>Allocation</strong>：n×m的矩阵。如果Allocation[i][j]=k，那么P<sub>i</sub>已经申请了k个R<sub>j</sub>资源</li><li><strong>Request</strong>：n×m的矩阵。如果Request[i][j]=k，那么P<sub>i</sub>正在申请k个R<sub>j</sub>资源</li></ol></li><li>检测算法：O(m×n<sup>2</sup>)<ol type="1"><li>令<strong>Work</strong>为一个长度为<strong>m</strong>的向量，<strong>Finish</strong>为一个长度为<strong>n</strong>的向量，初始化为：<ol type="1"><li>Work = Availabe</li><li>Finish[i] = { Allocation[k] [i]==0 ? true : false }</li></ol></li><li>找到一个序号<strong>i</strong>，满足<ol type="1"><li>Finish[i] = false</li><li>Request[i] <span class="math inline">\(\le\)</span> Work</li><li>如果不存在，进入步骤4</li></ol></li><li><strong>Work = Work + Allocation[i]</strong><ol type="1"><li>Finish[i] = true</li><li>返回步骤2</li></ol></li><li>如果存在<strong>Finish[i] ==false</strong>，则系统处于死锁状态，且是P<sub>i</sub>被死锁</li></ol></li></ol><h3 id="示例-4">7.6.3 示例</h3><ol type="1"><li><p>一共5个进程：P<sub>0</sub>~P<sub>4</sub>，3中资源：A(7个示例)、B(2个示例)、C(6个示例)</p></li><li><p>T<sub>0</sub>时的snapshot：</p><p><img src="/images/AssetMarkdown/image-20221114152426673.png" alt="image-20221114152426673" style="zoom:80%;" /></p><ol type="1"><li>执行序列：P<sub>0</sub>, P<sub>2</sub>, P<sub>3</sub>,P<sub>1</sub>, P<sub>4</sub></li></ol></li><li><p>T<sub>1</sub>时的snapshot：</p><p><img src="/images/AssetMarkdown/image-20221114152613665.png" alt="image-20221114152613665" style="zoom:80%;" /></p><ol type="1"><li>将P<sub>0</sub>执行结束后，无法执行P<sub>1</sub>~P<sub>4</sub>的任意一个进程，系统进入死锁状态</li><li>处于死锁状态的进程为P<sub>1</sub>~ P<sub>4</sub></li></ol></li></ol><h3 id="死锁检测算法的使用">7.6.4 死锁检测算法的使用</h3><ol type="1"><li>死锁检测算法的使用频率，取决于死锁发生的频率、希望有多少进程需要被回滚<ol type="1"><li>死锁发生的频率越高，死锁检测算法的使用频率越高</li><li>希望回滚的进程越少，死锁检测算法的使用频率越高</li></ol></li><li>如果随机调用检测算法，那么资源图中可能会有很多循环，因此我们将无法判断是哪个死锁进程“导致”了死锁</li></ol><h2 id="从死锁中恢复">7.7 从死锁中恢复</h2><ol type="1"><li>检测到死锁后采取措施：<ol type="1"><li>通知系统管理员</li><li>系统自己恢复</li></ol></li><li>打破死锁两种方法：<ol type="1"><li>进程终止</li><li>抢占资源</li></ol></li></ol><h3 id="进程终止-process-termination">7.7.1 进程终止 ProcessTermination</h3><ol type="1"><li>中止所有死锁进程</li><li>一次中止一个进程，直到消除死锁循环</li><li>许多因素可能决定选择哪种进程，包括：<ol type="1"><li>进程的优先级</li><li>这个进程计算了多长时间，还有多长时间才能完成</li><li>进程使用的资源</li><li>资源进程需要完成</li><li>需要终止多少进程</li><li>该进程是交互式的还是批处理的</li></ol></li></ol><h3 id="抢占资源-resource-preemption">7.7.2 抢占资源 ResourcePreemption</h3><ol type="1"><li>选择受害者：将成本降至最低最小化代价</li><li>回滚rollback： 返回到某个安全状态，从该状态重新启动进程。</li><li>饥饿starvation：同样的过程可能总是被选为受害者，包括成本因素中的回滚次数。</li></ol><h1 id="chapter-8main-memory">Chapter 8：Main Memory</h1><h2 id="background-1">8.1 Background</h2><ol type="1"><li>程序必须（从磁盘）放入内存，并放置在进程中才能运行</li><li>CPU只能直接访问主存储器和寄存器</li><li>寄存器访问的时间：1个CPU clock</li><li>主存储器访问的时间：需要很多周期</li><li>cache位于主内存和CPU寄存器之间</li><li>确保正确操作所需的内存保护</li></ol><h3 id="存储架构">8.1.1 存储架构</h3><p><img src="/images/AssetMarkdown/image-20221117163742987.png" alt="image-20221117163742987" style="zoom:80%;" /></p><h3 id="主存">8.1.2 主存</h3><p>基于冯·诺依曼体系结构，数据和程序指令存在于共享内存空间中</p><ol type="1"><li>程序重复执行以下内容：fetch-decode-execute</li><li>执行部分通常需要：数据获取和存储操作</li></ol><p><img src="/images/AssetMarkdown/image-20221117163934518.png" alt="image-20221117163934518" style="zoom:80%;" /></p><h3 id="逻辑地址-vs-物理地址">8.1.3 逻辑地址 vs 物理地址</h3><ol type="1"><li><strong>Logicaladdress</strong>(逻辑地址，相对地址，虚地址)：generated by the CPU; alsoreferred to as virtual address<ol type="1"><li>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式。</li><li>其首地址为0，其余指令中的地址都相对于首地址来编址。</li><li>不能用逻辑地址在内存中读取信息。</li></ol></li><li><strong>Physical address</strong>(物理地址，绝对地址，实地址)：address seen by the memory unit<ol type="1"><li>内存中存储单元的地址。物理地址可直接寻址</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221117164559398.png" alt="image-20221117164559398" style="zoom:80%;" /></p><h3 id="基址寄存器限长寄存器">8.1.4 基址寄存器、限长寄存器</h3><p>基址寄存器base register、限长寄存器limitregister：定义了逻辑内存空间</p><p><img src="/images/AssetMarkdown/image-20221117164654643.png" alt="image-20221117164654643" style="zoom:80%;" /></p><h3 id="将指令和数据与内存绑定">8.1.5 将指令和数据与内存绑定</h3><p>Addressbinding(地址绑定、地址映射、重定位)：指令和数据到内存地址的转换可以在三个不同的阶段进行</p><ol type="1"><li>编译时间：<ol type="1"><li>如果内存位置先验已知，则可以生成绝对代码</li><li>如果开始位置更改，则必须重新编译代码</li></ol></li><li>加载时间：<ol type="1"><li>如果编译时内存位置未知，则必须生成可<strong>重定位代码 relocatablecode</strong></li></ol></li><li>执行时间：<ol type="1"><li>如果进程在执行过程中可以从一个内存段移动到另一个内存，则绑定延迟到运行时</li><li>需要地址映射的硬件支持（如：Base and Limit Registers）</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221117165240437.png" alt="image-20221117165240437" style="zoom:67%;" /></p><h3 id="memory-management-unit-mmu">8.1.6 Memory-Management Unit(MMU)</h3><ol type="1"><li>将虚拟地址映射到物理地址的硬件设备</li><li>在MMU方案中，重定位寄存器(relocationregister)中的值被添加到用户进程在发送到内存时生成的每个地址</li><li>用户程序处理逻辑地址；它永远看不到真实的物理地址</li></ol><p><img src="/images/AssetMarkdown/image-20221117165947940.png" alt="image-20221117165947940" style="zoom:80%;" /></p><h3 id="dynamic-loading-动态载入">8.1.7 Dynamic Loading 动态载入</h3><ol type="1"><li>使用动态加载，进程启动时不会加载外部库<ol type="1"><li>库以可重定位的形式存储在磁盘上</li><li>仅在需要时将库加载到内存中</li></ol></li><li>更好的内存空间利用率；从未加载未使用的例程</li><li>当需要大量代码来处理不经常发生的情况时很有用</li><li>无需通过程序设计实现操作系统的特殊支持</li></ol><h3 id="dynamic-linking-动态链接">8.1.8 Dynamic Linking 动态链接</h3><ol type="1"><li>使用动态链接，可以将外部库预加载到（共享）内存中<ol type="1"><li>当进程调用库函数时，确定相应的物理地址</li></ol></li><li>一小段代码 (stub) 用于定位适当的内存驻留库例程</li><li>Stub用例程的地址替换自身，并执行例程</li><li>操作系统需要检查例程是否在进程的内存地址中</li><li>动态链接对库的调用特别有用</li><li>这种模式也称为共享库</li><li>Dynamically Linked Library 动态链接库</li></ol><h2 id="swapping-交换技术">8.2 Swapping 交换技术</h2><h3 id="交换技术">8.2.1 交换技术</h3><ol type="1"><li>进程可以临时从内存中交换到后备存储，然后再带回内存中继续执行</li><li>Backingstore备份存储：足够大的快速磁盘，可容纳所有用户的所有内存映像副本；必须提供对这些内存映像的直接访问<ol type="1"><li>Linux、UNIX-交换区</li><li>Windows-交换文件（pagefile.sys）</li></ol></li><li>Roll out，Roll in(调出，调进)<ol type="1"><li>用于基于优先级的调度算法的交换变量</li><li>低优先级进程被交换出去，以便可以加载和执行高优先级进程</li></ol></li><li>交换时间的主要部分是传输时间；总传输时间与交换的内存量成正比</li><li>在许多系统（如UNIX、Linux和Windows）上都可以找到经过修改的交换版本</li><li>系统维护一个准备好运行的进程队列，这些进程在磁盘上具有内存映像</li></ol><p><img src="/images/AssetMarkdown/image-20221117171601893.png" alt="image-20221117171601893" style="zoom:80%;" /></p><h3 id="不同操作系统的swapping">8.2.2 不同操作系统的Swapping</h3><ol type="1"><li>UNIX, Linux, and Windows：<ol type="1"><li>正常情况下，禁止交换</li><li>当空闲内存低于某一个阈值时，启用交换换出</li><li>当空闲内存增加一定数量时，停止换出</li></ol></li><li>移动系统不支持交换，Flash memory based：<ol type="1"><li>小空间</li><li>闪存写次数限制</li><li>在移动平台上闪存和CPU之间的吞吐量很低</li></ol></li><li>iOS要求应用程序自愿放弃分配的内存<ol type="1"><li>只读数据从系统中直接删除，已修改数据不会被删除</li><li>OS可以终止任何未能释放足够空间的应用</li></ol></li><li>Android如果空闲内存不足，会终止应用程序，但首先会将应用程序状态写入闪存，以便快速重启</li></ol><h2 id="contiguous-allocation-连续分配">8.3 Contiguous Allocation连续分配</h2><h3 id="连续分配">8.3.1 连续分配</h3><ol type="1"><li>主内存通常分为两个分区(分区):<ol type="1"><li>Resident operatingsystem常驻操作系统：通常保存在具有中断向量的低内存中</li><li>User processes用户进程：保存在高内存中</li></ol></li><li>Relocation registers重新定位寄存器：用于保护用户进程彼此不受影响，以及防止操作系统代码和数据发生变化<ol type="1"><li>Base register基址寄存器：包含最小物理地址的值</li><li>Limitregister限制寄存器：包含逻辑地址范围–每个逻辑地址必须小于限制寄存器</li><li>MMU动态映射逻辑地址</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221117172600963.png" alt="image-20221117172600963" style="zoom:67%;" /></p><h3 id="multiple-partition-allocation-多分区分配">8.3.2Multiple-partition allocation 多分区分配</h3><p>分区式管理的基本思想是将内存划分成若干个连续区域，称为分区。每个分区只能存放一个进程</p><h4 id="fixed-partitioning-固定分区">8.3.2.1 Fixed Partitioning固定分区</h4><ol type="1"><li>预先将内存空间切分成多个分区，当进程需要分区时，将一个大小匹配的分区分配给它</li></ol><p><img src="/images/AssetMarkdown/image-20221117173040646.png" alt="image-20221117173040646" style="zoom:67%;" /></p><h4 id="dynamic-partitions-动态分区">8.3.2.2 Dynamic Partitions动态分区</h4><ol type="1"><li><p>动态划分内存，在程序装入内存时把可用内存“切出”一个连续的区域分配给该进程，且分区大小正好适合进程的需要</p></li><li><p>操作系统需要维护的信息包括：</p><ol type="1"><li>allocated partitions 已分配的分区</li><li>free partitions (hole) 空闲的分区</li></ol><p><img src="/images/AssetMarkdown/image-20221117173241390.png" alt="image-20221117173241390" style="zoom:80%;" /></p></li><li><p>如何满足free holes列表中大小为n的请求</p><ol type="1"><li><p><strong>First-Fit</strong>：找到第一个能够满足要求的hole</p><p><img src="/images/AssetMarkdown/image-20221117173822733.png" alt="image-20221117173822733" style="zoom:67%;" /></p></li><li><p><strong>Best-Fit</strong>：找到能够满足要求的、最小的hole</p><p><img src="/images/AssetMarkdown/image-20221117173855252.png" alt="image-20221117173855252" style="zoom:67%;" /></p></li><li><p><strong>Worst-Fit</strong>：找到能够满足要求的、最大的hole</p><p><img src="/images/AssetMarkdown/image-20221117174055187.png" alt="image-20221117174055187" style="zoom: 67%;" /></p></li><li><p><strong>Next-Fit</strong>：从上次查找结束的地方开始，找到第一个能够满足要求的hole</p><p><img src="/images/AssetMarkdown/image-20221117174216889.png" alt="image-20221117174216889" style="zoom:67%;" /></p></li></ol></li></ol><h3 id="fragmentation-碎片">8.3.3 Fragmentation 碎片</h3><ol type="1"><li><p>内存因碎片而浪费，这可能会导致性能问题</p><ol type="1"><li>Internalfragmentation(内碎片、内零头)：在单个进程内存空间中浪费内存</li><li>External fragmentation(外碎片、外零头)：可能会减少可运行进程的数量<ol type="1"><li>总内存剩余空间可以满足要求，但由于内存空间不连续，导致程序不能运行</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221117174441628.png" alt="image-20221117174441628" style="zoom:80%;" /></p></li><li><p>通过压缩或整理碎片减少外部碎片(compaction or defragmentation）</p><ol type="1"><li>重新排列内存内容，将所有可用内存块组织在一个大块中</li><li>只有当重新定位是动态的并且在执行时完成时，才能进行压缩</li></ol><p><img src="/images/AssetMarkdown/image-20221117174612719.png" alt="image-20221117174612719" style="zoom:80%;" /></p></li></ol><h2 id="paging-分页页式存储管理">8.4 Paging 分页，页式存储管理</h2><h3 id="paging">8.4.1 Paging</h3><ol type="1"><li>进程的物理地址空间可能是不连续的；只要物理内存可用，就为进程分配物理内存</li><li>将<strong>物理内存</strong>划分为固定大小的块，称为<strong>frames</strong>(帧、物理块、页框)<ol type="1"><li>大小为2的整数次幂，介于512 bytes和8192 bytes之间</li><li>Linux、Windows for x86：4K</li></ol></li><li>将<strong>逻辑内存</strong>分成与帧大小相同的块，称为<strong>pages</strong>(页）</li><li>使用paging的模式<ol type="1"><li>跟踪所有空闲帧</li><li>要运行n pages大小的程序，需要找到n个空闲的frames，然后加载程序<ol type="1"><li>如果找不到，可以使用swap技术，将一部分程序放进内存，另一部分程序放入swap区</li></ol></li><li>设置<strong>page table</strong>(页表)，将逻辑地址转换为物理地址<ol type="1"><li>page table 列出了进程的逻辑页与其在主存中的物理帧间的对应关系</li></ol></li></ol></li><li>会存在Internal fragmentation</li></ol><h3 id="noncontiguous-allocation-非连续内存分配">8.4.2 NoncontiguousAllocation 非连续内存分配</h3><ol type="1"><li>当一个进程需要n个page运行时，操作系统会找到n个空闲的frame</li><li>操作系统通过一个page table，跟踪页的使用</li><li>一般情况下，最后一个page都无法用满，但是系统依旧会给它分配一个frame<ol type="1"><li>会导致Internal fragmentation</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221121144118808.png" alt="image-20221121144118808" style="zoom:80%;" /></p><h3 id="逻辑和物理内存的分页模型">8.4.3 逻辑和物理内存的分页模型</h3><ol type="1"><li><p>page table将逻辑内存地址映射到物理内存地址</p><p><img src="/images/AssetMarkdown/image-20221121144326270.png" alt="image-20221121144326270" style="zoom:67%;" /></p></li><li><p>例：进程<spanclass="math inline">\(P_i\)</span>需要16字节的逻辑内存</p><ol type="1"><li>逻辑内存通过页面表映射到32字节内存，页面大小为4字节</li></ol><p><img src="/images/AssetMarkdown/image-20221121144532110.png" alt="image-20221121144532110" style="zoom:67%;" /></p></li></ol><h3 id="address-translation-scheme-地址变换">8.4.4 Address TranslationScheme 地址变换</h3><ol type="1"><li><p>CPU生成的地址分为：</p><ol type="1"><li>pagenumber(p)页号：用作页表的索引，该页表包含物理内存中每个页的基地址</li><li>pageoffset(d)偏移：与基地址相结合以定义发送到存储器单元的物理存储器地址</li></ol></li><li><p>若page size = 2<sup>n</sup>，地址空间为2<sup>m</sup>，则地址可以分为：</p><p><img src="/images/AssetMarkdown/image-20221121145047525.png" alt="image-20221121145047525" style="zoom:67%;" /></p></li><li><p>Paging Hardware</p><p><img src="/images/AssetMarkdown/image-20221121145916777.png" alt="image-20221121145916777" style="zoom: 67%;" /></p></li><li><p>页面大小为4KB，虚地址2362H、1565H的物理地址分别是？页表如下</p><table><thead><tr class="header"><th style="text-align: center;">页号</th><th style="text-align: center;">页框 (Page Frame)号</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">101H</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">102H</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">254H</td></tr></tbody></table><ol type="1"><li>4KB=1000H</li><li>逻辑地址2362H对应的页号为2，254000H+362H = 254362H</li><li>逻辑地址1565H对应的页号为1，102000H+565H = 102565H</li></ol></li></ol><h3 id="page-table的实现">8.4.5 Page Table的实现</h3><ol type="1"><li>页表保存在Main Memory中</li><li>页表基寄存器(<strong>PTBR</strong>, Page-table baseregister)：指向页表，x86:cr3</li><li>页表长度寄存器(<strong>PTLR</strong>, Page-table length register)：表示页表的大小</li><li>在该方案中，每个数据/指令访问都需要两次memory访问<ol type="1"><li>一个用于页表</li><li>一个用于数据/指令</li></ol></li><li>两次内存访问可以通过使用cache来加速，该cache被称为联想寄存器、快表<ol type="1"><li>associative memory</li><li>TLB：translation look-aside buffers</li></ol></li><li>一些TLB在每个TLB条目中存储地址空间标识符(ASID, address-spaceidentifiers)：唯一标识每个进程，为该进程提供地址空间保护</li></ol><h3 id="associative-memory">8.4.6 Associative Memory</h3><p><img src="/images/AssetMarkdown/image-20221121152152896.png" alt="image-20221121152152896" style="zoom:67%;" /></p><p><img src="/images/AssetMarkdown/image-20221121152437668.png" alt="image-20221121152437668" style="zoom:67%;" /></p><ol type="1"><li>并行查找：Address translation(p, d)<ol type="1"><li>如果p在Associative Memory中，则取出帧#</li><li>否则，从内存中的页表获取帧#</li></ol></li></ol><h3 id="effective-access-time-有效访问时间">8.4.7 Effective Access Time有效访问时间</h3><ol type="1"><li>快表访问时间：Associative Lookup = <spanclass="math inline">\(\epsilon\)</span> time unit</li><li>内存访问时间：memory cycle time = <spanclass="math inline">\(t\)</span><br /></li><li>命中率：Hit ratio = <span class="math inline">\(\alpha\)</span></li><li>有效访问时间：EAT = <spanclass="math inline">\((t+\epsilon)\alpha+(t+t+\epsilon)(1-\alpha)\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20221121153123328.png" alt="image-20221121153123328" style="zoom:80%;" /></p><h3 id="memory-protection-内存保护">8.4.8 Memory Protection内存保护</h3><ol type="1"><li>通过将保护位与每个帧相关联来实现内存保护</li><li>Valid-invalid bit 附加到页表中每个条目：<ol type="1"><li>“valid”表示关联页面位于进程的逻辑地址空间中，因此是合法页面</li><li>“invalid”表示页面不在进程的逻辑地址空间中</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221121153531892.png" alt="image-20221121153531892" style="zoom:67%;" /></p><h3 id="共享页面">8.4.9 共享页面</h3><ol type="1"><li>共享代码<ol type="1"><li>进程之间共享的只读代码的一个副本。</li><li><strong>共享代码</strong>必须出现在所有进程的<strong>逻辑地址空间中的同一位置</strong></li></ol></li><li>私有代码和数据<ol type="1"><li>每个进程都保留代码和数据的单独副本</li><li>私有代码和数据的页面可以出现在逻辑地址空间的任何位置</li></ol></li><li>重新输入代码(重入代码)、 纯代码(纯代码)</li></ol><p><img src="/images/AssetMarkdown/image-20221121153744348.png" alt="image-20221121153744348" style="zoom:80%;" /></p><h3 id="page-table的数据结构">8.4.10 Page Table的数据结构</h3><h4 id="分级页表-hierarchical-paging">8.4.10.1 分级页表 HierarchicalPaging</h4><ol type="1"><li><p>x86的逻辑地址空间有2<sup>32</sup>Byte，如页面大小为4KB（2<sup>12</sup>Byte），则页表项最多有1M（2<sup>20</sup>）个，每个页表项占用4Byte，故每个进程的页表占用4MB内存空间，还要求是连续的，显然这是不现实的。</p></li><li><p>将逻辑地址空间分解为多个页表</p><ol type="1"><li>一种简单的技术是两级页表</li><li>Linux：四级页表</li><li>Windows：两级页表</li></ol></li><li><p>两级页表</p><p><img src="/images/AssetMarkdown/image-20221121154658709.png" alt="image-20221121154658709" style="zoom:67%;" /></p></li><li><p>两级页表示例：</p><ol type="1"><li><p>逻辑地址（在具有4K页面大小的32位机器上）分为：</p><ol type="1"><li>20-bit page number</li><li>12-bit page offset</li></ol></li><li><p>由于页表是分页的，页码进一步分为：</p><ol type="1"><li>10-bit page number</li><li>10-bit page offset</li></ol></li><li><p>因此，逻辑地址如下：</p><p><img src="/images/AssetMarkdown/image-20221121154943437.png" alt="image-20221121154943437" style="zoom:50%;" /></p></li><li><p>其中p<sub>1</sub>是outer page table的索引，p<sub>2</sub>是page ofthe page table的偏移量</p></li></ol></li><li><p>地址转换模式：</p><p><img src="/images/AssetMarkdown/image-20221124162941866.png" alt="image-20221124162941866" style="zoom:67%;" /></p></li><li><p>三级Page</p><p><img src="/images/AssetMarkdown/image-20221124163748171.png" alt="image-20221124163748171" style="zoom:67%;" /></p></li></ol><h4 id="哈希页表-hashed-page-tables">8.4.10.2 哈希页表 Hashed PageTables</h4><ol type="1"><li>通常情况下，地址空间&gt;32位</li><li>虚拟页码被hash到页表中<ol type="1"><li>此页表包含hash到同一位置的元素链</li></ol></li><li>在此链中比较虚拟页码以搜索匹配项<ol type="1"><li>如果找到匹配，则提取相应的物理帧</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221124164131844.png" alt="image-20221124164131844" style="zoom:80%;" /></p><h4 id="反向反置页表-inverted-page-table">8.4.10.3 反向(反置)页表Inverted Page Table</h4><ol type="1"><li>每个进程均有一个页表，想要让所有进程共享一个页表</li><li>每个进程自己的page number都是从0开始，但是所有进程的pagenumber均会映射到唯一的frame number</li><li>在Inverted Page Table中，索引对应物理内存中的framenumber，值对应进程+virtual number</li><li>进程在找frame时，需要遍历Inverted Page Table，十分耗时</li><li>通过hash table降低遍历所需时间</li></ol><p><img src="/images/AssetMarkdown/image-20221124164727384.png" alt="image-20221124164727384" style="zoom:80%;" /></p><h2 id="segmentation-分段段式管理">8.5 Segmentation 分段，段式管理</h2><blockquote><p>将同一类别的数据，放到对应大小的连续的内存空间</p></blockquote><p><img src="/images/AssetMarkdown/image-20221124165904816.png" alt="image-20221124165904816" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221124170112955.png" alt="image-20221124170112955" style="zoom:80%;" /></p><h3 id="segmentation-architecture">8.5.1 Segmentation Architecture</h3><ol type="1"><li><p>逻辑地址分为两个部分：段号+段内地址</p><p><img src="/images/AssetMarkdown/image-20221124170223059.png" alt="image-20221124170223059" style="zoom:80%;" /></p></li><li><p><strong>Segmenttable</strong>(段表)：映射二维物理地址；每个entry具有：</p><ol type="1"><li><strong>base</strong>：包含段在内存中的起始物理地址</li><li><strong>limit</strong>：指定段的长度</li></ol></li><li><p><strong>Segment-table baseregister(STBR)</strong>段表基址寄存器：指向段表在内存中的位置</p></li><li><p><strong>Segment-table lengthregister(STLR)</strong>段表限长寄存器：指示程序使用的段数；</p><ol type="1"><li>如果<strong>s&lt;STLR</strong>，则段号s合法</li></ol></li><li><p>保护：</p><ol type="1"><li>Segment table中的每一个entry都会包含：<ol type="1"><li>有效位 validation bit：为0时表示该segment无效</li><li>读/写/执行 权限</li></ol></li><li>保护位与段相关；代码共享发生在段级别</li><li>由于段的长度不同，内存分配是一个动态存储分配问题</li><li>下图显示了一个分段示例</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221124170509111.png" alt="image-20221124170509111" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221124170958507.png" alt="image-20221124170958507" style="zoom:80%;" /></p><h2 id="example-the-intel-pentium">8.6 Example: The Intel Pentium</h2><ol type="1"><li>支持分段和分页分段</li><li>CPU生成逻辑地址<ol type="1"><li>给分段单元<ol type="1"><li>产生线性地址</li></ol></li><li>将线性地址给到paging unit<ol type="1"><li>在主内存中生成物理地址</li><li>paging units相当于MMU</li></ol></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221124172249080.png" alt="image-20221124172249080" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221124172256488.png" alt="image-20221124172256488" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221124172318435.png" alt="image-20221124172318435" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221124172324503.png" alt="image-20221124172324503" style="zoom:80%;" /></p><h1 id="chapter-9virtual-memory">Chapter 9：Virtual Memory</h1><h2 id="background-2">9.1 Background</h2><h4 id="virtual-memory">9.1.1 Virtual Memory</h4><ol type="1"><li>Virtual Memory：只有运行程序的一部分需要加载到内存中执行<ol type="1"><li>虚拟内存将用户逻辑内存与物理内存分开</li><li>逻辑（或虚拟）地址空间可以大于物理地址空间</li><li>允许多个进程共享物理地址空间</li><li>实现更快的流程创建</li></ol></li><li>Virtual Memory的实现方法：<ol type="1"><li>Demand paging （请求调页，按需调页，请求页式管理）</li><li>0Demand segmentation（请求段式管理）</li></ol></li></ol><h3 id="局部性原理">9.1.2 局部性原理</h3><ol type="1"><li><strong>局部性原理</strong>(principle oflocality)：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。表现为：<ol type="1"><li><strong>时间局部性</strong>：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内</li><li><strong>空间局部性</strong>：当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内</li></ol></li><li><strong>虚拟存储器</strong>是具有请求调入功能和置换功能，能仅把进程的一部分装入内存便可运行进程的存储管理系统，它能从逻辑上对内存容量进行扩充的一种虚拟的存储器系统</li></ol><p><img src="/images/AssetMarkdown/image-20221128142639363.png" alt="image-20221128142639363" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221128142607160.png" alt="image-20221128142607160" style="zoom: 80%;" /></p><p><img src="/images/AssetMarkdown/image-20221128142621439.png" alt="image-20221128142621439" style="zoom:80%;" /></p><h2 id="demand-paging按需调页请求调页">9.2 DemandPaging：按需调页、请求调页</h2><h3 id="demand-paging">9.2.1 Demand Paging</h3><ol type="1"><li>仅在需要时将页面放入内存<ol type="1"><li>所需I/O更少</li><li>所需内存更少</li><li>更快的响应</li><li>更多用户</li></ol></li><li>需要页面 → 对它的引用<ol type="1"><li>无效的引用 → abort</li><li>不在内存中 → bring to memory</li></ol></li><li>Lazy swapper：除非需要页面，否则永远不要将页面交换到内存中<ol type="1"><li>处理页面的swapper是一个pager</li></ol></li></ol><blockquote><p>Transfer of a Paged Memory to Contiguous Disk Space</p></blockquote><p><img src="/images/AssetMarkdown/image-20221128142844807.png" alt="image-20221128142844807" style="zoom:80%;" /></p><h3 id="valid-invalid-bit">9.2.2 Valid-Invalid Bit</h3><ol type="1"><li><p>每个页表条目都有一个Valid-Invalid Bit：v → 在内存中，i →不在内存中</p></li><li><p>初始化：所有条目上的Valid-Invalid Bit设置为i</p></li><li><p>页表快照示例：</p><p><img src="/images/AssetMarkdown/image-20221128143549825.png" alt="image-20221128143549825" style="zoom:80%;" /></p></li><li><p>在地址转换期间，如果页表条目中的Valid-Invalid Bit为i → pagefault</p></li></ol><blockquote><p>Page Table When Some Pages Are Not in Main Memory</p></blockquote><p><img src="/images/AssetMarkdown/image-20221128143601069.png" alt="image-20221128143601069" style="zoom:80%;" /></p><h3 id="更完整的页表">9.2.3 更完整的页表</h3><p><img src="/images/AssetMarkdown/image-20221128143658452.png" alt="image-20221128143658452" style="zoom:80%;" /></p><ol type="1"><li>在请求分页系统中的每个页表项如图所示：<ol type="1"><li><strong>状态位P</strong>(存在位)：用于指示该页是否已调入内存，供程序访问时参考</li><li><strong>访问字段A</strong>：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选换出页时参考。</li><li><strong>修改位R/W</strong>：表示该页在调入内存后是否被修改过</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址，供调入该页时使用</li></ol></li></ol><h3 id="page-fault缺页">9.2.4 Page Fault：缺页</h3><p>如果存在对页面的引用，则对该页面的第一次引用将会产生：PageFault(缺页)</p><ol type="1"><li>操作系统查看另一个表以决定：<ol type="1"><li>无效的引用 → abort</li><li>仅仅是不在内存中</li></ol></li><li>获取空帧</li><li>将page交换进frame</li><li>重置表格</li><li>设置Valid-Invalid Bit = v</li><li>重新启动导致页面错误的指令</li></ol><blockquote><p>Steps in Handling a Page Fault</p></blockquote><p><img src="/images/AssetMarkdown/image-20221128144328745.png" alt="image-20221128144328745" style="zoom:80%;" /></p><h3 id="demand-paging-performance">9.2.5 Demand Paging Performance</h3><ol type="1"><li><p><strong>page fault rate</strong> p：</p><ol type="1"><li>p=0.0：没有page fault</li><li>p=1.0：所有page均发生page fault</li><li>通常p很小</li></ol></li><li><p><strong>effective memory-accesstime</strong>：<strong>EAT</strong></p><ol type="1"><li>(1-p) × physical-memory-access + p × page-fault service time</li></ol></li><li><p><strong>page-fault service time</strong>：</p><ol type="1"><li>page-fault-overhead + swap-page-out + swap-page-in +restart-overhead</li></ol></li><li><p>要计算EAT，我们必须知道需要多少时间来处理page fault。pagefault导致以下操作顺序发生：</p><ol type="1"><li>操作系统发生trap</li><li>保存用户寄存器和进程状态</li><li>确定中断是page fault</li><li>检查页面引用是否合法，并确定页面在磁盘上的位置</li><li>向空闲帧发出磁盘读取请求：<ol type="1"><li>在队列中等待设备，直到读取请求得到服务</li><li>等待设备查找时间和延迟时间</li><li>开始将page转移到free frame</li></ol></li><li>等待时，将CPU分配给其他用户（CPU调度，可选）</li><li>从磁盘中断（I/O完成）</li><li>为其他用户保存寄存器和进程状态（如果执行步骤6）</li><li>确定中断来自磁盘</li><li>更正页面表和其他表，以显示所需页面现在已在内存中</li><li>等待CPU再次分配给此进程</li><li>恢复用户寄存器、进程状态和新页表，然后恢复中断指令</li></ol></li><li><p>page-fault service time中的三个主要的部分</p><ol type="1"><li>Service the page-fault interrupt：缺页中断服务时间</li><li>Read in the page：将缺页读入时间</li><li>Restart the process：重新启动进程时间</li></ol></li><li><p>示例：</p><p><img src="/images/AssetMarkdown/image-20221128145139548.png" alt="image-20221128145139548" style="zoom:80%;" /></p></li></ol><h2 id="process-creation">9.3 Process Creation</h2><ol type="1"><li>虚拟内存在进程创建过程中提供了其他好处：Copy-on-Write写时拷贝</li><li>Copy-on-Write写时拷贝：允许父进程和子进程最初共享内存中的相同页面。如果任何一个进程修改了共享页面，则只复制该页面<ol type="1"><li>COW允许更高效的流程创建，因为只复制修改过的页面</li><li>可用页面是从一个清零页面池中分配的</li><li>Windows、Linux、Solaris</li></ol></li></ol><blockquote><p>Before Process 1 Modifies Page C</p></blockquote><p><img src="/images/AssetMarkdown/image-20221128150404451.png" alt="image-20221128150404451" style="zoom:80%;" /></p><blockquote><p>After Process 1 Modifies Page C</p></blockquote><p><img src="/images/AssetMarkdown/image-20221128150424447.png" alt="image-20221128150424447" style="zoom:80%;" /></p><h2 id="page-replacement-页面置换">9.4 Page Replacement 页面置换</h2><h3 id="page-replacement">9.4.1 Page Replacement</h3><p>如果没有free frame：</p><ol type="1"><li>Page Replacement：在内存中找到一些页面，但没有真正使用，请将其替换<ol type="1"><li>算法</li><li>性能：需要寻找一个可能导致page fault最少的算法</li></ol></li><li>同一页可能会多次进入内存</li><li>通过修改 page-fault service routine以实现页面替换，防止内存过度分配</li><li>使用<strong>modify(dirty)</strong>位减少页面传输的开销：只有修改过的页面才会写入磁盘</li><li>页面替换完成了逻辑内存和物理内存之间的分离：可以在较小的物理内存上提供较大的虚拟内存</li></ol><p><img src="/images/AssetMarkdown/image-20221128150907676.png" alt="image-20221128150907676" style="zoom:80%;" /></p><h3 id="页面置换的过程">9.4.2 页面置换的过程</h3><ol type="1"><li>在磁盘上查找所需页面的位置</li><li>查找空闲帧：<ol type="1"><li>如果有空闲帧，请使用它</li><li>如果没有空闲帧，则使用页面替换算法选择victim frame</li><li>将victim page写入磁盘；相应地更改页面和框架表。</li></ol></li><li>将所需页面放入（新的）free frame；更新页面和框架表</li><li>重新启动流程</li></ol><p><img src="/images/AssetMarkdown/image-20221128152032875.png" alt="image-20221128152032875" style="zoom:80%;" /></p><h3 id="页面置换的算法">9.4.3 页面置换的算法</h3><ol type="1"><li><p>希望page-fault rate最低</p></li><li><p>通过在一个特定的内存引用字符串(referencestring，引用串)并计算该字符串上的页面错误数，来判断算法的优劣</p></li><li><p>reference string：（每页100字节）</p><blockquote><p>0100, 0432, 0101, 0612, 0102, 0103, 0104, 0611, 0120</p><p>→ 1, 4, 1, 6, 1, 6, 1</p></blockquote></li><li><p>在我们的所有示例中，reference string为：</p><blockquote><p>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</p><p>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</p></blockquote></li><li><p>一般来说，帧数越多，page fault越小</p></li></ol><p><img src="/images/AssetMarkdown/image-20221128152212443.png" alt="image-20221128152212443" style="zoom:80%;" /></p><p>页面置换算法：</p><ol type="1"><li>First-In-First-OutAlgorithm：<strong>FIFO</strong>，先进先出算法</li><li>Optimal Algorithm：<strong>OPT</strong>，最佳页面置换算法</li><li>Least Recently UsedAlgorithm：<strong>LRU</strong>，最近最少使用算法</li><li>LRU Approximation Algorithms ：<strong>近似LRU算法</strong><ol type="1"><li>Additional-Reference-Bits Algorithm</li><li>Second-Chance（clock） Algorithm</li><li>Enhanced Second-Chance Algorithm</li></ol></li><li>Counting-Base Page Replacement：<ol type="1"><li>Least Frequently UsedAlgorithm：<strong>LFU</strong>，最不经常使用算法</li><li>Most Frequently UsedAlgorithm：<strong>MFU</strong>，引用最多算法00000000000000000000000000</li></ol></li><li>Page Buffering Algorithm：页面缓冲算法</li></ol><h4 id="fifo算法">9.4.3.1 FIFO算法</h4><ol type="1"><li>先进先出算法</li><li><strong>Belady’s Anomaly</strong>：更多的帧反而导致更多的pagefault</li></ol><p><img src="/images/AssetMarkdown/image-20221128152501463.png" alt="image-20221128152501463" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221128152640303.png" alt="image-20221128152640303" style="zoom:80%;" /></p><h4 id="optimal-page-replacement">9.4.3.2 Optimal Page Replacement</h4><ol type="1"><li><strong>OPT</strong>(最佳页面置换算法)：选择距离下次使用最远的page进行替换</li><li>理论最优，但是实际情况中很难判断哪个page距离下次使用最远</li></ol><p><img src="/images/AssetMarkdown/image-20221128152939195.png" alt="image-20221128152939195" style="zoom:80%;" /></p><h4 id="lru算法">9.4.3.3 LRU算法</h4><ol type="1"><li><p><strong>LRU</strong>(最近最少使用算法)：选择内存中<strong>最久没有引用</strong>的页面被置换</p><ol type="1"><li>这是局部性原理的合理近似，性能接近最佳算法</li><li>但由于需要记录页面使用时间，硬件开销太大</li></ol><p><img src="/images/AssetMarkdown/image-20221128153815218.png" alt="image-20221128153815218" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221128154107099.png" alt="image-20221128154107099" style="zoom:80%;" /></p></li><li><p>如何获知“多长时间没引用”？</p><ol type="1"><li>counter实现<ol type="1"><li>每个页面条目都有一个计数器；每次通过该条目引用页面时，将clock复制到计数器中</li><li>当需要更改页面时，查看计数器以确定要更改的页面</li></ol></li><li>stack实现：以双向链表形式保存页码堆栈<ol type="1"><li><p>引用的页面：</p><ol type="1"><li>将其移至顶部</li><li>需要更改6个指针</li></ol></li><li><p>不搜索替换</p><p><img src="/images/AssetMarkdown/image-20221128154413987.png" alt="image-20221128154413987" style="zoom:67%;" /></p></li></ol></li></ol></li></ol><h4 id="lru-approximation-algorithms">9.4.3.4 LRU ApproximationAlgorithms</h4><p><strong>Reference bit</strong></p><ol type="1"><li>每个页表条目关联一个位，初始值为0</li><li>当页面被引用时，Reference bit设置为1</li><li>替换Reference bit为0的页（如果存在）</li><li>然而，我们不知道页被访问的顺序</li></ol><p><img src="/images/AssetMarkdown/image-20221201163509642.png" alt="image-20221201163509642" style="zoom:80%;" /></p><h5 id="additional-reference-bits-algorithm">9.4.3.4.1Additional-Reference-Bits Algorithm</h5><p>附加引用位算法：</p><ol type="1"><li>为内存中的表中的每一页保留8位字节</li><li>每隔一段时间（每100毫秒），timer中断将控制权转移到OS<ol type="1"><li>OS将每个页面的ReferenceBit移到其8位字节的最高位，将其他位右移1位，丢弃低位</li><li>这些8位字节包含过去8个clock的页面使用历史</li></ol></li><li>如果我们将这些8位字节解释为无符号整数，则编号最低的页面是LRU页面，可以替换</li><li>被访问时左边<strong>最高位置1</strong>，<strong>定期右移</strong>并且最高位补0，于是<strong>寄存器数值最小</strong>的是最久未使用页面。</li></ol><h5 id="second-chance-clock-algorithm">9.4.3.4.2 Second-Chance (clock)Algorithm</h5><p>Second chance(clock算法)：</p><ol type="1"><li>需要Reference Bit</li><li>循环替换</li><li>如果要替换的页面(按顺时钟顺序)的Reference Bit=1，则：<ol type="1"><li>将Reference Bit设置为0</li><li>将页面留在内存中</li><li>替换下一页(按顺时钟顺序)，遵循相同规则</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221201164212728.png" alt="image-20221201164212728" style="zoom:80%;" /></p><h5 id="enhanced-second-chance-algorithm">9.4.3.4.3 EnhancedSecond-Chance Algorithm</h5><p>增强二次机会算法（改进型的clock算法）</p><ol start="2" type="1"><li>使用引用位和修改位：引用过或修改过置成1</li><li>(Reference bit, modified bit) ：<ol type="1"><li>(0,0)：最优先需要被替换的页</li><li>(0,1)：也可以被替换，但不如上一种更优</li><li>(1,0)：可能会马上被使用</li><li>(1,1)：最不应该被替换的页</li></ol></li><li>淘汰次序：(0,0) → (0,1) → (1,0) → (1,1)</li></ol><h4 id="counting-algorithm">9.4.3.5 Counting Algorithm</h4><ol type="1"><li>记录每页的引用次数</li><li>LFU(Least Frequently Used) Algorithm(最不经常使用算法)：替换被引用次数最少的页面</li><li>MFU(Most Frequently Used) Algorithm(经常使用算法)：被引用次数最小的页面可能刚刚被引入，尚未被使用</li></ol><h4 id="page-buffering-algorithm-页面缓冲算法">9.4.3.6 Page BufferingAlgorithm 页面缓冲算法</h4><p>页面缓冲算法：通过被置换页面的缓冲，有机会找回刚被置换的页面</p><ol type="1"><li>被置换页面的选择和处理：用FIFO算法选择被置换页，把被置换的页面放入两个链表之一。即：如果页面未被修改，就将其归入到<strong>空闲页面链表</strong>的末尾，否则将其归入到<strong>已修改页面链表</strong></li><li>需要调入新的页面时，将新页面内容读入到空闲页面链表的第一项所指的页面，然后将第一项删除</li><li>空闲页面和已修改页面，仍停留在内存中一段时间，如果这些页面被再次访问，这些页面还在内存中</li><li>当已修改页面达到一定数目后，再将它们一起调出到外存，然后将它们归入空闲页面链表</li></ol><h2 id="allocation-of-frames-帧分配">9.5 Allocation of Frames帧分配</h2><h3 id="fixed-allocation-固定分配">9.5.1 Fixed Allocation 固定分配</h3><ol type="1"><li>Equal allocation 平均分配法：将帧平均分配给每个进程</li><li>Proportional allocation 按比例分配法：根据进程的大小按比例分配</li></ol><p><img src="/images/AssetMarkdown/image-20221201170031536.png" alt="image-20221201170031536" style="zoom: 50%;" /></p><h3 id="priority-allocation-优先级分配">9.5.2 Priority Allocation优先级分配</h3><ol type="1"><li>根据进程的优先级，按比例分配</li><li>如果进程P<sub>i</sub>发生了page fault<ol type="1"><li>选择P<sub>i</sub>自己的一个帧进行替换</li><li>选择比P<sub>i</sub>优先级低的一个进程的一个帧进行替换</li></ol></li></ol><h3 id="global-vs.-local-allocation">9.5.3 Global vs. LocalAllocation</h3><p>置换策略：</p><ol type="1"><li>Global replacement全局置换：进程从所有帧的集合中选择替换帧；一个进程可以从另一个进程获取帧</li><li>Local replacement局部置换：每个进程仅从其自己的一组分配帧中进行选择</li></ol><p>分配策略：</p><ol type="1"><li>固定分配</li><li>可变分配</li></ol><h3 id="帧的分配和置换策略">9.5.4 帧的分配和置换策略</h3><p>组合成三种策略：</p><ol type="1"><li>固定分配局部置换策略</li><li>可变分配全局置换策略</li><li>可变分配局部置换策略</li></ol><h2 id="thrashing-颠簸抖动">9.6 Thrashing 颠簸、抖动</h2><ol type="1"><li>如果一个进程没有足够的page，则page-fault rate会很高，会导致：<ol type="1"><li>很低的CPU利用率</li><li>误导OS以为有必要提高多任务的程度</li><li>误导OS装入更多作业，内存中驻留更多进程</li><li>于是，每个进程拥有的页帧数更少</li><li>如此恶性循环，会怎样 ？</li></ol></li><li>Thrashing = a process is busy swapping pages in and out</li></ol><p><img src="/images/AssetMarkdown/image-20221201171543293.png" alt="image-20221201171543293" style="zoom:80%;" /></p><h3 id="demand-paging-and-thrashing">9.6.1 Demand Paging andThrashing</h3><ol type="1"><li>为什么会有demand page work：局部性原理<ol type="1"><li>进程从一个位置迁移到另一个位置</li><li>地点可能重叠</li></ol></li><li>为什么会有trash：<spanclass="math inline">\(\sum\)</span>locality的大小 &gt; 总内存大小</li></ol><h3 id="working-set-model">9.6.2 Working-Set Model</h3><ol type="1"><li><strong>workingset(WS)</strong>工作集：在最近Δ次页访问的页的集合</li><li><strong>working-set window</strong>工作集窗口Δ：固定次数的页访问<ol type="1"><li>如：10000 instruction</li></ol></li><li><strong>WSS<sub>i</sub></strong> working set size of ProcessP<sub>i</sub>工作集大小 = 在最近Δ时间内的页访问总次数<ol type="1"><li>如果Δ太小：不能表示整个局部空间</li><li>如果Δ太大：包括了多个局部空间</li><li>如果Δ=∞：包括了整个程序</li></ol></li><li><span class="math inline">\(D = \sumWSS_i\)</span>：总共需要的帧；<spanclass="math inline">\(m\)</span>：总共可用的帧<ol type="1"><li><spanclass="math inline">\(D&gt;m\)</span>时，会出现Thrashing，需要减少进程数目</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221201173253855.png" alt="image-20221201173253855" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221201173542748.png" alt="image-20221201173542748" style="zoom:80%;" /></p><h3 id="page-fault-frequency-scheme-缺页频率">9.6.3 Page-Fault FrequencyScheme 缺页频率</h3><p>缺页频率应该保证在一个区间</p><ol type="1"><li>如果过低：从进程收回帧</li><li>如果过高：给进程分配帧</li></ol><p><img src="/images/AssetMarkdown/image-20221201173547998.png" alt="image-20221201173547998" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221201173554956.png" alt="image-20221201173554956" style="zoom:80%;" /></p><h2 id="memory-mapped-files">9.7 Memory-Mapped Files</h2><ol type="1"><li>Memory-Mapped FilesI/O：通过将磁盘块映射到内存中的页面，允许将文件I/O视为例行内存访问</li><li>最初使用请求分页读取文件。文件的页面大小部分从文件系统读取到物理页面中。对文件的后续读/写被视为普通内存访问。</li><li>通过内存而不是read() write()系统调用处理文件I/O，简化了文件访问</li><li>还允许多个进程映射同一文件，从而共享内存中的页面</li></ol><p><img src="/images/AssetMarkdown/image-20221201174152851.png" alt="image-20221201174152851" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221201174157228.png" alt="image-20221201174157228" style="zoom:80%;" /></p><h2 id="allocating-kernel-memory">9.8 Allocating Kernel Memory</h2><h3 id="allocating-kernel-memory-1">9.8.1 Allocating Kernel Memory</h3><ol type="1"><li>与分配用户空间的方式不同</li><li>通常从空闲内存池分配<ol type="1"><li>内核根据结构，请求不同大小的内存</li><li>某些内核内存需要是连续的</li></ol></li></ol><h3 id="buddy-system">9.8.2 Buddy System</h3><ol type="1"><li>从由物理上连续的页组成固定大小的段，然后分配内存</li><li>使用power-of-2 allocator分配内存<ol type="1"><li>每个单元的大小为2<sup>n</sup></li><li>每次分配内存的请求对齐到2<sup>n</sup>，如请求6，则分配2<sup>3</sup></li><li>当请求的内存比可用的段小时，当前段被分成两个2<sup>n-1</sup>的伙伴<ol type="1"><li>继续，直到大小合适的块可用</li></ol></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221205142443883.png" alt="image-20221205142443883" style="zoom:80%;" /></p><h3 id="slab-allocator">9.8.3 Slab Allocator</h3><blockquote><p>另一种内存分配策略</p></blockquote><ol type="1"><li>Slab：是一个或多个物理上连续的页面</li><li>Cache：由一个或多个slab组成</li><li>每个唯一内核数据结构 &lt;==&gt; 一个cache<ol type="1"><li>每个cache都填充了object：数据结构的实例</li></ol></li><li>创建cache时，填充标记为空闲的对象</li><li>存储结构时，对象标记为已使用</li><li>如果slab中充满了已使用的对象，则从空slab中分配下一个对象<ol type="1"><li>如果没有空slab，则分配新的slab</li></ol></li><li>优点：没有碎片、快速满足内存请求</li></ol><p><img src="/images/AssetMarkdown/image-20221205142954698.png" alt="image-20221205142954698" style="zoom:80%;" /></p><h2 id="other-considerations">9.9 Other Considerations</h2><h3 id="prepaging-预调页">9.9.1 Prepaging 预调页</h3><ol type="1"><li>减少进程启动时出现的大量page-faults</li><li>在进程启用之前，预先将一些页调到内存中</li><li>但是如果预调页没有被使用，则会浪费I/O</li><li>假设预调页的页数为<span class="math inline">\(s\)</span>，其中<spanclass="math inline">\(\alpha\)</span>个页被用到<ol type="1"><li>节省的page fault数：<spanclass="math inline">\(s*\alpha\)</span></li><li>浪费的预调页：<span class="math inline">\(s*(1-\alpha)\)</span></li><li>如果<spanclass="math inline">\(\alpha\)</span>接近0，则称为prepaging loses</li></ol></li></ol><h3 id="page-size-页大小">9.9.2 Page Size 页大小</h3><ol type="1"><li>页大小会影响：<ol type="1"><li>碎片的大小 fragmentation：页越大，碎片越大</li><li>页表的大小：页越大，页表越小</li><li>I/O消耗：页越大，I/O消耗越大</li><li>局部性 Locality：如果页小于working set，则page fault会比较大</li></ol></li><li>增加页大小：<ol type="1"><li>会导致碎片的大小增加</li><li>并且并不是所偶有的应用程序都需要一个大的页大小</li></ol></li><li>提供多种页大小：<ol type="1"><li>这使得需要更大页大小的应用程序有机会在不增加碎片的情况下使用它们</li></ol></li></ol><h3 id="tlb范围">9.9.3 TLB范围</h3><ol type="1"><li>TLB Reach：TLB能够到达的内存范围</li><li><strong>TLB Reach = TLB Size × Page Size</strong></li><li>理想情况下，每个进程的working set均存储在TLB中，否则pagefault会比较大</li></ol><h3 id="程序结构">9.9.4 程序结构</h3><ol type="1"><li>遍历二维数组时，先枚举列还是先枚举行</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">128</span>][<span class="number">128</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line">        data[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) </span><br><span class="line">        data[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="io锁定">9.9.5 I/O锁定</h3><ol type="1"><li><strong>I/O Interlock</strong>：页面有时必须锁定在内存中</li><li>考虑I/O：用于从设备复制文件的页面必须被锁定，以防止页面替换算法被选中而替换</li></ol><p><img src="/images/AssetMarkdown/image-20221205145130942.png" alt="image-20221205145130942" style="zoom:67%;" /></p><h2 id="operating-system-examples-1">9.10 Operating System Examples</h2><h3 id="windows-xp">9.10.1 Windows XP</h3><ol type="1"><li>Uses demand paging with <strong>clustering</strong>. Clusteringbrings in pages surrounding the faulting page</li><li>Processes are assigned <strong>working set minimum</strong> and<strong>working set maximum</strong></li><li>Working set minimum is the minimum number of pages the process isguaranteed to have in memory</li><li>A process may be assigned as many pages up to its working setmaximum</li><li>When the amount of free memory in the system falls below athreshold, <strong>automatic working set trimming</strong> is performedto restore the amount of free memory</li><li>Working set trimming removes pages from processes that have pages inexcess of their working set minimum</li></ol><h3 id="solaris">9.10.2 Solaris</h3><ol type="1"><li>Maintains a list of free pages to assign faulting processes</li><li><strong>Lotsfree</strong> – threshold parameter (amount of freememory) to begin paging</li><li><strong>Desfree</strong> – threshold parameter to increasingpaging</li><li><strong>Minfree</strong> – threshold parameter to beingswapping</li><li>Paging is performed by pageout process</li><li>Pageout scans pages using modified clock algorithm</li><li>Scanrate is the rate at which pages are scanned. This ranges fromslowscan to fastscan</li><li>Pageout is called more frequently depending upon the amount of freememory available</li></ol><p><img src="/images/AssetMarkdown/image-20221205145550355.png" alt="image-20221205145550355" style="zoom:80%;" /></p><h1 id="chapter-10file-system-interface">Chapter 10：File-SystemInterface</h1><h2 id="file-concept">10.1 File Concept</h2><ol type="1"><li><p>文件：是存储某种介质上的（如磁盘、光盘、SSD等）并具有文件名的一组相关信息的集合</p></li><li><p>一个文件是在某些硬件设施上的一系列字符</p><p><img src="/images/AssetMarkdown/image-20221205153235071.png" alt="image-20221205153235071" style="zoom:80%;" /></p></li><li><p>类型：</p><ol type="1"><li>数据型：数字型、字符型、二进制型</li><li>程序型</li></ol></li></ol><h3 id="文件属性">10.1.1 文件属性</h3><ol type="1"><li>Name：文件名</li><li>Identifier：文件标识，唯一标记文件系统中的文件</li><li>Type：文件类型，系统用于支持不同类型的文件</li><li>Location：文件在设备中的位置</li><li>Size：当前文件大小</li><li>Protection：控制谁可读/写/执行</li><li>Time, date, and useridentification：用于保护/安全/使用监视的数据</li><li>有关文件的信息保存在磁盘上维护的目录结构中</li></ol><h3 id="文件操作">10.1.2 文件操作</h3><p>文件是一个抽象数据类型</p><ol type="1"><li>create</li><li>write</li><li>read</li><li>reposition within file</li><li>delete</li><li>truncate</li><li>open(F<sub>i</sub>)：在磁盘上的目录结构中搜索entryFi，并将条目的内容移动到内存中</li><li>close(F<sub>i</sub>)：将内存中entryFi的内容移动到磁盘上的目录结构</li></ol><h3 id="打开文件">10.1.3 打开文件</h3><p>用于打开文件的数据信息：</p><ol type="1"><li><strong>Filepointer</strong>：指向文件打开的每个进程的最后一个读/写位置的指针</li><li><strong>File-opencount</strong>：文件打开次数的计数器，允许在最后一个进程关闭时从打开的文件表中删除数据</li><li><strong>Disk location of the file</strong>：数据访问信息缓存</li><li><strong>Access rights</strong>：每个进程访问模式信息</li></ol><h3 id="文件的内部结构">10.1.4 文件的内部结构</h3><ol type="1"><li><strong>None</strong> 流文件结构<ol type="1"><li>一系列word/byte</li></ol></li><li><strong>Simple record structure</strong> 记录文件结构<ol type="1"><li>行</li><li>固定长度</li><li>可变长度</li></ol></li><li><strong>Complex Structures</strong><ol type="1"><li>格式化文档</li><li>可重定位的加载文件</li></ol></li><li>通过插入适当的控制字符，可以使用第一种方法模拟后两种</li><li>Who decides:<ol type="1"><li>操作系统</li><li>对应程序</li></ol></li></ol><h2 id="access-methods">10.2 Access Methods</h2><ol type="1"><li><p>Sequential Access 顺序存取</p><p><img src="/images/AssetMarkdown/image-20221208162949263.png" alt="image-20221208162949263" style="zoom: 50%;" /></p></li><li><p>Direct Access 直接存取</p><blockquote><p>使用Direct-access File模拟顺序存取</p></blockquote><p><img src="/images/AssetMarkdown/image-20221208163000966.png" alt="image-20221208163000966" style="zoom:50%;" /></p></li><li><p>Indexed sequential-acess 索引顺序</p><blockquote><p>Index and Relative File</p></blockquote><p><img src="/images/AssetMarkdown/image-20221208163009799.png" alt="image-20221208163009799" style="zoom:50%;" /></p></li></ol><h2 id="directory-structure-目录结构">10.3 Directory Structure目录结构</h2><h3 id="目录结构">10.3.1 目录结构</h3><ol type="1"><li><p>目录：一个节点的集合，包含所有文件的相关信息</p><p><img src="/images/AssetMarkdown/image-20221208163356292.png" alt="image-20221208163356292" style="zoom:80%;" /></p></li></ol><h3 id="磁盘结构">10.3.2 磁盘结构</h3><ol type="1"><li>磁盘可以被分割为<strong>partitions(分区)</strong></li><li>磁盘/分区可以作为<strong>RAID</strong>来预防failure</li><li>磁盘/分区可以使用<strong>raw</strong>，即使没有文件系统 或者没有被文件系统格式化过</li><li>分区，也被称为minidisk，slice</li><li>包含文件系统的示例被称为<strong>volume(卷)</strong></li><li>包含文件系统的每个卷还跟踪<strong>设备目录</strong>或<strong>卷目录</strong>中的文件系统信息</li><li>除了<strong>通用文件系统</strong>外，还有许多<strong>专用文件系统</strong>，通常都在同一操作系统或计算机中</li></ol><p><img src="/images/AssetMarkdown/image-20221208164020816.png" alt="image-20221208164020816" style="zoom:80%;" /></p><h3 id="目录的操作">10.3.3 目录的操作</h3><ol type="1"><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>列出目录</li><li>重命名文件</li><li>遍历文件系统</li></ol><h3 id="文件目录的组织结构">10.3.4 文件目录的组织结构</h3><p>需要考虑以下问题：</p><ol type="1"><li>查找效率：能够快速定位一个文件</li><li>重名：不同用户是否可以拥有同名文件，相同文件是否可以拥有不同名字</li><li>分组：通过文件的特性对文件分组</li></ol><h4 id="single-level-directory-单级目录">10.3.4.1 Single-Level Directory单级目录</h4><p><img src="/images/AssetMarkdown/image-20221208164717968.png" alt="image-20221208164717968" style="zoom:67%;" /></p><ol type="1"><li>重名：不同用户不能拥有同名文件，相同文件不能拥有不同名字</li><li>分组：不能按照文件类型进行分组</li></ol><h4 id="two-level-directory-二级目录">10.3.4.2 Two-Level Directory二级目录</h4><p><img src="/images/AssetMarkdown/image-20221208164843650.png" alt="image-20221208164843650" style="zoom:80%;" /></p><ol type="1"><li>查找效率：使用路径名</li><li>重名：不同用户可以拥有同名文件，相同文件不能拥有不同名字</li><li>分组：不能按照文件类型进行分组</li></ol><h4 id="tree-structured-directories-树型目录">10.3.4.3 Tree-StructuredDirectories 树型目录</h4><p><img src="/images/AssetMarkdown/image-20221208164916177.png" alt="image-20221208164916177" style="zoom:80%;" /></p><ol type="1"><li><p>查找效率：使用路径名，需要有当前目录的路径（绝对路径/相对路径）</p><ol type="1"><li>cd /spell/mail/prog</li><li>type list</li></ol></li><li><p>重名：不同用户可以拥有同名文件，相同文件不能拥有不同名字</p></li><li><p>分组：可以按照文件类型进行分组</p></li><li><p>删除文件：<code>rm &lt;file-name&gt;</code></p></li><li><p>添加目录：<code>mkdir &lt;dir-name&gt;</code></p></li><li><p>示例：当前路径为<code>/mail</code>，执行<code>mkdir count</code></p><p><img src="/images/AssetMarkdown/image-20221208165305078.png" alt="image-20221208165305078" style="zoom:80%;" /></p></li></ol><h4 id="acyclic-graph-directories-有向无环图结构目录">10.3.4.4Acyclic-Graph Directories 有向无环图结构目录</h4><p><img src="/images/AssetMarkdown/image-20221208165345326.png" alt="image-20221208165345326" style="zoom:80%;" /></p><ol type="1"><li>同一个文件可以有不同的名字</li><li>如果文件被删除了，但是指针没有被删除，则会导致danglingpointer，解决方法：<ol type="1"><li>Backpointers 逆向指针：删除文件时删除所有指针</li><li>Backpointers 使用菊花图的组织方式</li><li>Entry-hold-count solution 表项保留计数</li></ol></li><li>新的目录实体类型<ol type="1"><li>Link：一个已经存在的文件的另一个名字(指针)</li><li>Resolve the link：通过指针定位文件</li></ol></li></ol><h4 id="general-graph-directory-普通图结构目录">10.3.4.5 General GraphDirectory 普通图结构目录</h4><p><img src="/images/AssetMarkdown/image-20221208165553339.png" alt="image-20221208165553339" style="zoom:80%;" /></p><p>如何保证没有环</p><ol type="1"><li>只允许到文件的link，不允许到目录的链接</li><li>垃圾回收机制<ol type="1"><li>检测自我引用的文件，其引用计数不等于0</li><li>垃圾收集涉及遍历整个文件系统，并标记所有可访问的空间。然后，第二次将所有没有标记的</li><li>部分收集到空闲空间链表上。</li></ol></li><li>每次添加新link时，使用环检测算法(cycle detectionalgorithm)，确定是否可以添加</li></ol><h2 id="文件系统的挂载">10.4 文件系统的挂载</h2><ol type="1"><li>文件系统只有被挂载了(mounted)，才能被使用</li><li>文件系统会被挂载到<strong>挂载点(mount point)</strong>上</li></ol><blockquote><ol type="a"><li>Existing (b) Unmounted Partition</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20221208171015291.png" alt="image-20221208171015291" style="zoom:80%;" /></p><blockquote><p>mount point 挂载点</p></blockquote><p><img src="/images/AssetMarkdown/image-20221208171021245.png" alt="image-20221208171021245" style="zoom:80%;" /></p><h2 id="文件共享">10.5 文件共享</h2><ol type="1"><li>多用户系统需要实现文件的共享</li><li>共享的文件可能是保护模式</li><li>在分布式系统中，文件可以通过网络共享<ol type="1"><li>通常使用Network File System (NFS) 实现分布式文件共享</li></ol></li></ol><h3 id="文件共享多用户">10.5.1 文件共享：多用户</h3><ol type="1"><li><strong>User IDs</strong>：识别用户，授予每个用户权限和保护</li><li><strong>Group IDs</strong>：允许用户在组中，授予组访问权限</li></ol><h3 id="文件共享远程文件系统">10.5.2 文件共享：远程文件系统</h3><ol type="1"><li>使用网络允许系统之间的文件系统访问<ol type="1"><li>使用<strong>FTP等程序</strong>手动共享</li><li>使用<strong>分布式文件系统distributed filesystems</strong>自动共享</li><li>通过<strong>万维网world wide web</strong>半自动共享</li></ol></li><li>客户端-服务器模型允许客户端从服务器装载远程文件系统<ol type="1"><li>服务器可以为多个客户端提供服务</li><li>客户端和用户对客户端标识不安全或复杂</li><li><strong>NFS</strong>是标准的UNIX客户端-服务器文件共享协议</li><li><strong>CIFS</strong>是标准的Windows协议</li><li>标准操作系统文件调用被转换为远程调用</li></ol></li><li>LDAP、DNS、NIS、ActiveDirectory等分布式信息系统（分布式命名服务）实现了对远程计算所需信息的统一访问</li></ol><h3 id="文件共享错误模式">10.5.3 文件共享：错误模式</h3><ol type="1"><li>由于网络故障、服务器故障，远程文件系统添加了新的故障模式</li><li>故障恢复可能涉及有关每个远程请求状态的状态信息</li><li>无状态协议（如NFS）包含每个请求中的所有信息，允许轻松恢复，但安全性较低</li></ol><h3 id="文件共享一致性问题">10.5.4 文件共享：一致性问题</h3><p><strong>一致性语义Consistencysemantics</strong>：指定多个用户如何同时访问共享文件</p><ol type="1"><li>类似于Ch 7 进程同步算法<ol type="1"><li>由于磁盘I/O和网络延迟，会相对简单一点</li></ol></li><li>Andrew文件系统(AFS)实现了：<ol type="1"><li>复杂的远程文件共享语义</li></ol></li><li>Unix文件系统(UFS)实现了：<ol type="1"><li>写入同一打开文件的其他用户立即可见的打开文件</li><li>共享文件指针以允许多个用户同时读写</li></ol></li><li>AFS具有会话语义</li><li>仅对文件关闭后开始的会话可见的写入</li></ol><h2 id="protection">10.6 Protection</h2><ol type="1"><li>文件的拥有者/创建者需要能够控制：<ol type="1"><li>可以做什么</li><li>谁可以做</li></ol></li><li>操作的类型：<ol type="1"><li>读</li><li>写</li><li>执行</li><li>扩展</li><li>删除</li><li>列表</li></ol></li></ol><h3 id="access-lists-and-groups">10.6.1 Access Lists and Groups</h3><ol type="1"><li>基础操作：读R、写W、执行X</li><li>三种用户<ol type="1"><li>所有者owner</li><li>组group</li><li>公共public</li></ol></li><li>要求管理员创建group、添加用户到group</li><li>对一个特定的文件/子目录，定义访问的权限</li></ol><p><img src="/images/AssetMarkdown/image-20221208172500521.png" alt="image-20221208172500521" style="zoom:80%;" /></p><h1 id="chapter-11file-system-implementation">Chapter 11：File SystemImplementation</h1><h2 id="file-systemorganized-structure">11.1 File-System(organized)Structure</h2><ol type="1"><li>文件的结构：<ol type="1"><li>逻辑存储单元</li><li>相关信息的集合</li></ol></li><li>文件系统总是分层结构</li><li>文件系统存储在磁盘上<ol type="1"><li>通过允许轻松地存储、定位和检索数据，提供对磁盘的高效和方便的访问</li><li><strong>文件系统</strong>：是操作系统中以文件方式管理计算机软件资源的软件和被管理的文件和数据结构（如目录和索引表等）的集合</li></ol></li><li><strong>File control block文件控制块</strong>：由文件信息（属性）组成的存储结构</li><li><strong>Device driver 设备驱动</strong>：控制物理设备</li></ol><h3 id="分层设计的文件系统">11.1.1 分层设计的文件系统</h3><ol type="1"><li>应用程序：<ol type="1"><li>发送文件请求的代码</li></ol></li><li>逻辑文件系统<ol type="1"><li>管理<strong>元数据</strong>：文件系统的所有结构数据，而不包括实际数据（或文件内容）</li><li>根据给定符号文件名来管理目录结构</li><li>逻辑文件系统通过文件控制块(FCB)来维护文件结构</li></ol></li><li>文件组织模块<ol type="1"><li>知道文件及其逻辑块和物理块。</li><li>空闲空间管理器</li></ol></li><li>基本文件系统<ol type="1"><li>向合适的设备驱动程序发送一般命令就可对磁盘上的物理块进行读写</li></ol></li><li>I/O控制<ol type="1"><li>由设备驱动程序和中断处理程序组成，实现内存与磁盘之间的信息转移</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221208173053023.png" alt="image-20221208173053023" style="zoom:80%;" /></p><h3 id="文件系统的类型">11.1.2 文件系统的类型</h3><p><img src="/images/AssetMarkdown/image-20221208173658221.png" alt="image-20221208173658221" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221208173713927.png" alt="image-20221208173713927" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221208173728616.png" alt="image-20221208173728616" style="zoom:80%;" /></p><h2 id="文件系统的实现">11.2 文件系统的实现</h2><h3 id="在磁盘中的文件系统结构">11.2.1 在磁盘中的文件系统结构</h3><ol type="1"><li><p>在磁盘上，文件系统可能包括如下信息：</p><ol type="1"><li>如何启动所存储的操作系统</li><li>总的块数</li><li>空闲块的数目和位置</li><li>目录结构以及各个具体文件等</li></ol></li><li><p>磁盘结构包括</p><ol type="1"><li><strong>Boot controlblock</strong>：包含系统从该卷启动OS所需的信息</li><li><strong>Volume(卷)control block</strong>：包含卷详细信息</li><li><strong>Directory structure</strong>：组织文件</li><li>Per-file <strong>File Control Block(FCB，文件控制块)</strong>：包含文件的许多详细信息</li></ol></li><li><p>一个典型的文件控制块如下：</p><p><img src="/images/AssetMarkdown/image-20221208174042008.png" alt="image-20221208174042008" style="zoom: 50%;" /></p></li></ol><h3 id="在内存中的文件系统结构">11.2.2 在内存中的文件系统结构</h3><ol type="1"><li>An in-memory partition table：分区表</li><li>An in-memory directory structure：目录结构</li><li>The system-wide open-file table：系统打开文件表</li><li>The per-process open-file table：进程打开文件表</li></ol><p><img src="/images/AssetMarkdown/image-20221208174329371.png" alt="image-20221208174329371" style="zoom:80%;" /></p><h3 id="虚拟文件系统">11.2.3 虚拟文件系统</h3><ol type="1"><li>虚拟文件系统（VFS）提供了一种实现文件系统的面向对象方法</li><li>VFS允许相同的系统调用接口（API）用于不同类型的文件系统</li><li>API用于VFS接口，而不是任何特定类型的文件系统</li></ol><p><img src="/images/AssetMarkdown/image-20221208174537601.png" alt="image-20221208174537601" style="zoom:67%;" /></p><h2 id="目录实现">11.3 目录实现</h2><h3 id="线性列表">11.3.1 线性列表</h3><ol type="1"><li><strong>Linear list</strong>线性列表：存储文件名、指向数据块的指针<ol type="1"><li>实现简单</li><li>但是访问文件需要线性遍历</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212142011949.png" alt="image-20221212142011949" style="zoom:80%;" /></p><h3 id="哈希表">11.3.2 哈希表</h3><ol type="1"><li><strong>Hash Table</strong>哈希表：<ol type="1"><li>降低了搜索时间</li><li>collision冲突：当两个文件名hash到同一个位置时，会发生冲突</li><li>fixedsize：哈希表的最大困难是其通常固定的大小和哈希函数对大小的依赖性</li></ol></li><li>可以使用两层hash优化</li></ol><h2 id="allocation-methods-文件物理结构">11.4 Allocation Methods,文件物理结构</h2><ol type="1"><li>An allocation method refers to how disk blocks are allocated forfiles:<ol type="1"><li>Contiguous allocation 连续分配</li><li>Linked allocation 链接分配</li><li>Indexed allocation 索引分配</li><li>Unix、Linux直接间接混合分配方法</li></ol></li></ol><h3 id="连续分配-1">11.4.1 连续分配</h3><h4 id="连续分配-2">11.4.1.1 连续分配</h4><ol type="1"><li><p>每个文件占据磁盘上<strong>连续的块</strong></p></li><li><p>简单：只需要知道文件的起始位置(block #)和长度(number ofblocks)</p></li><li><p><strong>Random Access 随机存取</strong></p></li><li><p>如果动态分配的话，会浪费空间</p></li><li><p>文件变动的成本很高</p><p><img src="/images/AssetMarkdown/image-20221212143513022.png" alt="image-20221212143513022" style="zoom:67%;" /></p></li><li><p>逻辑地址 =&gt; 物理地址：LA / 512</p><ol type="1"><li>LA：存取文件的逻辑地址</li><li>512：每块的大小</li><li>待访问的块：Q+starting address</li><li>块内偏移量：R</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212143550218.png" alt="image-20221212143550218"  /></p><h4 id="基于扩展的连续分配系统">11.4.1.2 基于扩展的连续分配系统</h4><ol type="1"><li>将程序分为多个段</li><li>每个段是空间中的一片连续的空间</li><li>不同段之间可以不连续</li></ol><figure><img src="/images/AssetMarkdown/image-20221212143829537.png"alt="image-20221212143829537" /><figcaption aria-hidden="true">image-20221212143829537</figcaption></figure><h3 id="链接分配">11.4.2 链接分配</h3><h4 id="链接分配-1">11.4.2.1 链接分配</h4><ol type="1"><li>文件的内容放在内存中不同的块，通过链表将不同块连接起来</li><li>简单：只需要存储链表的起始地址，每个块内部会有指向下一个块的指针</li><li>不会浪费空间</li><li>不能随机访问</li><li>逻辑地址 =&gt; 物理地址：LA / 512</li><li>缺点：如果其中一个块的指针被修改了，那么后面的块均无法访问</li></ol><p><img src="/images/AssetMarkdown/image-20221212144327110.png" alt="image-20221212144327110" style="zoom:67%;" /></p><h4 id="链接分配的变种fat文件系统">11.4.2.2链接分配的变种：FAT文件系统</h4><ol type="1"><li><p>File-allocationtable(FAT)：文件分配表，是一个单独的数据结构，存储文件的链表信息</p><ol type="1"><li>原本的链表指针存储在每个数据块中</li><li>FAT表使用单独的空间，存储了整个文件的每一个块的链表指针</li></ol><p><img src="/images/AssetMarkdown/image-20221212144730183.png" alt="image-20221212144730183" style="zoom:67%;" /></p></li><li><p>FAT12、FAT16、FAT32</p><p><img src="/images/AssetMarkdown/image-20221212144612204.png" alt="image-20221212144612204" style="zoom:80%;" /></p></li><li><p>FAT32引导区记录被扩展为：包括重要数据结构的备份，根目录为一个普通的簇链，其目录项可以放在文件区任何地方</p></li><li><p>FAT32磁盘的结构：</p><ol type="1"><li><strong>主引导记录MBR</strong>：是主引导区的第一个扇区，它由两个部分组成:<ol type="1"><li>第一部分主引导代码，占据扇区的前446个字节，磁盘标识符(FD 4E F214)位于这段代码的未尾</li><li>第二部分是分区表，分区表中每个条目有16字节长，分区表最多有4个条目，第一个分区条目从扇区的偏移量位置是0x01BE</li></ol></li><li><strong>扩展引导记录</strong>：与主引导记录类同，如该扩展分区未装操作系统则第一部分主引导代码为0，标签字也标记一个扩展分区引导区和分区引导区的结束</li><li>计算机系统启动时，首先执行的是<strong>BIOS引导程序</strong>，完成自检，并加载主引导记录和分区表，然后执行<strong>主引导记录</strong>，由它引导激活分区引导记录，再执行<strong>分区引导记录</strong>，加载操作系统，最后执行<strong>操作系统</strong>，配置系统</li></ol></li><li><p>FAT32目录项结构</p><ol type="1"><li>FAT的<strong>每个目录项</strong>为<strong>32个字节</strong></li></ol></li><li><p><strong>FAT32长文件名</strong>的目录项由几个32B表项组成</p><ol type="1"><li>用一个表项存放短文件名和其他属性（包括簇号、文件大小，最后修改时间和最后修改日期、创建时间、创建日期和最后存取日期），短文件名的属性是0x20</li><li>用连续若干个表项存放长文件名，每个表项存放13个字符（使用Unicode编码，每个字符占用2个字节）</li><li>长文件名的表项首字节的二进制数低5位值，分别为00001 、00010 、 00011、……，表示它们的次序，左起第2位为1(也就是在低5位基础上加40H)表示该表项是最后一项。最后项存放13个字符位置多余时，先用2个字节0表示结束，再用FFH填充</li><li>长文件名的属性是0x0F</li><li>长文件名项的第13、27、28字节为0x00，第14字节为短文件名校验和</li><li>长文件名The quickbrown.fox（短文件名为THEQUI~1.FOX）目录项格式如下：</li></ol><p><img src="/images/AssetMarkdown/image-20221212145723827.png" alt="image-20221212145723827" style="zoom:80%;" /></p></li></ol><h4 id="ntfs文件系统">11.4.2.3 NTFS文件系统</h4><ol type="1"><li><p>NTFS卷布局：</p><p><img src="/images/AssetMarkdown/image-20221212145820512.png" alt="image-20221212145820512"  /></p></li><li><p>每个分区均有一个主文件表<strong>Master FileTable(MFT)</strong></p><ol type="1"><li>MFT用数据库记录形式组织，每条记录(MFT表项)长度1K</li><li>MFT由一个个MFT项(也称为文件记录)组成，每个MFT项占用1024字节的空间</li><li>MFT前16个记录用来存放元数据文件的信息，它们占有固定的位置</li><li>每个MFT项的前部几十个字节有着固定的头结构，用来描述本MFT项的相关信息。后面的字节存放着文件属性等</li><li>每个文件或目录的信息都包含在MFT中，每个文件或目录至少有一个MFT项</li></ol><p><img src="/images/AssetMarkdown/image-20221212145917582.png" alt="image-20221212145917582" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221212150032357.png" alt="image-20221212150032357" style="zoom:80%;" /></p></li></ol><h3 id="索引分配">11.4.3 索引分配</h3><h4 id="索引分配-1">11.4.3.1 索引分配</h4><ol type="1"><li><p>将所有指针统一放到<strong>索引块 index block</strong>中</p></li><li><p>逻辑视图</p></li><li><p>每个文件都使用磁盘上的索引块来包含文件使用的其他磁盘块的地址</p></li><li><p>当写入第<spanclass="math inline">\(i\)</span>个块时，块的地址被放置在索引块的第<spanclass="math inline">\(i\)</span>个位置</p></li><li><p>方法会浪费空间，因为对于小文件，大部分索引块都被浪费了</p><ol type="1"><li>如果索引块太小，我们可以：<ol type="1"><li>将几个链接在一起</li><li>使用多级索引</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212151200110.png" alt="image-20221212151200110" style="zoom:50%;" /></p></li><li><p>需要索引表</p></li><li><p>可以实现随机访问</p></li><li><p>动态分配不会产生额外的碎片，但是会浪费索引块的空间</p></li><li><p>在最大大小为256KB、块大小为512B的文件中从逻辑映射到物理。索引表只需要1个块</p></li></ol><h4 id="链接索引">11.4.3.2 链接索引</h4><ol type="1"><li>将索引表，使用链表连接起来</li></ol><p><img src="/images/AssetMarkdown/image-20221212151713695.png" alt="image-20221212151713695" style="zoom:80%;" /></p><h4 id="二级索引">11.4.3.3 二级索引</h4><ol type="1"><li>Two-level index</li></ol><p><img src="/images/AssetMarkdown/image-20221212151851581.png" alt="image-20221212151851581" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221212152013361.png" alt="image-20221212152013361" style="zoom:80%;" /></p><h3 id="组合模式">11.4.4 组合模式</h3><ol type="1"><li>使用不同索引，适配不同大小的文件<ol type="1"><li>direct blocks：直接指向数据所在的位置</li><li>single indirect：指向一级索引块</li><li>double indirect：指向二级索引块</li></ol></li></ol><blockquote><p>Linux ext2/ext3</p></blockquote><p><img src="/images/AssetMarkdown/image-20221212152131318.png" alt="image-20221212152131318" style="zoom:80%;" /></p><h2 id="free-space-management-空闲空间管理">11.5 Free-Space Management空闲空间管理</h2><ol type="1"><li><p>Bitmap 位图</p><p><img src="/images/AssetMarkdown/image-20221215163231777.png" alt="image-20221215163231777" style="zoom:80%;" /></p><ol type="1"><li><p>对于有n个blocks的空间 <span class="math display">\[bit[i]=\left\{\begin{aligned}  &amp; 0 =&gt; block[i]空闲\\  &amp; 0 =&gt; block[i]被占用\end{aligned} \right.\]</span></p></li><li><p>Bitmap需要额外的空间来记录空闲空间</p></li></ol><p><img src="/images/AssetMarkdown/image-20221215163339003.png" alt="image-20221215163339003" style="zoom:67%;" /></p></li><li><p>Free list 空闲列表</p><ol type="1"><li>将空闲的空间连接起来</li><li>没有空间浪费</li><li>但是不能容易的得到连续的空间</li></ol></li><li><p>Grouping 分组</p><ol type="1"><li>可以较为容易的得到一块连续的空间</li><li>如果分组大小为固定的，则难以满足所有程序的需求</li><li>如果分组大学为动态的，则容易产生碎片</li></ol></li><li><p>Counting 空闲表</p></li><li><p>需要保护的内容：</p><ol type="1"><li>指向空闲列表的指针</li><li>Bitmap：<ol type="1"><li>必须保存在磁盘上</li><li>内存和磁盘中的副本可能不同</li><li>不能允许block[i]在内存中的bit[i]=1，而在磁盘上的bit[i]=0</li></ol></li><li>解决方法：<ol type="1"><li>set 磁盘中的 bit[i] = 1</li><li>申请block[i]</li><li>set 内存中的 bit[i] = 1</li></ol></li></ol></li></ol><blockquote><p>Linked Free Space List on Disk</p></blockquote><p><img src="/images/AssetMarkdown/image-20221215164144034.png" alt="image-20221215164144034" style="zoom: 67%;" /></p><h2 id="效率和性能">11.6 效率和性能</h2><ol type="1"><li>效率依赖于：<ol type="1"><li>磁盘分配、目录算法</li><li>文件中目录项的数据的类型</li></ol></li><li>性能：<ol type="1"><li>disk cache：在内存中开辟一块空间，访问磁盘时先访问这块内存</li><li>free-behind andread-ahead：释放时不真正将内存中的内容刷新，读取时提前将相关的block读入内存</li><li>通过将部分内存用作虚拟磁盘或RAM磁盘来提高PC性能</li></ol></li></ol><h3 id="page-cache">11.6.1 Page Cache</h3><ol type="1"><li>Page Cache使用虚拟内存技术缓存页面而不是磁盘块，</li><li>Memory-mapped I/O会使用Page Cache</li><li>通过文件系统的例行I/O使用缓冲区（磁盘）缓存</li></ol><p><img src="/images/AssetMarkdown/image-20221215164907603.png" alt="image-20221215164907603" style="zoom:67%;" /></p><h3 id="unified-buffer-cache">11.6.2 Unified Buffer Cache</h3><ol type="1"><li>Unified Buffer Cache统一缓冲区缓存：使用相同的页面缓存来缓存memory-mapped pages和普通文件系统I/O</li></ol><p><img src="/images/AssetMarkdown/image-20221215165214104.png" alt="image-20221215165214104" style="zoom:80%;" /></p><h2 id="recovery">11.7 Recovery</h2><ol type="1"><li><strong>Consistency checking</strong>一致性比较：将目录结构中的数据与磁盘上的数据块进行比较，并尝试修复不一致性</li><li><strong>back up</strong>备份：使用系统程序将数据从磁盘备份到其他存储设备（磁带、其他磁盘、光盘）</li><li><strong>restoring</strong>恢复：通过从备份中恢复数据来恢复丢失的文件或磁盘</li></ol><h3 id="log-structured-file-systems">11.7.1 Log Structured FileSystems</h3><ol type="1"><li><strong>Log structured</strong>日志结构(或日志)文件系统：将文件系统的每次更新记录为事务<strong>transaction</strong></li><li>所有事务都写入日志<ol type="1"><li>事务写入日志后即被视为已提交</li><li>但是，文件系统可能尚未更新</li></ol></li><li>日志中的事务将异步写入文件系统<ol type="1"><li>修改文件系统时，事务将从日志中删除</li></ol></li><li>如果文件系统崩溃，则仍必须执行日志中的所有剩余事务</li></ol><h3 id="network-file-system-nfs-网络文件系统">11.7.2 Network File System(NFS) 网络文件系统</h3><h4 id="nfs">11.7.2.1 NFS</h4><ol type="1"><li>NFS：跨LAN/WAN访问远程文件的软件系统的实现和规范</li><li>该实现是使用不可靠数据报协议(UDP/IP协议和以太网)在Sun工作站上运行的Solaris和SunOS操作系统的一部分</li><li>互连工作站被视为一组具有独立文件系统的独立计算机，允许以透明的方式在这些文件系统之间共享<ol type="1"><li>远程目录加载在本地文件系统目录上<ol type="1"><li>加载的目录看起来像本地文件系统的一个完整子树，替换了从本地目录向下的子树(mount的过程)</li></ol></li><li>装载操作的远程目录的规范是不透明的；必须提供远程目录的主机名<ol type="1"><li>然后可以以透明的方式访问远程目录中的文件</li></ol></li><li>根据访问权限认证，可能任何文件系统（或文件系统中的目录）都可以远程安装在任何本地目录的顶部</li></ol></li><li>NFS旨在在不同机器、操作系统和网络架构的异构环境中运行；独立于这些介质的NFS规范<ol type="1"><li>这种独立性是通过使用构建在两个独立于实现的接口之间使用的外部数据表示(ExternalData Representation XDR)协议之上的RPC原语(RPC primitives)实现的</li></ol></li><li>NFS规范区分了装载机制提供的服务和实际的远程文件访问服务</li></ol><p><img src="/images/AssetMarkdown/image-20221215171246096.png" alt="image-20221215171246096" style="zoom:67%;" /></p><p><img src="/images/AssetMarkdown/image-20221215171336215.png" alt="image-20221215171336215" style="zoom:80%;" /></p><h4 id="nfs-mount-protocol">11.7.2.2 NFS Mount Protocol</h4><ol type="1"><li>在服务器和客户端之间建立初始逻辑连接</li><li>mount操作包括：要装载的远程目录的名称、存储该目录的服务器计算机的名称<ol type="1"><li>mount请求被映射到相应的RPC，并转发到服务器计算机上运行的装载服务器</li><li>Exportlist导出列表：指定服务器导出以进行mount的本地文件系统，以及允许mount它们的计算机的名称</li></ol></li><li>在符合其导出列表的装载请求之后，服务器返回一个文件句柄：一个用于进一步访问的密钥</li><li>文件句柄：一个文件系统标识符和一个inode编号，用于标识导出的文件系统中装载的目录</li><li>装载操作仅更改用户的视图，不会影响服务器端</li></ol><h4 id="nfs-protocol">11.7.2.3 NFS Protocol</h4><ol type="1"><li>为远程文件操作提供一组远程过程调用。程序支持以下操作：<ol type="1"><li>在目录中搜索文件</li><li>读取一组目录条目</li><li>操作链接和目录</li><li>访问文件属性</li><li>读取和写入文件</li></ol></li><li>NFS服务器是无状态<strong>stateless</strong>：每个请求都必须提供一组完整的参数<ol type="1"><li>NFS V4刚刚推出，非常不同，有状态</li></ol></li><li>修改数据时，必须先修改服务器的磁盘，才能将数据返回客户端<ol type="1"><li>保证了同步</li><li>失去缓存的优势</li></ol></li><li>NFS协议不提供并发控制机制</li></ol><h4 id="nfs架构中的三个主要层">11.7.2.4 NFS架构中的三个主要层</h4><ol type="1"><li>UNIX文件系统接口<ol type="1"><li>基于打开、读取、写入和关闭调用以及文件描述符</li></ol></li><li>虚拟文件系统(VFS)层：区分本地文件和远程文件，本地文件根据其文件系统类型进一步区分<ol type="1"><li>VFS根据文件系统类型激活文件系统特定操作以处理本地请求</li><li>为远程请求调用NFS协议过程</li></ol></li><li>NFS服务层：体系结构的底层<ol type="1"><li>实施NFS协议</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221215172431386.png" alt="image-20221215172431386" style="zoom:80%;" /></p><h4 id="nfs-path-name-translation">11.7.2.5 NFS Path-NameTranslation</h4><ol type="1"><li>通过将路径拆分为组件名称并对每对组件名称和目录vnode执行单独的NFS查找调用来执行</li><li>为了加快查找速度，客户端的目录名查找缓存保存远程目录名的vnode</li></ol><h4 id="nfs远端操作">11.7.2.6 NFS远端操作</h4><ol type="1"><li>常规UNIX系统调用与NFS协议RPC之间几乎一一对应（打开和关闭文件除外）</li><li>NFS遵循远程服务范式，但为了性能考虑，采用了缓冲和缓存技术</li><li>文件块缓存：打开文件时，内核会与远程服务器检查是否获取或重新验证缓存的属性<ol type="1"><li>仅当相应的缓存属性是最新的时，才使用缓存文件块</li></ol></li><li>文件属性缓存：每当新属性从服务器到达时，都会更新属性缓存</li><li>在服务器确认数据已写入磁盘之前，客户端不会释放延迟的写入块</li></ol><h2 id="示例wafl文件系统">*11.8 示例：WAFL文件系统</h2><ol type="1"><li>用于Network Appliance“Filers”：分布式文件系统设备</li><li>在任何位置写入文件布局</li><li>为NFS、CIFS、http、ftp提供服务</li><li>随机I/O优化，写优化<ol type="1"><li>用于写缓存的NVRAM</li></ol></li><li>类似于Berkeley Fast File System，具有广泛的修改</li></ol><blockquote><p>The WAFL File Layout</p></blockquote><p><img src="/images/AssetMarkdown/image-20221215172923567.png" alt="image-20221215172923567" style="zoom:80%;" /></p><blockquote><p>Snapshots in WAFL</p></blockquote><p><img src="/images/AssetMarkdown/image-20221215172935282.png" alt="image-20221215172935282" style="zoom:80%;" /></p><h1 id="chapter-12mass-storage-systems">Chapter 12：Mass-StorageSystems</h1><h2 id="大容量存储系统-概览">12.1 大容量存储系统 概览</h2><blockquote><p>分层存储体系</p></blockquote><p><img src="/images/AssetMarkdown/image-20221219143646168.png" alt="image-20221219143646168" style="zoom:80%;" /></p><ol type="1"><li>磁盘<code>Magnetic disks</code>：<ol type="1"><li>每秒钟60~200转</li><li>传输速率<code>Transfer Rate</code>：从驱动器到计算机之间的数据传输速率<ol type="1"><li>与磁盘、计算机连接驱动的方式有关</li></ol></li><li>定位时间<code>Positioning Time</code> /<code>Random-access time</code>：分为两部分<ol type="1"><li>将磁盘臂移动到所需柱面的时间（寻道时间<code>seek time</code>）</li><li>所需扇区在磁盘头下旋转的时间（旋转延迟<code>rotational latency</code>）</li></ol></li><li><code>Head Crash</code>：磁头与磁盘相碰，会导致磁盘坏区</li><li>磁盘可以被移除</li><li>驱动通过I/O总线与计算机相连<ol type="1"><li>总线有很多种，如：EIDE, ATA, SATA, USB, Fibre Channel, SCSI</li><li>计算机中的主机控制器使用总线与内置在驱动器或存储阵列中的磁盘控制器通信</li></ol></li></ol></li><li>固态硬盘<code>Solid State Drives</code>：<ol type="1"><li>简称固盘，固态硬盘用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成</li><li>第一只SSD出现在1978年（STK 4305，每MB售价8800美元，DRAM）</li><li>全闪存阵列（AFAS）和混合闪存阵列（HFA）呈爆发式增长</li><li>现在SSD的容量是15.36TB（SAS）</li><li>非易失性、低功耗（只有HDD的三分之一）</li><li>无活动部件、可靠性高：―位误码率(<code>BER</code>)1x10<sup>-17</sup></li><li>读取存取时间：0.2毫秒，存取时间比HDD大概快 50倍</li></ol></li><li>磁带<code>Magnetic tape</code>：<ol type="1"><li>出货的磁带驱动器中超过85%是LTO（Linear Tape Open）</li><li>磁带驱动器的可靠性、数据传输速率和容量已超过磁盘</li><li>磁带的原生容量为10TB，压缩容量超过25TB。(LTO-10:48TB)</li><li>磁带的原生数据传输速率为360MB/s</li><li>LTFS(Liner Tape FileSystem)为磁带提供了一种通用、开放的文件系统</li><li>由于总体拥有成本，云采用磁带解决方案用于归档服务</li><li>对企业级磁带和LTO而言，磁带介质的寿命至少是30年</li></ol></li></ol><h2 id="磁盘结构-1">12.2 磁盘结构</h2><h3 id="磁盘结构-2">12.2.1 磁盘结构</h3><ol type="1"><li>磁盘被划分为逻辑块的一个一维阵列，其中逻辑块是最小的传输单位</li><li>逻辑块的大小通常为512字节</li><li>逻辑块的一维阵列按顺序映射到磁盘的扇区中<ol type="1"><li>扇区0：是最外柱面上，第一个磁道的，第一个扇区</li><li>映射顺序：磁道上的其它扇区 =&gt; 柱面上的其它磁道 =&gt;其它柱面</li></ol></li></ol><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20221219145527826.png" alt="image-20221219145527826"  /></th><th><img src="/images/AssetMarkdown/image-20221219145531858.png" alt="image-20221219145531858" style="zoom:80%;" /></th></tr></thead><tbody></tbody></table><h3 id="host-attached-storage">12.2.2 Host-attached storage</h3><ol type="1"><li><p>主机通过I/O接口与I/O总线进行通信</p></li><li><p><code>IDE</code>：</p><ol type="1"><li>每个I/O bus 最多2个驱动器</li></ol></li><li><p><code>SCSI</code>：</p><ol type="1"><li>SCSI本身是一条总线，一根电缆上最多有16个设备，SCSI启动器请求操作，SCSI目标执行任务</li><li>每个目标最多可以有8个逻辑单元（连接到设备控制器的磁盘）</li></ol></li><li><p><code>FC</code>：Fibre Channel，光纤通道</p><ol type="1"><li>可以是具有24位地址空间的交换结构，这是存储区域网络(SAN, storage areanetworks)的基础，其中许多主机连接到许多存储单元</li><li>可仲裁126个设备的环路（FC-AL）</li></ol></li><li><p><code>NAS</code>：Network-attached storage</p><ol type="1"><li>网络连接存储（NAS）是通过网络而不是通过本地连接（如总线）提供的存储</li><li>NFS和CIFS（通用Internet文件系统）是通用协议</li><li>通过主机和存储之间的远程过程调用（RPC）实现</li><li>新的iSCSI协议使用IP网络来承载SCSI协议</li></ol><p><img src="/images/AssetMarkdown/image-20221219150412657.png" alt="image-20221219150412657" style="zoom:80%;" /></p></li><li><p><code>SAN</code>：Storage Area Network</p><ol type="1"><li>在大型存储环境中很常见（而且越来越常见）</li><li>多个主机连接到多个存储阵列—灵活</li></ol><p><img src="/images/AssetMarkdown/image-20221219150441725.png" alt="image-20221219150441725" style="zoom:80%;" /></p></li><li><p>存储虚拟化技术：<code>SNIA</code>(Storage Networking IndustryAssociation，存储网络联合会)官方对于<code>Virtualization</code>(存储虚拟化技术)的定义如下：</p><ol type="1"><li>是将存储（子）系统内部功能与具体应用、主机及通用网络资源分离、隐藏及抽象的行为。以期达到存储或数据管理的网络无关性</li><li>对于存储服务及设备的虚拟化应用，以期达到整合设备功能、隐藏复杂细节以及向已经存在的底层存储资源添加新的应用</li></ol><p><img src="/images/AssetMarkdown/image-20221219150541740.png" alt="image-20221219150541740" style="zoom: 80%;" /></p></li></ol><h2 id="磁盘调度">12.4 磁盘调度</h2><h3 id="磁盘调度-1">12.4.1 磁盘调度</h3><ol type="1"><li>操作系统负责有效地使用硬件-对于磁盘驱动器，这意味着具有快速的访问时间和磁盘带宽</li><li>访问时间有三个主要组成部分<ol type="1"><li><code>Seek time</code>(寻道时间)：是磁盘将磁头移动到包含所需扇区的气缸的时间</li><li><code>Rotational latency</code>(旋转延迟)：是等待磁盘将所需扇区旋转到磁盘头的额外时间</li><li><code>Transfer time</code>(传输时间)</li></ol></li><li><strong>目标：最小化寻道时间</strong></li><li>seek time ≈ seek distance 寻道时间 ≈ 寻道距离</li><li>磁盘带宽：传输的总字节数 /第一次服务请求和最后一次传输完成之间的总时间</li></ol><blockquote><ol type="1"><li>7200(转／每分钟)的硬盘，每旋转一周所需时间为60×1000（毫秒）÷7200＝8.33毫秒，则平均旋转延迟时间为8.33÷2＝4.17毫秒(平均情况下，需要旋转半圈)。</li><li>7200转机械硬盘的寻道时间一般为12-14毫秒，固态硬盘可以达到0.1毫秒甚至更低</li><li>固态硬盘持续读写速度超过500MB/s</li><li>机械硬盘读写速度超过50~200MB/s（接口不同）</li><li>磁带的原生数据传输速率为360MB/s</li></ol></blockquote><h3 id="磁盘调度算法">12.4.2 磁盘调度算法</h3><p>假设</p><ol type="1"><li>请求队列为：<code>98, 183, 37, 122, 14, 124, 65, 67</code></li><li>磁头目前在：<code>53</code></li></ol><h4 id="fcfs-先来先服务">12.4.2.1 FCFS 先来先服务</h4><blockquote><p>总距离：<code>640</code>个磁道距离</p></blockquote><p><img src="/images/AssetMarkdown/image-20221219152543077.png" alt="image-20221219152543077" style="zoom:67%;" /></p><h4 id="sstf-最短寻道时间优先">12.4.2.2 SSTF 最短寻道时间优先</h4><ol type="1"><li>选择对于当前磁头来说，所需寻道时间最小的请求</li><li>SSTF(Shortest Seek TimeFirst)是SJF的一个变种，可能会导致starvation</li></ol><blockquote><p>总距离：<code>236</code>个磁道距离</p></blockquote><p><img src="/images/AssetMarkdown/image-20221219152910224.png" alt="image-20221219152910224" style="zoom:67%;" /></p><h4 id="scan-扫描">12.4.2.3 SCAN 扫描</h4><ol type="1"><li>磁盘臂从磁盘的一端开始，向另一端移动，当遇到请求的块时，直接读取，直到到达磁盘的另一端</li><li>此时磁头移动方向取反，继续响应途中遇到的请求</li><li>SCAN算法有时称为电梯算法</li><li>SCAN算法的稳定性不高</li></ol><blockquote><p>总距离：<code>236</code>个磁道距离</p></blockquote><p><img src="/images/AssetMarkdown/image-20221219153237456.png" alt="image-20221219153237456" style="zoom:67%;" /></p><h4 id="c-scan">12.4.2.4 C-SCAN</h4><ol type="1"><li>磁盘臂从磁盘的一端开始，向另一端移动，当遇到请求的块时，直接读取，直到到达磁盘的另一端</li><li>此时磁头直接跳转到磁盘的开始端，然后继续向另一端移动</li><li>C-SCAN更加稳定，因为保证了同一时间遇到的请求可以在一次SCAN过程中都取到</li></ol><blockquote><p>总距离：<code>382</code>个磁道距离</p></blockquote><p><img src="/images/AssetMarkdown/image-20221219153555618.png" alt="image-20221219153555618" style="zoom:67%;" /></p><h4 id="look">12.4.2.5 LOOK</h4><ol type="1"><li>SCAN的时候，不一定要到边上，只要到达所有请求的最小/大值处，即可折返</li></ol><blockquote><p>总距离：<code>208</code>个磁道距离</p></blockquote><p><img src="/images/AssetMarkdown/image-20221219154814261.png" alt="image-20221219154814261" style="zoom:67%;" /></p><h4 id="c-look">12.4.2.6 C-LOOK</h4><ol type="1"><li>C-SCAN的时候，不一定要到边上，只要到达所有请求的最小/大值处，即可折返</li></ol><blockquote><p>总距离：<code>322</code>个磁道距离</p></blockquote><p><img src="/images/AssetMarkdown/image-20221219153956094.png" alt="image-20221219153956094" style="zoom:67%;" /></p><h3 id="选择一种磁盘调度算法">12.4.3 选择一种磁盘调度算法</h3><ol type="1"><li>SSTF很常见，具有自然吸引力</li><li>SCAN和C-SCAN在磁盘负载较大的系统中表现更好</li><li>性能取决于请求的数量和类型</li><li>磁盘服务请求可能会受到文件分配方法的影响</li><li>磁盘调度算法应作为操作系统的一个单独模块来编写，允许在必要时使用不同的算法来替换</li><li>SSTF或LOOK是一种合理的默认算法</li></ol><h2 id="磁盘控制">12.5 磁盘控制</h2><h3 id="磁盘控制-1">12.5.1 磁盘控制</h3><ol type="1"><li>Low-level formatting / physical formatting 低级格式化/物理格式化：<ol type="1"><li>为每个扇区采用特别的数据结构，包括头、数据区域和尾部组成</li><li>头部和尾部包含了一些磁盘控制器所使用的信息，例如扇区号码和纠错代码（ECC）</li><li>当控制器在正常I/O时写入一个扇区数据时，ECC会用一个根据磁盘数据计算出来的值更新</li><li>当读入扇区时，ECC值会重新计算，并与原来存储的值相比较，如果两个值不一样，那么可能表示扇区的数据可能已损坏或扇区可能变坏</li></ol></li><li>要使用磁盘保存文件，操作系统仍需要在磁盘上记录自己的数据结构<ol type="1"><li>Partition分区：<ol type="1"><li>一个分区可以用来存储操作系统的可执行代码，而其他分区用来存储用户数据</li><li>分区可看做一个独立的磁盘</li></ol></li><li>Logical formatting 逻辑格式化：<ol type="1"><li>操作系统将初始的文件系统数据结构存储到磁盘上</li><li>这些数据结构包括空闲和已分配的空间（FAT和inode）和一个初始为空的目录</li></ol></li><li>cluster 簇：<ol type="1"><li>为了提高效率，大多数操作系统将块集中到一大块，叫做簇cluster</li><li>磁盘I/O通过块完成，文件系统I/O通过簇完成，确保I/O可以进行更多的顺序存取和更少的随机存取</li></ol></li></ol></li></ol><h3 id="boot-block-启动块">12.5.2 Boot Block 启动块</h3><ol type="1"><li>Boot block 初始化系统：<ol type="1"><li>引导程序（自举程序）初始化系统从cpu寄存器到设备控制器和内存，接着启动操作系统</li><li>自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，开始操作系统的执行</li></ol></li><li>经典的启动顺序<ol type="1"><li>ROM中的代码（简单引导）<ol type="1"><li>ROM中保留一个很小的自举加载程序，它的作用是进一步从磁盘上调入更为完整的自举程序</li></ol></li><li>Boot Block中的代码（完全引导）<ol type="1"><li>引导加载程序，例如Grub或LILO</li><li>磁盘上的自举程序可以容易地进行修改，拥有启动分区的磁盘称为启动磁盘或系统磁盘</li></ol></li><li>操作系统的整个内核</li></ol></li></ol><h3 id="windows-2000的启动">12.5.3 Windows 2000的启动</h3><blockquote><ol type="1"><li>Windows系统通过运行系统ROM上的代码，开始启动，指示系统从MBR读取引导代码。MBR包含一个硬盘分区列表和一个说明系统引导分区的标志</li><li>引导分区，bootpartition，包含操作系统和设备驱动程序。系统一旦确定引导分区，它读取该分区的第一个扇区，所谓引导扇区，并继续余下的启动过程，包括加载各种子系统和系统服务</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20221222164450979.png" alt="image-20221222164450979" style="zoom:80%;" /></p><h3 id="bad-block-坏块">12.5.4 Bad Block 坏块</h3><blockquote><p>有坏块是正常的，出厂的时候就有可能有坏块。对于简单磁盘，Format进行逻辑格式化时找到坏块，就在相应的FAT条目上写上特殊值以通知分配程序不要使用该块。如果在正常使用中块变坏，就必须人工的执行chkdsk来搜索坏块。</p></blockquote><ol type="1"><li>磁盘经常有缺陷块或坏块</li><li>坏块的处理方法</li><li>MS-DOS的处理方法: format，chkdsk命令</li></ol><h2 id="交换空间的管理">12.6 交换空间的管理</h2><ol type="1"><li>交换空间：虚拟内存使用磁盘空间作为主内存的扩展</li><li>交换空间可以有2种形式：<ol type="1"><li>在普通的文件系统中：windows--<code>pagefile.sys文件</code></li><li>在独立的磁盘分区种：linux、unix--<code>SWAP分区</code></li></ol></li><li>交换空间的大小：<ol type="1"><li>交换空间太大容易造成浪费</li><li>交换空间太小容易造成死机现象：中断进程或使整个系统死机</li></ol></li><li>BSD在进程启动时分配交换空间；保存文本段（程序）和数据段<ol type="1"><li>内核使用交换映射来跟踪交换空间的使用</li></ol></li><li>Solaris2仅在页面被强制移出物理内存时才分配交换空间，而不是在首次创建虚拟内存页面时</li></ol><blockquote><p>Data Structures for Swapping on Linux Systems</p></blockquote><p><img src="/images/AssetMarkdown/image-20221222165445838.png" alt="image-20221222165445838" style="zoom:80%;" /></p><h2 id="raid结构">12.7 RAID结构</h2><h3 id="raid介绍">12.7.1 RAID介绍</h3><ol type="1"><li><strong>RAID</strong>：Redundant Arrays of Inexpensive(Independent)Disks，冗余廉价磁盘阵列<ol type="1"><li>RAID是一种把多块独立的硬盘(物理硬盘)按不同的方式组合起来形成一个硬盘组(逻辑硬盘)，从而提供比单个硬盘更高的存储性能和提供数据备份技术</li><li>Inexpensive =&gt; Independent</li><li>RAID：使用多个磁盘，通过冗余提供可靠性</li><li>增加平均故障时间</li><li>通常与NVRAM组合使用，提升性能</li><li>分为了6个级别</li></ol></li><li>磁盘使用技术的一些改进涉及使用多个磁盘协同工作</li><li>磁盘条带化(striping)：将一组磁盘用作一个存储单元</li><li>RAID方案通过存储冗余数据来提高存储系统的性能和可靠性<ol type="1"><li>镜像(Mirroring)或shadowing(RAID 1)：保留每个磁盘的副本</li><li>条带化镜像(RAID 1+0)或镜像条带(RAID0+1)：提供了高性能和高可靠性</li><li>块交错奇偶校验(RAID 4、5、6)：使用更少的冗余</li></ol></li><li>如果阵列发生故障，存储阵列中的RAID仍可能发生故障，因此阵列之间的数据自动复制很常见</li><li>通常，少数hot-sparedisks不会被分配，自动替换故障磁盘并将数据重建到这些磁盘上</li></ol><h3 id="raid层级">12.7.2 RAID层级</h3><ol type="1"><li><strong>Raid0</strong>：没有冗余性的保证，但是可以将多个磁盘条带化成1个</li><li><strong>Raid 1</strong>：镜像磁盘，是数据的一个完整拷贝</li><li><strong>Raid2</strong>：内存方式的差错纠正代码结构，内存系统中的每个字节都有一个相关奇偶位，以记录字节中置为1的个数是偶数还是奇数</li><li><strong>Raid3</strong>：按位校验，奇偶校验码和其它磁盘的相应扇区或块一起用于恢复出错磁盘的扇区和块</li><li><strong>Raid4</strong>：按块校验，奇偶校验码和其它磁盘的相应扇区或块一起用于恢复出错磁盘的扇区和块</li><li><strong>Raid5</strong>：将数据和奇偶校验分布在所有N+1块磁盘上</li><li><strong>Raid6</strong>：保存了额外的冗余信息以防止多个磁盘出错，每4个位的数据使用了2个位的冗余数据，这样系统可以容忍两个磁盘出错。</li></ol><p><img src="/images/AssetMarkdown/image-20221222171059973.png" alt="image-20221222171059973" style="zoom:80%;" /></p><h3 id="raid01-和-raid10">12.7.3 RAID(0+1) 和 RAID(1+0)</h3><ol type="1"><li>RAID 0+1：<ol type="1"><li>先分散，再镜像</li><li>一组磁盘分散成条，每一条再镜像到另一条</li><li>RAID 0和RAID 1的组合，RAID 0提供性能，RAID 1提供可靠性</li><li>RAID0+1允许坏多个盘，但只能在坏在同一个RAID0中，不允许两个RAID0都有坏盘</li></ol></li><li>RAID 1+0：<ol type="1"><li>先镜像，再分散</li><li>如果单个磁盘不可用，其它镜像仍如其它磁盘一样可用</li><li>RAID1+0允许坏多个盘，只要不是一对磁盘坏就可以</li></ol></li><li>RAID 1+0在整体容错能力和恢复代价上比RAID0+1更有优势，所以更为常用</li></ol><p><img src="/images/AssetMarkdown/image-20221222171500654.png" alt="image-20221222171500654" style="zoom:80%;" /></p><h3 id="拓展">12.7.4 拓展</h3><ol type="1"><li>单独使用RAID无法防止或检测数据损坏或其他错误，只是防止磁盘故障</li><li>Solaris ZFS添加了所有数据和元数据的校验和<ol type="1"><li>与对象指针一起保存的校验和，用于检测对象是否正确以及是否已更改</li><li>可以检测并纠正数据和元数据损坏</li></ol></li><li>ZFS还删除了卷、分区<ol type="1"><li>磁盘分配到pool中</li><li>具有池的文件系统共享该池，使用和释放空间，如“malloc”和“free”内存分配/释放调用</li></ol></li></ol><blockquote><p>ZFS Checksums All Metadata and Data</p></blockquote><p><img src="/images/AssetMarkdown/image-20221222172044176.png" alt="image-20221222172044176" style="zoom:80%;" /></p><blockquote><p>Traditional and Pooled Storage</p></blockquote><p><img src="/images/AssetMarkdown/image-20221222172052943.png" alt="image-20221222172052943" style="zoom:80%;" /></p><h1 id="chapter-13io-system">Chapter 13：I/O System</h1><h2 id="overview-1">13.1 Overview</h2><ol type="1"><li>计算机的两个主要工作<ol type="1"><li>I/O</li><li>计算</li></ol></li><li>与计算机相连的设备的控制是操作系统设计者的主要关注点</li><li>I/O设备技术出现两个相矛盾的趋势：<ol type="1"><li>硬件和软件接口日益增长的标准化</li><li>I/O设备日益增长的多样性。</li></ol></li><li>操作系统内核设计成使用设备驱动程序模块的结构</li><li>设备驱动程序为I/O子系统提供了统一接口</li></ol><h2 id="io硬件">13.2 I/O硬件</h2><ol type="1"><li>I/O系统的组成：<ol type="1"><li>PC总线型I/O系统</li><li>大型机I/O系统</li></ol></li><li>通用概念<ol type="1"><li>Port ，端口</li><li>Bus (daisy chain or shared direct access)，总线</li><li>Controller (host adapter)，控制器</li></ol></li><li>I/O instructions控制设备</li><li>寻址方式<ol type="1"><li>直接使用I/O指令</li><li>内存映射I/O</li></ol></li></ol><blockquote><p>PC总线型I/O</p></blockquote><p><img src="/images/AssetMarkdown/image-20221226143530861.png" alt="image-20221226143530861" style="zoom:80%;" /></p><blockquote><p>Mainframe Systems 大型机(主机)系统</p><ol type="1"><li>这类计算机以存储器为中心，CPU和各种通道都与存储器相连</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20221226143547576.png" alt="image-20221226143547576" style="zoom:80%;" /></p><h2 id="io方式">13.3 I/O方式</h2><h3 id="轮询">13.3.1 轮询</h3><ol type="1"><li>CPU查询I/O的状态</li><li>I/O返回当前状态<ol type="1"><li>command-ready</li><li>busy</li><li>error</li></ol></li><li>如果I/O没有准备好，则会返回第1步，进入busy-wait(忙等待)状态</li><li>如果I/O准备好了，则CPU读取I/O的数据，写入内存，然后返回第1步</li></ol><p><img src="/images/AssetMarkdown/image-20221226144148862.png" alt="image-20221226144148862" style="zoom:67%;" /></p><h3 id="interrupt中断">13.3.2 Interrupt中断</h3><ol type="1"><li>CPU硬件有一条<strong>中断请求线（interrupt-request line,IRL）</strong>，由I/O设备触发<ol type="1"><li>设备控制器通过中断请求线发送信号而引起中断，CPU捕获中断并派遣到中断处理程序，中断处理程序通过处理设备来清除中断。</li></ol></li><li>两种中断请求<ol type="1"><li><strong>非屏蔽中断</strong>：主要用来处理如不可恢复内存错误等事件</li><li><strong>可屏蔽中断</strong>：由CPU在执行关键的不可中断的指令序列前加以屏蔽</li></ol></li><li><strong>中断向量</strong></li><li><strong>中断优先级</strong>：能够使CPU延迟处理低优先级中断而不屏蔽所有中断，这也可以让高优先级中断抢占低优先级中断处理。</li><li>中断的用途<ol type="1"><li>中断机制用于处理各种异常，如被零除，访问一个受保护的或不存在的内存地址</li><li>系统调用的实现需要用到中断（软中断）</li><li>中断也可以用来管理内核的控制流</li></ol></li></ol><blockquote><p>中断驱动I/O循环</p></blockquote><p><img src="/images/AssetMarkdown/image-20221226145032534.png" alt="image-20221226145032534" style="zoom:80%;" /></p><h3 id="直接内存访问dmadirect-memory-access">13.3.3直接内存访问DMA(Direct Memory Access)</h3><ol type="1"><li>用来避免处理大量数据移动时按字节来向控制器送入数据的问题</li><li>需要DMA控制器</li><li>绕过CPU直接在内存与I/O设备之间进行数据传输</li><li>步骤：<ol type="1"><li>硬件告诉设备驱动器：要传输在地址X处的磁盘数据</li><li>设备驱动器告诉磁盘控制器：从磁盘中读取地址X处的C个字节到buffer</li><li>磁盘控制器：初始化DMA传输</li><li>磁盘控制器：传输字节，给到DMA控制器</li><li>DMA控制器：传输字节给到buffer，地址++，C--，直到C=0</li><li>当C=0时，DMA中断CPU，声明传输已经结束</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221226145852776.png" alt="image-20221226145852776" style="zoom: 80%;" /></p><h3 id="应用io接口">13.4 应用I/O接口</h3><ol type="1"><li>I/O系统调用：实现统一的I/O接口</li><li>I/O系统调用将设备行为封装在泛型类中，如块设备I/O系统调用包括磁盘、磁带、光盘等一系列块设备的read、write、seek。</li><li>设备驱动程序(Device-driver)层从内核隐藏I/O控制器之间的差异</li><li>设备在许多方面都有所不同<ol type="1"><li>Character-stream or block 字符流或者块设备</li><li>Sequential or random-access 顺序或随机访问设备</li><li>Synchronous or aSynchronous 同步或异步</li><li>Sharable or dedicated 共享或独占设备</li><li>Speed of operation 操作速度（快速、中速、慢速）</li><li>read-write, read only, or write only 读写、只读、只写设备</li></ol></li></ol><blockquote><ol type="1"><li>大多数操作系统存在后门，允许应用程序将任何命令透明的传给设备控制器</li><li>对UNIX，这个系统调用是ioctl（）<ol type="1"><li>系统调用ioctl能使应用程序访问由设备驱动程序实现的一切功能</li><li>Ioctl有三个参数<ol type="1"><li>第一个文件描述符，引用某一个硬件设备</li><li>第二个是整数，来确定哪个命令</li><li>第三个是内存中的指针，使得应用程序和控制器传输任何必要的命令信息或数据</li></ol></li></ol></li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20221226151634158.png" alt="image-20221226151634158" style="zoom:80%;" /></p><h3 id="block-and-character-devices-块和字符设备">13.4.1 Block andCharacter Devices 块和字符设备</h3><blockquote><p>read，write，seek描述了块存储设备的基本特点，这样应用程序就不必关注这些设备的底层差别。</p><p>原始I/O或直接I/O文件操作模式</p><ol type="1"><li>原始I/O：将块设备当做一个简单的线性块数组来访问</li><li>直接I/O：文件采用禁止缓存和锁的文件操作模式</li></ol><p>内存映射文件访问是建立在块设备驱动程序之上的。内存映射接口不是提供read和write操作，而是提供通过内存中的字节数组来访问磁盘存储。</p><p>应用程序可以get或put一个字符。在此基础上，可以构造库以提供具有缓冲和编辑功能的按行访问。</p><p>这种访问方式也有助于输出设备，例如打印机、声卡，这些设备适合于线性字节流</p></blockquote><ol type="1"><li>Block devices（块设备） include disk drives<ol type="1"><li>Commands include read, write, seek</li><li>Raw I/O or file-system access</li><li>Memory-mapped file access possible</li></ol></li><li>Character devices （字符设备） include keyboards, mice, serial ports<ol type="1"><li>Commands include get(), put()</li><li>Libraries layered on top allow line editing</li></ol></li></ol><h3 id="network-devices-网络设备">13.4.2 Network Devices 网络设备</h3><ol type="1"><li>网络I/O的性能与访问特点与磁盘I/O相比有很大差别，绝大多数操作系统所提供的网络I/O接口也不同于磁盘的read-write-seek接口</li><li>许多OS所提供的是网络套接字接口<ol type="1"><li>套接字接口还提供了select函数，以管理一组套接字</li><li>调用select可以得知哪个套接字已有接收数据需要处理，哪个套接字已有空间可以接收数据以便发送</li></ol></li></ol><h3 id="clocks-and-timers-时钟和定时器">13.4.3 Clocks and Timers时钟和定时器</h3><ol type="1"><li>提供以下三个基本函数<ol type="1"><li>获取当前时间</li><li>获取已经逝去的时间</li><li>设置定时器以在T时触发操作X</li></ol></li><li>测量逝去时间和触发器操作的硬件称为可编程间隔定时器（programmableinterval timer）<ol type="1"><li>可被设置为等待一定的时间，然后触发中断</li><li>也可设置成做一次或重复多次以产生定时中断</li></ol></li></ol><h3 id="blocking-and-nonblocking-io-阻塞和非阻塞io">13.4.4 Blocking andNonblocking I/O 阻塞和非阻塞I/O</h3><ol type="1"><li>Blocking：进程挂起直到I/O完成为止<ol type="1"><li>很容易使用和理解</li><li>对某些需求是低效的</li></ol></li><li>Nonblocking：I/O调用立刻返回<ol type="1"><li>用户界面</li><li>通过多进程实现</li><li>返回读/写了多少个字节</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221226153141627.png" alt="image-20221226153141627" style="zoom:67%;" /></p><h3 id="asynchronous-异步">13.4.5 Asynchronous 异步</h3><ol type="1"><li>Asynchronous(异步)：进程与I/O同时运行<ol type="1"><li>难以使用</li><li>当I/O完成时，I/O子系统会提醒进程</li></ol></li><li>非阻塞与异步系统调用的<strong>差别</strong>:<ol type="1"><li><strong>非阻塞read调用会马上返回</strong>，其所读取的数据可以等于或少于所要求的，或为零</li><li><strong>异步read调用所要求的传输应完整地执行，其具体执行可以是将来某个特定时间</strong></li></ol></li></ol><h2 id="内核io子系统">13.5 内核I/O子系统</h2><ol type="1"><li>内核与I/O有关服务：<ol type="1"><li>I/O scheduling：I/O调度</li><li>buffering：缓存</li><li>caching：高速缓存</li><li>spooling：假脱机</li><li>device reservation：设备预定</li><li>error handling：错误处理</li></ol></li><li>内核I/O子系统负责：<ol type="1"><li>文件和设备命名空间的管理</li><li>文件和设备访问控制</li><li>操作控制（for example, a modem cannot seek()）</li><li>文件系统空间的分配</li><li>设备分配</li><li>缓冲、高速缓存、假脱机</li><li>I/O调度</li><li>设备状态监控、错误处理、失败恢复</li><li>设备驱动程序的配置和初始化</li></ol></li></ol><h3 id="io调度">13.5.1 I/O调度</h3><ol type="1"><li>I/O调度：调度一组I/O请求就是确定一个好的顺序来执行这些请求<ol type="1"><li>某些I/O需要按设备队列的顺序：先来先服务</li><li>某些操作系统尝试着公平：优先级高者优先</li><li>磁盘I/O调度</li></ol></li><li>实现<ol type="1"><li>OS通过为每个设备维护一个请求队列来实现调度。</li><li>可以试图公平，也可以根据不同的优先级进行I/O调度。</li><li>其他方法：缓冲、高速缓冲、假脱机</li></ol></li></ol><h3 id="缓冲buffer">13.5.2 缓冲buffer</h3><blockquote><p><strong>拷贝语义</strong>：</p><ol type="1"><li>某应用程序需要将缓冲区内的数据写入磁盘，它可以调用write()系统调用</li><li>当系统调用返回时，如果应用程序改变了缓冲区的内容，根据拷贝语义，操作系统保证要写入磁盘的数据就是write()系统调用发生时的版本</li><li>一个简单方法就是操作系统在write()系统调用返回前，将应用程序缓冲区复制到内核缓冲区中</li></ol></blockquote><ol type="1"><li><strong>缓冲Buffering</strong>：用来保存在两设备之间或在设备和应用程序之间所传输数据的内存区域。</li><li>缓冲作用：<ol type="1"><li>解决设备速度不匹配</li><li>解决设备传输块的大小不匹配</li><li>为了维持<strong>拷贝语义“copy semantics”</strong>要求</li></ol></li><li>缓冲区管理：为了解决<strong>CPU与I/O之间速度不匹配的矛盾</strong>，在它们之间配置了缓冲区。这样设备管理程序又要负责管理缓冲区的建立、分配和释放。</li><li>单缓冲、双缓冲、多缓冲、缓冲池</li></ol><h3 id="高速缓冲cacheing">13.5.3 高速缓冲cacheing</h3><ol type="1"><li><p><strong>高速缓存 Caching </strong>：fast memory holding copy ofdata</p><ol type="1"><li><p>缓冲与高速缓存的差别是缓冲只是保留数据仅有的一个现存拷贝，而高速缓存只是提供了一个驻留在其他地方的数据的一个高速拷贝</p></li><li><p>高速缓存和缓冲是两个不同的功能，但有时一块内存区域也可以同时用于两个目的</p></li><li><p>当内核接收到I/O请求时，内核首先检查高速缓存以确定相应文件的内容是否在内存中。如果是，物理磁盘I/O就可以避免或延迟</p></li></ol></li></ol><h3 id="假脱机技术-spooling">13.5.4 假脱机技术 SPOOLing</h3><ol type="1"><li><strong>SPOOLing</strong>（Simultaneous Peripheral Operation OnLine）称为<strong>假脱机</strong>技术：<ol type="1"><li>用来保存设备输出的缓冲，这些设备如打印机不能接收交叉的数据流</li><li>操作系统通过截取对打印机的输出来解决这一问题。应用程序的输出先是假脱机到一个独立的磁盘文件上。当其它应用程序完成打印时，假脱机系统将相应的待送打印机的假脱机文件进行排队</li></ol></li><li>Printing：打印机虽然是独享设备，通过SPOOLing技术，可以将它改造为一台可供多个用户共享的设备</li></ol><h3 id="设备预定-device-reservation">13.5.5 设备预定 Devicereservation</h3><ol type="1"><li><strong>设备预定 Device reservation</strong><ol type="1"><li>提供对设备的独占访问</li><li>分配和再分配的系统调用</li><li>有可能产生死锁</li></ol></li></ol><h3 id="错误处理-error-handling">13.5.6 错误处理 Error Handling</h3><ol type="1"><li><strong>错误处理 Error Handling</strong><ol type="1"><li>操作系统可以恢复磁盘读，设备无效，暂时的失败</li><li>当I/O失败时，大多数返回一个错误码</li><li>系统日志记录了出错报告</li></ol></li></ol><h3 id="io保护">13.5.7 I/O保护</h3><ol type="1"><li>用户进程可能通过非法的I/O指令，来恶意打破一些正常操作<ol type="1"><li>所有I/O指令被特权化</li><li>I/O必须通过系统调用</li><li>内存映射和I/O端口内存位置也必须受到保护</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221229162906570.png" alt="image-20221229162906570" style="zoom:67%;" /></p><h3 id="内核数据结构">13.5.8 内核数据结构</h3><ol type="1"><li>内核需要保存I/O组件使用的<strong>状态信息</strong>，包括打开文件表，网络连接，字符设备状态等</li><li>许多复杂的数据结构用来跟踪缓冲，内存分配，及“脏”块</li><li>某些OS用面向对象的方法和消息传递的方法来实现I/O</li></ol><p><img src="/images/AssetMarkdown/image-20221229163949586.png" alt="image-20221229163949586" style="zoom:80%;" /></p><h2 id="io-requests-to-hardware-operations">13.6 I/O Requests toHardware Operations</h2><p>进程从磁盘中读取一个文件：</p><ol type="1"><li>确定保存文件的设备</li><li>转换名字到设备的表示法</li><li>把数据从磁盘读到缓冲区中</li><li>通知请求进程数据现在是有效的</li><li>把控制权返回给进程</li></ol><blockquote><p>一次I/O请求的生命周期</p><p><img src="/images/AssetMarkdown/image-20221229164104537.png" alt="image-20221229164104537" style="zoom:80%;" /></p></blockquote><h2 id="streams">13.7 STREAMS</h2><ol type="1"><li>STREAMS：Unix SystemV及更高版本中用户级进程与设备之间的全双工通信信道</li><li>流包括：<ol type="1"><li>STREAM头与用户进程接口</li><li>驱动端与设备接口——它们之间没有或多个STREAM模块。</li></ol></li><li>每个模块包含一个读队列和一个写队列</li><li>消息传递用于队列之间的通信</li></ol><p><img src="/images/AssetMarkdown/image-20221229164309121.png" alt="image-20221229164309121" style="zoom:67%;" /></p><h2 id="性能">13.8 性能</h2><ol type="1"><li>I/O是系统性能的一个主要因素：<ol type="1"><li>要求CPU执行设备驱动程序、内核I/O代码</li><li>中断导致的上下文切换</li><li>数据复制</li><li>网络流量尤其紧张</li></ol></li><li>提高性能的方法：<ol type="1"><li>减少上下文开关的数量</li><li>减少数据拷贝</li><li>通过使用大型传输、智能控制器和轮询减少中断</li><li>使用DMA</li><li>平衡CPU、内存、总线和I/O性能，实现最高吞吐量</li></ol></li></ol><blockquote><p>计算机之间的通信</p><p><img src="/images/AssetMarkdown/image-20221229164358578.png" alt="image-20221229164358578" style="zoom:80%;" /></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用指令</title>
      <link href="/2023/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>在<code>Blog</code>目录下，执行下列命令，更新网页，并推送到远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy &amp;&amp; hexo server</span><br></pre></td></tr></table></figure><p>本地查看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>推送到远端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>在<code>_posts</code>中新建页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;GAMES101&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104</title>
      <link href="/2023/04/01/GAMES104/"/>
      <url>/2023/04/01/GAMES104/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1id="二引擎架构分层与整体pipeline">二、引擎架构分层与整体pipeline</h1><h2 id="游戏引擎分层简介-51">2.1 游戏引擎分层简介 5+1</h2><ol type="1"><li>工具层<strong>Tool Layer</strong>：各种编辑器</li><li>功能层<strong>FunctionLayer</strong>：让游戏Visible(渲染)、Movable(物理系统)、Playable(状态机&amp;人机交互)</li><li>资源层<strong>ResourceLayer</strong>：各种数据文件，如图形、几何、声音、视频、场景等等</li><li>核心层<strong>CoreLayer</strong>：引擎的工具箱，如内存管理、容器分配、数学运算等等</li><li>平台层<strong>Platform Layer</strong>：隐藏不同平台的不同接口</li></ol><p>第三方库文件<strong>3nd PartyLibraries</strong>，与各个层都会有关系</p><h2 id="资源层">2.2 资源层</h2><ol type="1"><li>将各种资源文件，转化成引擎统一的格式，如<strong>.uasset</strong></li><li>这一步会将很多冗余信息清除，将文件的格式转化为GPU可以高效绘制的格式</li><li>还需要生成一些资源文件，用于表示不同资源文件之间的关联</li><li>需要负责管理所有资产的<strong>生命周期</strong>：垃圾回收GC、延迟加载</li></ol><h2 id="功能层">2.3 功能层</h2><ol type="1"><li>每经过一个<strong>Tick</strong>，会将整个游戏的逻辑和渲染运行一遍</li><li><strong>tick</strong>会分为两个步骤：<strong>tickLogic()</strong>=&gt; <strong>tickRender()</strong><ol type="1"><li><strong>tickLogic()</strong>：对世界的模拟，如输入输出、物理系统、碰撞检测</li><li><strong>tickRender()</strong>：对世界的渲染</li></ol></li><li>功能层是整个引擎中最多的部分，会跟具体游戏有关联</li><li>功能层的某些模块既可以当作是引擎的模块，也可以当作是游戏的模块，如：相机的移动</li></ol><p><img src="/images/AssetMarkdown/image-20230425210150246.png" alt="image-20230425210150246" style="zoom:80%;" /></p><p>多线程计算：</p><p><img src="/images/AssetMarkdown/image-20230425210452719.png" alt="image-20230425210452719" style="zoom:80%;" /></p><h2 id="核心层">2.4 核心层</h2><ol type="1"><li>数学库：<ol type="1"><li>为了提高效率，因此会在核心层中，重写数学库</li><li>如用SIMD实现矩阵乘法</li></ol></li><li>数据结构和容器：<ol type="1"><li>也是为了提高效率，因此会在核心层中，重写数据结构，而不是直接使用STL容器</li></ol></li><li>内存管理<ol type="1"><li>游戏引擎会提前申请一大块内存，由引擎管理</li><li>三个原则：尽可能将数据放到一起、按顺序访问数据、一次申请/释放一整块数据</li></ol></li><li>一般来说，核心层的代码质量最高，轻易不会修改</li></ol><h2 id="平台层">2.5 平台层</h2><ol type="1"><li><p>掩盖掉不同平台之间的差异</p><ol type="1"><li><p>文件的路径</p></li><li><p>图形学API：用Render Hardware Interface(RHI)隐藏起来</p><p><img src="/images/AssetMarkdown/image-20230425211749281.png" alt="image-20230425211749281" style="zoom:80%;" /></p></li><li><p>硬件架构</p></li></ol></li><li><p>平台层的好坏影响了游戏在不同平台上的性能优劣</p></li></ol><h2 id="工具层">2.6 工具层</h2><p>允许所有人用引擎创建游戏</p><ol type="1"><li>保证工具层展示的结果和最终游戏的结果是一样的</li><li>以开发效率为优先，而不是以运行效率为优先</li></ol><p>DCC：Digital Content Creation</p><ol type="1"><li>将其他工具产生的数字资产，转化为引擎统一的数字资产</li></ol><h2 id="为什么要分层架构">2.7 为什么要分层架构</h2><ol type="1"><li>降低问题的复杂度，让每一层只需要考虑自己的任务<ol type="1"><li>越底层的东西越不会轻易改变</li><li>越往上，越灵活；越往下，越稳定</li></ol></li><li>要先将问题划分为不同层次的任务，然后再进行开发</li><li>只允许上层调用下层，下层不能调用上层</li></ol><h1 id="三如何构建游戏世界">三、如何构建游戏世界</h1><h1 id="十八网络游戏的架构基础">十八、网络游戏的架构基础</h1><h2 id="同步算法">18.1 同步算法</h2><h3 id="快照同步snapshot">18.1.1 快照同步Snapshot</h3><blockquote><p>如Quake</p></blockquote><ol type="1"><li>步骤：<ol type="1"><li>客户端：把<strong>输入</strong>发送给服务器</li><li>服务器：将所有客户的输入集合起来，在服务器中进行<strong>游戏世界的模拟</strong>，然后将<strong>游戏世界的状态</strong>生成<strong>快照</strong>返回给客户端</li><li>客户端：拿到服务器给的快照后，将所有对象设置为对应的状态，然后进行<strong>渲染</strong></li></ol></li><li>优点：<ol type="1"><li>结构清晰，保证了绝<strong>对的一致性</strong>，无法作弊</li><li>不用担心同步的问题</li><li>客户端只负责输入和最后的渲染</li><li>当客户端非常多时，服务器的计算量是最低的，因为只需要对世界模拟一次即可</li></ol></li><li>针对实际情况的改进：<ol type="1"><li>服务器端的帧率通常会很低，需要客户端进行插值</li><li>快照可能包含非常多的信息，但是相邻两帧通常差距不大，因此可以只传delta，从而降低信息量</li></ol></li><li>缺点：<ol type="1"><li>浪费了客户端的算力</li><li>服务器生成快照传递给每一个客户端，会占用非常大的服务器处的上行带宽</li></ol></li></ol><h3 id="帧同步lockstep">18.1.2 帧同步Lockstep</h3><blockquote><p>如DOOM、王者荣耀</p></blockquote><ol type="1"><li>步骤：<ol type="1"><li>每一帧：客户端把输入统一交给服务器</li><li>服务器等待所有服务器提交输入，然后把所有输入分发给客户端</li><li>客户端得到服务器的指令，做一致的游戏逻辑模拟，得到的结果一定相同</li><li>要求所有客户端进行初始化，初始条件必须相同</li></ol></li><li>针对实际情况的改进：<ol type="1"><li>如果有一个客户端发送输入总是很慢，就需要其他客户端等待它<ol type="1"><li><strong>BucketSynchronization</strong>：每隔固定的时间收集一次信息，服务器没收到的就当没发生</li></ol></li></ol></li><li>缺点：<ol type="1"><li>一样的输入，得到的结果<strong>不一定</strong>相同，因为会有随机数、浮点数等<strong>不确定</strong>的因素<ol type="1"><li>浮点数：要求满足IEE754标准</li><li>随机数：要求随机数种子、随机数算法严格相同</li></ol></li></ol></li></ol><h3 id="状态同步state-synchornization">18.1.3 状态同步StateSynchornization</h3><blockquote><p>如CS</p></blockquote><ol type="1"><li>步骤：<ol type="1"><li>客户端：Authorized将命令发送给服务器(如向某个方向发射一个炮弹)</li><li>服务器：接收客户端的命令，模拟操作(如打中某个对象)，然后将改变的状态广播给所有客户端</li><li>客户端：接收服务器的对场景状态的改变，模拟出整个世界</li></ol></li><li>针对实际情况的改进：<ol type="1"><li>客户端发送指令，服务器接受指令并确返回结果，会存在延迟<ol type="1"><li><strong>Client-sideprediction</strong>：客户端要进行预测操作，即先将客户的指令执行，然后再和服务器对齐<ol type="1"><li>守望先锋：预测半个RTT+一个命令帧时间</li></ol></li><li><strong>ServerReconciliation</strong>：预测与服务器的返回不一致时，客户端要与服务器对齐<ol type="1"><li>平滑的差值对齐</li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES系列课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101</title>
      <link href="/2023/02/26/GAMES101/"/>
      <url>/2023/02/26/GAMES101/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第00课-vs环境配置">第00课 VS环境配置</h1><p><strong>库文件的安装</strong></p><p><ahref="https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.zip"><strong>Eigen库下载</strong></a>：解压路径如下</p><blockquote><p><code>D:\Program\Library\eigen-3.4.0</code></p></blockquote><p><strong>opencv库下载</strong>：解压路径如下</p><blockquote><p><code>D:\Program\Library\opencv</code></p></blockquote><p><strong>将opencv添加到环境变量中</strong></p><p>在<strong>Path</strong>中添加：</p><blockquote><p><code>D:\Program\Library\opencv\opencv\build\x64\vc14\bin</code></p><p><code>D:\Program\Library\opencv\opencv\build\x64\vc15\bin</code></p></blockquote><p><img src="/images/AssetMarkdown/image-20230226182328400.png" alt="image-20230226182328400" style="zoom:80%;" /></p><p><strong>修改VS的项目设置</strong></p><ol type="1"><li><p>【VC++目录】</p><ol type="1"><li><p>【包含目录】：添加如下项</p><blockquote><p><code>D:\Program\Library\eigen-3.4.0\Eigen</code></p><p><code>D:\Program\Library\opencv\opencv\build\include</code></p></blockquote></li><li><p>【库目录】：添加如下项</p><blockquote><p><code>D:\Program\Library\opencv\opencv\build\x64\vc14\lib</code></p></blockquote></li></ol></li><li><p>【C/C++】【常规】【附加包含目录】：添加如下项</p><blockquote><p><code>D:\Program\Library\opencv\opencv\build\include</code></p></blockquote></li><li><p>【链接器】【输入】【附加依赖项】：添加如下项</p><ol type="1"><li>带d的为Debug环境，不带d的为Release环境</li></ol><blockquote><p><code>opencv_world460d.lib</code></p></blockquote></li><li><p>将所有代码中，有关Eigen库的引用，修改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>【配置属性】【调试】【命令参数】中，可以输入传递给main函数的参数</p><ol type="1"><li>如作业3中，需要输入的是<code>./Rasterizer output.png phong</code></li><li>那么我们就可以在此输入<code>output.png phong</code></li></ol><p><img src="/images/AssetMarkdown/2ccaa721e75c48ebb38a0a55662c518d.png" alt="img" style="zoom:80%;" /></p></li></ol><p><strong>VirtualBox挂载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t vboxsf Share share_dir</span><br></pre></td></tr></table></figure><h1 id="第01课-计算机图形学概览">第01课 计算机图形学概览</h1><ol type="1"><li><p><strong>光栅化</strong>：将三维空间的几何形体显示在屏幕上</p></li><li><p><strong>实时</strong>：每秒钟能够生成30幅画面/30帧/30fps；否则称为离线</p></li><li><p><strong>计算机图形学</strong> 与 <strong>计算机视觉</strong>的区别：</p><p><img src="/images/AssetMarkdown/image-20230223153108705.png" alt="image-20230223153108705" style="zoom:80%;" /></p></li></ol><h1 id="第02课-线性代数复习">第02课 线性代数复习</h1><h2 id="向量点乘">2.1 向量点乘</h2><p><img src="/images/AssetMarkdown/image-20230223163818522.png" alt="image-20230223163818522" style="zoom:80%;" /></p><h3 id="定义">2.1.1 定义</h3><p><span class="math display">\[\begin{aligned}\vec{a}·\vec{b}&amp;=||\vec{a}||*||\vec{b}||*\cos\theta \\               &amp;=x_a*x_b+y_a*y_b+z_a*z_b\\\end{aligned}\]</span></p><h3 id="性质">2.1.2 性质</h3><ol type="1"><li><spanclass="math inline">\(\vec{a}·\vec{b}=\vec{b}·\vec{a}\)</span></li><li><spanclass="math inline">\(\vec{a}·(\vec{b}+\vec{c})=\vec{a}·\vec{b}+\vec{a}·\vec{c}\)</span></li><li><spanclass="math inline">\((k\vec{a})·\vec{b}=\vec{a}·(k\vec{b})=k(\vec{a}·\vec{b})\)</span></li></ol><h3 id="应用">2.1.3 应用</h3><ol type="1"><li><p>计算夹角：<spanclass="math inline">\(\cos\theta=\frac{\vec{a}·\vec{b}}{||\vec{a}||*||\vec{b}||}\)</span></p><p><img src="/images/AssetMarkdown/image-20220810170049692.png" alt="image-20220810170049692" style="zoom: 67%;" /></p></li><li><p>计算投影：<spanclass="math inline">\(||\vec{b}_⊥||=||\vec{b}||\cos\theta\)</span>，<spanclass="math inline">\(\vec{b}_⊥=(||\vec{b}||\cos\theta)\ \hata\)</span></p><p><img src="/images/AssetMarkdown/image-20220810170106422.png" alt="image-20220810170106422" style="zoom: 67%;" /></p></li><li><p>将<span class="math inline">\(\vec{b}\)</span>在<spanclass="math inline">\(\vec{a}\)</span>方向分解：<spanclass="math inline">\(\vec{b}=\vec{b}_⊥+(\vec{b}-\vec{b}_⊥)\)</span></p><p><img src="/images/AssetMarkdown/image-20220810170343996.png" alt="image-20220810170343996" style="zoom: 67%;" /></p></li><li><p>向量之间的方向</p><ol type="1"><li><span class="math inline">\(\vec{a}\)</span>与<spanclass="math inline">\(\vec{b}\)</span>方向基本一致：<spanclass="math inline">\(\hat{a}·\hat{b} &gt;0\)</span>，越接近1，夹角越接近0°</li><li><span class="math inline">\(\vec{a}\)</span>与<spanclass="math inline">\(\vec{b}\)</span>方向基本相反：<spanclass="math inline">\(\hat{a}·\hat{b} &lt;0\)</span>，越接近-1，夹角越接近180°</li><li><span class="math inline">\(\vec{a}\)</span>与<spanclass="math inline">\(\vec{b}\)</span>垂直：<spanclass="math inline">\(\hat{a}·\hat{b}=0\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20220810170534209.png" alt="image-20220810170534209" style="zoom: 67%;" /></p></li></ol><h2 id="向量叉乘">2.2 向量叉乘</h2><h3 id="定义-1">2.2.1 定义</h3><p><img src="/images/AssetMarkdown/image-20220810171343721.png" alt="image-20220810171343721" style="zoom: 67%;" /></p><p>大小：<spanclass="math inline">\(||\vec{a}×\vec{b}||=||\vec{a}||*||\vec{b}||*\sin\theta\)</span></p><p>方向：右手螺旋定则，四指方向为<spanclass="math inline">\(\vec{a}\)</span>旋转到<spanclass="math inline">\(\vec{b}\)</span>，拇指方向为<spanclass="math inline">\(\vec{a}×\vec{b}\)</span>的方向</p><p><img src="/images/AssetMarkdown/image-20220810172156875.png" alt="image-20220810172156875" style="zoom: 67%;" /></p><h3 id="性质-1">2.2.2 性质</h3><p>性质：<spanclass="math inline">\(\vec{a}×\vec{b}=-\vec{b}×\vec{a}\)</span>，可以用于建立空间直角坐标系：</p><ol type="1"><li>右手坐标系：<spanclass="math inline">\(\vec{x}×\vec{y}=\vec{z}\)</span></li><li>左手坐标系：<spanclass="math inline">\(\vec{x}×\vec{y}=-\vec{z}\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20220810171901046.png" alt="image-20220810171901046" style="zoom: 67%;" /></p><h3 id="应用-1">2.2.3 应用</h3><ol type="1"><li><p>判断左右：假设<spanclass="math inline">\(\vec{a}、\vec{b}\)</span>均在XY平面上</p><ol type="1"><li><span class="math inline">\(\vec{b}\)</span>在<spanclass="math inline">\(\vec{a}\)</span>的左侧：<spanclass="math inline">\(Z_{\vec{a}×\vec{b}}&gt;0\)</span></li><li><span class="math inline">\(\vec{b}\)</span>在<spanclass="math inline">\(\vec{a}\)</span>的右侧：<spanclass="math inline">\(Z_{\vec{a}×\vec{b}}&lt;0\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20220810172421848.png" alt="image-20220810172421848" style="zoom: 67%;" /></p></li><li><p>判断内外：假设ABCP四点共面</p><ol type="1"><li>P在▲ABC的内部：若ABC逆时针排列，则都在左面；若ABC顺时针排列，则都在右面<ol type="1"><li><span class="math inline">\(\vec{AP}\)</span>在<spanclass="math inline">\(\vec{AB}\)</span>的左面</li><li><span class="math inline">\(\vec{BP}\)</span>在<spanclass="math inline">\(\vec{BC}\)</span>的左面</li><li><span class="math inline">\(\vec{CP}\)</span>在<spanclass="math inline">\(\vec{CA}\)</span>的左面</li></ol></li><li>P在▲ABC的外部：上述三个条件有一个不符合</li></ol><p><img src="/images/AssetMarkdown/image-20220810172608646.png" alt="image-20220810172608646" style="zoom: 67%;" /></p></li></ol><h2 id="正交基坐标系">2.3 正交基/坐标系</h2><p>正交基：Orthonormal Bases</p><p>坐标系：Coordinate Frames</p><h3 id="定义-2">2.3.1 定义</h3><ol type="1"><li><spanclass="math inline">\(\vec{u}、\vec{v}、\vec{w}\)</span>均为单位向量</li><li><spanclass="math inline">\(\vec{u}、\vec{v}、\vec{w}\)</span>两两垂直</li><li><span class="math inline">\(\vec{w}=\vec{u}×\vec{v}\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20220810173601736.png" alt="image-20220810173601736" style="zoom: 67%;" /></p><h2 id="矩阵">2.4 矩阵</h2><h3 id="矩阵乘法">2.4.1 矩阵乘法</h3><ol type="1"><li>定义：设<spanclass="math inline">\(A[m][n]*B[n][p]=C[m][p]\)</span>，则<spanclass="math inline">\(C[i][j]=\sum_{k=1}^nA[i][k]*B[k][j]=\{A的第i行\}·\{B的第j列\}\)</span></li><li>性质：<ol type="1"><li>没有交换律</li><li>有结合律：<span class="math inline">\((AB)C=A(BC)\)</span></li><li>有分配律：<span class="math inline">\(A(B+C)=AB+AC\)</span>，<spanclass="math inline">\((A+B)C=AC+BC\)</span></li></ol></li></ol><h3 id="矩阵转置">2.4.2 矩阵转置</h3><ol type="1"><li><p>定义：将行列互换</p><p><img src="/images/AssetMarkdown/image-20220812181413411.png" alt="image-20220812181413411" style="zoom: 67%;" /></p></li><li><p>性质：<span class="math inline">\((AB)^T=B^TA^T\)</span></p></li></ol><h3 id="单位矩阵矩阵的逆">2.4.3 单位矩阵&amp;矩阵的逆</h3><ol type="1"><li><p>单位矩阵：</p><p><img src="/images/AssetMarkdown/image-20220812181521742.png" alt="image-20220812181521742" style="zoom:67%;" /></p></li><li><p>逆矩阵的定义：<spanclass="math inline">\(AA^{-1}=A^{-1}A=I\)</span></p></li><li><p>逆矩阵的性质：<spanclass="math inline">\((AB)^{-1}=B^{-1}A^{-1}\)</span></p></li></ol><h3 id="矩阵向量点乘叉乘">2.4.4 矩阵&amp;向量点乘/叉乘</h3><ol type="1"><li><p>向量的对偶矩阵：</p><p><img src="/images/AssetMarkdown/image-20230223174941145.png" alt="image-20230223174941145" style="zoom:80%;" /></p></li><li><p>矩阵&amp;向量点乘/叉乘：</p><p><img src="/images/AssetMarkdown/image-20230223175008749.png" alt="image-20230223175008749" style="zoom:80%;" /></p></li></ol><h1 id="第03课-变换12维变换">第03课 变换1：2维变换</h1><p>变换：</p><ol type="1"><li>Modeling：模型变换，物体在3D空间中的运动</li><li>Viewing：视图变换，3D到2D的投影</li></ol><h2 id="d-transform">3.1 2D Transform</h2><h3 id="scale缩放变换">3.1.1 Scale缩放变换</h3><p><img src="/images/AssetMarkdown/image-20220811125108799.png" alt="image-20220811125108799" style="zoom:80%;" /></p><h3 id="reflectin翻转">3.1.2 Reflectin翻转</h3><p><img src="/images/AssetMarkdown/image-20220811125051816.png" alt="image-20220811125051816" style="zoom:80%;" /></p><h3 id="shear切变">3.1.3 Shear切变</h3><p><img src="/images/AssetMarkdown/image-20220811125253629.png" alt="image-20220811125253629" style="zoom:80%;" /></p><h3 id="rotate旋转默认-绕原点-逆时针-旋转">3.1.4 Rotate旋转(默认 绕原点逆时针 旋转)</h3><p><img src="/images/AssetMarkdown/image-20220811125758262.png" alt="image-20220811125758262" style="zoom:80%;" /></p><h3 id="linear-transform线性变换矩阵">3.1.5 LinearTransform线性变换=矩阵</h3><p><img src="/images/AssetMarkdown/image-20220811130400053.png" alt="image-20220811130400053" style="zoom:80%;" /></p><h2 id="homogeneous-coordinates齐次坐标">3.2 Homogeneouscoordinates齐次坐标</h2><h3 id="translation平移变换notin线性变换">3.2.1 Translation平移变换<spanclass="math inline">\(\notin\)</span>线性变换</h3><p><img src="/images/AssetMarkdown/image-20220811130553973.png" alt="image-20220811130553973" style="zoom:80%;" /></p><p>矩阵表示：</p><p><img src="/images/AssetMarkdown/image-20220811130633298.png" alt="image-20220811130633298" style="zoom:80%;" /></p><h3 id="齐次坐标">3.2.2 齐次坐标</h3><p>添加一个维度</p><ol type="1"><li>2维点：<span class="math inline">\((x,y,1)^T\)</span></li><li>2维点的补充形式：<spanclass="math inline">\((x,y,w)^T\)</span>与<spanclass="math inline">\((\frac{x}{w},\frac{y}{w},1)^T\)</span>等价</li><li>2维向量：<span class="math inline">\((x,y,0)^T\)</span></li></ol><p>对于两者第3个坐标的解释：</p><ol type="1"><li>点的第三维为0，向量的第三维为1，可以满足向量的平移不变性</li><li>且可以满足以下性质<ol type="1"><li>vector + vector = vector</li><li>point - point = vector</li><li>point + vector = point</li><li>point + point = 两个point的中点</li></ol></li></ol><h3 id="affine-transformation仿射变换-线性变换-平移变换">3.2.3 AffineTransformation仿射变换 = 线性变换 + 平移变换</h3><p><img src="/images/AssetMarkdown/image-20220811131633578.png" alt="image-20220811131633578" style="zoom:80%;" /></p><h3 id="d-transformation">3.2.4 2D Transformation</h3><p><img src="/images/AssetMarkdown/image-20220811131725685.png" alt="image-20220811131725685" style="zoom:80%;" /></p><h3 id="inverse-transform逆变换">3.2.5 Inverse Transform逆变换</h3><p>逆变换 &lt;==&gt; 乘变换矩阵的逆矩阵</p><p><img src="/images/AssetMarkdown/image-20220811155155659.png" alt="image-20220811155155659" style="zoom:80%;" /></p><h2 id="composing-transforms变换的组合">3.3 ComposingTransforms变换的组合</h2><h3 id="举例">3.3.1 举例</h3><ol type="1"><li>复杂变换可以有简单变换组合而成</li><li>简单变换的顺序是很有必要的 &lt;==&gt; 矩阵乘法不满足交换律</li></ol><p>变换的目标：</p><p><img src="/images/AssetMarkdown/image-20220811155307566.png" alt="image-20220811155307566" style="zoom:80%;" /></p><p>变换的方法：先平移后旋转 or 先旋转后平移</p><p><img src="/images/AssetMarkdown/image-20220811155434542.png" alt="image-20220811155434542" style="zoom:80%;" /></p><p>矩阵表示：<strong>从右到左</strong>进行矩阵乘法，顺序为：<strong>缩放=&gt; 旋转 =&gt; 平移</strong></p><p><img src="/images/AssetMarkdown/image-20220811155453930.png" alt="image-20220811155453930" style="zoom:80%;" /></p><h3 id="多个变换">3.3.2 多个变换</h3><p>假设有一系列仿射变换<spanclass="math inline">\(A_1,A_2,A_3...\)</span></p><ol type="1"><li><p>可以用矩阵乘法表示：</p><p><img src="/images/AssetMarkdown/image-20220811155912416.png" alt="image-20220811155912416" style="zoom:80%;" /></p></li><li><p>可以先计算<spanclass="math inline">\(A_n...A_2·A_1\)</span>，再与列向量相乘</p><ol type="1"><li>一个3*3的矩阵可以表示任意的变换</li></ol></li></ol><h3 id="变换的分解">3.3.3 变换的分解</h3><p>以C点为中心进行旋转<spanclass="math inline">\(\alpha\)</span>度：<spanclass="math inline">\(T(\vec{c})·R(\alpha)·T(\vec{-c})\)</span></p><ol type="1"><li>先将图形按照<spanclass="math inline">\(\vec{-c}\)</span>的方向进行平移：<spanclass="math inline">\(T(\vec{-c})\)</span></li><li>然后绕原点旋转<span class="math inline">\(\alpha\)</span>度：<spanclass="math inline">\(R(\alpha)\)</span></li><li>然后将图形按照<spanclass="math inline">\(\vec{c}\)</span>的方向进行平移：<spanclass="math inline">\(T(\vec{c})\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20220811160035313.png" alt="image-20220811160035313" style="zoom:80%;" /></p><h1 id="第04课-变换2三维变换">第04课 变换2：三维变换</h1><h2 id="有关旋转的补充">4.0 有关旋转的补充</h2><strong>旋转矩阵的逆 == 旋转矩阵的转置</strong> ==&gt;<strong>旋转矩阵为正交矩阵</strong> $$ R_{}= (<span class="math display">\[\begin{matrix}\cos\theta &amp; -\sin\theta \\\sin\theta &amp; \cos\theta\end{matrix}\]</span><p>) \</p>R_{-}= (<span class="math display">\[\begin{matrix}\cos\theta &amp; \sin\theta \\-\sin\theta &amp; \cos\theta\end{matrix}\]</span><p>) =R_{}^T \</p><p>R_{-}=R_^{-1} $$</p><p>正交矩阵：<span class="math inline">\(R^T=R^{-1}\)</span></p><h2 id="d-transformations">4.1 3D Transformations</h2><h3 id="齐次坐标-1">4.4.1 齐次坐标</h3><ol type="1"><li>3维点：<span class="math inline">\((x,y,z,1)^T\)</span></li><li>3维点的补充形式：<spanclass="math inline">\((x,y,z,w)^T\)</span>与<spanclass="math inline">\((\frac{x}{w},\frac{y}{w},\frac{z}{w},1)^T\)</span>等价</li><li>3维向量：<span class="math inline">\((x,y,z,0)^T\)</span></li></ol><h3 id="仿射变换">4.4.2 仿射变换</h3><blockquote><p><strong>Affine Transform</strong>：</p></blockquote><ol type="1"><li>变换的顺序：先<strong>线性变换</strong>，后加<strong>平移</strong>量</li></ol><p><img src="/images/AssetMarkdown/image-20220812113815122.png" alt="image-20220812113815122" style="zoom:80%;" /></p><h4 id="缩放">4.4.2.1 缩放</h4><p><img src="/images/AssetMarkdown/image-20220812113919856.png" alt="image-20220812113919856" style="zoom:80%;" /></p><h4 id="平移">4.4.2.2 平移</h4><p><img src="/images/AssetMarkdown/image-20220812113927686.png" alt="image-20220812113927686" style="zoom:80%;" /></p><h4 id="旋转">4.4.2.3 旋转</h4><h5 id="绕坐标轴旋转">4.4.2.3.1 绕坐标轴旋转</h5><ol type="1"><li><p>绕X轴：X不变，YZ旋转</p><p><img src="/images/AssetMarkdown/image-20220812114205936.png" alt="image-20220812114205936" style="zoom:80%;" /></p></li><li><p>绕Y轴：Y不变，ZX旋转</p><p><img src="/images/AssetMarkdown/image-20220812114238231.png" alt="image-20220812114238231" style="zoom:80%;" /></p></li><li><p>绕Z轴：Z不变，XY旋转</p><p><img src="/images/AssetMarkdown/image-20220812114220868.png" alt="image-20220812114220868" style="zoom:80%;" /></p></li></ol><h5 id="绕任意过原点的轴旋转">4.4.2.3.2 绕任意过原点的轴旋转</h5><blockquote><p>有两种形式：欧拉角、四元数</p><ol type="1"><li>四元数：多应用于旋转的插值操作</li></ol></blockquote><ol type="1"><li><p>绕任意轴旋转：分解为<strong>欧拉角</strong></p><ol type="1"><li>将任意轴方向的旋转，分解为绕X、Y、Z轴的旋转：<spanclass="math inline">\(R_{x,y,z}(\alpha,\beta,\gamma)\)</span></li><li><spanclass="math inline">\(\alpha,\beta,\gamma\)</span>也被称为欧拉角</li></ol><p><img src="/images/AssetMarkdown/image-20230226070451531.png" alt="image-20230226070451531" style="zoom: 80%;" /></p></li><li><p><strong>Rodrigues’ Rotation Formula 罗德里格旋转公式</strong></p><ol type="1"><li>向量<strong>v</strong>绕过原点的轴<strong>n</strong>旋转<strong><spanclass="math inline">\(\alpha\)</span></strong>角</li><li>向量<strong>I</strong>为向量<strong>v</strong>方向的单位向量</li></ol><p><img src="/images/AssetMarkdown/image-20230226070549341.png" alt="image-20230226070549341" style="zoom:80%;" /></p></li></ol><blockquote><p>推导思路：</p><ol type="1"><li><p><strong>v</strong>与<strong>n</strong>垂直时，<spanclass="math inline">\(\vec{v&#39;}=\cos\alpha*\vec{v}+\sin\alpha*(\vec{n}×\vec{I})\)</span></p></li><li><p><strong>v</strong>与<strong>n</strong>不垂直时，将<strong>v</strong>分解为垂直于<strong>n</strong>的向量<strong>v<sub>⊥</sub></strong>和平行于<strong>n</strong>的向量<strong>v<sub>∥</sub></strong></p><ol type="1"><li><spanclass="math inline">\(\vec{v_∥&#39;}=\vec{v_∥}=|\vec{v}|*cos&lt;\vec{v},\vec{n}&gt;=\vec{v}·\vec{n}·\vec{n}\)</span></li><li><spanclass="math inline">\(\vec{v_⊥}=\vec{v}-\vec{v_∥}=\vec{v}-\vec{v}·\vec{n}·\vec{n}\)</span></li><li><spanclass="math inline">\(\vec{v_⊥&#39;}=\cos\alpha*\vec{v_⊥}+\sin\alpha*(\vec{n}×\vec{v_⊥})\)</span></li><li>综上可得：<spanclass="math inline">\(\vec{v&#39;}=\vec{v_∥&#39;}+\vec{v_⊥&#39;}=\cos\alpha*\vec{v}+(1-\cos\alpha)*\vec{v}·\vec{n}·\vec{n}+\sin\alpha*(\vec{n}×\vec{v})\)</span></li></ol></li><li><p>矩阵形式：<spanclass="math inline">\(\vec{v&#39;}=\cos\alpha*\vec{v}+(1-\cos\alpha)*\vec{v}·\vec{n}·\vec{n}+\sin\alpha*(\vec{n}×\vec{v})\)</span>$</p><pre><code>                   $=[\cos\alpha*\vec&#123;I&#125;+(1-\cos\alpha)*\vec&#123;n&#125;·\vec&#123;n&#125;^T+\sin\alpha*(\vec&#123;n&#125;×\vec&#123;I&#125;)]·\vec&#123;v&#125;$</code></pre></li></ol></blockquote><h5 id="绕过任意点的任意轴旋转">4.4.2.3.2 绕过任意点的任意轴旋转</h5><p>绕过任意轴<strong>n</strong>旋转<strong><spanclass="math inline">\(\alpha\)</span></strong>角</p><ol type="1"><li>先将轴平移至过原点</li><li>然后旋转</li><li>最后平移回去</li></ol><h2 id="model-view-transformation">4.2 Model &amp; ViewTransformation</h2><h3 id="什么是视图变换">4.2.1 什么是视图变换</h3><ol type="1"><li>与照相类比：<strong>MVP</strong>变换</li></ol><table><colgroup><col style="width: 42%" /><col style="width: 57%" /></colgroup><thead><tr class="header"><th style="text-align: center;">照相</th><th style="text-align: center;">对应变换</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">找一个好的地方、人物排列</td><td style="text-align: center;">模型变换 <strong>model</strong>transformation</td></tr><tr class="even"><td style="text-align: center;">找一个好的角度放置摄像机</td><td style="text-align: center;">视图变换 <strong>view</strong>transformation</td></tr><tr class="odd"><td style="text-align: center;">拍照，三维空间投影到二维平面</td><td style="text-align: center;">投影变换 <strong>projection</strong>transformation</td></tr></tbody></table><h3 id="定义camera">4.2.2 定义Camera</h3><ol type="1"><li>位置<strong>Position</strong>：<spanclass="math inline">\(\vec{e}\)</span></li><li>往哪看<strong>Look-at/gaze direction</strong>：<spanclass="math inline">\(\vec{g}\)</span></li><li>向上方向<strong>Up direction</strong>：<spanclass="math inline">\(\vec{t}\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20220812123220752.png" alt="image-20220812123220752" style="zoom:80%;" /></p><h3 id="关键点相机与物体的相对位置决定看到的图像">4.2.3关键点：相机与物体的相对位置决定看到的图像</h3><ol type="1"><li><p>只要<strong>摄像机</strong>与<strong>物体</strong>的相对位置一样，所看到的图形就是一样的</p><figure><img src="/images/AssetMarkdown/image-20220812123524813.png"alt="image-20220812123524813" /><figcaption aria-hidden="true">image-20220812123524813</figcaption></figure></li><li><p>将摄像机永远放在一个标准的位置</p><ol type="1"><li><strong>Position</strong>：原点</li><li><strong>Up direction</strong>：Y轴</li><li><strong>Look-at direction</strong>：-Z轴</li></ol></li><li><p>当相机变换时，将物体随着相机变换</p></li></ol><h3 id="将相机移动到标准位置">4.2.4 将相机移动到标准位置</h3><ol type="1"><li><p>方法</p><ol type="1"><li>将<spanclass="math inline">\(\vec{e}\)</span>平移到<strong>原点</strong></li><li>旋转 <span class="math inline">\(\vec{g}\)</span>到<strong>-Z</strong>的方向</li><li>旋转 <span class="math inline">\(\vec{t}\)</span>到<strong>Y</strong>的方向</li><li>旋转 <span class="math inline">\(\vec{g}×\vec{t}\)</span>到<strong>X</strong>方向</li></ol></li><li><p>矩阵表示：设<spanclass="math inline">\(M_{view}=R_{view}T_{view}\)</span></p><ol type="1"><li><p>将<span class="math inline">\(\vec{e}\)</span>平移到原点</p><p><img src="/images/AssetMarkdown/image-20220812164249448.png" alt="image-20220812164249448" style="zoom:80%;" /></p></li><li><p>旋转 <span class="math inline">\(\vec{g}\)</span>到<strong>-Z</strong>、 <span class="math inline">\(\vec{t}\)</span>到<strong>Y</strong>、<spanclass="math inline">\(\vec{g}×\vec{t}\)</span>到<strong>X</strong>：考虑逆矩阵</p><p><img src="/images/AssetMarkdown/image-20220812164531901.png" alt="image-20220812164531901" style="zoom:80%;" /></p></li></ol></li></ol><h3 id="总结">4.2.5 总结</h3><ol type="1"><li>将物体与相机一起旋转：<strong>Model Transformation ==&gt; <spanclass="math inline">\(M_{model}\)</span></strong></li><li>将相机变换到标准位置：<strong>View Transformation ==&gt; <spanclass="math inline">\(M_{view}\)</span></strong><ol type="1"><li>Position：原点</li><li>Up direction：Y轴</li><li>Look-at direction：-Z轴</li></ol></li></ol><h2 id="projection-transformation">4.3 Projection Transformation</h2><ol type="1"><li>正交投影 <strong>OrthographicProjection</strong>：不存在近大远小</li><li>透视投影 <strong>PerspectiveProjection</strong>：存在近大远小，平行线不再平行</li></ol><p><img src="/images/AssetMarkdown/image-20220812165450522.png" alt="image-20220812165450522" style="zoom:80%;" /></p><h3 id="正交投影">4.3.1 正交投影</h3><blockquote><p><strong>Orthographic Projection</strong>：</p><ol type="1"><li>思想：直接扔掉物体的Z坐标，然后将其移动到[-1,1]的标准范围内</li></ol></blockquote><ol type="1"><li><p>实际做法：将一个立方体<span class="math inline">\([l, r]×[b,t]×[f, n]\)</span>映射到标准立方体<span class="math inline">\([-1,1]^3\)</span>上</p><ol type="1"><li>首先，通过<strong>平移</strong>操作，将立方体的中心移到原点</li><li>然后，通过<strong>缩放</strong>操作，将立方体缩放为标准立方体</li><li>立方体的定义：X轴<spanclass="math inline">\([l,r]\)</span>；Y轴<spanclass="math inline">\([b,t]\)</span>；Z轴<spanclass="math inline">\([f,n]\)</span></li><li>变换之后，物体一定会有拉伸</li></ol><p><img src="/images/AssetMarkdown/image-20220812170410007.png" alt="image-20220812170410007" style="zoom:80%;" /></p></li><li><p>变换矩阵：先平移到原点，再将<spanclass="math inline">\(x,y,z\)</span>缩放到<spanclass="math inline">\(2\)</span></p><p>$$ M_{ortho}= (</p><span class="math display">\[\begin{matrix}\frac{2}{r-l} &amp; 0              &amp; 0             &amp; 0 \\0              &amp; \frac{2}{t-b} &amp; 0             &amp; 0 \\0              &amp; 0             &amp; \frac{2}{n-f} &amp; 0 \\0              &amp; 0             &amp; 0             &amp; 1 \\\end{matrix}\]</span><p>)</p><p>(</p><span class="math display">\[\begin{matrix}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\]</span><p>)</p><p>= (</p><span class="math display">\[\begin{matrix}\frac{2}{r-l} &amp; 0              &amp; 0             &amp;-\frac{r+l}{r-l} \\0              &amp; \frac{2}{t-b} &amp; 0             &amp;-\frac{t+b}{t-b} \\0              &amp; 0             &amp; \frac{2}{n-f} &amp;-\frac{n+f}{n-f} \\0              &amp; 0             &amp; 0             &amp; 1 \\\end{matrix}\]</span><p>) $$</p></li></ol><h3 id="透视投影">4.3.2 透视投影</h3><blockquote><p><strong>Perspective Projection</strong></p><ol type="1"><li>基础知识：<span class="math inline">\((x,y,z,1)\)</span>与<spanclass="math inline">\((kx,ky,kz,k)\)</span>表示同一个点，因此<spanclass="math inline">\((xz,yz,z^2,z)\)</span>表示的也是这个点</li><li>思想：将透视投影转化为正交投影<spanclass="math inline">\(M_{persp-&gt;ortho}\)</span>，然后再进行正交投影变换<spanclass="math inline">\(M_{ortho}\)</span></li></ol></blockquote><h4 id="如何进行透视投影">4.3.2.1 如何进行透视投影</h4><p><img src="/images/AssetMarkdown/image-20220812171751431.png" alt="image-20220812171751431" style="zoom:80%;" /></p><ol type="1"><li>首先，定义从相机点向外的两个平面<strong>n、f</strong>，<strong>f</strong>平面要比<strong>n</strong>平面大</li><li>此时就相当于<strong>f</strong>平面上的点全部投影到<strong>n</strong>平面上</li><li>透视投影的做法<ol type="1"><li>先将<strong>Frustum</strong>挤成<strong>Cuboid</strong>(<spanclass="math inline">\(n \rightarrow n，f \rightarrowf&#39;\)</span>)，满足如下三个定义：<spanclass="math inline">\(M_{persp-&gt;ortho}\)</span><ol type="1"><li>近平面<span class="math inline">\(n\)</span>永远不变</li><li>远平面<span class="math inline">\(f\)</span>的Z值永远不变</li><li>远平面<span class="math inline">\(f\)</span>的中心点<spanclass="math inline">\((0,0,f)\)</span>永远不变</li></ol></li><li>再进行一次正交投影：<spanclass="math inline">\(M_{ortho}\)</span></li></ol></li></ol><h4 id="计算矩阵m_persp-ortho">4.3.2.2 计算矩阵<spanclass="math inline">\(M_{persp-&gt;ortho}\)</span></h4><ol type="1"><li><p>思路：找到变换后的点<spanclass="math inline">\((x&#39;,y&#39;,z&#39;)\)</span>与原来的点<spanclass="math inline">\((x,y,z)\)</span>的对应关系</p></li><li><p>从YZ平面上看，挤压前后存在相似三角形，从而可得到<spanclass="math inline">\(y&#39;=\frac{n}{z}*y\)</span></p><ol type="1"><li>同理，<span class="math inline">\(x&#39;=\frac{n}{z}*x\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20220812172142284.png" alt="image-20220812172142284" style="zoom:80%;" /></p></li><li><p>齐次坐标表示</p><p><img src="/images/AssetMarkdown/image-20220812172516140.png" alt="image-20220812172516140" style="zoom:80%;" /></p></li><li><p>矩阵表示</p><table><colgroup><col style="width: 11%" /><col style="width: 88%" /></colgroup><thead><tr class="header"><th style="text-align: center;">由3得</th><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20220812172528972.png" alt="image-20220812172528972" style="zoom:80%;" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>因此</strong></td><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20220812172545755.png" alt="image-20220812172545755" style="zoom:80%;" /></td></tr></tbody></table></li><li><p>对于矩阵的第三行(对于Z值)，有以下性质</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: center;">在近平面上的点，坐标不变</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20220812173013770.png" alt="image-20220812173013770" style="zoom:80%;" /></td></tr><tr class="even"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20220812173047212.png" alt="image-20220812173047212" style="zoom:80%;" /></td></tr><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20220812173249005.png" alt="image-20220812173249005" style="zoom:80%;" /></td></tr></tbody></table><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: center;">在远平面上的中心点<spanclass="math inline">\((0,0,f)\)</span>，坐标不变</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20220812173205858.png" alt="image-20220812173205858" style="zoom:80%;" /></td></tr></tbody></table><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: center;">根据两个等式，可以解出<spanclass="math inline">\(A,B\)</span></th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20220812173341348.png" alt="image-20220812173341348" style="zoom:80%;" /></td></tr></tbody></table></li><li><p>综上 <span class="math display">\[M_{persp \rightarrow ortho}=\left(\begin{matrix}n &amp; 0 &amp; 0   &amp; 0 \\0 &amp; n &amp; 0   &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1   &amp; 0 \\\end{matrix}\right)\]</span></p></li><li><p>最后，再进行正交投影：<spanclass="math inline">\(M_{persp}=M_{ortho}M_{persp-&gt;ortho}\)</span></p></li></ol>$$ M_{persp}= (<span class="math display">\[\begin{matrix}\frac{2}{r-l} &amp; 0             &amp; 0             &amp;-\frac{r+l}{r-l} \\0             &amp; \frac{2}{t-b} &amp; 0             &amp;-\frac{t+b}{t-b} \\0             &amp; 0             &amp; \frac{2}{n-f} &amp;-\frac{n+f}{n-f} \\0             &amp; 0             &amp; 0             &amp; 1 \\\end{matrix}\]</span><p>)</p>(<span class="math display">\[\begin{matrix}n &amp; 0 &amp; 0   &amp; 0 \\0 &amp; n &amp; 0   &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1   &amp; 0 \\\end{matrix}\]</span><p>)</p><p>=</p>(<span class="math display">\[\begin{matrix}\frac{2n}{r-l}  &amp; 0              &amp; -\frac{r+l}{r-l} &amp; 0 \\0               &amp; \frac{2n}{t-b} &amp; -\frac{t+b}{t-b} &amp; 0  \\0               &amp; 0              &amp; \frac{n+f}{n-f}  &amp;-\frac{2nf}{n-f} \\0               &amp; 0              &amp; 1                &amp; 0 \\\end{matrix}\]</span><p>) $$</p><h4 id="对于不在近远平面上的点">4.3.3.3 对于不在近/远平面上的点</h4><p><span class="math display">\[\left(\begin{matrix}n &amp; 0 &amp; 0   &amp; 0 \\0 &amp; n &amp; 0   &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1   &amp; 0 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)=\left(\begin{matrix}nx \\ny \\(n+f)z-nf \\z \\\end{matrix}\right)==&gt;\left(\begin{matrix}\frac{n}{z}x \\\frac{n}{z}y \\(n+f)-\frac{nf}{z} \\1 \\\end{matrix}\right)\]</span></p><ol type="1"><li>近平面上的点<span class="math inline">\((z=n)\)</span><ol type="1"><li><spanclass="math inline">\(z&#39;=(n+f)-\frac{nf}{n}=n\)</span></li><li><span class="math inline">\(z&#39;=z\)</span></li></ol></li><li>远平面上的点<span class="math inline">\((z=f)\)</span><ol type="1"><li><spanclass="math inline">\(z&#39;=(n+f)-\frac{nf}{f}=f\)</span></li><li><span class="math inline">\(z&#39;=z\)</span></li></ol></li><li>不在近/远平面上的点<spanclass="math inline">\((f&lt;z&lt;n)\)</span><ol type="1"><li><span class="math inline">\(z&#39;=(n+f)-\frac{nf}{z}\)</span><ol type="1"><li>设<span class="math inline">\(n=1,f=-1,z=0.5\)</span>，则<spanclass="math inline">\(z&#39;=2\)</span></li><li>设<span class="math inline">\(n=1,f=-1,z=-0.5\)</span>，则<spanclass="math inline">\(z&#39;=-2\)</span></li></ol></li><li>可得：若<span class="math inline">\(z&lt;0\)</span>，则<spanclass="math inline">\(z&#39;\)</span>更靠近<strong>远平面<spanclass="math inline">\(f\)</span></strong>；若<spanclass="math inline">\(z&gt;0\)</span>，则<spanclass="math inline">\(z&#39;\)</span>更靠近<strong>近平面<spanclass="math inline">\(n\)</span></strong></li></ol></li></ol><h4 id="定义视锥">4.3.3.4 定义视锥</h4><blockquote><p>定义一个视锥，需要</p><ol type="1"><li>宽高比：<strong>Aspect ratio</strong></li><li>垂直的可视角度：<strong>Vertical Field of View</strong></li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20220813112938428.png" alt="image-20220813112938428" style="zoom:80%;" /></p><ol type="1"><li><p><strong>Aspect ratio 纵横比</strong>：<spanclass="math inline">\(\frac{width}{height}\)</span></p></li><li><p><strong>field-of-view(fovY)视野</strong>：从摄像机所在位置出发，连接屏幕宽的两个中点，两条线所夹的角度</p></li><li><p>从<strong>fovY</strong>和<strong>Aspect</strong>推出<strong>l, r,b, t</strong></p><p><img src="/images/AssetMarkdown/image-20220813113243520.png" alt="image-20220813113243520" style="zoom:80%;" /></p></li></ol><h1 id="第05课-光栅化1三角形">第05课 光栅化1：三角形</h1><blockquote><p>规范立方体 =&gt; 屏幕：<strong>Canonical Cube to Screen</strong></p></blockquote><h2 id="屏幕的定义">5.1 屏幕的定义</h2><ol type="1"><li><p>像素点形成的二维数组</p><ol type="1"><li>数组的大小：分辨率<strong>Resolution</strong></li></ol></li><li><p>屏幕是一个典型的光栅成像设备：<strong>Raster Display</strong></p><ol type="1"><li>在德语中，raster == screen</li><li>rasterize == drawing onto the screen</li></ol></li><li><p>像素<strong>Pixel</strong>：FYL，picture element的缩写</p><ol type="1"><li>在本节课中，一个像素就是一个小的立方体，有着一个固定的颜色</li><li>颜色是红、绿、蓝的组合</li></ol></li><li><p>屏幕空间<strong>Screen Space</strong></p><p><img src="/images/AssetMarkdown/image-20220813114126068.png" alt="image-20220813114126068" style="zoom:67%;" /></p></li><li><p>像素的坐标</p><ol type="1"><li>由一个整数坐标<strong>(x,y)</strong>表示，范围为<strong>(0,0) ~(width-1, height-1)</strong></li><li>像素的中心在<strong>(x+0.5, y+0.5)</strong></li><li>屏幕的范围为<strong>(0, 0) ~ (width, height)</strong></li></ol></li></ol><h2 id="视口变换-113-rightarrow-0width0height">5.2 视口变换：<spanclass="math inline">\([-1,1]^3 \rightarrow[0,width]×[0,height]\)</span></h2><blockquote><p><strong>Viewport Transform</strong>，思想：</p><ol type="1"><li>忽略Z</li><li>变换XY坐标：<span class="math inline">\([-1,1]^2 \rightarrow[0,width]×[0,height]\)</span></li></ol><p>此时，三维空间中的多种物体，已经变成了二维空间上的多个多边形</p></blockquote><p><span class="math display">\[M_{viewport}=\left(\begin{matrix}\frac{width}{2} &amp; 0                 &amp; 0 &amp; \frac{width}{2} \\0               &amp; \frac{height}{2}  &amp; 0 &amp; \frac{height}{2}\\0               &amp; 0                 &amp; 1 &amp; 0 \\0               &amp; 0                 &amp; 0 &amp; 1\end{matrix}\right)\]</span></p><h2 id="现代显示原理">5.3 现代显示原理</h2><ol type="1"><li><p>帧缓冲<strong>FrameBuffer</strong>：将内存中的一块区域映射到屏幕上，内存中的数据即为要显示的数据</p></li><li><p>液晶显示器<strong>LCD</strong>：Liquid Crystal Display，通过液晶将光翻转</p><p><img src="/images/AssetMarkdown/image-20230226081745766.png" alt="image-20230226081745766" style="zoom:80%;" /></p></li><li><p>发光二极管阵列LED：</p><p><img src="/images/AssetMarkdown/image-20230226081945181.png" alt="image-20230226081945181" style="zoom:80%;" /></p></li><li><p>电子墨水屏：通过通电，控制每个像素的黑色/白色</p><p><img src="/images/AssetMarkdown/image-20230226082024437.png" alt="image-20230226082024437" style="zoom:80%;" /></p></li></ol><h2 id="三角形的性质">5.4 三角形的性质</h2><ol type="1"><li>最基础的多边形，任何多边形都可以拆分成多个三角形</li><li>三角形三个顶点一定共面</li><li>可以很好的定义内部外部</li><li>定义三个顶点的属性后，可以轻易定义三角形内部的每个点的属性插值：重心插值</li></ol><h2 id="光栅化三角形-像素">5.5 光栅化：三角形 =&gt; 像素</h2><p><img src="/images/AssetMarkdown/image-20220813121135954.png" alt="image-20220813121135954" style="zoom: 67%;" /></p><h3 id="采样法-确定像素颜色">5.5.1 采样法 确定像素颜色</h3><blockquote><p><strong>Sampling</strong>：对于每一个采样点，查询函数的值</p></blockquote><ol type="1"><li><p>也就是函数离散化的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; x++)</span><br><span class="line">    output[x] = <span class="built_in">f</span>(x);</span><br></pre></td></tr></table></figure></li><li><p>定义一个函数：<strong>inside(t, x, y)</strong> <spanclass="math display">\[inside(t,x,y)=\left\{\begin{matrix}1 &amp; (x,y)在三角形t内\\0 &amp; (x,y)不在三角形t内\end{matrix}\right.\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; y++)</span><br><span class="line">        image[x][y] = <span class="built_in">inside</span>(tri, x+<span class="number">0.5</span>, y+<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/AssetMarkdown/image-20220813121848377.png" alt="image-20220813121848377" style="zoom: 67%;" /></p></li><li><p><strong>inside(t, x,y)</strong>函数的实现方法：<strong>叉乘</strong></p><ol type="1"><li><p>已知点与三角形共面，如何判断一个点是否在三角形内</p></li><li><p>按照<spanclass="math inline">\(P_0,P_1,P_2\)</span>的顺序进行叉乘<spanclass="math inline">\(\vec{P_0P_1}×\vec{P_0Q}、\vec{P_1P_2}×\vec{P_1Q}、\vec{P_2P_0}×\vec{P_2Q}\)</span>，三者的<spanclass="math inline">\(Z\)</span>的正负性相同则说明<spanclass="math inline">\(Q\)</span>在三角形内</p><p><img src="/images/AssetMarkdown/image-20220813122230668.png" alt="image-20220813122230668" style="zoom: 50%;" /></p></li><li><p>边界情况：可以不做处理 or 特殊处理，在本课中，均不做处理</p></li></ol><p><img src="/images/AssetMarkdown/image-20220813122354867.png" alt="image-20220813122354867" style="zoom: 50%;" /></p></li></ol><h3 id="三角形的包围盒">5.5.2 三角形的包围盒</h3><ol type="1"><li><p>三角形的包围盒<strong>BoundingBox</strong>：只需要考虑包围盒内的像素</p><ol type="1"><li><p>这里是轴向的<strong>AABB</strong>包围盒，因为只有XY平面的</p><p><img src="/images/AssetMarkdown/image-20220813122501707.png" alt="image-20220813122501707" style="zoom:50%;" /></p></li></ol></li><li><p>也可以对每行计算 最左像素 和 最右像素</p><p><img src="/images/AssetMarkdown/image-20220813122658221.png" alt="image-20220813122658221" style="zoom:50%;" /></p></li></ol><h1 id="第06课-光栅化2反走样深度缓冲">第06课光栅化2：反走样&amp;深度缓冲</h1><blockquote><p><strong>Antialiasing and Z-Buffering</strong></p></blockquote><ol type="1"><li><p><strong>Artifacts</strong>：瑕疵，指一切看上去不太对的地方</p></li><li><p>采样可能产生的瑕疵：</p><ol type="1"><li><p>锯齿</p><p><img src="/images/AssetMarkdown/image-20230226185128331.png" alt="image-20230226185128331" style="zoom: 50%;" /></p></li><li><p>摩尔纹：将左图的奇数行和奇数列删除，会产生右面的效果</p><p><img src="/images/AssetMarkdown/image-20230226185149464.png" alt="image-20230226185149464" style="zoom:80%;" /></p></li></ol></li><li><p>车轮效应：车轮高速逆时针旋转时，看上去好像是在顺时针旋转</p></li></ol><table><thead><tr class="header"><th style="text-align: center;">现象</th><th style="text-align: center;">原因</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">锯齿 Jaggies</td><td style="text-align: center;">在空间上的采样率不足</td></tr><tr class="even"><td style="text-align: center;">摩尔纹 Moire</td><td style="text-align: center;">对一个图像降低采样率</td></tr><tr class="odd"><td style="text-align: center;">车轮效应 Wagon wheel effect</td><td style="text-align: center;">在时间上的采样率不足</td></tr></tbody></table><h2 id="反走样方法在采样之前进行过滤模糊处理">6.1反走样方法：在采样之前进行过滤/模糊处理</h2><p><img src="/images/AssetMarkdown/image-20230226185816066.png" alt="image-20230226185816066" style="zoom:80%;" /></p><h3 id="先滤波后采样aliasing">6.1.1 先滤波，后采样：Aliasing</h3><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th style="text-align: center;">原始图片</th><th style="text-align: center;">点采样</th><th style="text-align: center;">模糊处理抗锯齿</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20230226185933649.png" alt="image-20230226185933649" style="zoom:80%;" /></td><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20230226185944079.png" alt="image-20230226185944079" style="zoom:80%;" /></td><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20230226185951932.png" alt="image-20230226185951932" style="zoom:80%;" /></td></tr></tbody></table><h3 id="先采样后滤波blurred-aliasing">6.1.2 先采样，后滤波：BlurredAliasing</h3><p><img src="/images/AssetMarkdown/image-20230226190155171.png" alt="image-20230226190155171" style="zoom:80%;" /></p><h2 id="频率域">6.2 频率域</h2><h3 id="空间域-与-频率域的转换傅里叶变换">6.2.1 空间域 与频率域的转换：傅里叶变换</h3><p><img src="/images/AssetMarkdown/image-20230226191158596.png" alt="image-20230226191158596" style="zoom:80%;" /></p><ol type="1"><li>任何一个函数，均可以展开为多个三角函数的和</li><li>傅里叶变换，实际上就是将函数在不同频率域上展开</li></ol><h3 id="函数的频率越高需要的采样频率越高">6.2.2函数的频率越高，需要的采样频率越高</h3><p><img src="/images/AssetMarkdown/image-20230226191506715.png" alt="image-20230226191506715" style="zoom:80%;" /></p><h3 id="从频率角度理解走样">6.2.3 从频率角度理解走样</h3><p><img src="/images/AssetMarkdown/image-20230226191902811.png" alt="image-20230226191902811" style="zoom:80%;" /></p><ol type="1"><li>在采样频率一定时，采样两个频率不同的函数，我们无法区分这两个函数，因此会产生锯齿</li></ol><h2 id="滤波删除一些频率的内容">6.3 滤波：删除一些频率的内容</h2><h3 id="通过傅里叶变换将图像变为频率图">6.3.1通过傅里叶变换，将图像变为频率图</h3><p><img src="/images/AssetMarkdown/image-20230226192200644.png" alt="image-20230226192200644" style="zoom:80%;" /></p><ol type="1"><li>中心是低频区，四周是高频区</li><li>亮度表示当前频率包含的信息数量</li><li>上图的信息主要集中在低频区</li><li>出现两条线的原因<ol type="1"><li>一般情况下，傅里叶变换会将图像视为周期函数</li><li>对于图片来说，相当于在图像的右边再复制一份图像</li><li>通常情况下，图片的左右边界不会相同，因此在边界处会有剧烈的变换</li><li>分析图像内部的内容时，一般忽略这两条线</li></ol></li></ol><h3 id="高通滤波">6.3.2 高通滤波</h3><blockquote><p><strong>高通滤波 ==&gt; 只保留图像的高频部分 ==&gt;图像内容的边界</strong></p></blockquote><p><img src="/images/AssetMarkdown/image-20230226192757970.png" alt="image-20230226192757970" style="zoom:80%;" /></p><h3 id="低通滤波">6.3.3 低通滤波</h3><blockquote><p><strong>低通滤波 ==&gt; 只保留图像的低频部分 ==&gt;对图像的模糊处理</strong></p></blockquote><p><img src="/images/AssetMarkdown/image-20230226192911384.png" alt="image-20230226192911384" style="zoom:80%;" /></p><h3 id="过滤高频和低频部分">6.3.4 过滤高频和低频部分</h3><p><img src="/images/AssetMarkdown/image-20230226193200309.png" alt="image-20230226193200309" style="zoom:80%;" /></p><h2 id="滤波-平均-卷积">6.4 滤波 = 平均 = 卷积</h2><blockquote><p><strong>Filter = Averaging = Convolution</strong></p><ol type="1"><li>滤波器覆盖信号的某些部分时，将对应位做点乘：卷积操作</li><li>实际上也是一个平均操作</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20230226193458236.png" alt="image-20230226193458236" style="zoom:80%;" /></p><h3 id="卷积定理时域的卷积-频域的乘积">6.4.1 卷积定理：时域的卷积&lt;=&gt; 频域的乘积</h3><p><strong>卷积定理</strong>：在时域上的卷积，等价于在频域上的乘积，即以下两个操作等价</p><ol type="1"><li>在时域上，通过卷积进行滤波</li><li>先通过傅里叶变换，将函数与滤波器转换到频域上；然后把两者相乘；最后再进行逆傅里叶变换，变换到时域上</li></ol><p><img src="/images/AssetMarkdown/image-20230226194122537.png" alt="image-20230226194122537" style="zoom:80%;" /></p><h3 id="滤波器的时域与频域的关系">6.4.2 滤波器的时域与频域的关系</h3><blockquote><p>时域上变大了，频域上反而变低了：Box越大，得出的结果越模糊</p></blockquote><p><img src="/images/AssetMarkdown/image-20230226194605360.png" alt="image-20230226194605360" style="zoom:67%;" /></p><p><img src="/images/AssetMarkdown/image-20230226194506188.png" alt="image-20230226194506188" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230226194514473.png" alt="image-20230226194514473" style="zoom:80%;" /></p><h2 id="频率角度理解采样">6.5 频率角度理解采样</h2><h3 id="采样-重复原始信号的频谱">6.5.1 采样 = 重复原始信号的频谱</h3><blockquote><p>采样频率越快，频谱复制越稀疏</p><p>采样频率越满，频谱复制越密集</p></blockquote><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: center;">时域上采样 &lt;=&gt; 两个函数相乘</th><th style="text-align: center;">频域上的卷积 &lt;=&gt;重复原始信号的频谱</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20230226194857621.png" alt="image-20230226194857621" style="zoom:80%;" /></td><tdstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20230226194911883.png" alt="image-20230226194911883" style="zoom:80%;" /></td></tr></tbody></table><h3 id="走样-频谱的内容出现重叠">6.5.2 走样 = 频谱的内容出现重叠</h3><p><img src="/images/AssetMarkdown/image-20230226195426029.png" alt="image-20230226195426029" style="zoom:80%;" /></p><h3 id="反走样-先删除高频信息在采样">6.5.3 反走样 =先删除高频信息，在采样</h3><ol type="1"><li>先模糊，后采样：先删除一个信号的高频信息，然后在进行采样</li></ol><p><img src="/images/AssetMarkdown/image-20230226195656888.png" alt="image-20230226195656888" style="zoom:80%;" /></p><h2 id="反走样的实际做法">6.6 反走样的实际做法</h2><ol type="1"><li>对每个像素，根据三角形覆盖的面积，做平均值</li><li>然后再进行采样</li></ol><p><img src="/images/AssetMarkdown/image-20230226200044458.png" alt="image-20230226200044458" style="zoom:80%;" /></p><h3 id="msaamultisample-antialiasing">6.6.1 MSAA：MultisampleAntialiasing</h3><ol type="1"><li><strong>超采样SuperSampling</strong>：将每个像素划分为多个小的采样点，然后该像素的颜色为多个采样点的平均</li><li>MSAA近似的是抗锯齿的第一步操作，即<strong>模糊处理</strong></li><li>MSAA无法提高屏幕的分辨率，只是通过多个采样点得到近似的三角形覆盖</li><li>MSAA是通过增大计算量，得到抗锯齿效果</li><li>在实际使用中，会将采样点按特殊的方法排列，有些采样点还会被多个像素复用</li></ol><blockquote><p><img src="/images/AssetMarkdown/image-20230226201008321.png" alt="image-20230226201008321" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230226201027928.png" alt="image-20230226201027928" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230226201036128.png" alt="image-20230226201036128" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230226201053512.png" alt="image-20230226201053512" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230226201100860.png" alt="image-20230226201100860" style="zoom:80%;" /></p></blockquote><h3 id="fxaafast-approximate-antialiasing">6.6.2 FXAA：Fast ApproximateAntialiasing</h3><ol type="1"><li>快速近似抗锯齿</li><li>通过图像的后期处理，先将有锯齿的图像得出来，然后通过图像匹配找到边界，将这些像素换为边界上的颜色</li></ol><h3 id="taatemporal-antialiasing">6.6.3 TAA：Temporal Antialiasing</h3><ol type="1"><li>通过找上一帧的信息，进行抗锯齿操作</li><li>假设是静止画面，在相邻两帧同一个像素用不同的点感知是否在一个三角形内</li><li>复用上一帧感知到的值，相当于将MSAA的采样点分布在时间上，对于具体的某一帧没有额外操作</li></ol><h2 id="超分辨率超采样">6.7 超分辨率/超采样</h2><ol type="1"><li>采样率不够，而分辨率较大时，会使用这种技术</li><li>DLSS：Deep Learning SuperSampling，通过深度学习，猜测丢失的信息</li></ol><h2 id="深度缓冲解决可见性">6.8 深度缓冲：解决可见性</h2><p><img src="/images/AssetMarkdown/image-20230316201036427.png" alt="image-20230316201036427" style="zoom:80%;" /></p><ol type="1"><li>Z-Buffer：存储<strong>每一个像素</strong>，所看到的几何物体的最浅距离<ol type="1"><li>设Z始终为整数，且Z越小离相机越近</li></ol></li><li>具体算法：<ol type="1"><li>初始化深度缓存为<code>∞</code></li><li>对于每一个三角形<code>T</code><ol type="1"><li>对于<code>T</code>中的每一个采样点<code>(x,y,z)</code>：</li><li>如果<code>Z &lt; z-buffer[x,y]</code>：更新<code>frame-buffer、z-buffer</code></li><li>否则，跳过该采样点</li></ol></li></ol></li><li>复杂度<ol type="1"><li>有<code>n</code>个三角形，则复杂度为<code>O(n)</code></li><li>此处并没有排序，而是对每一个像素，维护了一个最小值</li></ol></li><li>画出来的结果，与画三角形的顺序无关</li><li><strong>深度缓存无法处理透明物体</strong></li></ol><h1 id="第07课-着色1blinn-phong反射模型">第07课着色1：Blinn-Phong反射模型</h1><blockquote><p><strong>Shading</strong>：着色</p><ol type="1"><li>对不同物体，定义不同材质，从而与光线产生不同作用</li></ol><p>局部性：</p><ol type="1"><li>只考虑自己的属性，不考虑与其他物体的存在</li><li>因此，没有阴影</li></ol></blockquote><figure><img src="/images/AssetMarkdown/image-20230316203039767.png"alt="image-20230316203039767" /><figcaption aria-hidden="true">image-20230316203039767</figcaption></figure><h2 id="反射模型的输入">7.1 反射模型的输入</h2><p><img src="/images/AssetMarkdown/image-20230316203536809.png" alt="image-20230316203536809" style="zoom:80%;" /></p><h2 id="光照的能量传递关系">7.2 光照的能量传递关系</h2><ol type="1"><li><p>余弦定理：单位面积接收到的光的能量占比为<code>cos θ</code>，<code>θ</code>为光照方向与平面法线的夹角</p><p><img src="/images/AssetMarkdown/image-20230316204159302.png" alt="image-20230316204159302" style="zoom:80%;" /></p></li><li><p>设光源的能量为<code>I</code>，光源与表面的距离为<code>r</code>，则到达表面的能量为<spanclass="math inline">\(\frac{I}{r^2}\)</span></p><p><img src="/images/AssetMarkdown/image-20230316204518794.png" alt="image-20230316204518794" style="zoom:80%;" /></p></li></ol><h2 id="漫反射-diffuse-reflection">7.3 漫反射 Diffuse Reflection</h2><p><span class="math display">\[L_d=k_d\frac{I}{r^2}max(0,\vec{n}·\vec{l})\]</span></p><ol type="1"><li><span class="math inline">\(L_d\)</span>：漫反射光照</li><li><spanclass="math inline">\(k_d\)</span>：漫反射系数，通常为物体的颜色</li><li><span class="math inline">\(I/r^2\)</span>：到达该点的能量</li><li><spanclass="math inline">\(max(0,\vec{n}·\vec{l})\)</span>：该点接收到的能量</li><li>由于漫反射到四面八方的能量均相同，因此没有<spanclass="math inline">\(\vec{v}\)</span>的事情</li></ol><p><img src="/images/AssetMarkdown/image-20230316204556352.png" alt="image-20230316204556352" style="zoom:80%;" /></p><h2 id="镜面反射高光项-specular-reflection">7.4 镜面反射&amp;高光项Specular Reflection</h2><blockquote><p>接近镜面反射时，会出现高光</p></blockquote><p><span class="math display">\[L_s=k_s\frac{I}{r^2}max(0,\vec{n}·\vec{h})^p\]</span></p><ol type="1"><li><span class="math inline">\(L_s\)</span>：镜面反射光照</li><li><spanclass="math inline">\(k_s\)</span>：镜面反射系数，通常为白色</li><li><span class="math inline">\(I/r^2\)</span>：到达该点的能量</li><li><spanclass="math inline">\(max(0,\vec{n}·\vec{l})\)</span>：该点接收到的能量</li><li><spanclass="math inline">\(p\)</span>：为了让高光的区域足够小，需要将夹角余弦进行幂操作</li></ol><p><img src="/images/AssetMarkdown/image-20230316205631263.png" alt="image-20230316205631263" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230316220333380.png" alt="image-20230316220333380" style="zoom:80%;" /></p><h2 id="环境光-ambient-term">7.5 环境光 Ambient Term</h2><blockquote><p>假设所有点接收到的环境光均相同</p></blockquote><p><span class="math display">\[L_a=k_aI_a\]</span></p><ol type="1"><li><span class="math inline">\(L_a\)</span>：环境光</li><li><spanclass="math inline">\(k_a\)</span>：环境光系数，通常为物体颜色</li><li>环境光通常为一个常量，保证没有地方是黑的</li></ol><p><img src="/images/AssetMarkdown/image-20230316220425251.png" alt="image-20230316220425251" style="zoom:80%;" /></p><h2 id="blinn-phong反射模型">7.6 Blinn-Phong反射模型</h2><p><span class="math display">\[\begin{aligned}L &amp;= L_a+L_d+L_s\\  &amp;= k_aI_a+k_d\frac{I}{r^2}max(0,n·l)+k_s\frac{I}{r^2}max(0,n·h)^p\end{aligned}\]</span></p><p><img src="/images/AssetMarkdown/image-20230316220636330.png" alt="image-20230316220636330" style="zoom:80%;" /></p><h1 id="第08课-着色2着色频率实时渲染管线">第08课着色2：着色频率&amp;实时渲染管线</h1><h2 id="着色频率">8.1 着色频率</h2><p><img src="/images/AssetMarkdown/image-20230316221140250.png" alt="image-20230316221140250" style="zoom:80%;" /></p><ol type="1"><li>着色频率即为：将结果应用到哪些平面上<ol type="1"><li>左1：应用到每个三角面上，<strong>Flat Shading</strong></li><li>左2：应用到每个顶点上，<strong>Gouraud Shading</strong></li><li>左3：应用到每个像素上，<strong>Phong Shading</strong></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230316221604284.png" alt="image-20230316221604284" style="zoom:80%;" /></p><h3 id="计算顶点法线">8.1.1 计算顶点法线</h3><blockquote><p>将与该顶点相关的所有面的法线，做加权平均，权重为三角形面积</p></blockquote><p><span class="math display">\[N_v=\frac{\sum_i N_i}{|\sum_i N_i|}\]</span></p><p><img src="/images/AssetMarkdown/image-20230316221815730.png" alt="image-20230316221815730" style="zoom:80%;" /></p><h3 id="计算像素法线">8.1.2 计算像素法线</h3><blockquote><p>使用重心坐标，对相邻两个顶点的法线进行插值</p></blockquote><p><img src="/images/AssetMarkdown/image-20230316222038138.png" alt="image-20230316222038138" style="zoom:80%;" /></p><h2 id="实时渲染管线">8.2 实时渲染管线</h2><ol type="1"><li>输入：3维空间中的若干个点</li><li><strong>Vertex Processing</strong>：将3维空间的点，投影到屏幕空间上<ol type="1"><li>Model, View Projection变换</li><li>着色、纹理映射</li></ol></li><li><strong>Triangle Processing</strong>：形成屏幕空间上的三角形</li><li><strong>Rasterization</strong>：通过光栅化，将三角形绘制到屏幕上<ol type="1"><li>对三角形是否覆盖进行采样</li></ol></li><li><strong>Fragment Processing</strong>：对像素进行着色<ol type="1"><li>Z-Buffer</li><li>着色、纹理映射</li></ol></li><li><strong>Framebuffer Opreations</strong>：将三角形拼装成图像</li></ol><p><img src="/images/AssetMarkdown/image-20230316222331676.png" alt="image-20230316222331676" style="zoom:80%;" /></p><h2 id="shader程序">8.3 Shader程序</h2><ol type="1"><li>对每一个顶点/像素，Shader均会执行一次</li><li>顶点着色器：对顶点操作</li><li>片段着色器、像素着色器：对像素操作，确定当前像素是什么颜色</li></ol><h2 id="gpu">8.4 GPU</h2><ol type="1"><li>是整个图形管线的硬件实现：如光栅化、投影</li><li>有一部分是可编程的：即着色器</li><li>GPGPU：通用GPU计算，可以完成各种各样的GPU计算</li><li>是一个高度并行化的多核处理器</li></ol><p><img src="/images/AssetMarkdown/image-20230316225348436.png" alt="image-20230316225348436" style="zoom:80%;" /></p><h2 id="纹理映射">8.5 纹理映射</h2><ol type="1"><li><p>根本作用：定义3维物体上任何一个点的属性</p></li><li><p><strong>纹理</strong>：任何一个3维物体的表面都是2维的，因此可以和一张图有一个一一对应的关系，这张图即为纹理</p><ol type="1"><li>将3维物体上的每一个三角形的顶点，映射到纹理图像上<ol type="1"><li>由美工完成</li><li>自动化：参数化模型</li></ol></li></ol></li><li><p>UV坐标系：即纹理坐标的坐标系，通常范围为[0~1] × [0~1]</p><p><img src="/images/AssetMarkdown/image-20230316230121429.png" alt="image-20230316230121429" style="zoom:80%;" /></p></li><li><p>不同的位置可以映射到同一个位置上</p><p><img src="/images/AssetMarkdown/image-20230316230208252.png" alt="image-20230316230208252" style="zoom:80%;" /></p></li><li><p>好的纹理：纹理的上下左右可以无缝衔接，称为<strong>tiledtextures</strong></p><p><img src="/images/AssetMarkdown/image-20230316230252605.png" alt="image-20230316230252605" style="zoom:80%;" /></p></li></ol><h1 id="第09课-着色3纹理的应用">第09课 着色3：纹理的应用</h1><h2 id="重心坐标-barycentric-coordinates">9.1 重心坐标 BarycentricCoordinates</h2><p>为什么需要插值</p><ol type="1"><li>我们的很多操作是定义在<strong>顶点</strong>上的</li><li>我们需要在<strong>三角形</strong>内获得平滑的值</li></ol><p>插值什么内容</p><ol type="1"><li>纹理坐标、颜色、法线</li></ol><p>怎么做插值</p><ol type="1"><li>重心坐标</li></ol><h3 id="重心坐标是什么">9.1.1 重心坐标是什么</h3><p><img src="/images/AssetMarkdown/image-20230320181655673.png" alt="image-20230320181655673" style="zoom:80%;" /></p><ol type="1"><li><p>定义在三角形上：三角形<strong>所在平面</strong>的任意一个点的坐标，都可以用三个顶点坐标的线性组合表示，且<spanclass="math inline">\(\alpha+\beta+\gamma=1\)</span></p><ol type="1"><li><span class="math inline">\((x,y)=\alpha A+ \beta B + \gammaC\)</span>，可以得到一个坐标<spanclass="math inline">\((\alpha,\beta,\gamma)\)</span></li><li>如果在<strong>三角形内</strong>，则<spanclass="math inline">\(\alpha,\beta,\gamma\)</span>均为<strong>非负</strong>的</li></ol></li><li><p>求<spanclass="math inline">\(\alpha,\beta,\gamma\)</span>：通过面积计算</p><p><img src="/images/AssetMarkdown/image-20230320182149277.png" alt="image-20230320182149277" style="zoom:80%;" /></p></li><li><p>三角形的<strong>重心</strong>：分成的三个三角形面积相等</p><p><img src="/images/AssetMarkdown/image-20230320182314078.png" alt="image-20230320182314078" style="zoom:80%;" /></p></li><li><p>使用公式计算：</p><p><img src="/images/AssetMarkdown/image-20230320182412696.png" alt="image-20230320182412696" style="zoom:80%;" /></p></li></ol><h3 id="重心坐标插值">9.1.2 重心坐标插值</h3><p><strong>注意：投影后，重心坐标可能会改变，因此插值三维属性，应该使用三维坐标</strong></p><p><img src="/images/AssetMarkdown/image-20230320182502273.png" alt="image-20230320182502273" style="zoom:80%;" /></p><h2 id="纹理的基础应用">9.2 纹理的基础应用</h2><h3 id="简单纹理映射漫反射颜色">9.2.1 简单纹理映射：漫反射颜色</h3><p>对每一个屏幕中的采样点<spanclass="math inline">\((x,y)\)</span>：</p><ol type="1"><li>通过重心坐标插值，计算<spanclass="math inline">\((x,y)\)</span>对应的纹理坐标<spanclass="math inline">\((u,v)\)</span></li><li>得到纹理中，<spanclass="math inline">\((u,v)\)</span>所在点的颜色，记为<code>texcolor = texture.sample(u,v)</code></li><li>将该采样点的颜色，设置为<code>texcolor</code></li></ol><h3 id="纹理放大双线性插值-bilinear-interpolation">9.2.2纹理放大：双线性插值 Bilinear interpolation</h3><blockquote><p>像素<strong>pixel</strong> &lt;=&gt;纹理元素<strong>texel</strong>，纹理需要放大时，多个pixel会对应到同一个texel上</p></blockquote><blockquote><p>纹理过小：失真</p><p><img src="/images/AssetMarkdown/image-20230320184241753.png" alt="image-20230320184241753" style="zoom:80%;" /></p></blockquote><ol type="1"><li>找到临近的四个点</li><li>计算水平距离<code>s</code>和垂直距离<code>t</code>，均为<code>[0,1]</code>之间的值</li><li>定义线性插值操作：<spanclass="math inline">\(lerp(x,v_0,v_1)=v_0+x(v_1-v_0)\)</span>，<spanclass="math inline">\(x\)</span>为<code>[0,1]</code>之间的值</li><li>进行<strong>两次线性插值</strong>操作：<ol type="1"><li>水平方向：<spanclass="math inline">\(u_0=lerp(s,u_{00},u_{10}),u_1=lerp(s,u_{01},u_{11})\)</span></li><li>垂直方向：<spanclass="math inline">\(f(x,y)=lerp(t,u_0,u_1)\)</span></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230320183957812.png" alt="image-20230320183957812" style="zoom:80%;" /></p><h3 id="纹理缩小">9.2.3 纹理缩小</h3><blockquote><p>纹理过大：远处摩尔纹，近处锯齿</p><ol type="1"><li>远处，一个像素覆盖了纹理上的很大一块区域，因此会存在走样</li></ol><p><img src="/images/AssetMarkdown/image-20230320184320810.png" alt="image-20230320184320810" style="zoom:80%;" /></p></blockquote><h4 id="mipmap">9.2.3.1 Mipmap</h4><p><strong>Mipmap</strong>：允许做<strong>快速、近似、正方形</strong>的范围查询</p><ol type="1"><li><p>每一层均将上一层缩小到原来的一半</p><ol type="1"><li>预处理纹理</li><li>多了1/3的存储量</li></ol><p><img src="/images/AssetMarkdown/image-20230320185053505.png" alt="image-20230320185053505" style="zoom:80%;" /></p></li><li><p>计算某个像素对应到纹理的正方形区域</p><ol type="1"><li>将屏幕上的某个像素点<code>p1</code>及其两个邻居<code>p2,p3</code>对应到纹理上的三个点<code>t1,t2,t3</code></li><li>在屏幕上，<code>p1</code>与<code>p2</code>的距离为<code>1</code>，<code>p1</code>与<code>p3</code>的距离为<code>1</code></li><li>在纹理中，<code>t1</code>与<code>t2</code>的距离为<code>L1</code>，<code>t1</code>与<code>t2</code>的距离为<code>L2</code></li><li>取<code>L=max(L1,L2)</code>，则该像素在纹理空间上对应的正方形区域为，以<code>t1</code>为中心的<code>L×L</code>的区域</li></ol><p><img src="/images/AssetMarkdown/image-20230320185714401.png" alt="image-20230320185714401" style="zoom:80%;" /></p></li><li><p>计算正方形区域的平均值</p><ol type="1"><li>假设正方形为<code>1×1</code>，则可以直接在<code>0</code>层中获得该区域的平均值</li><li>假设正方形为<code>4×4</code>，则可以直接在<code>1</code>层中获得该区域的平均值</li><li>因此，我们可以在第<spanclass="math inline">\(D=log_2L\)</span>层中获取该区域的平均值</li><li>如果<spanclass="math inline">\(log_2L\)</span>不是整数，则可以通过<strong>线性插值</strong>，获得该区域的平均值</li><li>每一层的查询，使用了一次<strong>双线性插值</strong>，最后又进行了一次<strong>线性插值</strong>，因此称为<strong>三线性插值</strong></li></ol><p><img src="/images/AssetMarkdown/image-20230320190152780.png" alt="image-20230320190152780" style="zoom:80%;" /></p></li><li><p>缺点：在远处会完全模糊<strong>overblur</strong></p></li></ol><h4 id="各向异性过滤">9.2.3.2 各向异性过滤</h4><p><strong>AnisotropicFiltering</strong>：各向异性过滤，对矩形的区域快速查询平均值</p><p><img src="/images/AssetMarkdown/image-20230320190538811.png" alt="image-20230320190538811" style="zoom:80%;" /></p><ol type="1"><li>各向异性过滤：水平、竖直压扁，开销为原本的3倍</li><li>EWA过滤：将图像分为一个个的椭圆</li></ol><p><img src="/images/AssetMarkdown/image-20230320190625611.png" alt="image-20230320190625611" style="zoom:80%;" /></p><h2 id="纹理的其他应用">9.3 纹理的其他应用</h2><p>现代GPU中，纹理的本质：是一块内存区域，且可以进行范围查询</p><h3 id="环境贴图-environment-map">9.3.1 环境贴图 Environment Map</h3><ol type="1"><li>环境贴图：即为空间中的某个点，向上下左右前后六个方向，所能接收到的光</li><li>可以通过环境贴图，进行光照计算，进而实现环境光渲染</li><li>基本假设：环境光来自无限远处，只记录环境光的方向信息</li><li>可以使用<strong>Spherical Map</strong>或者<strong>CubeMap</strong>表示</li></ol><p><img src="/images/AssetMarkdown/image-20230320203116579.png" alt="image-20230320203116579" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230320203423125.png" alt="image-20230320203423125" style="zoom:80%;" /></p><blockquote><p>由于立方体的<strong>各个面都是均匀</strong>的，因此能很好的避免天空球的<strong>极点消失</strong>现象</p><ol type="1"><li>天空盒只记录方向信息</li><li>需要先判断某个方向是属于哪一个面上的</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20230320203303350.png" alt="image-20230320203303350" style="zoom:80%;" /></p><h3 id="凹凸贴图-法线贴图">9.3.2 凹凸贴图 &amp; 法线贴图</h3><ol type="1"><li>凹凸贴图：定义某个点的相对高度(沿法线移动的距离)，从而改变周围像素的法线方向</li><li>法线贴图：定义某个点的法线</li></ol><p><img src="/images/AssetMarkdown/image-20230320203552597.png" alt="image-20230320203552597" style="zoom:80%;" /></p><blockquote><p>计算修改后的法线</p></blockquote><ol type="1"><li><p>一维贴图，修改像素的法线：<strong>flatland</strong></p><ol type="1"><li>设原来的表面法线<code>n(p)=(0, 1)</code></li><li>计算梯度：<code>dp=c*[h(p+1)-h(p)]</code></li><li>则切线为：<code>(1,dp)</code></li><li>因此更改后的法线为：<code>n(p)=(-dp, 1).normalized()</code></li></ol><p><img src="/images/AssetMarkdown/image-20230320203941915.png" alt="image-20230320203941915" style="zoom:80%;" /></p></li><li><p>二维贴图，修改像素的法线：<strong>局部坐标系下</strong></p><ol type="1"><li>设原来的表面法线<code>n(p)=(0, 0, 1)</code></li><li>计算梯度：<code>dp/du=c1*[h(u+1)-h(u)]</code>，<code>dp/dv=c2*[h(v+1)-h(v)]</code></li><li>因此更改后的法线为：<code>n(p)=(-dp/du, -dp/dv ,1).normalized()</code></li></ol></li></ol><h3 id="位移贴图-displacement-mapping">9.3.3 位移贴图 DisplacementMapping</h3><ol type="1"><li>与凹凸贴图类似，但是会直接<strong>更改三角形顶点的位置</strong></li><li>要求原有模型的三角形比较细，要求模型的三角形顶点之间的间隔，比纹理之间的间隔小</li></ol><p><img src="/images/AssetMarkdown/image-20230320204818983.png" alt="image-20230320204818983" style="zoom:80%;" /></p><h3 id="三维纹理">9.3.4 三维纹理</h3><ol type="1"><li>定义一个三维空间的噪声函数，可以得到三维空间中，任意一个点的属性</li></ol><p><img src="/images/AssetMarkdown/image-20230320205137485.png" alt="image-20230320205137485" style="zoom:80%;" /></p><h3 id="保存预处理的数据">9.3.5 保存预处理的数据</h3><p><img src="/images/AssetMarkdown/image-20230320205230388.png" alt="image-20230320205230388" style="zoom:80%;" /></p><h3 id="三维纹理-体积渲染">9.3.6 三维纹理 &amp; 体积渲染</h3><p><img src="/images/AssetMarkdown/image-20230320205313633.png" alt="image-20230320205313633" style="zoom:80%;" /></p><h1 id="第10课-几何1介绍">第10课 几何1：介绍</h1><h2 id="隐式表示-implicit">10.1 隐式表示 Implicit</h2><ol type="1"><li><p><strong>f(x,y,z) =0</strong>：表示一定的关系，并不直接给出实际点</p></li><li><p>优点：便于判断某个<strong>点与面</strong>的关系</p><p><img src="/images/AssetMarkdown/image-20230320210121129.png" alt="image-20230320210121129" style="zoom:80%;" /></p></li><li><p>缺点：无法直接判断出<strong>形状</strong>/找到所有在这个面上的点</p><p><img src="/images/AssetMarkdown/image-20230320210022919.png" alt="image-20230320210022919" style="zoom:80%;" /></p></li></ol><h2 id="显示表示-explicit">10.2 显示表示 Explicit</h2><ol type="1"><li><p>显示表示：直接用三角形表示 / 通过参数映射给出</p><p><img src="/images/AssetMarkdown/image-20230320210219640.png" alt="image-20230320210219640" style="zoom:80%;" /></p></li><li><p>优点：便于<strong>取样</strong>，判断形状</p><p><img src="/images/AssetMarkdown/image-20230320210302100.png" alt="image-20230320210302100" style="zoom:80%;" /></p></li><li><p>缺点：难以判断某个<strong>点和面</strong>的关系</p><p><img src="/images/AssetMarkdown/image-20230320210417478.png" alt="image-20230320210417478" style="zoom:80%;" /></p></li></ol><h2 id="cg中的隐式几何表示">10.3 CG中的隐式几何表示</h2><h3 id="数学公式表述">10.3.1 数学公式表述</h3><p><img src="/images/AssetMarkdown/image-20230320210536832.png" alt="image-20230320210536832" style="zoom:80%;" /></p><h3 id="构造几何csgconstructive-solid-geometry">10.3.2构造几何CSG：Constructive Solid Geometry</h3><p><img src="/images/AssetMarkdown/image-20230320210649720.png" alt="image-20230320210649720" style="zoom:80%;" /></p><h3 id="距离函数-distance-functions">10.3.3 距离函数 DistanceFunctions</h3><ol type="1"><li>描述空间中的任何一个点，到该表面的最近距离<ol type="1"><li>如果在物体外，则为正数</li><li>如果在物体内，则为负数</li><li>SDF：有向距离函数</li></ol></li><li>优点：便于做两个物体的<strong>边界融合</strong></li></ol><p><img src="/images/AssetMarkdown/image-20230320210931112.png" alt="image-20230320210931112" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230320211414373.png" alt="image-20230320211414373" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230320211444830.png" alt="image-20230320211444830" style="zoom:80%;" /></p><h3 id="水平集函数">10.3.4 水平集函数</h3><p><img src="/images/AssetMarkdown/image-20230320211928804.png" alt="image-20230320211928804" style="zoom:80%;" /></p><h3 id="分形-fractal">10.3.5 分形 Fractal</h3><p><strong>分形 &lt;=&gt; 自相似</strong></p><p><img src="/images/AssetMarkdown/image-20230320212054041.png" alt="image-20230320212054041" style="zoom:80%;" /></p><h2 id="cg中的显示几何表示">10.4 CG中的显示几何表示</h2><h3 id="点云">10.4.1 点云</h3><ol type="1"><li>通过特别多的点，表示一个模型</li><li>通常为三维扫描的输出</li></ol><p><img src="/images/AssetMarkdown/image-20230320212656886.png" alt="image-20230320212656886" style="zoom:80%;" /></p><h3 id="多边形面">10.4.2 多边形面</h3><ol type="1"><li>通常为三角形 &amp; 四边形</li></ol><p><img src="/images/AssetMarkdown/image-20230320212736997.png" alt="image-20230320212736997" style="zoom:80%;" /></p><h3 id="the-wavefront-object-file-format">10.4.3 The Wavefront ObjectFile Format</h3><ol type="1"><li><code>v</code>：点的坐标</li><li><code>vt</code>：纹理坐标</li><li><code>vn</code>：法向</li><li><code>f</code>：连接关系，同一行内为三角形的三个点，每个点的格式为<code>v/vt/vn</code>，表示该点的坐标/纹理坐标/法向</li></ol><p><img src="/images/AssetMarkdown/image-20230320212854657.png" alt="image-20230320212854657" style="zoom:80%;" /></p><h1 id="第11课-几何2曲线和曲面">第11课 几何2：曲线和曲面</h1><h2 id="贝塞尔曲线-bezier-curve">11.1 贝塞尔曲线 Bezier Curve</h2><ol type="1"><li>定义四个控制点<code>p0,p1,p2,p3</code>，要求曲线的起始切线方向为<code>p1-p0</code>，终止切线方向为<code>p3-p2</code></li><li>曲线不一定经过控制点</li></ol><p><img src="/images/AssetMarkdown/image-20230320213504658.png" alt="image-20230320213504658" style="zoom:80%;" /></p><h3 id="de-casteljau算法">11.1.1 de Casteljau算法</h3><h4 id="二次贝塞尔曲线三个控制点">11.1.1.1二次贝塞尔曲线：三个控制点</h4><ol type="1"><li><code>b0</code>为起点，<code>b2</code>为终点，<code>b1</code>控制曲线弯曲</li><li>实际上是：对于每一个时间<code>t</code>，找到当前时刻对应的点的坐标<ol type="1"><li>第一步：<ol type="1"><li>在<span class="math inline">\(b_0b_1\)</span>上，设<spanclass="math inline">\(b_0\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^1\)</span></li><li>在<span class="math inline">\(b_1b_2\)</span>上，设<spanclass="math inline">\(b_1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_2\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_1^1\)</span></li></ol></li><li>第二步：<ol type="1"><li>在<span class="math inline">\(b_0^1b_1^1\)</span>上，设<spanclass="math inline">\(b_0^1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1^1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^2\)</span></li></ol></li><li>则<spanclass="math inline">\(b_0^2\)</span>记为贝塞尔曲线，在时间<code>t</code>所在的位置</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230320214216113.png" alt="image-20230320214216113" style="zoom:80%;" /></p><h4 id="四个控制点">11.1.1.2 四个控制点</h4><ol type="1"><li><code>b0</code>为起点，<code>b3</code>为终点，<code>b1,b2</code>控制曲线弯曲</li><li>实际上是：对于每一个时间<code>t</code>，找到当前时刻对应的点的坐标<ol type="1"><li>第一步：<ol type="1"><li>在<span class="math inline">\(b_0b_1\)</span>上，设<spanclass="math inline">\(b_0\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^1\)</span></li><li>在<span class="math inline">\(b_1b_2\)</span>上，设<spanclass="math inline">\(b_1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_2\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_1^1\)</span></li><li>在<span class="math inline">\(b_2b_3\)</span>上，设<spanclass="math inline">\(b_2\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_3\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_2^1\)</span></li></ol></li><li>第二步：<ol type="1"><li>在<span class="math inline">\(b_0^1b_1^1\)</span>上，设<spanclass="math inline">\(b_0^1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1^1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^2\)</span></li><li>在<span class="math inline">\(b_1^1b_2^1\)</span>上，设<spanclass="math inline">\(b_1^1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_2^1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_1^2\)</span></li></ol></li><li>第三步：<ol type="1"><li>在<span class="math inline">\(b_0^2b_1^2\)</span>上，设<spanclass="math inline">\(b_0^2\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1^2\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^3\)</span></li></ol></li><li>则<spanclass="math inline">\(b_0^3\)</span>记为贝塞尔曲线，在时间<code>t</code>所在的位置<code>x(t)</code></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230320214234859.png" alt="image-20230320214234859" style="zoom:80%;" /></p><h4 id="贝塞尔曲线的代数形式">11.1.1.3 贝塞尔曲线的代数形式</h4><p><img src="/images/AssetMarkdown/image-20230320214621950.png" alt="image-20230320214621950" style="zoom:80%;" /></p><blockquote><p>2阶贝塞尔曲线</p></blockquote><p><img src="/images/AssetMarkdown/image-20230320214734581.png" alt="image-20230320214734581" style="zoom:80%;" /></p><h3 id="n阶贝塞尔曲线的代数表示">11.1.2 n阶贝塞尔曲线的代数表示</h3><blockquote><p>参数为 <strong>(1-t+t)<sup>n</sup></strong> 的多项式展开</p></blockquote><p><span class="math display">\[b^n(t) = \sum_{j=0}^n b_j B_j^n(t)\]</span></p><ol type="1"><li><spanclass="math inline">\(b^n(t)\)</span>：n阶贝塞尔曲线的表达式</li><li><spanclass="math inline">\(b_j\)</span>：第j个控制点，可以为三维空间中的点</li><li><spanclass="math inline">\(B_j^n(t)\)</span>：Bernstein多项式，此处为<spanclass="math inline">\(C_{n}^i\ t^i\ (1-t)^{n-i}\)</span></li></ol><h3 id="贝塞尔曲线的性质">11.1.3 贝塞尔曲线的性质</h3><ol type="1"><li><p>必须过起点和终点：<spanclass="math inline">\(b(0)=b_0,b(1)=b_n\)</span></p></li><li><p>对于三阶贝塞尔曲线：<spanclass="math inline">\(b&#39;(0)=3(b_1-b_0),b&#39;(1)=3(b_3-b_2)\)</span></p></li><li><p>在仿射变换中：<strong>对贝塞尔曲线的仿射变换 &lt;=&gt;对控制点做仿射变换然后再计算贝塞尔曲线</strong></p><ol type="1"><li>但是对投影变换不行</li></ol></li><li><p>凸包性质：<strong>贝塞尔曲线一定在控制点形成的凸包内</strong></p><ol type="1"><li><p>凸包：包围某些顶点的最小凸多边形</p><blockquote><p>可以将顶点想象为钉子，用橡皮筋包裹住所有顶点，然后松手，橡皮筋最后的形状记为这些顶点的凸包</p></blockquote></li><li><p>如果控制点在同一条直线上，则贝塞尔曲线就是这条直线</p></li></ol></li></ol><h3 id="分段贝塞尔曲线-picewise-bezier-curves">11.1.4 分段贝塞尔曲线Picewise Bezier Curves</h3><ol type="1"><li><p>通常为4个控制点，控制一段贝塞尔曲线</p></li><li><p>PS中的钢笔工具，就应用了分段贝塞尔曲线</p><p><img src="/images/AssetMarkdown/image-20230320220627770.png" alt="image-20230320220627770" style="zoom:80%;" /></p></li><li><p>保证<strong>连续</strong>（<strong>C<sup>0</sup>连续</strong>）：</p><p><img src="/images/AssetMarkdown/image-20230320221118919.png" alt="image-20230320221118919" style="zoom:80%;" /></p></li><li><p>保证<strong>光滑/切线连续</strong>（<strong>C<sup>1</sup>连续</strong>）：相邻的两端贝塞尔曲线中，上一段曲线的最后两个控制点，与下一段曲线的最初两个控制点，共线且距离相同</p><p><img src="/images/AssetMarkdown/image-20230320221132408.png" alt="image-20230320221132408" style="zoom:80%;" /></p></li></ol><h2 id="样条曲线-spline">11.2 样条曲线 Spline</h2><p>样条：一个可控的曲线</p><h3 id="b样条-basis-spline">11.2.1 B样条 Basis-Spline</h3><p>基函数样条</p><ol type="1"><li>贝塞尔曲线，既可以理解为用Bernstein多项式，对控制点加权求和；也可以理解为用控制点，对Bernstein多项式进行加权求和。则Bernstein多项式，即为基函数</li><li>相当于由不同的函数，通过某一种方式结合起来，得到另一个函数</li><li>B样条是对贝塞尔曲线的扩展，可以保证<strong>修改的局部性</strong>，改变一个点，至多影响曲线的某个部分</li></ol><h2 id="贝塞尔曲面-bezier-surfaces">11.3 贝塞尔曲面 Bezier Surfaces</h2><h3 id="个控制点">11.3.1 4×4个控制点</h3><ol type="1"><li><p>对于每一行的4个控制点，计算每一行的贝塞尔曲线</p></li><li><p>对于每一个时间<code>t1</code>，对应的4行贝塞尔曲线上的点，认为是4个控制点，可以得到另一个贝塞尔曲线，其时间为<code>t2</code></p><p><img src="/images/AssetMarkdown/image-20230320222831716.png" alt="image-20230320222831716" style="zoom:80%;" /></p></li><li><p>在<code>t1,t2</code>的变换过程中，即可得到贝塞尔曲面</p><p><img src="/images/AssetMarkdown/image-20230320222940089.png" alt="image-20230320222940089" style="zoom:80%;" /></p></li></ol><h3 id="计算贝塞尔曲面">11.3.2 计算贝塞尔曲面</h3><blockquote><p>可以将参数<code>(u,v)</code>，映射到曲面上的对应点，因此贝塞尔曲面是显示表示</p></blockquote><p><img src="/images/AssetMarkdown/image-20230320223338990.png" alt="image-20230320223338990" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230320223409877.png" alt="image-20230320223409877" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230320223417719.png" alt="image-20230320223417719" style="zoom:80%;" /></p><h1 id="第12课-几何3网格体">第12课 几何3：网格体</h1><h2 id="网格体的细分-subdivision">12.1 网格体的细分 Subdivision</h2><ol type="1"><li>引入更多三角形</li><li>调整顶点的位置，让网格体更加接近原样</li></ol><h3 id="loop细分三角形网格体">12.1.1 Loop细分：三角形网格体</h3><ol type="1"><li><p>连接三角形三条边的中点，可以将一个三角形划分为四个三角形</p><p><img src="/images/AssetMarkdown/image-20230321162509372.png" alt="image-20230321162509372" style="zoom:80%;" /></p></li><li><p>计算新的顶点的位置</p><ol type="1"><li>设新增的顶点为图中的白点，白点被原来的两个三角形<code>ABC、ABD</code>共享</li><li>则可以计算新的顶点的坐标值：<code>3/8 * (A+B) + 1/8 * (C+D)</code></li></ol><p><img src="/images/AssetMarkdown/image-20230321162618650.png" alt="image-20230321162618650" style="zoom:80%;" /></p></li><li><p>更改旧的顶点的位置</p><ol type="1"><li>设顶点的度为<code>n</code>，与<code>n</code>相关的一个数<code>u</code></li><li>则更改顶点的位置为：<code>(1-n*u) * 当前顶点原来的位置 + u * 相邻节点的位置之和</code></li></ol><p><img src="/images/AssetMarkdown/image-20230321162914642.png" alt="image-20230321162914642" style="zoom:80%;" /></p></li></ol><h3 id="catmull-clark细分一般的网格体">12.1.2Catmull-Clark细分：一般的网格体</h3><ol type="1"><li>quad face：四边形面</li><li>non-quad face：非四边形面</li><li>Extraordinary vertex：奇异点，度数不为4的点</li></ol><p><img src="/images/AssetMarkdown/image-20230321163537134.png" alt="image-20230321163537134" style="zoom:80%;" /></p><p>细分方法：</p><ol type="1"><li><p>增加新的点：每一条线取中点，每一个面取中点，然后将边上的中点与面中心的点连起来</p><ol type="1"><li>新出现了2个奇异点，度数均为2</li><li>每个原来的非四边形面均会引入一个奇异点，且一次操作后会消失</li></ol><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20230321163943647.png" alt="image-20230321163943647" style="zoom:80%;" /></th><thstyle="text-align: center;"><img src="/images/AssetMarkdown/image-20230321164016513.png" alt="image-20230321164016513" style="zoom:80%;" /></th><th><img src="/images/AssetMarkdown/image-20230321163957959.png" alt="image-20230321163957959" style="zoom:80%;" /></th></tr></thead><tbody></tbody></table></li><li><p>修改点的坐标</p><p><img src="/images/AssetMarkdown/image-20230321164236099.png" alt="image-20230321164236099" style="zoom:80%;" /></p></li></ol><h2 id="网格体简化-simplification">12.2 网格体简化 Simplification</h2><h3 id="边坍缩-collapsing-an-edge">12.2.1 边坍缩 Collapsing An Edge</h3><ol type="1"><li>选中一条边，将两个端点合并为一个顶点</li></ol><p><img src="/images/AssetMarkdown/image-20230321164735232.png" alt="image-20230321164735232" style="zoom:80%;" /></p><h3 id="二次度量误差-quadric-error-metrics">12.2.2 二次度量误差 QuadricError Metrics</h3><ol type="1"><li>将点放到某一个位置，使得其到原本与它关联面的距离平方和最小</li></ol><p><img src="/images/AssetMarkdown/image-20230321165037373.png" alt="image-20230321165037373" style="zoom:80%;" /></p><h3 id="边坍缩的二次误差">12.2.3 边坍缩的二次误差</h3><ol type="1"><li>假设坍缩该边，并且将坍缩后的点放到最佳位置，计算其二次度量误差</li><li>从误差小的边开始坍缩</li><li>但是每一次坍缩后，需要更新其他受影响边的二次度量误差：用堆维护</li><li>本质上是一个贪心算法，用局部最优，组成全局最优</li></ol><p><img src="/images/AssetMarkdown/image-20230321165529353.png" alt="image-20230321165529353" style="zoom:80%;" /></p><h1 id="第12课-阴影-shadow-mapping">第12课 阴影 Shadow Mapping</h1><ol type="1"><li>本质上是一个<strong>图像空间</strong>的算法<ol type="1"><li>不需要知道场景的几何信息</li><li>会存在<strong>走样</strong>现象</li></ol></li><li>核心思想：<ol type="1"><li>点不在阴影里 &lt;=&gt; 摄像机&amp;光源均可以看到该点</li></ol></li><li>ShadowMapping只能处理点光源的阴影，且会有明显的边界，即<strong>硬阴影</strong></li></ol><h2 id="第一步render-from-light">12.1 第一步：Render from Light</h2><p>从光源看向场景，记录看到的任何点的深度，即获取Z-Buffer</p><p><img src="/images/AssetMarkdown/image-20230321170213274.png" alt="image-20230321170213274" style="zoom:80%;" /></p><h2 id="第二步render-from-eye">12.2 第二步：Render from Eye</h2><ol type="1"><li><p>从摄像机看向场景，记录看到的点</p><p><img src="/images/AssetMarkdown/image-20230321170427126.png" alt="image-20230321170427126" style="zoom:80%;" /></p></li><li><p>将看到的点，投影回光源，判断该位置对应的光源看到的深度</p><ol type="1"><li>如果深度相同，则可以看到</li><li>如果深度不相同，则不可以看到</li></ol><p><img src="/images/AssetMarkdown/image-20230321170510434.png" alt="image-20230321170510434" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230321170625379.png" alt="image-20230321170625379" style="zoom:80%;" /></p></li></ol><h2 id="示例">12.3 示例</h2><p><img src="/images/AssetMarkdown/image-20230321170932574.png" alt="image-20230321170932574" style="zoom:80%;" /></p><ol type="1"><li><p>从光源看向场景，记录深度图</p><p><img src="/images/AssetMarkdown/image-20230321170818410.png" alt="image-20230321170818410" style="zoom:80%;" /></p></li><li><p>从相机看向场景，将每一个像素投影回光源看到的图像，对比两个深度</p><p><img src="/images/AssetMarkdown/image-20230321170902602.png" alt="image-20230321170902602" style="zoom:80%;" /></p></li><li><p>由于存在浮点精度、shadowmap的分辨率与场景的分辨率等问题，会导致阴影的各种问题</p></li></ol><h2 id="硬阴影与软阴影">12.4 硬阴影与软阴影</h2><ol type="1"><li>Umbra 本影：完全看不到光源</li><li>Penumbra 半影：看到部分光源</li><li>软阴影一定是因为光源存在大小</li></ol><p><img src="/images/AssetMarkdown/image-20230321171532601.png" alt="image-20230321171532601" style="zoom:80%;" /></p><h1 id="第13课-光线追踪1whitted-style-ray-tracing">第13课光线追踪1：Whitted-Style Ray Tracing</h1><h2 id="为什么要使用光线追踪">13.1 为什么要使用光线追踪</h2><ol type="1"><li><p>光栅化不能很好解决全局效果</p><ol type="1"><li>软阴影</li><li>Glossy反射</li><li>间接光照</li></ol><p><img src="/images/AssetMarkdown/image-20230321172627995.png" alt="image-20230321172627995" style="zoom:80%;" /></p></li><li><p>光栅化的速度很快，但是质量较低，通常用于实时渲染</p></li><li><p>光线追踪质量高，但是非常慢，通常用于离线制作</p></li></ol><h2 id="基础光线追踪算法">13.2 基础光线追踪算法</h2><h3 id="光线是什么">13.2.1 光线是什么</h3><ol type="1"><li>光线沿直线传播</li><li>光线和光线不会发生碰撞</li><li>光线从光源发出，经过反射、折射等过程，进入人的眼睛：<strong>光路可逆性</strong></li></ol><h3 id="光线投射">13.2.2 光线投射</h3><ol type="1"><li>eyeray：从<strong>眼睛</strong>到屏幕上的<strong>像素</strong>，连接的而成的射线，只记录最近的<strong>交点</strong></li><li>shadowray：从某个<strong>点</strong>到<strong>光源</strong>的连线</li><li>根据两条线的关系，判断着色</li></ol><p><img src="/images/AssetMarkdown/image-20230321173554636.png" alt="image-20230321173554636" style="zoom:80%;" /></p><h3 id="递归光线追踪">13.2.3 递归光线追踪</h3><p><img src="/images/AssetMarkdown/image-20230321173940996.png" alt="image-20230321173940996" style="zoom:80%;" /></p><ol type="1"><li>primary ray：即eye ray</li><li>secondary ray：经过折射/反射后的光线</li></ol><p><img src="/images/AssetMarkdown/image-20230321174050214.png" alt="image-20230321174050214" style="zoom:80%;" /></p><h2 id="光线和表面的交点">13.3 光线和表面的交点</h2><h3 id="光线的数学定义">13.3.1 光线的数学定义</h3><ol type="1"><li>起点<code>o</code>，方向<code>d</code></li><li>射线定义：<code>r(t) = o + td</code></li></ol><p><img src="/images/AssetMarkdown/image-20230321174353486.png" alt="image-20230321174353486" style="zoom:80%;" /></p><h3 id="光线-与-球-求交点">13.3.2 光线 与 球 求交点</h3><p><img src="/images/AssetMarkdown/image-20230321174429897.png" alt="image-20230321174429897" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230321174531995.png" alt="image-20230321174531995" style="zoom:80%;" /></p><h3 id="光线-与-隐式表面-求交点">13.3.3 光线 与 隐式表面 求交点</h3><p><img src="/images/AssetMarkdown/image-20230321174700426.png" alt="image-20230321174700426" style="zoom:80%;" /></p><h3 id="光线-与-三角形-求交点">13.3.4 光线 与 三角形 求交点</h3><blockquote><p>如果射线与物体的交点数量为<strong>奇数</strong>，则点在<strong>物体内</strong>；如果是<strong>偶数</strong>，则在<strong>物体外</strong></p></blockquote><ol type="1"><li>光线和平面求交</li><li>判断点是否在三角形内</li></ol><h4 id="平面的数学定义">13.3.4.1 平面的数学定义</h4><ol type="1"><li>给一个点<span class="math inline">\(p_0\)</span>，一条法线<spanclass="math inline">\(\vec{N}\)</span></li><li>则平面为：<span class="math inline">\((p-p_0)·\vec{N} =0\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20230321175203939.png" alt="image-20230321175203939" style="zoom:80%;" /></p><h4 id="光线和平面的交点">13.3.4.2 光线和平面的交点</h4><p><img src="/images/AssetMarkdown/image-20230321203414616.png" alt="image-20230321203414616" style="zoom:80%;" /></p><h4 id="moller-trumbore算法">13.3.4.3 Moller Trumbore算法</h4><ol type="1"><li>用重心坐标表示平面：<span class="math inline">\((1-b_1-b_2)\vec{P_0}+ b_1\vec{P_1} + b_2\vec{P_2}\)</span></li><li>判定点在射线上：<span class="math inline">\(t\ge 0\)</span></li><li>判定点在三角形内：<span class="math inline">\(b_1 \ge 0,b_2 \ge0\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20230321203545908.png" alt="image-20230321203545908" style="zoom:80%;" /></p><h2 id="加速-光线-与-三角形表面-求交">13.4 加速 光线 与 三角形表面求交</h2><h3 id="包围盒-bounding-volumes">13.4.1 包围盒 Bounding Volumes</h3><ol type="1"><li>用一个简单的形状，将物体包围起来，如果不能与包围盒相交，则一定不会与物体相交</li></ol><p><img src="/images/AssetMarkdown/image-20230321215130003.png" alt="image-20230321215130003" style="zoom:80%;" /></p><h3 id="轴对齐包围盒aabbaxis-aligned-bounding-box">13.4.2轴对齐包围盒AABB：Axis-Aligned Bounding Box</h3><ol type="1"><li><p>空间中的长方体，可以理解为3对表面的交集</p></li><li><p>轴对齐包围盒：长方体的每一个边，均与坐标轴平行</p></li><li><p>二维空间，光线与长方形求交</p><ol type="1"><li>对于竖着的情况，可以得到在<spanclass="math inline">\(t=t_{x-min}\)</span>时，与<spanclass="math inline">\(x=x_0\)</span>相交；在<spanclass="math inline">\(t=t_{x-max}\)</span>时，与<spanclass="math inline">\(x=x_1\)</span>相交</li><li>对于横着的情况，可以得到在<spanclass="math inline">\(t=t_{y-min}\)</span>时，与<spanclass="math inline">\(y=y_0\)</span>相交；在<spanclass="math inline">\(t=t_{y-max}\)</span>时，与<spanclass="math inline">\(y=y_1\)</span>相交</li><li>由于长方形可以看作四条线的交集，因此光线在长方形中的部分，也可以看作<spanclass="math inline">\([t_{x-min},t_{x-max}]\)</span>和<spanclass="math inline">\([t_{y-min},t_{y-max}]\)</span>的交集</li><li>从而可以得到光线与长方形的交点对应的时间<spanclass="math inline">\(t_{enter} =\max(t_{x-min},t_{y-min})\)</span>，<spanclass="math inline">\(t_{exit}=\min(t_{x-max},t_{y-max})\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20230321220625451.png" alt="image-20230321220625451" style="zoom:80%;" /></p></li><li><p>三维空间，光线与长方体求交</p><ol type="1"><li>只有当光线同时进入了3对表面，才能说光线进入了长方体</li><li>光线只要离开了1对表面，就说钢线离开了长方体</li><li>对于每一对表面，计算一次<spanclass="math inline">\([t_{min},t_{max}]\)</span></li><li>则对于长方体来说，<span class="math inline">\(t_{enter} =\max(t_{min})\)</span>，<spanclass="math inline">\(t_{exit}=\min(t_{max})\)</span></li></ol></li><li><p>如果<spanclass="math inline">\(t_{exit}&lt;0\)</span>，则说明盒子在光线的背后，不可能有交点</p></li><li><p>如果<span class="math inline">\(t_{exit}\ge0,t_{enter}&lt;0\)</span>，则说明光线的起点在盒子里面，肯定有交点</p></li></ol><p><strong>因此，光线与AABB有交点，当且仅当：<spanclass="math inline">\(t_{enter}&lt;t_{exit}\)</span> 并且 <spanclass="math inline">\(t_{exit} \ge 0\)</span></strong></p><h1 id="第14课-光线追踪2使用aabb包围盒加速光线追踪">第14课光线追踪2：使用AABB包围盒加速光线追踪</h1><h2 id="直接使用aabb包围盒">14.1 直接使用AABB包围盒</h2><ol type="1"><li><p>找到包围盒</p></li><li><p>将包围盒分为格子<code>Grid</code></p></li><li><p>如果某个格子与物体的表面相交，则标记该格子</p><p><img src="/images/AssetMarkdown/image-20230321222357738.png" alt="image-20230321222357738" style="zoom:80%;" /></p></li><li><p>将光线与格子求交</p><ol type="1"><li>如果光线与格子相交，且格子内有物体，则将光线与对应物体求交</li></ol><p><img src="/images/AssetMarkdown/image-20230321222609290.png" alt="image-20230321222609290" style="zoom:80%;" /></p></li><li><p>格子过于稀疏 or 过于密集，均会使效率变低</p></li><li><p>通常，格子的数量是场景中的物体数目的整数倍：<code>#cells = C * #objs</code></p><p><img src="/images/AssetMarkdown/image-20230321222827253.png" alt="image-20230321222827253" style="zoom:80%;" /></p></li></ol><h2 id="空间划分-spatial-partitions">14.2 空间划分 SpatialPartitions</h2><p>将空间划分为大小不同的盒子</p><p>缺点：</p><ol type="1"><li>难以判断哪些三角形属于当前格子</li><li>一个三角形可能会处在多个格子中</li></ol><p><img src="/images/AssetMarkdown/image-20230321225126054.png" alt="image-20230321225126054" style="zoom:80%;" /></p><h3 id="kd-tree-预处理">14.2.1 KD-Tree 预处理</h3><ol type="1"><li>注意，每一个部分都要划分，按照水平、竖直的顺序交替分割</li><li>中间节点：<ol type="1"><li>分割轴：x、y、z</li><li>分割位置：在分割轴上的分割点的坐标</li><li>子节点：指向子节点的指针，有2个子节点</li></ol></li><li>叶节点：<ol type="1"><li>记录和该格子相交的物体</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230322164639853.png" alt="image-20230322164639853" style="zoom:80%;" /></p><h3 id="kd-tree加速光线追踪">14.2.2 KD-Tree加速光线追踪</h3><ol type="1"><li>如果光线和格子没有交点，则不做操作</li><li>如果光线和格子有交点<ol type="1"><li>如果格子为叶节点，则光线与叶节点中的所有物体求交</li><li>否则与格子的两个子节点求交</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230322170220976.png" alt="image-20230322170220976" style="zoom:80%;" /></p><h2 id="物体划分-object-partitions">14.3 物体划分 Object Partitions</h2><ol type="1"><li>将物体分为两堆，然后再求包围盒</li><li>包围盒之间可能有相交，但可以保证一个三角形最多只在一个包围盒中</li></ol><h3 id="层次包围盒-bvhbounding-volume-hierarchy">14.3.1 层次包围盒BVH：Bounding Volume Hierarchy</h3><ol type="1"><li>找到一个包围盒</li><li>递归的将包围盒中的物体划分为两个部分</li><li>重新计算包围盒</li><li>重复23，直到每个包围和中的物体数量足够少</li><li>将物体存在每个叶节点中</li></ol><p><img src="/images/AssetMarkdown/image-20230322171211451.png" alt="image-20230322171211451" style="zoom:80%;" /></p><h3 id="划分方法">14.3.2 划分方法</h3><ol type="1"><li>每次找最长的轴进行划分</li><li>每次找第n/2个三角形，进行划分，保证两边的三角形个数相差不多<ol type="1"><li>根据重心坐标，划分三角形的位置</li><li>可以类似于找第k大数，通过快排，在O(n)时间内找到</li></ol></li><li>如果场景中的物体移动了，就需要重新建立BVH树</li></ol><h3 id="bvh加速光线追踪">14.3.3 BVH加速光线追踪</h3><ol type="1"><li>如果光线和包围盒没有交点，则不做操作</li><li>如果光线和包围盒有交点<ol type="1"><li>如果包围盒为叶节点，则光线与叶节点中的所有物体求交</li><li>否则与包围盒的两个子节点求交</li></ol></li></ol><h3 id="空间划分-vs-物体划分">14.3.4 空间划分 vs 物体划分</h3><p><img src="/images/AssetMarkdown/image-20230322172055257.png" alt="image-20230322172055257" style="zoom:80%;" /></p><h1 id="第15课-光线追踪3brdf-渲染方程">第15课 光线追踪3：BRDF &amp;渲染方程</h1><h2 id="辐射度量学-basic-radiometry">15.1 辐射度量学 Basicradiometry</h2><ol type="1"><li>如何描述光照：定义了一系列的方法和单位</li><li>给光赋予了一系列空间上的属性（依旧是基于几何光学）<ol type="1"><li>Radiant flux：辐射通量</li><li>intensity：强度</li><li>irradiance：辐射通量密度</li><li>radiance：辐射</li></ol></li><li>在物理上准确定义光照的方法</li></ol><p><img src="/images/AssetMarkdown/image-20230322174129089.png" alt="image-20230322174129089" style="zoom:80%;" /></p><h3 id="radiant-fluxpower单位时间的能量">15.1.1 RadiantFlux/Power：单位时间的能量</h3><ol type="1"><li>Radiant <strong>Energy</strong>：光源辐射出来的能量，<spanclass="math inline">\(Q\)</span>，单位为<strong>焦耳J</strong>，在CG中基本不使用</li><li>Radiant <strong>Flux/Power</strong>：单位时间内发射的能量，<spanclass="math inline">\(\Phi=\frac{dQ}{dt}\)</span>，单位为<strong>瓦特W</strong>/<strong>流明lm=lumen</strong></li></ol><h3 id="radiant-intensity单位立体角的能量">15.1.2 RadiantIntensity：单位立体角的能量</h3><ol type="1"><li>Radiant <strong>Intensity</strong>：单位立体角上的power，<spanclass="math inline">\(I(\omega)=\frac{d\Phi}{d\omega}\)</span>，单位为<strong>坎德拉cd</strong><ol type="1"><li>也就是光源在某个方向上的亮度</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230322174233794.png" alt="image-20230322174233794" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230322175039042.png" alt="image-20230322175039042" style="zoom:80%;" /></p><h4 id="立体角-solid-angles">15.1.2.1 立体角 Solid Angles</h4><ol type="1"><li>角度：<spanclass="math inline">\(\theta=\frac{l}{r}\)</span>，单位为<strong>rad</strong></li><li>立体角：<spanclass="math inline">\(\Omega=\frac{A}{r^2}\)</span>，单位为<strong>sr</strong></li></ol><p><img src="/images/AssetMarkdown/image-20230322174554385.png" alt="image-20230322174554385" style="zoom:80%;" /></p><h4 id="单位立体角-differential-solid-angles">15.1.2.2 单位立体角Differential Solid Angles</h4><ol type="1"><li>单位面积：<span class="math inline">\(dA=r^2sin\theta\ d\theta\d\phi\)</span></li><li>单位立体角：<span class="math inline">\(d\omega=sin\theta\ d\theta\d\phi\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20230322174804469.png" alt="image-20230322174804469" style="zoom:80%;" /></p><h3 id="irradiance单位面积的能量">15.1.4 Irradiance：单位面积的能量</h3><ol type="1"><li><p>Irradiance：表面上<strong>与光线垂直</strong>的单位面积接收到的能量，<spanclass="math inline">\(E(x)=\frac{d\phi(x)}{dA}\)</span>，单位<strong><spanclass="math inline">\(\frac{W}{m^2}\)</span>，<spanclass="math inline">\(\frac{lm}{m^2}\)</span>=lux</strong></p><ol type="1"><li>如果表面与光线<strong>不垂直</strong>，则需要投影到垂直方向：<spanclass="math inline">\(E(x)=\frac{d\phi(x)}{dA}\ \cos\theta\)</span>，<spanclass="math inline">\(\theta\)</span>为光线与法线的夹角</li></ol><p><img src="/images/AssetMarkdown/image-20230323202218229.png" alt="image-20230323202218229" style="zoom:80%;" /></p></li><li><p>光在传播的过程中，Intensity没有变，而Irradiate变小了，因为面积变大了</p><p><img src="/images/AssetMarkdown/image-20230323202709508.png" alt="image-20230323202709508" style="zoom:80%;" /></p></li></ol><h3 id="radiance单位立体角单位面积的能量">15.1.5Radiance：单位立体角&amp;单位面积的能量</h3><ol type="1"><li>Radiance：表面上<strong>与光线垂直</strong>的单位面积接收到的能量，<spanclass="math inline">\(L(p,\omega)=\frac{d^2\phi(p,\omega)}{d\omega dAcos \theta}\)</span>，单位<strong><span class="math inline">\(\frac{cd}{m^2}\)</span>，<span class="math inline">\(\frac{lm}{sr\m^2}=\frac{lm}{sr\ m^2}\)</span>=nit</strong><ol type="1"><li>单位面积的Intensity：<spanclass="math inline">\(L(p,\omega)=\frac{dI(p,\omega)}{dA cos\theta}\)</span></li><li>单位立体角的Irradiance：<spanclass="math inline">\(L(p,\omega)=\frac{dE(p)}{d\omega cos\theta}\)</span></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230323203046905.png" alt="image-20230323203046905" style="zoom:80%;" /></p><h3 id="irradiance-vs-radiance">15.1.6 Irradiance vs Radiance</h3><ol type="1"><li><strong>Irradiance</strong>：单位面积<strong>dA</strong>接收到的所有能量，<spanclass="math inline">\(E(p)\)</span></li><li><strong>Radiance</strong>：单位面积<strong>dA</strong>在单位方向<strong>dω</strong>处接收到的所有能量，<spanclass="math inline">\(L(p,\omega)\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20230323203503761.png" alt="image-20230323203503761" style="zoom:80%;" /></p><h2 id="brdf双向反射分布函数">15.2 BRDF：双向反射分布函数</h2><blockquote><p><strong>Bidirectional Reflectance Distribution Function</strong></p></blockquote><h3 id="某个点的反射">15.2.1 某个点的反射</h3><ol type="1"><li>单位面积<strong>dA</strong>，在某个单位立体角<strong>ω<sub>i</sub></strong>处吸收能量<strong>dE(ω<sub>i</sub>)</strong></li><li>会反射到另一个单位立体角<strong>ω<sub>r</sub></strong>、单位面积的能量<strong>dL<sub>r</sub>(x,ω<sub>r</sub>)</strong></li></ol><p><img src="/images/AssetMarkdown/image-20230323204145095.png" alt="image-20230323204145095" style="zoom:80%;" /></p><h3 id="brdf">15.2.2 BRDF</h3><ol type="1"><li>入射光的Radiance：<strong>dE<sub>i</sub>(ω<sub>i</sub>)</strong></li><li>反射光的Irradiance：<strong>dL<sub>r</sub>(ω<sub>r</sub>)</strong></li><li>入射光在反射方向的能量分布比例<strong>f<sub>r</sub>(ω<sub>i</sub> →ω<sub>r</sub>)</strong>为：<ol type="1"><li>入射光的Radiance / 反射光的Irradiance</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230323204215288.png" alt="image-20230323204215288" style="zoom:80%;" /></p><h3 id="反射方程-reflection-equation">15.2.3 反射方程 ReflectionEquation</h3><ol type="1"><li>某个着色点<strong>p</strong>，当反射方向为<strong>ω<sub>r</sub></strong>是，反射的光<strong>L<sub>r</sub>(p,ω<sub>r</sub>)</strong>为：<ol type="1"><li>在每个入射方向<strong>ω<sub>i</sub></strong>的反射的能量<strong>f<sub>r</sub>(p,ω<sub>i</sub> → ω<sub>r</sub>) L<sub>i</sub>(p, ω<sub>i</sub>) cosθ<sub>i</sub></strong>，对入射方向立体角<strong>dω<sub>i</sub></strong>的积分</li><li>只考虑半球<strong>H<sup>2</sup> / Ω+</strong></li></ol></li><li>问题：任何出射的radiance，都可能作为其他着色点的入射的radiance，因此存在递归定义</li></ol><p><img src="/images/AssetMarkdown/image-20230323204816473.png" alt="image-20230323204816473" style="zoom:80%;" /></p><h2 id="渲染方程-rendering-equation">15.3 渲染方程 RenderingEquation</h2><p>某个点<strong>p</strong>向某个方向<strong>ω<sub>o</sub></strong>出射的光<strong>L<sub>o</sub>(p,ω<sub>o</sub>)</strong>由两部分构成</p><ol type="1"><li>自己产生的光：<span class="math inline">\(L_e(p, ω_o)\)</span></li><li>反射的光：<spanclass="math inline">\(\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n·\omega_i)d\omega_i\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20230323205330782.png" alt="image-20230323205330782" style="zoom:80%;" /></p><h3 id="一个点光源">15.3.1 一个点光源</h3><p><img src="/images/AssetMarkdown/image-20230323211001791.png" alt="image-20230323211001791" style="zoom:80%;" /></p><h3 id="很多个点光源加和">15.3.2 很多个点光源：加和</h3><p><img src="/images/AssetMarkdown/image-20230323211106534.png" alt="image-20230323211106534" style="zoom:80%;" /></p><h3 id="面光源很多个点光源的集合-积分">15.3.3 面光源：很多个点光源的集合=&gt; 积分</h3><p><img src="/images/AssetMarkdown/image-20230323211423936.png" alt="image-20230323211423936" style="zoom:80%;" /></p><h3 id="其他表面的反射当成面光源使用">15.3.4其他表面的反射：当成面光源使用</h3><p><img src="/images/AssetMarkdown/image-20230323211407432.png" alt="image-20230323211407432" style="zoom:80%;" /></p><h3 id="渲染方程的简化表示">15.3.5 渲染方程的简化表示</h3><blockquote><p>积分方程</p></blockquote><p><img src="/images/AssetMarkdown/image-20230323211552304.png" alt="image-20230323211552304" style="zoom:80%;" /></p><blockquote><p>线性算子等式</p></blockquote><p><img src="/images/AssetMarkdown/image-20230323211712567.png" alt="image-20230323211712567" style="zoom:80%;" /></p><h3 id="光线弹射n次的光线追踪-全局光照">15.3.6 光线弹射n次的光线追踪=&gt; 全局光照</h3><p><img src="/images/AssetMarkdown/image-20230323212038657.png" alt="image-20230323212038657" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230323212529890.png" alt="image-20230323212529890" style="zoom:80%;" /></p><h2 id="概率论">15.4 概率论</h2><h3 id="pdf概率分布函数x-px">15.4.1 PDF：概率分布函数，X ~ p(x)</h3><blockquote><p><strong>Probability Distribution Function</strong></p></blockquote><p><img src="/images/AssetMarkdown/image-20230323213850665.png" alt="image-20230323213850665" style="zoom:80%;" /></p><h3 id="随机变量函数的期望">15.4.2 随机变量函数的期望</h3><p><img src="/images/AssetMarkdown/image-20230323214009047.png" alt="image-20230323214009047" style="zoom:80%;" /></p><h1 id="第16课-光线追踪4蒙特卡洛积分-路径追踪">第16课光线追踪4：蒙特卡洛积分 &amp; 路径追踪</h1><h2 id="复习">16.1 复习</h2><blockquote><p>渲染方程：描述了光线的传递</p></blockquote><p><img src="/images/AssetMarkdown/image-20230323221310058.png" alt="image-20230323221310058" style="zoom:80%;" /></p><ol type="1"><li>存在积分</li><li>是一个递归的计算：因为入射光可能是其他面的反射光</li></ol><h2 id="蒙特卡洛积分采样求定积分">16.2 蒙特卡洛积分：采样求定积分</h2><p><img src="/images/AssetMarkdown/image-20230323221704667.png" alt="image-20230323221704667" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230323222122882.png" alt="image-20230323222122882" style="zoom:80%;" /></p><ol type="1"><li>在<spanclass="math inline">\([a,b]\)</span>中采样多次，设每次采样点为<spanclass="math inline">\(x_i\)</span>，对应的函数值为<spanclass="math inline">\(f(x_i)\)</span>，则使用<spanclass="math inline">\((b-a)*f(x_i)\)</span>，近似定积分的值</li><li>当采样次数足够多时，求平均值，即可得到实际的定积分的值</li><li>设随机采样点<span class="math inline">\(X_i\)</span> ~ <spanclass="math inline">\(p(x)\)</span>，要求<spanclass="math inline">\(\int_{a}^bp(x)=1\)</span>，则蒙特卡洛的积分值为：<spanclass="math inline">\(F_N=\frac{1}{N}\sum_{i=1}^{N}\frac{f(X_i)}{p(X_i)}\)</span></li></ol><blockquote><p>示例：用<span class="math inline">\(X_i\)</span> ~ <spanclass="math inline">\(p(x)\)</span> = C采样</p><p><img src="/images/AssetMarkdown/image-20230323222403543.png" alt="image-20230323222403543" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230323222419854.png" alt="image-20230323222419854" style="zoom:80%;" /></p></blockquote><p>注意：</p><ol type="1"><li>采样次数越多，结果越精确</li><li>在x上采样，则就是在x上积分</li></ol><h2 id="路径追踪path-tracing">16.3 路径追踪：Path Tracing</h2><h3 id="whitted-style-ray-tracing-的做法存在的问题">16.3.1 Whitted-StyleRay Tracing 的做法存在的问题</h3><p>不断的弹射光线，在任意一个位置均弹射光线</p><ol type="1"><li>如果是光滑物体：则沿镜面方向反射、折射方向折射</li><li>如果是漫反射物体：停止弹射</li></ol><p>存在问题：</p><ol type="1"><li>对于glossy物体，不能按照specular那样的镜面反射处理</li><li>漫反射物体会将光线均匀的弹射到各个部分，而非不反射</li></ol><h3 id="使用蒙特卡洛积分实现渲染方程中的积分">16.3.2使用蒙特卡洛积分，实现渲染方程中的积分</h3><p><img src="/images/AssetMarkdown/image-20230323224040938.png" alt="image-20230323224040938" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230323224120396.png" alt="image-20230323224120396" style="zoom:80%;" /></p><h4 id="直接光照">16.3.2.1 直接光照</h4><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li>随机选择<strong>N</strong>个方向，N的分布满足某一种PDF</li><li><strong>L<sub>o</sub></strong>初始化为0.0</li><li>对于每一个方向<strong>ω<sub>i</sub></strong><ol type="1"><li>追踪光线<strong>r(p, ω<sub>i</sub>)</strong></li><li>如果光线<strong>r</strong>击中了光源<ol type="1"><li><strong>L<sub>o</sub> += (1/N) * L<sub>i</sub> * f<sub>r</sub> * cosθ / PDF(ω<sub>i</sub>)</strong></li></ol></li></ol></li><li>返回<strong>L<sub>o</sub></strong></li></ol><h4 id="间接光照">16.3.2.2 间接光照</h4><blockquote><p>相当于从P点看Q点的直接光照</p></blockquote><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li>随机选择<strong>N</strong>个方向，N的分布满足某一种PDF</li><li><strong>L<sub>o</sub></strong>初始化为0.0</li><li>对于每一个方向<strong>ω<sub>i</sub></strong><ol type="1"><li>追踪光线<strong>r(p,ω<sub>i</sub>)</strong>（p点发出，方向为ω<sub>i</sub>）</li><li>如果光线<strong>r</strong>击中了光源<ol type="1"><li><strong>L<sub>o</sub> += (1/N) * L<sub>i</sub> * f<sub>r</sub> * cosθ / PDF(ω<sub>i</sub>)</strong></li></ol></li><li>如果光线<strong>r</strong>击中了物体，且物体位于<strong>q</strong><ol type="1"><li><strong>L<sub>o</sub> += (1/N) * shade(q, -ω<sub>i</sub>) *f<sub>r</sub> * cos θ / PDF(ω<sub>i</sub>)</strong></li></ol></li></ol></li><li>返回<strong>L<sub>o</sub></strong></li></ol><p><img src="/images/AssetMarkdown/image-20230323224729779.png" alt="image-20230323224729779" style="zoom:80%;" /></p><h2 id="路径追踪解决光线数量爆炸">16.4 路径追踪：解决光线数量爆炸</h2><blockquote><p>问题：光线的数量会爆炸：光线数量 = N <sup>反射次数</sup>，只有当N =1时，才不会指数爆炸 ==&gt; 路径追踪</p></blockquote><p><img src="/images/AssetMarkdown/image-20230323225058558.png" alt="image-20230323225058558" style="zoom:80%;" /></p><h3 id="每一个着色点只使用1根光线进行追踪">16.4.1每一个着色点，只使用1根光线进行追踪</h3><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li>随机选择<strong>1</strong>个方向<strong>ω<sub>i</sub></strong>，ω<sub>i</sub>的分布满足某一种PDF</li><li>追踪光线<strong>r(p,ω<sub>i</sub>)</strong>（p点发出，方向为ω<sub>i</sub>）</li><li>如果光线<strong>r</strong>击中了光源<ol type="1"><li>返回 <strong>L<sub>o</sub> = L<sub>i</sub> * f<sub>r</sub> * cos θ /PDF(ω<sub>i</sub>)</strong></li></ol></li><li>如果光线<strong>r</strong>击中了物体，且物体位于<strong>q</strong><ol type="1"><li>返回 <strong>L<sub>o</sub> = shade(q, -ω<sub>i</sub>) *f<sub>r</sub> * cos θ / PDF(ω<sub>i</sub>)</strong></li></ol></li></ol><h3 id="解决噪声问题选择多个穿过该着色点的路径每个路径1条光线">16.4.2解决噪声问题：选择多个穿过该着色点的路径，每个路径1条光线</h3><p><strong>ray_generation(camPos, pixel)</strong></p><ol type="1"><li>在该像素中，随机选择<strong>N</strong>个采样位置</li><li><strong>pixel_radiance = 0.0</strong></li><li>对于每一个采样位置<ol type="1"><li>追踪光线<strong>r(camPos, cam_to_sample)</strong></li><li>如果光线<strong>r</strong>在<strong>p</strong>点击中场景<ol type="1"><li><strong>pixel_radiance += (1/N) * shade(p,sample_to_cam)</strong></li></ol></li></ol></li><li>返回<strong>pixel_radiance</strong></li></ol><p><img src="/images/AssetMarkdown/image-20230323225611788.png" alt="image-20230323225611788" style="zoom:80%;" /></p><h3 id="解决递归无法停下问题runssian-roulette">16.4.3解决递归无法停下问题：Runssian Roulette</h3><blockquote><p>问题：<strong>shade(p,ω<sub>o</sub>)</strong>是递归定义的，可能无法停下 ==&gt;RR，一定概率停止追踪</p></blockquote><ol type="1"><li>定义一个概率<strong>P</strong></li><li><strong>P</strong>的概率，发射一个光线，并且返回<strong>L<sub>o</sub>/ P</strong></li><li><strong>1-P</strong>的概率，不发射光线，返回<strong>0</strong></li><li>最后的期望依旧为<strong>L<sub>o</sub></strong></li></ol><p><img src="/images/AssetMarkdown/image-20230323230308526.png" alt="image-20230323230308526" style="zoom:80%;" /></p><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li>定义概率<strong>P_RR</strong></li><li>随机生成一个在<strong>[0,1]</strong>的实数<strong>dist</strong>，如果<strong>dist&gt;P_RR</strong>，则返回<strong>0.0</strong></li><li>随机选择<strong>1</strong>个方向<strong>ω<sub>i</sub></strong>，ω<sub>i</sub>的分布满足某一种PDF</li><li>追踪光线<strong>r(p,ω<sub>i</sub>)</strong>（p点发出，方向为ω<sub>i</sub>）</li><li>如果光线<strong>r</strong>击中了光源<ol type="1"><li>返回 <strong>L<sub>o</sub> = L<sub>i</sub> * f<sub>r</sub> * cos θ /PDF(ω<sub>i</sub>) / P_RR</strong></li></ol></li><li>如果光线<strong>r</strong>击中了物体，且物体位于<strong>q</strong><ol type="1"><li>返回 <strong>L<sub>o</sub> = shade(q, -ω<sub>i</sub>) *f<sub>r</sub> * cos θ / PDF(ω<sub>i</sub>) / P_RR</strong></li></ol></li></ol><h3 id="让路径追踪变得高效对光源采样">16.4.4让路径追踪变得高效：对光源采样</h3><blockquote><p>均匀采样，导致很多光线无法打到小的光源，导致浪费计算力</p></blockquote><p><img src="/images/AssetMarkdown/image-20230323231200753.png" alt="image-20230323231200753" style="zoom:80%;" /></p><blockquote><p>对光源进行采样，然后将渲染方程修改为对光源的积分：即找到<strong>dω</strong> 与 <strong>dA</strong> 的关系</p></blockquote><p><img src="/images/AssetMarkdown/image-20230323231551425.png" alt="image-20230323231551425" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230323231600802.png" alt="image-20230323231600802" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230323231643529.png" alt="image-20230323231643529" style="zoom:80%;" /></p><blockquote><p>优化算法</p></blockquote><p>将radiance分为两个部分：</p><ol type="1"><li>来自光源的radiance：直接采样光源</li><li>其他反射光：使用RR的方法</li></ol><p><img src="/images/AssetMarkdown/image-20230323231831265.png" alt="image-20230323231831265" style="zoom:80%;" /></p><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li><blockquote><p>光源的贡献</p></blockquote><ol type="1"><li>均匀的对位于<strong>x'</strong>的光源进行采样，<strong>PDF_light = 1/ A</strong></li><li>从<strong>p</strong>向<strong>x'</strong>发射一条光线，如果光线不会被阻挡，则<ol type="1"><li><strong>L_dir = L<sub>i</sub> * f<sub>r</sub> * cos θ * cos θ‘ / |x'- p|<sup>2</sup> / PDF_light</strong></li></ol></li></ol></li><li><blockquote><p>其他反射光的贡献</p></blockquote><ol type="1"><li><strong>L_indir = 0.0</strong></li><li>判断是否需要采样，RR的概率为<strong>P_RR</strong></li><li>均匀的对半球进行采样，方位角为<strong>ω<sub>i</sub></strong>，<strong>PDF_hemi= 1 / 2Π</strong></li><li>追踪光线<strong>r(p,ω<sub>i</sub>)</strong>（p点发出，方向为ω<sub>i</sub>）</li><li>如果光线<strong>r</strong>击中了<strong>非发光体</strong>，且物体位于<strong>q</strong><ol type="1"><li><strong>L_indir = shade(q, -ω<sub>i</sub>) * f<sub>r</sub> * cos θ /PDF_hemi / P_RR</strong></li></ol></li></ol></li><li>返回<strong>L_dir + L_indir</strong></li></ol><h1 id="第17课-材质与外观">第17课 材质与外观</h1><h2 id="材质-brdf-btdf-bsdf">17.1 材质 == BRDF + BTDF= BSDF</h2><h3 id="漫反射材质-brdf">17.1.1 漫反射材质 BRDF</h3><ol type="1"><li>光线会被均匀的反射到每个方向</li><li>完全不吸收能量、不发光的漫反射材质：<spanclass="math inline">\(f_r=\frac{\rho}{\pi} \in[0,\frac{1}{\pi}]\)</span><ol type="1"><li>其中<span class="math inline">\(\rho \in[0,1]\)</span>，表示对光的反射率</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230324152718150.png" alt="image-20230324152718150" style="zoom:80%;" /></p><h3 id="镜面反射-brdf">17.1.2 镜面反射 BRDF</h3><ol type="1"><li>将入射光、反射光、平面放到立体角中</li><li>立体角坐标轴的Z轴方向为法线方向，XY平面为物体表面</li></ol><p><img src="/images/AssetMarkdown/image-20230322174804469.png" alt="image-20230322174804469" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230324153808848.png" alt="image-20230324153808848" style="zoom:80%;" />-</p><h3 id="折射-btdf">17.1.3 折射 BTDF</h3><ol type="1"><li>使用折射定律，算出反射角对应的<spanclass="math inline">\(\theta\)</span></li><li>然后通过方位角，求解对应向量</li></ol><p><img src="/images/AssetMarkdown/image-20230324154159876.png" alt="image-20230324154159876" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230324154758730.png" alt="image-20230324154758730" style="zoom:80%;" /></p><h3 id="菲涅尔项多少光反射多少光折射">17.1.4菲涅尔项：多少光反射，多少光折射</h3><ol type="1"><li><strong>反射率</strong>取决于<strong>入射角度</strong></li></ol><p><img src="/images/AssetMarkdown/image-20230324161453003.png" alt="image-20230324161453003" style="zoom:80%;" /></p><blockquote><p><img src="/images/AssetMarkdown/image-20230324155034305.png" alt="image-20230324155034305" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230324161318996.png" alt="image-20230324161318996" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230324161350170.png" alt="image-20230324161350170" style="zoom:80%;" /></p></blockquote><h2 id="微表面模型-microfacet-material">17.2 微表面模型 MicrofacetMaterial</h2><ol type="1"><li>从近处看：看到几何</li><li>从远处看：看到材质、外观</li></ol><p><img src="/images/AssetMarkdown/image-20230324161736587.png" alt="image-20230324161736587" style="zoom:80%;" /></p><h3 id="微表面brdf">17.2.1 微表面BRDF</h3><ol type="1"><li>微表面都是完全的镜子，只有在镜面反射方向，才能看到反射光线</li><li>微表面的法线分布，可以表示表面的粗糙程度<ol type="1"><li>法线分布集中 &lt;=&gt; glossy</li><li>法线分布发散 &lt;=&gt; diffuse</li></ol></li><li>当光线接近平行射入表面时，微表面之间的相互遮挡较大<ol type="1"><li>称为grazing angle</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230330212241199.png" alt="image-20230330212241199" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330212608972.png" alt="image-20230330212608972" style="zoom:80%;" /></p><h3 id="各向同性各向异性材质-isotropicanisotropic-materials">17.2.2各向同性/各向异性材质 Isotropic/Anisotropic Materials</h3><p><img src="/images/AssetMarkdown/image-20230330213918232.png" alt="image-20230330213918232" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330214126623.png" alt="image-20230330214126623" style="zoom:80%;" /></p><h2 id="brdf的性质">17.3 BRDF的性质</h2><ol type="1"><li><p>值非负：<span class="math inline">\(f_r(\omega_i \rightarrow\omega_r) \ge 0\)</span></p></li><li><p>线性性质：<spanclass="math inline">\(L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i\rightarrow \omega_r)L_i(p, \omega_i)cos \theta_i\d\omega_i\)</span></p><ol type="1"><li>可以分成很多块，然后相加</li></ol><p><img src="/images/AssetMarkdown/image-20230330214746731.png" alt="image-20230330214746731" style="zoom:80%;" /></p></li><li><p>可逆性：<span class="math inline">\(f_r(\omega_i \rightarrow\omega_r) = f_r(\omega_r \rightarrow \omega_i)\)</span></p><p><img src="/images/AssetMarkdown/image-20230330214759683.png" alt="image-20230330214759683" style="zoom:80%;" /></p></li><li><p>能量守恒：<span class="math inline">\(\forall \omega_r,\int_{H^2}f_r(\omega_i \rightarrow \omega_r)cos \theta_i\ d\omega_i \le1\)</span></p><ol type="1"><li>BRDF不可能让能量变多</li><li>因此，光线追踪经过很多次反射后，能量会收敛</li></ol></li><li><p>各向同性 &amp; 各向异性</p><ol type="1"><li>各向同性：<spanclass="math inline">\(f_r(\theta_i,\phi_i;\theta_r,\phi_r)=f_r(\theta_i,\theta_r,\phi_r-\phi_i)\)</span><ol type="1"><li>降低了一个维度的自由度</li></ol></li><li>考虑对称性，对于所有的BRDF：<spanclass="math inline">\(f_r(\theta_i,\theta_r,\phi_r-\phi_i)=f_r(\theta_r,\theta_i,\phi_i-\phi_r)=f_r(\theta_i,\theta_r,|\phi_r-\phi_i|)\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20230330215347624.png" alt="image-20230330215347624" style="zoom:80%;" /></p></li></ol><h2 id="测量brdf">17.4 测量BRDF</h2><ol type="1"><li>给定一个光源(入射方向)、一个摄像机(出射方向)</li><li>更改这光源和摄像机的位置，测量对应的BRDF</li><li>优化：<ol type="1"><li>对于各向同性的物体，可以通过方位角，将4D转化为3D</li><li>可逆性：降低了一半的测量次数</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230330215511604.png" alt="image-20230330215511604" style="zoom: 80%;" /></p><h2 id="保存brdf">17.5 保存BRDF</h2><p>MERL BRDF Database：</p><ol type="1"><li>测量了很多不同的材质</li><li>保存为三维数组</li></ol><p><img src="/images/AssetMarkdown/image-20230330220014005.png" alt="image-20230330220014005" style="zoom:80%;" /></p><h1 id="第18课-高级渲染">第18课 高级渲染</h1><h2 id="高级光线传播">18.1 高级光线传播</h2><h3 id="无偏-有偏-蒙特卡洛估计">18.1.1 无偏 &amp; 有偏 蒙特卡洛估计</h3><ol type="1"><li>无偏：不论样本数是多少，估计值的期望总是正确的</li><li>有偏：期望和正确值不一样；但是样本数足够多时，会收敛到正确值<strong>consistency</strong><ol type="1"><li>有偏 = 模糊</li><li>一致性 = 样本足够多时可以收敛到不模糊</li></ol></li></ol><h3 id="双向路径追踪-bdpt">18.1.2 双向路径追踪 BDPT</h3><ol type="1"><li>从光源、观察点开始，分别生成两个不同的半路径</li><li>将半路径的端点连起来</li><li>缺点：渲染速度慢</li></ol><p><img src="/images/AssetMarkdown/image-20230330220720680.png" alt="image-20230330220720680" style="zoom:80%;" /></p><blockquote><p>对于间接光较多的场景，双向路径追踪效果更好</p></blockquote><p><img src="/images/AssetMarkdown/image-20230330220814339.png" alt="image-20230330220814339" style="zoom:80%;" /></p><h3 id="metropolis光线传播-mlt">18.1.3 Metropolis光线传播 MLT</h3><ol type="1"><li>用马尔科夫链进行采样<ol type="1"><li>马尔科夫链：当前有一个样本，返回一个与之接近的样本</li><li>优点：可以生成一个样本分布与与任意函数形状一致的PDF</li></ol></li><li>给任意一个路径，可以生成与之相似的路径：是一个局部的方法</li></ol><p><img src="/images/AssetMarkdown/image-20230330221257024.png" alt="image-20230330221257024" style="zoom:80%;" /></p><blockquote><p>适用于做困难的路径传播，因为可以由一条较好的路径开始，找到更多的路径</p><p><img src="/images/AssetMarkdown/image-20230330221447583.png" alt="image-20230330221447583" style="zoom:80%;" /></p><p>缺点：</p><ol type="1"><li>难以在理论上计算收敛的速度</li><li>所有操作都是局部的，有的像素快，有的像素满，会很"脏"</li><li>难以用于动画的渲染</li></ol><p><img src="/images/AssetMarkdown/image-20230330222050918.png" alt="image-20230330222050918" style="zoom:80%;" /></p></blockquote><h3 id="光子映射-photon-mapping">18.1.4 光子映射 Photon Mapping</h3><ol type="1"><li><p>适用于渲染SDS(Specular-Diffuse-Specular)路径、生成caustics</p><ol type="1"><li>caustics：由于光线的聚焦产生的非常强的高亮图案</li></ol><p><img src="/images/AssetMarkdown/image-20230330222033557.png" alt="image-20230330222033557" style="zoom:80%;" /></p></li><li><p>分为两步：</p><ol type="1"><li>从光源开始，辐射光子，直到光子打到diffuse表面，将结果记录下来</li><li>从摄像机开始，发射半路径，直到路径打到diffuse表面上</li><li>计算局部密度估计 local density estimation：<ol type="1"><li>对任何一个着色点，取最近的n个光子，计算这n个光子占据的面积，计算其密度</li><li>n较少时，噪声大；n较大时，会模糊</li></ol></li></ol></li><li><p>有偏估计：</p><ol type="1"><li>因为dN / dA != ΔN / ΔA，只有ΔA很小时才接近dA</li><li>光子越多，找n个光子占据的面积越小，就更接近正确结果</li><li>不能确定ΔA，增加光子，因为ΔA永远不会接近dA</li></ol></li></ol><h3 id="vertex-connection-and-merging">18.1.5 Vertex Connection andMerging</h3><ol type="1"><li>将BDPT和光子映射结合起来</li><li>使用BDPT生成两段sub-path</li><li>如果有两段sub-path的终点非常接近，则使用光子映射计算其贡献</li></ol><p><img src="/images/AssetMarkdown/image-20230330223206732.png" alt="image-20230330223206732" style="zoom: 80%;" /></p><h3 id="实时辐射度-instant-radiosity">18.1.6 实时辐射度 InstantRadiosity</h3><ol type="1"><li>已经被照亮的地方，认为是光源，照亮别的地方<ol type="1"><li>从光源开始发射sub-path，停在某些地方，形成新的光源VPL(Virtual PointLight)</li><li>用新的光源照亮着色点</li></ol></li><li>优点：快，并且效果较好</li><li>缺点：<ol type="1"><li>在缝隙处会出现问题</li><li>不能做glossy物体</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230330223358225.png" alt="image-20230330223358225" style="zoom:80%;" /></p><h2 id="高级外观建模">18.2 高级外观建模</h2><p>外观 == 材质 == BRDF</p><h3 id="非表面模型云-烟雾等">18.2.1 非表面模型：云、 烟、雾等</h3><p><strong>Participating Media</strong>：参与介质</p><p><img src="/images/AssetMarkdown/image-20230330224145788.png" alt="image-20230330224145788" style="zoom:80%;" /></p><p><strong>Phase Function</strong>：相位函数，规定光线如何散射</p><p><img src="/images/AssetMarkdown/image-20230330224250395.png" alt="image-20230330224250395" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330224330452.png" alt="image-20230330224330452" style="zoom:80%;" /></p><h3 id="头发表面">18.2.2 头发表面</h3><p>会有两种高光：有色、无色</p><p><strong>Kajiya-Kay模型</strong>：光线打到圆柱上，会反射为圆锥</p><p><img src="/images/AssetMarkdown/image-20230330224648071.png" alt="image-20230330224648071" style="zoom:80%;" /></p><p><strong>Marschner模型</strong>：光线打到圆柱上，一部分会反射为圆锥，一部分会穿进去</p><ol type="1"><li><strong>R</strong>：直接反射</li><li><strong>TT</strong>：穿进头发，然后再穿出来</li><li><strong>TRT</strong>：穿进头发，发生反射，然后再穿出来</li><li>定义光线和一根圆柱如何作用：R、TT、TRT</li><li>根据光线传播，计算和多个头发的作用</li></ol><p><img src="/images/AssetMarkdown/image-20230330224739393.png" alt="image-20230330224739393" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330225204954.png" alt="image-20230330225204954" style="zoom:80%;" /></p><p><strong>Double Cylinder Model</strong>：增加一个圆柱，模拟髓质</p><p><img src="/images/AssetMarkdown/image-20230330225312464.png" alt="image-20230330225312464" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330225323075.png" alt="image-20230330225323075" style="zoom:80%;" /></p><h3 id="颗粒材质granular">18.2.3 颗粒材质：Granular</h3><ol type="1"><li><p>由很多小石子构成的模型</p><p><img src="/images/AssetMarkdown/image-20230330225609403.png" alt="image-20230330225609403" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330225635165.png" alt="image-20230330225635165" style="zoom:80%;" /></p></li></ol><h3 id="表面模型次表面散射-bssrdf">18.2.4 表面模型：次表面散射BSSRDF</h3><p><strong>Translucent</strong>：光线从一个点进入表面，在物体内发生了一系列散射，然后再从另一个点钻出表面</p><p><img src="/images/AssetMarkdown/image-20230330225827858.png" alt="image-20230330225827858" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330225950269.png" alt="image-20230330225950269" style="zoom:80%;" /></p><p><strong>Dipole</strong>近似：在物体上下添加两个光源，模拟次表面反射的效果</p><p><img src="/images/AssetMarkdown/image-20230330230124438.png" alt="image-20230330230124438" style="zoom:80%;" /></p><h3 id="布料">18.2.5 布料</h3><p>布料的定义</p><ol type="1"><li>纤维的集合 fiber</li><li>纤维缠绕，可以得到不同的股 Ply</li><li>股绕在一起，可以得到线 Yarn</li><li>线织成布 cloth</li></ol><p><img src="/images/AssetMarkdown/image-20230330230502109.png" alt="image-20230330230502109" style="zoom:80%;" /></p><p>将布料当作物体表面，使用<strong>BRDF</strong>渲染</p><p><img src="/images/AssetMarkdown/image-20230330230747552.png" alt="image-20230330230747552" style="zoom:80%;" /></p><p>将布料划分为很小的块，作为<strong>散射介质</strong>渲染</p><p><img src="/images/AssetMarkdown/image-20230330230632698.png" alt="image-20230330230632698" style="zoom:80%;" /></p><p>将布料划分为很多个线，类似<strong>头发模型</strong>渲染</p><p><img src="/images/AssetMarkdown/image-20230330230810766.png" alt="image-20230330230810766" style="zoom:80%;" /></p><h2 id="通过修改微表面法线分布得到不同的效果">18.3通过修改微表面法线分布，得到不同的效果</h2><p><img src="/images/AssetMarkdown/image-20230330231505492.png" alt="image-20230330231505492" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330231516015.png" alt="image-20230330231516015" style="zoom:80%;" /></p><h3 id="对一个区域内的微表面进行积分">18.3.1对一个区域内的微表面进行积分</h3><p><img src="/images/AssetMarkdown/image-20230330231534136.png" alt="image-20230330231534136" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330231544316.png" alt="image-20230330231544316" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330231601075.png" alt="image-20230330231601075" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230330231611914.png" alt="image-20230330231611914" style="zoom:80%;" /></p><h3 id="波动光学与几何光学得到的ndf">18.3.2波动光学与几何光学得到的NDF</h3><p><img src="/images/AssetMarkdown/image-20230330231719561.png" alt="image-20230330231719561" style="zoom:80%;" /></p><h2 id="程序化生成表面">18.4 程序化生成表面</h2><ol type="1"><li>定义在空间中的函数，可以在使用的时候，查询空间中的某个点的值，而不是将三维纹理存储下来，<strong>噪声函数</strong></li></ol><p><img src="/images/AssetMarkdown/image-20230330231937462.png" alt="image-20230330231937462" style="zoom:80%;" /></p><h1 id="第19课-相机透镜光场">第19课 相机&amp;透镜&amp;光场</h1><h2 id="相机">19.1 相机</h2><p>快门：控制光在某个极短时间内进入相机</p><p>传感器：将光的信息记录下来，只能记录Irradiance，不能记录radiance，因此需要小孔/棱镜成像</p><p><img src="/images/AssetMarkdown/image-20230331150921690.png" alt="image-20230331150921690" style="zoom:80%;" /></p><h3 id="针孔相机">19.1.1 针孔相机</h3><ol type="1"><li>没有景深的效果，不会模糊</li></ol><h3 id="基础概念">19.1.2 基础概念</h3><h4 id="视场-fov">19.1.2.1 视场 FOV</h4><p><strong>FOV</strong>：视场</p><ol type="1"><li>传感器高度：<strong>h</strong></li><li>传感器到小孔的距离：<strong>焦距f</strong></li><li>焦距越大，视场越大</li><li>传感器越小，视场越小</li></ol><p><img src="/images/AssetMarkdown/image-20230331151043290.png" alt="image-20230331151043290" style="zoom:80%;" /></p><blockquote><p>以<strong>35mm格式</strong>的胶片为标准，通过更改<strong>焦距f</strong>，定义视场</p><ol type="1"><li>也就是确定了传感器高度<strong>h</strong></li><li>通常说的是等效到35mm格式，而不是传感器就是35mm</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20230331151357618.png" alt="image-20230331151357618" style="zoom:80%;" /></p><p>传感器sensor和胶片film可以不一样，但可以当作是一样的</p><ol type="1"><li>传感器：接收到了具体信息</li><li>胶片：最后呈现的效果</li></ol><blockquote><p>小的传感器 + 小焦距，可以得到相同的视场</p></blockquote><p><img src="/images/AssetMarkdown/image-20230331151711271.png" alt="image-20230331151711271" style="zoom:80%;" /></p><h4 id="曝光度-exposure">19.1.2.2 曝光度 Exposure</h4><p><strong>Exposure = 时间(T) × Irradiance(E)</strong></p><ol type="1"><li>时间越长、单位时间内接收到的能量越多，最后的曝光度越大</li><li>曝光度记录的是energy，而不是power</li><li>时间：由快门控制</li><li>Irradiance：由很多因素决定，如光圈</li></ol><h4 id="影响曝光度的因素光圈快门iso">19.1.2.3影响曝光度的因素：光圈&amp;快门&amp;ISO</h4><ol type="1"><li>光圈<strong>ApertureSize</strong>：用<strong><code>FN</code>或<code>F/N</code></strong>表示<ol type="1"><li>模拟人的瞳孔，通过<strong>F-stop/F-number</strong>控制开关</li><li><strong>N</strong>对应光圈半径的倒数</li><li><strong>光圈越大，越亮，但是远的部分越模糊</strong></li><li>如果要考虑景深，光圈就应该小，图像就会暗，因此就需要更长的快门时间，从而无法考虑运动模糊的问题</li></ol></li><li>快门<strong>Shutter speed</strong>：用分数表示<ol type="1"><li>控制记录的时间</li><li><strong>时间越长，越模糊</strong></li><li>因为存在运动模糊效果：对快门时间内记录到的所有信息做了一个平均</li><li>相当于在时间上采样时，做了一个模糊效果</li><li><strong>Rollingshutter</strong>：对于高速运动的物体，可能会出现扭曲的现象</li></ol></li><li>感光度<strong>ISO gain</strong>：用ISOxx表示<ol type="1"><li>类似于后期处理，对接收到的光乘上某个数</li><li>可以发生在硬件上，也可以发生在软件上</li><li><strong>ISO越大，越亮，但是噪声也越大</strong></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20230331152235235.png" alt="image-20230331152235235" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230331153511790.png" alt="image-20230331153511790" style="zoom:80%;" /></p><h4 id="高速低速摄影">19.1.2.4 高速/低速摄影</h4><p><strong>高速摄影</strong></p><ol type="1"><li>即每秒钟要拍更多的照片</li><li>快门时间变短，同时需要更大的光圈</li></ol><p><strong>低速摄影/延迟摄影</strong></p><ol type="1"><li>即每秒钟要拍更少的照片</li><li>快门时间变长，就是需要运动模糊</li></ol><h2 id="薄透镜近似">19.2 薄透镜近似</h2><h3 id="理想化薄透镜">19.2.1 理想化薄透镜</h3><ol type="1"><li>平行光可以汇聚到焦点上，过交点可以发散为平行光</li><li>过中心不改变光路</li><li>可以任意更改焦距：通过透镜组，动态改变焦距</li></ol><p><img src="/images/AssetMarkdown/image-20230331154506466.png" alt="image-20230331154506466" style="zoom:80%;" /></p><h3 id="焦散模糊-defocus-blur">19.2.2 焦散模糊 Defocus Blur</h3><p><strong>CoC</strong>：Circle of Confusion</p><ol type="1"><li>当感光器在成像点后面时，会导致成像为一个圆</li><li>光圈越大，CoC越大</li></ol><p><img src="/images/AssetMarkdown/image-20230331155356722.png" alt="image-20230331155356722" style="zoom:80%;" /></p><h3 id="f-number的定义">19.2.3 F-Number的定义</h3><ol type="1"><li>F-Number = 焦距 / 光圈直径</li><li>拍的更清楚 =&gt; 使用小光圈</li></ol><p><img src="/images/AssetMarkdown/image-20230331155149689.png" alt="image-20230331155149689" style="zoom:80%;" /></p><h2 id="光线追踪模拟薄透镜">19.3 光线追踪模拟薄透镜</h2><h3 id="定义-3">19.3.1 定义</h3><ol type="1"><li>感光器的大小</li><li>焦距、光圈大小</li><li>物体与棱镜的距离，即物距<strong>z<sub>o</sub></strong></li></ol><p><img src="/images/AssetMarkdown/image-20230331155614225.png" alt="image-20230331155614225" style="zoom:80%;" /></p><h3 id="渲染方式">19.3.2 渲染方式</h3><ol type="1"><li>在感光元件上选一个点<strong>x'</strong></li><li>在透镜上选另一个点<strong>x''</strong></li><li>连接<strong>x'</strong>和<strong>x''</strong>，可以得到通过该透镜后的光线<strong>x''→x'''</strong></li><li>考虑<strong>x''→x'''</strong>的Radiance，记录到<strong>x'</strong>上即可</li></ol><h2 id="景深-depth-of-fielddf-dn">19.4 景深 Depth ofField：D<sub>F</sub> ~ D<sub>N</sub></h2><ol type="1"><li>用不同的光圈，会影响模糊的范围</li><li>在<strong>实际场景</strong>中有<strong>一段深度(景深)</strong>，这段通过透镜，会在成像区域附近形成一个区域，我们认为这个区域内的CoC都是足够小的</li><li>这段深度内的像素，认为均是锐利的，即不模糊的</li></ol><p><img src="/images/AssetMarkdown/image-20230331160147996.png" alt="image-20230331160147996" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230331161005848.png" alt="image-20230331161005848" style="zoom:80%;" /></p><h2 id="光场-light-field-lumigraph">19.5 光场 Light Field /Lumigraph</h2><h3 id="全光函数-plenoptic-function">19.5.1 全光函数 PlenopticFunction</h3><h4 id="grayscale-snapshotpθ-φ">19.5.1.1 Grayscale snapshot：P(θ,Φ)</h4><ol type="1"><li>定义了在一个固定地方，向任意一个<strong>方向(θ,Φ)</strong>看，能够看到的亮度值</li></ol><h4 id="color-snapshotpθ-φ-λ">19.5.1.2 Color snapshot：P(θ, Φ, λ)</h4><ol type="1"><li>定义了在一个固定地方，向任意一个<strong>方向(θ,Φ)</strong>看，能够看到的<strong>波长为λ</strong>的亮度值</li></ol><h4 id="moviepθ-φ-λ-t">19.5.1.3 Movie：P(θ, Φ, λ, t)</h4><ol type="1"><li>定义了在一个固定地方，在某个<strong>时间t</strong>，向任意一个<strong>方向(θ,Φ)</strong>看，能够看到的<strong>波长为λ</strong>的亮度值</li><li>即电影</li></ol><h4 id="holographic-moviepθ-φ-λ-t-vx-vy-vz">19.5.1.4 HolographicMovie：P(θ, Φ, λ, t, V<sub>X</sub>, V<sub>Y</sub>, V<sub>Z</sub>)</h4><ol type="1"><li>定义了在某个<strong>位置(V<sub>X</sub>, V<sub>Y</sub>,V<sub>Z</sub>)</strong>，在某个<strong>时间t</strong>，向任意一个<strong>方向(θ,Φ)</strong>看，能够看到的<strong>波长为λ</strong>的亮度值</li><li>即全息电影</li></ol><h4 id="plenoptic-functionpθ-φ-λ-t-vx-vy-vz">19.5.1.5 PlenopticFunction：P(θ, Φ, λ, t, V<sub>X</sub>, V<sub>Y</sub>,V<sub>Z</sub>)</h4><ol type="1"><li>在任何<strong>时间t</strong>、任何<strong>地点V</strong>、向任何<strong>方向(θ,Φ)</strong>看，所能看到的所有的<strong>光λ</strong></li><li>是一个七维函数</li></ol><h3 id="光线的定义">19.5.2 光线的定义</h3><p>5个维度：<strong>P(θ, Φ, V<sub>X</sub>, V<sub>Y</sub>,V<sub>Z</sub>)</strong></p><ol type="1"><li>3个维度的坐标</li><li>2个维度的方向</li></ol><p><img src="/images/AssetMarkdown/image-20230331162624696.png" alt="image-20230331162624696" style="zoom:80%;" /></p><p>4个维度：</p><ol type="1"><li>2维的位置：<strong>(u, v)</strong></li><li>2维的方向：<strong>(θ, Φ)</strong></li></ol><p><img src="/images/AssetMarkdown/image-20230331162633863.png" alt="image-20230331162633863" style="zoom:80%;" /></p><h3 id="全光表面-plenoptic-surface">19.5.3 全光表面 PlenopticSurface</h3><p><img src="/images/AssetMarkdown/image-20230331162812295.png" alt="image-20230331162812295" style="zoom:80%;" /></p><p>光场：任何一个位置，往任何一个方向去的光的强度</p><ol type="1"><li>在表面的位置：<strong>(u, v)</strong></li><li>方向：<strong>(θ, Φ)</strong></li><li>从任意一个位置，往任意一个方向看，都看到该光场的强度</li></ol><h3 id="光场">19.5.4 光场</h3><p>不需要直到物体具体是什么，只需要直到<strong>包围盒外</strong>的光场信息</p><p><img src="/images/AssetMarkdown/image-20230331163303962.png" alt="image-20230331163303962" style="zoom:80%;" /></p><h3 id="lumigraph-organization">19.5.5 Lumigraph-Organization</h3><p>取一个平面，只需要直到该平面上任何一个位置，往任何一个方向去的光的强度</p><p><img src="/images/AssetMarkdown/image-20230331163416657.png" alt="image-20230331163416657" style="zoom:80%;" /></p><p>也可以定义两个平面<strong>(u,v) &amp; (s,t)</strong>，定义该光线</p><p><img src="/images/AssetMarkdown/image-20230331163525401.png" alt="image-20230331163525401" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230331164408327.png" alt="image-20230331164408327" style="zoom:80%;" /></p><blockquote><p><img src="/images/AssetMarkdown/image-20230331164514848.png" alt="image-20230331164514848" style="zoom:80%;" /></p></blockquote><h1 id="第20课-颜色与视觉">第20课 颜色与视觉</h1><h1 id="第21课-动画模拟仿真">第21课 动画/模拟/仿真</h1><h2 id="关键帧动画">21.1 关键帧动画</h2><ol type="1"><li>给定一系列关键的帧，通过<strong>插值</strong>，将中间的帧补全</li></ol><p><img src="/images/AssetMarkdown/image-20230406213305918.png" alt="image-20230406213305918" style="zoom:80%;" /></p><h2 id="物理模拟">21.2 物理模拟</h2><ol type="1"><li>建立物理模型，解某个时刻对应的方程</li></ol><p><img src="/images/AssetMarkdown/image-20230406213618926.png" alt="image-20230406213618926" style="zoom:80%;" /></p><h3 id="质点弹簧系统-mass-spring-system">21.2.1 质点弹簧系统 Mass SpringSystem</h3><ol type="1"><li>是一系列相互连接的质点和弹簧</li></ol><h4 id="理想弹簧">21.2.1.1 理想弹簧</h4><ol type="1"><li>弹簧没有长度，弹簧的力只与其被拉伸的长度有关</li><li><span class="math inline">\(k_s\)</span>：劲度系数</li></ol><p><img src="/images/AssetMarkdown/image-20230406214224321.png" alt="image-20230406214224321" style="zoom:80%;" /></p><h4 id="非零长度弹簧">21.2.1.2 非零长度弹簧</h4><ol type="1"><li>在理想弹簧的基础上，弹簧的初始长度为<spanclass="math inline">\(l\)</span></li><li>问题：由于动能和弹性势能的相互转换，弹簧会永远震动下去</li></ol><p><img src="/images/AssetMarkdown/image-20230406214307106.png" alt="image-20230406214307106" style="zoom:80%;" /></p><h4 id="添加能量流失">21.2.1.3 添加能量流失</h4><ol type="1"><li>在非零长度弹簧的基础上，添加一个摩擦力<spanclass="math inline">\(f=-k_d\dot b\)</span>，使弹簧能够停下来</li><li><span class="math inline">\(k_d\)</span>：阻尼系数 dampingcoefficient</li><li>问题：只能表示弹簧整体的能量损耗，不能表示弹簧内部的能量损耗</li></ol><p><img src="/images/AssetMarkdown/image-20230406215157003.png" alt="image-20230406215157003" style="zoom:80%;" /></p><h4 id="添加内部阻尼">21.2.1.4 添加内部阻尼</h4><ol type="1"><li>在上述弹簧的基础上，添加内部阻尼，以让弹簧能够恢复原样<ol type="1"><li>相对速度的投影：分解到沿着ab方向的速度，只有这个速度会让弹簧产生形变</li></ol></li><li>内部阻尼与弹簧的直接形变没有关系，只与ab的相对速度有关系</li></ol><p><img src="/images/AssetMarkdown/image-20230406215514210.png" alt="image-20230406215514210" style="zoom:80%;" /></p><h4 id="弹簧的结构">21.2.1.5 弹簧的结构</h4><p>用网格结构的弹簧模拟布料</p><ol type="1"><li>无法抵抗切变的力：从</li><li>无法抵抗out-of-plane的力</li></ol><p><img src="/images/AssetMarkdown/image-20230406215820111.png" alt="image-20230406215820111" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20230406220402457.png" alt="image-20230406220402457" style="zoom:80%;" /></p><blockquote><p>添加两个方向的对角线方向的弹簧，抵抗切变的力：</p><ol type="1"><li>当从两端拉弹簧时，对角线上的弹簧会被压缩，从而产生抵抗切变的力</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20230406220645857.png" alt="image-20230406220645857" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES系列课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/02/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/02/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="chapter-1计算机网络的概念">Chapter 1：计算机网络的概念</h1><h2 id="概念组成功能分类">1.1 概念、组成、功能、分类</h2><h3 id="计算机网络的概念">1.1.1 计算机网络的概念</h3><ol type="1"><li><strong>计算机网络</strong>：是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统</li><li>计算机网络是<strong>互连</strong>的、<strong>自治</strong>的计算机集合<ol type="1"><li>互联：互连互通，使用通信链路</li><li>自治：无主从关系</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221108140214225.png" alt="image-20221108140214225" style="zoom: 67%;" /></p><h3 id="计算机网络的功能">1.1.2 计算机网络的功能</h3><ol type="1"><li><strong>数据通信</strong>：连通性</li><li><strong>资源共享</strong>：硬件、软件、数据</li><li>分布式处理：多台计算机各自承担同一工作任务的不同部分</li><li>提高可靠性：一台计算机宕机了，可以由另一台计算机替代它</li><li>负载均衡：多台计算机相互配合</li></ol><h3 id="计算机网络的组成">1.1.3 计算机网络的组成</h3><ol type="1"><li><p>组成部分：硬件、软件、协议</p></li><li><p><strong>工作方式</strong>：</p><ol type="1"><li>边缘部分：主机所在的部分，用户可以直接使用<ol type="1"><li><p>C/S方式</p><p><img src="/images/AssetMarkdown/image-20221231152632850.png" alt="image-20221231152632850" style="zoom:80%;" /></p></li><li><p>P2P方式</p><p><img src="/images/AssetMarkdown/image-20221231152643718.png" alt="image-20221231152643718" style="zoom:80%;" /></p></li></ol></li><li>核心部分：为边缘部分服务</li></ol><p><img src="/images/AssetMarkdown/image-20221108140609953.png" alt="image-20221108140609953" style="zoom: 67%;" /></p></li><li><p><strong>功能组成</strong></p><ol type="1"><li>通信子网：实现数据通信</li><li>资源子网：实现资源共享、数据处理</li></ol><p><img src="/images/AssetMarkdown/image-20221108140715884.png" alt="image-20221108140715884" style="zoom: 67%;" /></p></li></ol><h3 id="计算机网络的分类">1.1.4 计算机网络的分类</h3><ol type="1"><li><p>按分布范围分：</p><ol type="1"><li>广域网WAN：交换技术</li><li>城域网MAN</li><li>局域网WAN</li><li>个人区域网PAN：广播技术</li></ol></li><li><p>按使用者分：</p><ol type="1"><li>公用网：交钱就能进，如电信网</li><li>专用网：必须有特殊身份，如军队使用的网络</li></ol></li><li><p>按交换技术分：</p><ol type="1"><li>电路交换</li><li>报文交换</li><li>分组交换</li></ol></li><li><p>按拓扑结构分：</p><ol type="1"><li>总线型</li><li>星型</li><li>环型</li><li>网状型</li></ol><p><img src="/images/AssetMarkdown/image-20221108141011216.png" alt="image-20221108141011216" style="zoom:67%;" /></p></li><li><p>按传输技术分：</p><ol type="1"><li>广播式网络：共享公共通信信道</li><li>点对点网络：使用分组存储转发、路由选择的机制</li></ol></li></ol><h3 id="总结">1.1.5 总结</h3><p><img src="/images/AssetMarkdown/image-20221108141244410.png" alt="image-20221108141244410" style="zoom:80%;" /></p><h2 id="标准化工作及相关组织">1.2 标准化工作及相关组织</h2><h3 id="标准的分类">1.2.1 标准的分类</h3><ol type="1"><li>法定标准<ol type="1"><li>由权威机构制定的、正式的、合法的标准</li><li>如：OSI</li></ol></li><li>事实标准<ol type="1"><li>某些公司的产品在竞争中占据了主流，时间长了，这些产品中的技术和协议就成了标准</li><li>如：TCP/IP</li></ol></li></ol><h3 id="rfc">1.2.2 RFC</h3><ol type="1"><li>RFC：Request For Comments，是因特网标准的形式</li><li>RFC上升为因特网正式标准的四个阶段<ol type="1"><li>因特网草案(Internet Draft)：这个阶段还不是RFC文档</li><li>建议标准(Proposed Standard)：从这个阶段开始成为RFC文档</li><li>草案标准(Draft Standard)：交给IEFT、IAB进行审核</li><li>因特网标准(Internet Standard)：审核通过后，就成为因特网标准</li></ol></li></ol><h3 id="标准化工作的相关组织">1.2.3 标准化工作的相关组织</h3><ol type="1"><li><strong>国际标准化组织ISO</strong>：<ol type="1"><li>OSI参考模型，HDLC协议</li></ol></li><li>国际电信联盟ITU：<ol type="1"><li>制定通信规则</li></ol></li><li>电气电子工程师学会IEEE：<ol type="1"><li>学术机构、IEEE802系列标准、5G</li></ol></li><li>Internet工程任务组IETF：<ol type="1"><li>负责因特网相关标准的制定</li></ol></li></ol><h3 id="总结-1">1.2.4 总结</h3><p><img src="/images/AssetMarkdown/image-20221108142307828.png" alt="image-20221108142307828" style="zoom:80%;" /></p><h2 id="速率相关的性能指标">1.3 速率相关的性能指标</h2><h3 id="速率">1.3.1 速率</h3><ol type="1"><li><p>速率、<strong>数据率</strong>、<strong>数据传输速率</strong>、<strong>比特率</strong></p><ol type="1"><li>连接在计算机网络上的主机在数字信道上传送<strong>数据位数的速率</strong></li><li>单位：b/s, kb/s, Mb/s, Gb/s, Tb/s，依次递增10<sup>3</sup></li></ol><p><img src="/images/AssetMarkdown/image-20221108142711478.png" alt="image-20221108142711478" style="zoom:80%;" /></p></li></ol><h3 id="带宽">1.3.2 带宽</h3><ol type="1"><li><p>带宽：单位时间内，从网络中某一点到另一点所能通过的<strong>最高数据率</strong></p><ol type="1"><li>网络设备所能支持的最高速度</li><li>单位：b/s, kb/s, Mb/s, Gb/s</li></ol></li><li><p>带宽是链路的发送端发送数据的速率</p><ol type="1"><li>传播速率一般都是2×10<sup>8</sup> m/s</li></ol></li><li><p>带宽变大，会使链路发送数据的速率变大，但是不会影响数据传播的速率</p><p><img src="/images/AssetMarkdown/image-20221108143352010.png" alt="image-20221108143352010" style="zoom:80%;" /></p></li></ol><h3 id="吞吐量">1.3.3 吞吐量</h3><ol type="1"><li><p>吞吐量：单位时间内，通过<strong>某个网络(/信道/接口)</strong>的数据量</p><ol type="1"><li>单位：b/s, kb/s, Mb/s</li></ol></li><li><p>吞吐量受网络的带宽、网络的额定速率的限制</p><ol type="1"><li>链路带宽：理想情况下，接收方接受数据的最高速率</li><li>吞吐量：多个发送方发来数据的速率之和，一般小于链路带宽</li></ol><p><img src="/images/AssetMarkdown/image-20221108143744006.png" alt="image-20221108143744006" style="zoom:67%;" /></p></li></ol><h2 id="时延时延带宽积rtt利用率">1.4 时延、时延带宽积、RTT、利用率</h2><h3 id="时延">1.4.1 时延</h3><p>时延：数据从网络的一端传送到另一端所需的时间，也叫延迟/迟延，单位是s</p><ol type="1"><li><p>发送时延(传输时延)：</p><ol type="1"><li>从发送分组的第一个bit算起，到该分组的最后一个bit发送完毕的所需时间</li><li><span class="math inline">\(发送时延 =\frac{数据长度}{信道带宽(发送速率)}\)</span></li><li>发生在<strong>主机</strong>内</li><li>高速链路：提高了信道带宽(发送速率)</li></ol><p><img src="/images/AssetMarkdown/image-20221109132505719.png" alt="image-20221109132505719" style="zoom:80%;" /></p></li><li><p>传播时延：</p><ol type="1"><li>电磁波在信道上传播一定距离所需的时间</li><li><span class="math inline">\(传播时延 =\frac{信道长度}{电磁波在信道上的传播速率}\)</span></li><li>发生在<strong>信道</strong>上</li></ol><p><img src="/images/AssetMarkdown/image-20221109132649076.png" alt="image-20221109132649076" style="zoom:80%;" /></p></li><li><p>排队时延：</p><ol type="1"><li>等待输出/入链路所需的时间</li><li>发生在<strong>路由器</strong>，类似过安检排队</li></ol></li><li><p>处理时延：</p><ol type="1"><li>处理数据所需的时间</li><li>发送在<strong>路由器</strong>，类似过安检时的扫描</li></ol></li></ol><h3 id="时延带宽积">1.4.2 时延带宽积</h3><ol type="1"><li><span class="math inline">\(时延带宽积 = 传播时延 ×带宽\)</span>，单位为bit</li><li>也称为：以比特为单位的链路长度，即某段线路现在有多少比特，链路容量</li></ol><p><img src="/images/AssetMarkdown/image-20221109133245849.png" alt="image-20221109133245849" style="zoom:80%;" /></p><h3 id="往返时延rtt">1.4.3 往返时延RTT</h3><ol type="1"><li><strong>RTT</strong>：从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延<ol type="1"><li>RTT越大，在收到确认之前，可发送的数据越多</li></ol></li><li><span class="math inline">\(RTT = 传播时延×2+末端处理时间\)</span><ol type="1"><li>RTT不包括发送时延(传输时延)</li></ol></li></ol><h3 id="利用率">1.4.4 利用率</h3><ol type="1"><li>信道利用率：<span class="math inline">\(信道利用率 =\frac{有数据通过的时间}{(有+无)数据通过的时间}\)</span></li><li>网络利用率：信道利用率的加权平均值</li></ol><p><img src="/images/AssetMarkdown/image-20221109133634462.png" alt="image-20221109133634462" style="zoom: 67%;" /></p><h3 id="总结-2">1.4.5 总结</h3><p><img src="/images/AssetMarkdown/image-20221109133702155.png" alt="image-20221109133702155" style="zoom:80%;" /></p><h2 id="分层结构协议接口服务">1.5 分层结构、协议、接口、服务</h2><h3 id="分层的基本原则">1.5.1 分层的基本原则</h3><ol type="1"><li>各层之间相互独立，每层只实现一种相对独立的功能</li><li>每层之间界面自然清晰，易于理解，相互交流尽可能少</li><li>结构上可分割开，每层都采用最合适的技术来实现</li><li>保持下层对上层的独立性，上层单向使用下层提供的服务</li><li>整个分层结构应该能促进标准化工作</li></ol><h3 id="概念">1.5.2 概念</h3><ol type="1"><li>实体：第n层中的活动元素称为n层实体</li><li>对等实体：同一层的实体</li><li>协议：为进行网络中的对等实体数据交换而建立的规则、标准、约定，称为网络协议【水平】<ol type="1"><li>语法：规定传输数据的格式</li><li>语义：规定所要完成的功能</li><li>同步：规定各种操作的顺序</li></ol></li><li>接口(访问服务点SAP)：上层使用下层服务的入口</li><li>服务：下层为相邻上层提供的功能调用【垂直】</li></ol><p><img src="/images/AssetMarkdown/image-20221109211117196.png" alt="image-20221109211117196" style="zoom:67%;" /></p><ol type="1"><li><strong>SDU</strong>服务数据单元：为完成用户所要求的功能而应传送的数据</li><li><strong>PCI</strong>协议控制信息：控制协议操作的信息</li><li><strong>PDU</strong>协议数据单元：对等层次之间传送的数据单位</li></ol><p><img src="/images/AssetMarkdown/image-20221109211219883.png" alt="image-20221109211219883" style="zoom: 50%;" /></p><h3 id="概念总结">1.5.3 概念总结</h3><p><img src="/images/AssetMarkdown/image-20221109211511126.png" alt="image-20221109211511126" style="zoom:80%;" /></p><h3 id="总结-3">1.5.4 总结</h3><p><img src="/images/AssetMarkdown/image-20221109211533054.png" alt="image-20221109211533054" style="zoom:80%;" /></p><h2 id="osi参考模型">1.6 OSI参考模型</h2><h3 id="osi提出的背景">1.6.1 OSI提出的背景</h3><ol type="1"><li>目的：支持<strong>异构网络系统</strong>的互联互通</li><li>ISO在1984年提出开放系统互联(OSI)参考模型</li><li>理论成功，市场失败<ol type="1"><li>专家没有实操的经验</li><li>OSI实现复杂，运行效率低</li><li>制定时间过长，没有及时进入市场</li><li>层次划分不合理，有些功能会在多个层次中多次出现</li></ol></li></ol><h3 id="osi七层结构">1.6.2 OSI七层结构</h3><p><img src="/images/AssetMarkdown/image-20221109212411182.png" alt="image-20221109212411182" style="zoom:80%;" /></p><h3 id="osi参考模型解释通信过程">1.6.3 OSI参考模型解释通信过程</h3><p><img src="/images/AssetMarkdown/image-20221109212814640.png" alt="image-20221109212814640" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221109213106176.png" alt="image-20221109213106176" style="zoom:80%;" /></p><h3 id="osi不同分层">1.6.4 OSI不同分层</h3><h4 id="应用层">1.6.4.1 应用层</h4><ol type="1"><li>应用层：用户与网络的界面，即所有能和用户交互<strong>产生网络流量</strong>的程序</li><li>典型应用层服务<ol type="1"><li>文件传输：FTP</li><li>电子邮件：SMTP</li><li>万维网：HTTP</li></ol></li></ol><h4 id="表示层">1.6.4.2 表示层</h4><ol type="1"><li>表示层：用于处理在两个通信系统中交换信息的<strong>表示方式</strong>（语法和语义）</li><li>功能<ol type="1"><li>数据格式的变换：翻译官</li><li>数据加密解密</li><li>数据压缩和恢复</li></ol></li></ol><h4 id="会话层">1.6.4.3 会话层</h4><ol type="1"><li>会话层：向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据</li><li>会话，也叫<strong>建立同步SYN</strong></li><li>功能：<ol type="1"><li>建立、管理、终止会话</li><li>使用校验点，可使会话在通信失效时，从<strong>校验点/同步点</strong>继续恢复通信，实现数据同步<ol type="1"><li>适用于传输大文件</li></ol></li></ol></li><li>主要协议：ADSP、ASP</li></ol><h4 id="传输层">1.6.4.4 传输层</h4><ol type="1"><li>负责主机中<strong>两个进程</strong>的通信，即<strong>端到端</strong>的通信。传输单位是报文段/用户数据报</li><li>功能<ol type="1"><li>可靠传输、不可靠传输</li><li>差错控制</li><li>流量控制：接收端控制发送端发送的速率</li><li>复用分用<ol type="1"><li>复用：多个应用层进程可同时使用下面运输层的服务</li><li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程</li></ol></li></ol></li><li>主要协议：TCP、UDP</li></ol><h4 id="网络层">1.6.4.5 网络层</h4><ol type="1"><li>网络层：把分组从源端传送到目的端，为分组交换网上的不同主机提供通信服务</li><li>传输单位：<strong>数据报</strong></li><li>功能<ol type="1"><li>路由选择：最佳路径</li><li>差错控制</li><li>流量控制：协调发送端和接收端的速度，限制发送方的速度</li><li>拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状"态。因此要采取一定措施，缓解这种拥塞</li></ol></li><li>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</li></ol><h4 id="数据链路层">1.6.4.6 数据链路层</h4><ol type="1"><li>数据链路层：把网络层传下来的数据报组装成帧</li><li>传输单位：<strong>帧</strong></li><li>功能：<ol type="1"><li>成帧：定义帧的开始和结束</li><li>差错控制：帧错、位错</li><li>流量控制</li><li>访问(接入)控制：控制对信道的访问</li></ol></li><li>主要协议：SDLC、HDLC、PPP、STP</li></ol><h4 id="物理层">1.6.4.7 物理层</h4><ol type="1"><li>物理层：在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong></li><li>传输单位：<strong>比特</strong></li><li>透明传输：不管所传的数据是什么比特组合，都能在链路上传送</li><li>功能：<ol type="1"><li>定义接口特性</li><li>定义传输模式<ol type="1"><li>单工：只有一个人能够说话</li><li>半双工：两个人均能说话，但同一时间只有一个人说话</li><li>双工：两个人均能说话</li></ol></li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ol></li><li>主要协议：Rj45、802.3</li></ol><h3 id="总结-4">1.6.3 总结</h3><p><img src="/images/AssetMarkdown/image-20221109220133205.png" alt="image-20221109220133205" style="zoom:80%;" /></p><h2 id="tcpip参考模型5层参考模型">1.7 TCP/IP参考模型、5层参考模型</h2><p><img src="/images/AssetMarkdown/image-20221110211627791.png" alt="image-20221110211627791" style="zoom:80%;" /></p><h3 id="osi与tcpip的共同点">1.7.1 OSI与TCP/IP的共同点</h3><ol type="1"><li>都分层</li><li>基于独立的协议栈的概念</li><li>可以实现异构网络互联</li></ol><h3 id="osi与tcpip的不同点">1.7.2 OSI与TCP/IP的不同点</h3><p><img src="/images/AssetMarkdown/image-20221110212313192.png" alt="image-20221110212313192" style="zoom:80%;" /></p><h3 id="层参考模型">1.7.3 5层参考模型</h3><p><img src="/images/AssetMarkdown/image-20221110212523658.png" alt="image-20221110212523658" style="zoom:80%;" /></p><h3 id="层参考模型的数据封装与解封装">1.7.45层参考模型的数据封装与解封装</h3><p><img src="/images/AssetMarkdown/image-20221110212735024.png" alt="image-20221110212735024" style="zoom:80%;" /></p><h2 id="第一章知识总结">1.8 第一章知识总结</h2><p><img src="/images/AssetMarkdown/image-20221110212818174.png" alt="image-20221110212818174" style="zoom:80%;" /></p><h1 id="chapter-2物理层">Chapter 2：物理层</h1><p><img src="/images/AssetMarkdown/image-20221110213211010.png" alt="image-20221110213211010" style="zoom:50%;" /></p><h2 id="物理层的基本概念">2.1 物理层的基本概念</h2><ol type="1"><li>物理层：解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是具体的传输媒体</li><li>主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性【定义标准】<ol type="1"><li><strong>机械特性</strong>：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目</strong>、<strong>引脚数量</strong>、排列情况</li><li><strong>电气特性</strong>：规定传输<strong>二进制位</strong>时，线路上信号的<strong>电压范围</strong>、阻抗匹配、<strong>传输速率</strong>、<strong>距离限制</strong>等</li><li><strong>功能特性</strong>：指明某条线上出现某一<strong>电平表示何种意义</strong>，接口部件的信号线的用途</li><li><strong>规程特性(过程特性)</strong>：定义各条物理线路的工作<strong>规程</strong>和<strong>时序</strong>关系</li></ol></li></ol><h2 id="数据通信的基础知识">2.2 数据通信的基础知识</h2><h3 id="典型的数据通信模型">2.2.1 典型的数据通信模型</h3><p><img src="/images/AssetMarkdown/image-20221110214223211.png" alt="image-20221110214223211" style="zoom:80%;" /></p><h3 id="相关术语">2.2.2 相关术语</h3><ol type="1"><li><p>通信的目的：传送消息</p></li><li><p><strong>数据</strong>：传送信息的实体，通常是有意义的符号序列</p></li><li><p><strong>信号</strong>：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong></p><ol type="1"><li>数字信号：代表消息的参数取值是离散的</li><li>模拟信号：代表消息的参数取值是连续的</li></ol></li><li><p><strong>信源</strong>：产生和发送数据的源头</p></li><li><p><strong>信宿</strong>：接收数据的终点</p></li><li><p><strong>信道</strong>：信号传输的媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道</p><p><img src="/images/AssetMarkdown/image-20221110215133733.png" alt="image-20221110215133733" style="zoom:80%;" /></p></li></ol><h3 id="三种通信方式">2.2.3 三种通信方式</h3><ol type="1"><li><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互，仅需要<strong>一条</strong>信道</li><li><strong>半双工通信</strong>：通信的双方都可以发送或接收消息，但任何一方都不能同时发送和接收，需要<strong>两条</strong>信道</li><li><strong>全双工通信</strong>：通信双方可以同时发送和接收消息，也需要<strong>两条</strong>信道</li></ol><h3 id="两种数据传输方式">2.2.4 两种数据传输方式</h3><ol type="1"><li>串行传输：速度慢，费用低，适合远距离</li><li>并行传输：速度快，费用高，适合近距离，用于计算机内部数据传输</li></ol><p><img src="/images/AssetMarkdown/image-20221110215514788.png" alt="image-20221110215514788" style="zoom:80%;" /></p><h2 id="码元波特速率带宽计算">2.3码元、波特、速率、带宽(<strong>计算</strong>)</h2><h3 id="码元">2.3.1 码元</h3><ol type="1"><li><strong>码元</strong>是指用一个<strong>固定时长</strong>的<strong>信号波形</strong>(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<strong>k进制码元</strong>，而该时长称为<strong>码元宽度</strong><ol type="1"><li>当码元的离散状态有M个时(M大于2)，此时码元为<strong>M进制码元</strong></li></ol></li><li><strong>1码元可以携带多个比特的信息量</strong>。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态</li></ol><p><img src="/images/AssetMarkdown/image-20221113162232308.png" alt="image-20221113162232308" style="zoom:80%;" /></p><h3 id="速率波特带宽">2.3.2 速率、波特、带宽</h3><ol type="1"><li>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。</li><li><strong>码元传输速率</strong>：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的<strong>码元个数</strong>(也可称为<strong>脉冲个数或信号变化的次数</strong>)<ol type="1"><li>单位是<strong>波特(Baud)</strong></li><li><strong>1波特</strong>：表示数字通信系统每秒传输一个码元，<strong>1Baud= 1码元/s</strong></li><li>这里的码元可以是多进制的，也可以是二进制的，但<strong>码元速率与进制数无关</strong></li></ol></li><li><strong>信息传输速率</strong>：别名信息速率、比特率等，表示单位时间内数字通信系统传输的<strong>二进制码元个数</strong>(即比特数)<ol type="1"><li>单位：<strong>比特/秒(b/s)</strong></li></ol></li><li><strong>关系</strong>：若一个码元携带n bit的信息量，则MBaud的码元传输速率所对应的信息传输速率为<span class="math inline">\(M ×n\)</span> bit/s</li><li><strong>带宽</strong>：表示在单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”，常用来表示网络的通信线路所能传输数据的能力<ol type="1"><li>单位：<strong>比特/秒(b/s)</strong></li></ol></li></ol><h3 id="练习题">2.3.3 练习题</h3><p><img src="/images/AssetMarkdown/image-20221113163219588.png" alt="image-20221113163219588" style="zoom: 80%;" /></p><h2 id="奈氏准则香农定理计算">2.4奈氏准则、香农定理(<strong>计算</strong>)</h2><h3 id="失真">2.4.1 失真</h3><p><img src="/images/AssetMarkdown/image-20221113163436831.png" alt="image-20221113163436831" style="zoom:80%;" /></p><p>影响失真程度的因素：</p><ol type="1"><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ol><h3 id="失真的一种现象码间串扰">2.4.2 失真的一种现象：码间串扰</h3><ol type="1"><li><strong>信道带宽</strong>：信道能够通过的<strong>最高频率和最低频率之差</strong></li><li><strong>码间串扰</strong>：<strong>接收端</strong>收到的信号波形<strong>失去了码元之间清晰界限</strong>的现象</li></ol><p><img src="/images/AssetMarkdown/image-20221113163739821.png" alt="image-20221113163739821" style="zoom:80%;" /></p><h3 id="奈氏准则奈奎斯特定理极限码元传输速率">2.4.3奈氏准则(奈奎斯特定理)：极限码元传输速率</h3><ol type="1"><li><p><strong>奈氏准则</strong>：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，<strong>极限码元传输速率</strong>为<strong>2W</strong>(Baud)</p><ol type="1"><li>W：信道带宽，单位是<strong>Hz</strong></li></ol></li><li><p>理想低通信道下的<strong>极限数据传输率</strong>：<strong>2Wlog<sub>2</sub>V</strong> (b/s)</p><ol type="1"><li>W：信道带宽，单位是<strong>Hz</strong></li><li>V：几种码元/码元的离散电平数目</li></ol></li><li><p>结论：</p><ol type="1"><li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能</li><li>信道的<strong>频带越宽</strong>(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输</li><li>奈氏准则给出了<strong>码元传输速率</strong>的限制，但并没有对信息传输速率给出限制</li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用<strong>多元制的调制方法</strong></li></ol></li><li><p>例：</p><p><img src="/images/AssetMarkdown/image-20221113165306084.png" alt="image-20221113165306084" style="zoom:67%;" /></p></li></ol><h3 id="香农定理数据传输速率">2.4.4 香农定理：数据传输速率</h3><ol type="1"><li><p><strong>噪声</strong>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，<strong>信噪比</strong>就很重要</p></li><li><p>信噪比=<spanclass="math inline">\(\frac{信号的平均功率}{噪声的平均功率}\)</span>，记为<strong>S/N</strong>，用分贝<strong>db</strong>作为度量单位</p><ol type="1"><li><strong>信噪比(dB) = 10 log<sub>10</sub>(S/N)</strong></li></ol></li><li><p>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值</p><ol type="1"><li><strong>信道的极限数据传输速率 = W log<sub>2</sub>(1+S/N)(b/s)</strong></li><li>W：信道带宽，单位是<strong>Hz</strong></li><li>S/N：信噪比</li><li>S：信道所传信号的平均功率</li><li>N：信道内的高斯噪声功率</li></ol></li><li><p>结论：</p><ol type="1"><li>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong></li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了</li><li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输</li><li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少</li><li>从香农定理可以看出，若信道带宽w或信噪比S/N没有上限(不可能)，那么信道的极限信息传输速率也就没有上限</li></ol></li><li><p>例：</p><p><img src="/images/AssetMarkdown/image-20221113170048282.png" alt="image-20221113170048282" style="zoom:67%;" /></p></li></ol><h3 id="奈氏准则与香农定理">2.4.5 奈氏准则与香农定理</h3><p><img src="/images/AssetMarkdown/image-20221113170318805.png" alt="image-20221113170318805" style="zoom:80%;" /></p><p>例：</p><p><img src="/images/AssetMarkdown/image-20221113170400885.png" alt="image-20221113170400885" style="zoom:80%;" /></p><h3 id="采样定理">2.4.6 采样定理</h3><p><span class="math display">\[f_{采样频率} ≥ 2f_{信号最高频率}\]</span></p><ol type="1"><li>对于一个正弦波，我们只需要确定两个点，就可以确定其波形</li><li>因此只需要在一个正弦波周期中，取到两个点，就可以得到正弦波的波形</li><li>故：采样频率 ≥ 2信号最高频率</li></ol><h2 id="编码调制">2.5 编码&amp;调制</h2><h3 id="基带信号与宽带信号">2.5.1 基带信号与宽带信号</h3><ol type="1"><li>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道<ol type="1"><li>按传输信号分：模拟信道、数字信道</li><li>按传输介质分：无线信道、有线信道</li></ol></li><li>信道上传输的信号<ol type="1"><li><strong>基带信号Baseband</strong>：将数字信号1和0直接用两种不同的电压表示，再送到<strong>数字信道</strong>上去传输(<strong>基带传输</strong>)<ol type="1"><li><strong>来自信源</strong>的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号</li><li>基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号</li></ol></li><li><strong>宽带信号Passband</strong>：将基带信号进行调制后形成的频分复用模拟信号，再传送到<strong>模拟信道</strong>上去传输(<strong>宽带传输</strong>)<ol type="1"><li>把基带信号经过<strong>载波调制</strong>后，把信号的<strong>频率范围搬移</strong>到<strong>较高的频段</strong>以便在信道中传输(即仅在一段频率范围内能够通过信道)</li></ol></li><li>在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化)</li><li>在传输距离较远时，计算机网络采用宽带传输方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)</li></ol></li></ol><h3 id="编码与调制">2.5.2 编码与调制</h3><p><img src="/images/AssetMarkdown/image-20221113171517993.png" alt="image-20221113171517993" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221113171553542.png" alt="image-20221113171553542" style="zoom:80%;" /></p><h3 id="数字数据-编码为-数字信号">2.5.3 数字数据 编码为 数字信号</h3><ol type="1"><li><p><strong>非归零编码【NRZ】</strong>：高1低0</p><ol type="1"><li>编码容易实现</li><li>但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方<strong>难以保持同步</strong></li></ol></li><li><p>归零编码【RZ】：信号电平在一个码元之内都要恢复到0</p></li><li><p>反向不归零编码【NRZI】：信号电平翻转表示0，不变表示1</p><ol type="1"><li>需要时钟信号</li></ol></li><li><p><strong>曼彻斯特编码</strong>：</p><ol type="1"><li>规则：将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1；码元0则正好相反。也可以采用相反的规定</li><li>该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号(可用于同步)又作数据信号</li><li>但它所占的频带宽度是原始的基带宽度的两倍</li><li>每一个码元都被调成两个电平，所以<strong>数据传输速率只有调制速率的1/2</strong></li></ol></li><li><p><strong>差分曼彻斯特编码</strong>：同1异0</p><ol type="1"><li>规则：常用于局域网传输，其规则是:若码元为1，则前半个码元的电平，与上一个码元的后半个码元的电平相同，若为0，则相反</li><li>该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码</li></ol><p><img src="/images/AssetMarkdown/image-20221113172748058.png" alt="image-20221113172748058" style="zoom:67%;" /></p><p><img src="/images/AssetMarkdown/image-20221113172758786.png" alt="image-20221113172758786" style="zoom:67%;" /></p><p><img src="/images/AssetMarkdown/image-20221113172219724.png" alt="image-20221113172219724" style="zoom:67%;" /></p></li><li><p>4B/5B编码</p><ol type="1"><li>比特流中插入额外的比特以打破连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B</li><li>编码效率为80%</li></ol><p><img src="/images/AssetMarkdown/image-20221113172937516.png" alt="image-20221113172937516" style="zoom:67%;" /></p></li></ol><h3 id="数字数据-调制为-模拟信号">2.5.4 数字数据 调制为 模拟信号</h3><ol type="1"><li>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程</li><li>分为：调幅(ASK)、调频(FSK)、调相(PSK)、调幅+调相(QAM)</li></ol><p><img src="/images/AssetMarkdown/image-20221113173212187.png" alt="image-20221113173212187" style="zoom:67%;" /></p><h3 id="模拟数据-编码为-数字信号">2.5.5 模拟数据 编码为 数字信号</h3><ol type="1"><li>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列(即实现<strong>音频数字化</strong>)</li><li>最典型的例子就是对音频信号进行编码的脉码调制(<strong>PCM</strong>)，在计算机应用中，能够达到<strong>最高保真水平</strong>的就是<strong>PCM编码</strong>，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步：<ol type="1"><li><strong>抽样</strong>：对模拟信号进行周期性扫描<ol type="1"><li>把时间上连续的信号变为时间上离散的信号</li><li>为了使所得的离散信号能够无失真的代表被抽样的模拟数据，要使用采样定理进行采样</li><li><strong>f<sub>采样频率</sub> ≥2f<sub>信号最高频率</sub></strong></li></ol></li><li><strong>量化</strong>：把抽样取得的电平幅值按照一定的分级标准转化为对应的数字值，并取整数。<ol type="1"><li>把连续的电平幅值转化为离散的数据量</li></ol></li><li><strong>编码</strong>：把量化的结果转化为与之对应的二进制编码</li></ol></li></ol><h3 id="模拟数据-调制为-模拟信号">2.5.6 模拟数据 调制为 模拟信号</h3><ol type="1"><li>为了实现传输的有效性，可能需要较高的频率</li><li>这种调制方式还可以使用频分复用技术，充分利用带宽资源</li><li>在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的</li></ol><p><img src="/images/AssetMarkdown/image-20221113190432048.png" alt="image-20221113190432048" style="zoom:80%;" /></p><h3 id="总结-5">2.5.7 总结</h3><p><img src="/images/AssetMarkdown/image-20221113190415378.png" alt="image-20221113190415378" style="zoom:80%;" /></p><h2 id="复用multiplexing">2.6 复用Multiplexing</h2><h3 id="频分复用fdmafrequency-division-multiplexing">2.6.1频分复用FDMA：Frequency Division Multiplexing</h3><p><img src="/images/AssetMarkdown/image-20221231161448196.png" alt="image-20221231161448196" style="zoom:80%;" /></p><ol type="1"><li>一人一个频段，一起发送</li><li>缺点：相邻子信道之间需要有保护频段</li></ol><h3id="正交频分复用ofdmorthogonal-frequency-division-multiplexing">2.6.2正交频分复用OFDM：Orthogonal Frequency Division Multiplexing</h3><p><img src="/images/AssetMarkdown/image-20221231161609812.png" alt="image-20221231161609812" style="zoom:80%;" /></p><ol type="1"><li>相邻子信道之间叠在一起，不需要保护频段</li><li>使用示例：4G、5G、WIFI</li></ol><h3 id="时分复用tdmatime-division-multiplexing">2.6.3 时分复用TDMA：TimeDivision Multiplexing</h3><p><img src="/images/AssetMarkdown/image-20221231161719420.png" alt="image-20221231161719420" style="zoom:80%;" /></p><ol type="1"><li>一人一个字节，轮流发送</li></ol><h3 id="码分复用cdmacode-division-multiplexing">2.6.4 码分复用CDMA：CodeDivision Multiplexing</h3><p><img src="/images/AssetMarkdown/image-20221231161836274.png" alt="image-20221231161836274" style="zoom:80%;" /></p><ol type="1"><li>大家的时间、频率是重叠在一起的，同时发送，但是同一段数据对不同人表示的含义不一样</li><li>每个人使用的0/1的码型，两两之间是正交的<ol type="1"><li>正交：对应位相乘，然后相加，得到的和为0</li></ol></li><li>具体见<strong>3.5.1.3.5</strong></li></ol><h2 id="各种网络">2.7 各种网络</h2><h3 id="固定电话网">2.7.1 固定电话网</h3><h4 id="电话网">2.7.1.1 电话网</h4><p><img src="/images/AssetMarkdown/image-20221231162429588.png" alt="image-20221231162429588" style="zoom:80%;" /></p><ol type="1"><li>电话机和端局之间：<strong>本地环路Local loop</strong><ol type="1"><li>通信的两个方向是叠加在同一根线上的</li><li>通常为模拟电路</li></ol></li><li>交换机和交换机之间：<strong>中继线trunk</strong><ol type="1"><li>中继线都是四线制的，通信的两个方向是分开的</li><li>通常为数字电路</li></ol></li></ol><h4 id="调制解调器-modems">2.7.1.2 调制解调器 Modems</h4><p><img src="/images/AssetMarkdown/image-20221231162845030.png" alt="image-20221231162845030" style="zoom:80%;" /></p><ol type="1"><li>由于中继线是数字化的，因此分配给每个用户的通话频率是固定的，不能超过4kHz</li><li>需要将基带信号调制为4kHz以内的音频信号，在电话线上进行传输</li><li><strong>modems</strong>：调制解调器</li></ol><h4 id="adsl">2.7.1.3 ADSL</h4><p><img src="/images/AssetMarkdown/image-20221231163129059.png" alt="image-20221231163129059" style="zoom:80%;" /></p><ol type="1"><li><strong>ADSL</strong>：在本地环路上，低频部分用于打电话，高频部分用于上网<ol type="1"><li>高频部分通过频分复用，分为上传/下载部分</li></ol></li></ol><h4 id="ftth">2.7.1.4 FTTH</h4><p><img src="/images/AssetMarkdown/image-20221231163253090.png" alt="image-20221231163253090" style="zoom:80%;" /></p><ol type="1"><li><strong>FTTH</strong>：电信局通过一根光纤连接到分光器，由分光器将数据分发给家家户户<ol type="1"><li>家庭到电信局的数据：发给分光器，然后走共享光纤</li><li>电信局到家庭的数据：走共享光纤发给分光器，然后广播</li></ol></li><li>分光器：是无源设备</li></ol><h4 id="t1">2.7.1.5 T1</h4><p><img src="/images/AssetMarkdown/image-20221231163608997.png" alt="image-20221231163608997" style="zoom:80%;" /></p><h4 id="sonetsdh">2.7.1.6 SONET、SDH</h4><p><img src="/images/AssetMarkdown/image-20221231163802561.png" alt="image-20221231163802561" style="zoom:80%;" /></p><ol type="1"><li>将一个2M的电路，一步甩到几个G的电路上跑</li></ol><h3 id="移动通信网">2.7.2 移动通信网</h3><table><colgroup><col style="width: 3%" /><col style="width: 7%" /><col style="width: 13%" /><col style="width: 17%" /><col style="width: 57%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">采用技术</th><th style="text-align: center;">支持的通信</th><th style="text-align: center;">复用方法</th><th style="text-align: center;">标准</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1G</td><td style="text-align: center;">模拟技术</td><td style="text-align: center;">话音通信</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">2G</td><td style="text-align: center;">数字技术</td><td style="text-align: center;">话音通信</td><td style="text-align: center;">码分复用</td><td style="text-align: center;">GSM(欧洲)、CDMA(北美)</td></tr><tr class="odd"><td style="text-align: center;">3G</td><td style="text-align: center;">数字技术</td><td style="text-align: center;">话音、数据通信</td><td style="text-align: center;">CDMA标准的码分复用</td><td style="text-align: center;">WCDMA(欧洲, 中国联通)<br>CDMA-2000(北美, 中国电信) <br>TDSCDMA(中国移动)</td></tr><tr class="even"><td style="text-align: center;">4G</td><td style="text-align: center;">数字技术</td><td style="text-align: center;">数据通信</td><td style="text-align: center;">正交频分复用OFDM</td><td style="text-align: center;">TD-LTE、FDD-LTE</td></tr><tr class="odd"><td style="text-align: center;">5G</td><td style="text-align: center;">数字技术</td><td style="text-align: center;">数据通信</td><td style="text-align: center;">都会用到</td><td style="text-align: center;"></td></tr></tbody></table><h2 id="物理层的传输介质">2.8 物理层的传输介质</h2><h3 id="传输介质及分类">2.8.1 传输介质及分类</h3><ol type="1"><li>传输介质<ol type="1"><li>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路</li><li>传输媒体并不是物理层</li><li>传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层</li><li>在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了<strong>电气特性</strong>，因此能够识别所传送的比特流</li></ol></li><li>传输介质的分类<ol type="1"><li>导向性传输介质：<ol type="1"><li>电磁波被导向沿着固体媒介(铜线/光纤)传播</li></ol></li><li>非导向性传输介质：<ol type="1"><li>自由空间，介质可以是空气、真空、海水灯</li></ol></li></ol></li></ol><h3 id="导向性传输介质双绞线">2.8.2 导向性传输介质：双绞线</h3><p><img src="/images/AssetMarkdown/image-20221113190911864.png" alt="image-20221113190911864" style="zoom:80%;" /></p><ol type="1"><li>双绞线是古老、又最常用的传输介质</li><li>它由<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的<strong>铜导线</strong>组成</li><li><strong>绞合可以减少对相邻导线的电磁干扰</strong></li><li>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<strong>金属丝</strong>编织成的屏蔽层，这就是<strong>屏蔽双绞线(STP)</strong>，无屏蔽层的双绞线就称为<strong>非屏蔽双绞线(UTP)</strong></li><li>特点：<ol type="1"><li>双绞线价格<strong>便宜</strong>，是最常用的传输介质之一，在局域网和传统电话网中普遍使用</li><li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里</li><li>距离太远时，对于<strong>模拟传输</strong>，要用<strong>放大器</strong>放大衰减的信号；对于<strong>数字传输</strong>，要用<strong>中继器</strong>将失真的信号整形</li></ol></li></ol><h3 id="导向性传输介质同轴电缆">2.8.3 导向性传输介质：同轴电缆</h3><p><img src="/images/AssetMarkdown/image-20221113191213938.png" alt="image-20221113191213938" style="zoom:80%;" /></p><ol type="1"><li>同轴电缆由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层构成</li><li>按特性阻抗数值的不同，通常将同轴电缆分为两类：50Ω同轴电缆和75Ω同轴电缆。<ol type="1"><li>50Ω同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，它在局域网中得到广泛应用</li><li>75Ω同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，它主要用于有线电视系统</li></ol></li><li>同轴电缆 vs 双绞线<ol type="1"><li>由于外导体屏蔽层的作用，同轴电缆<strong>抗干扰特性</strong>比双线好，被广泛用于传输较高，速率的数据，其传输距离更远</li><li>但价格较双绞线贵</li></ol></li></ol><h3 id="导向性传输介质光纤">2.8.4 导向性传输介质：光纤</h3><p><img src="/images/AssetMarkdown/image-20221113191544856.png" alt="image-20221113191544856" style="zoom:80%;" /></p><ol type="1"><li><p>光纤通信就是利用光导纤维(简称光纤)传递光脉冲来进行通信。有光脉冲表示1，无光脉冲表示0</p></li><li><p>而可见光的频率大约是10MHz，因此光纤通信系统的<strong>带宽远远大于</strong>目前其他各种传输媒体的带宽</p></li><li><p>光纤主要由<strong>纤芯(实心的!)</strong>和<strong>包层</strong>构成</p><ol type="1"><li>光波通过纤芯进行传导，包层较纤芯有较低的折射率</li><li>当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角</li><li>因此，如果入射角足够大，就会出现全反射，即光线碰到包，层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去</li></ol></li><li><p>多模光纤与单模光纤</p><p><img src="/images/AssetMarkdown/image-20221113191723325.png" alt="image-20221113191723325" style="zoom:80%;" /></p></li><li><p>特点：</p><ol type="1"><li>传输<strong>损耗小</strong>，中继距离长，对远距离传输特别经济</li><li><strong>抗雷电</strong>和<strong>电磁干扰</strong>性能好</li><li>无串音干扰，保密性好，也<strong>不易被窃听或截取数据</strong></li><li><strong>体积小，重量轻</strong></li></ol></li></ol><h3 id="非导向性传输介质">2.8.5 非导向性传输介质</h3><ol type="1"><li>无线电波：<ol type="1"><li>信号向所有方向传播</li><li>较强<strong>穿透能力</strong>，可传远距离</li><li>广泛应用于通信领域</li></ol></li><li>微波：<ol type="1"><li>信号固定方向传播</li><li>微波通信频率较高、频段范围宽，因此数据率很高</li><li>应用于地面微波接力通信、卫星通信</li><li>卫星通信：<ol type="1"><li>优点：通信容量大、距离远、覆盖广、广播通信和多址通信</li><li>缺点：传播时延长(250~270ms)、受气候影响大、误码率高、成本高</li></ol></li></ol></li><li>红外线、激光：<ol type="1"><li>信号固定方向传播</li><li>把要传输的信号分别<strong>转换为各自的信号格式</strong>，即红外信号和激光信号，再向空间中传播</li></ol></li></ol><h3 id="总结-6">2.8.6 总结</h3><p><img src="/images/AssetMarkdown/image-20221113192314851.png" alt="image-20221113192314851" style="zoom:80%;" /></p><h2 id="物理层设备">2.9 物理层设备</h2><h3 id="中继器">2.9.1 中继器</h3><p><img src="/images/AssetMarkdown/image-20221113192538817.png" alt="image-20221113192538817" style="zoom:80%;" /></p><ol type="1"><li>诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误</li><li>中继器的功能：对信号进行<strong>再生</strong>和<strong>还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度</li><li>中继器的两端：<ol type="1"><li>两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类</strong>网络的互连，且两个网段速率要相同</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据</li><li>两端可连相同媒体，也可连不同媒体</li><li>中继器两端的网段一定要是同一个协议。(中继器不会存储转发)</li></ol></li><li><strong>5-4-3规则</strong>：<ol type="1"><li>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障</li><li>只能有最多不超过<strong>5</strong>个网段，最多有<strong>4</strong>个物理层的设备，只有<strong>3</strong>个段可以挂接计算机</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221113192930270.png" alt="image-20221113192930270" style="zoom:80%;" /></p><h3 id="集线器多口中继器">2.9.2 集线器(多口中继器)</h3><p><img src="/images/AssetMarkdown/image-20221113193026268.png" alt="image-20221113193026268" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221113193631458.png" alt="image-20221113193631458" style="zoom:80%;" /></p><ol type="1"><li>集线器的功能：对信号进行<strong>再生放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有(除输入端口外)处于工作，状态的端口上，以增加信号传输的距离，延长网络的长度<ol type="1"><li>不具备信号的定向传送能力，是一个共享式设备【广播】</li></ol></li></ol><h2 id="物理层总结">2.10 物理层总结</h2><p><img src="/images/AssetMarkdown/image-20221113193707636.png" alt="image-20221113193707636" style="zoom:80%;" /></p><h1 id="chapter-3数据链路层">Chapter 3：数据链路层</h1><h2 id="数据链路层功能概述">3.1 数据链路层功能概述</h2><h3 id="数据链路层的相关概念">3.1.1 数据链路层的相关概念</h3><ol type="1"><li><strong>结点</strong>：主机、路由器</li><li><strong>链路</strong>：网络中两个结点之间的<strong>物理通道</strong><ol type="1"><li>链路的传输介质主要有双绞线、光纤和微波</li><li>链路分为有线链路、无线链路。</li></ol></li><li><strong>数据链路</strong>：网络中两个结点之间的<strong>逻辑通道</strong>，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路</li><li><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报</li><li><strong>数据链路层</strong>负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报</li></ol><h3 id="数据链路层的功能">3.1.2 数据链路层的功能</h3><p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据<strong>可靠</strong>地传输到相邻节点的目标机网络层。其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路</p><p><img src="/images/AssetMarkdown/image-20221115102409340.png" alt="image-20221115102409340" style="zoom:80%;" /></p><ol type="1"><li>为网络层提供服务：<ol type="1"><li>无确认无连接服务：通信质量好的有线通信</li><li>有确认无连接服务：无线通信</li><li>有确认面向连接服务：无线通信</li><li><strong>有连接一定有确认</strong></li></ol></li><li>链路管理：<ol type="1"><li>连接的建立、维持、释放</li><li>用于面向连接的服务</li></ol></li><li>组帧</li><li>流量控制<ol type="1"><li>限制发送方</li></ol></li><li>差错控制<ol type="1"><li>帧错</li><li>位错</li></ol></li></ol><h2 id="封装成帧-透明传输">3.2 封装成帧 &amp; 透明传输</h2><h3 id="封装成帧">3.2.1 封装成帧</h3><p><img src="/images/AssetMarkdown/image-20221115103117195.png" alt="image-20221115103117195" style="zoom:80%;" /></p><ol type="1"><li><strong>封装成帧</strong>：在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束</li><li>首部和尾部包含很多控制信息，其中一个重要的作用为：<strong>帧定界</strong>（确定帧的界限）</li><li><strong>帧同步</strong>：<strong>接收方</strong>应当能从接收到的二进制比特流中区分出帧的起始和终止</li></ol><h3 id="透明传输">3.2.2 透明传输</h3><ol type="1"><li><strong>透明传输</strong>：指不管所传的数据是什么样的比特组合，都应当能够在链路上传输。因此，链路层就“看不见”有什么妨碍数据传输的东西</li><li>当所传的数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使得接收方不会将这样的数据误认为时某种控制信息。这样才能保证数据链路层的传输是透明的</li></ol><h3 id="组帧的四种方法">3.2.3 组帧的四种方法</h3><h4 id="字符计数法">3.2.3.1 字符计数法</h4><p><img src="/images/AssetMarkdown/image-20221115103709113.png" alt="image-20221115103709113" style="zoom: 67%;" /></p><ol type="1"><li>帧首部使用一个计数字段(第一个<strong>字节</strong>，8位)来表明帧内字符(节)数</li><li>缺点：一旦第一个字节出错，后面所有的帧都会跟着出错</li></ol><h4 id="字符节填充法">3.2.3.2 字符(节)填充法</h4><p><img src="/images/AssetMarkdown/image-20221115103822523.png" alt="image-20221115103822523" style="zoom: 67%;" /></p><ol type="1"><li>SOH和EOT具体指什么，根据具体的协议而定</li><li>当传送的帧由ASCII码文本文件组成时，不管键盘上输入的是什么字符，都可以放在帧里传过去，即<strong>透明传输</strong></li><li>当传送的帧是由非ASCII码的文本文件组成时(二进制代码或图像等)，就要<strong>采用字符填充方法实现透明传输</strong></li><li>字符填充法：在数据中的EOT/SOH前方添加一个<strong>转义字符ESC</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221115104254949.png" alt="image-20221115104254949" style="zoom:80%;" /></p><h4 id="零比特填充法重点">3.2.3.3零比特填充法(<strong>重点</strong>)</h4><p><img src="/images/AssetMarkdown/image-20221115104336747.png" alt="image-20221115104336747" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221115104456514.png" alt="image-20221115104456514" style="zoom:67%;" /></p><ol type="1"><li>发送端：扫描整个信息字段，只要连续5个1，就立即填入1个0</li><li>接收端：先找到标志字段确定边界，再对比特流进行扫描，发现连续5个1时，就把后面的0删除</li></ol><h4 id="违规编码法">3.2.3.4 违规编码法</h4><p><img src="/images/AssetMarkdown/image-20221115104613011.png" alt="image-20221115104613011" style="zoom:80%;" /></p><ol type="1"><li>用两个编码中不会用到的电平，表示帧的开始和结束</li><li>目前普遍使用的帧同步法是：<strong>比特填充</strong>和<strong>违规编码</strong></li></ol><h2 id="差错控制">3.3 差错控制</h2><h3 id="检错编码">3.3.1 检错编码</h3><h4 id="差错从何而来">3.3.1.1 差错从何而来</h4><ol type="1"><li>概括来说，传输中的差错都是由于噪声引起的</li><li>全局性差错：由于线路本身电气特性所产生的<strong>随机噪声</strong>(热噪声)，是信道固有的，随机存在的<ol type="1"><li>解决办法：提高信噪比来减少或避免干扰(对传感器下手)</li></ol></li><li>局部性：外界特定的短暂原因所造成的<strong>冲击噪声</strong>，是产生差错的主要原因。<ol type="1"><li>解决办法：通常利用编码技术来解决</li></ol></li><li>差错的分类<ol type="1"><li>位错：比特位出错，1变成0，0变成1</li><li>帧错：【#1】-【#2】-【#3】<ol type="1"><li>帧丢失：【#1】-【#3】</li><li>帧重复：【#1】-【#2】-【#2】-【#3】</li><li>帧失序：【#1】-【#3】-【#2】</li></ol></li></ol></li></ol><h4 id="数据链路层的差错控制比特错">3.3.1.2数据链路层的差错控制(比特错)</h4><ol type="1"><li>差错控制(比特错)<ol type="1"><li>检错编码：奇偶校验码、循环冗余码CRC</li><li>纠错编码：海明码</li></ol></li><li>数据链路层的编码 vs 物理层的编码<ol type="1"><li>数据链路层编码和物理层的数据编码与调制不同</li><li>物理层编码针对的是<strong>单个比特</strong>，解决传输过程中比特的同步等问题，如曼彻斯特编码</li><li>而数据链路层的编码针对的是<strong>一组比特</strong>，它通过冗余码的技术实现一组二进制比特串在传输过程是否出现了差错</li></ol></li><li>冗余编码<ol type="1"><li>在数据发送之前，先按某种关系<strong>附加</strong>上一定的<strong>冗余位</strong>，构成一个符合某一规则的码字后再发送</li><li>当要发送的有效数据变化时，相应的冗余位也随之变化，使码字遵从不变的规则</li><li>接收端根据收到码字是否仍符合原规则，从而判断是否出错。</li></ol></li></ol><h5 id="检错编码奇偶校验码">3.3.1.2.1 检错编码：奇偶校验码</h5><ol type="1"><li>奇偶校验码：<strong>n-1</strong>位信息元，1位校验元<ol type="1"><li>奇校验码：”1“的个数是奇数</li><li>偶校验码：”1“的个数是偶数</li><li>注意，这里的个数包含校验元本身</li></ol></li><li>特点：只能检查出<strong>奇数个比特</strong>错误，检错能力位50%</li></ol><p><img src="/images/AssetMarkdown/image-20221115110125756.png" alt="image-20221115110125756" style="zoom:67%;" /></p><h5 id="检错编码crc循环冗余码重点">3.3.1.2.2检错编码：CRC循环冗余码(<strong>重点</strong>)</h5><p><img src="/images/AssetMarkdown/image-20221115110614634.png" alt="image-20221115110614634" style="zoom:80%;" /></p><ol type="1"><li><p>最终发送的数据：要发送的数据 + 帧检验序列FCS</p></li><li><p>计算冗余码</p><ol type="1"><li>加0：若生成多项式的G(x)的阶为r，则加r个0</li><li>模2除法：数据加0后除以多项式，余数为冗余码/FCS/CRC校验码的比特序列</li></ol><p><img src="/images/AssetMarkdown/image-20221115111043531.png" alt="image-20221115111043531" style="zoom:80%;" /></p></li><li><p>接收端检测的过程：</p><ol type="1"><li>把收到的每一个帧都除以同样的除数，然后检查得到的余数R<ol type="1"><li>余数为0，判定这个帧没有差错，接受。</li><li>余数为不为0，判定这个帧有差错(无法确定到位)，丢弃</li></ol></li><li>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输</li></ol></li><li><p>在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对帧的无差错接收，即“<strong>凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错</strong>”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。“凡是接收端数据链路层接收的帧均无差错”</p><ol type="1"><li><strong>可靠传输</strong>：数据链路层发送端发送什么，接收端就收到什么</li><li>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输</li></ol></li></ol><h3 id="纠错编码海明码重点">3.3.2纠错编码：海明码(<strong>重点</strong>)</h3><p>海明码：<strong>发现双</strong>比特错，<strong>纠正单</strong>比特错</p><p><img src="/images/AssetMarkdown/image-20221115111706921.png" alt="image-20221115111706921" style="zoom:80%;" /></p><ol type="1"><li><p>海明不等式：<span class="math inline">\(2^r \gek+r+1\)</span></p><ol type="1"><li><span class="math inline">\(r\)</span>：冗余信息位</li><li><span class="math inline">\(k\)</span>：信息位</li></ol><p><img src="/images/AssetMarkdown/image-20221115111801363.png" alt="image-20221115111801363" style="zoom: 67%;" /></p></li><li><p>确定校验码和数据的位置</p><p><img src="/images/AssetMarkdown/image-20221115111902445.png" alt="image-20221115111902445" style="zoom:80%;" /></p></li><li><p>求校验码的值</p><ol type="1"><li>要校验的位：<ol type="1"><li>如1的二进制表示为0001，则P<sub>1</sub>要校验的位为：P<sub>1</sub>、D<sub>1</sub>(0011)、D<sub>2</sub>(0101)、D<sub>4</sub>(0111)、D<sub>5</sub>(1001)</li><li>如2的二进制表示为0010，则P<sub>2</sub>要校验的位为：P<sub>2</sub>、D<sub>1</sub>(0011)、D<sub>3</sub>(0110)、D<sub>4</sub>(0111)、D<sub>6</sub>(1010)</li></ol></li><li>校验码的值<ol type="1"><li><strong>令所有要校验的位异或=0</strong></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221115112532663.png" alt="image-20221115112532663" style="zoom:80%;" /></p></li><li><p>检错并纠错</p><ol type="1"><li><strong>令所有要校验的位异或运算</strong></li><li>异或出来的结果逆序排列，所得结果即为出错的位置</li></ol><p><img src="/images/AssetMarkdown/image-20221115112835685.png" alt="image-20221115112835685" style="zoom:80%;" /></p></li></ol><h3 id="总结-7">3.3.3 总结</h3><p><img src="/images/AssetMarkdown/image-20221115112859589.png" alt="image-20221115112859589" style="zoom:80%;" /></p><h2 id="流量控制与可靠传输">3.4 流量控制与可靠传输</h2><p><strong>较高的发送速度</strong>和<strong>较低的接收能力</strong>的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作</p><h3 id="流量控制与可靠传输机制">3.4.1 流量控制与可靠传输机制</h3><h4 id="数据链路层的流量控制-与-传输层流量控制的区别">3.4.1.1数据链路层的流量控制 与 传输层流量控制的区别</h4><ol type="1"><li><strong>数据链路层</strong>的流量控制是：<strong>点对点</strong>的(两个相邻节点之间)</li><li><strong>传输层</strong>的流量控制是：<strong>端到端</strong>的(两个主机之间)</li><li><strong>数据链路层</strong>流量控制手段：接收方收不下就不回复确认</li><li><strong>传输层</strong>流量控制手段：接收端给发送端一个窗口公告</li></ol><h4 id="流量控制的方法">3.4.1.2 流量控制的方法</h4><ol type="1"><li><p>停止-等待协议：每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧</p><p><img src="/images/AssetMarkdown/image-20221117211143333.png" alt="image-20221117211143333" style="zoom:67%;" /></p></li><li><p>滑动窗口协议：<strong>链路层中，窗口的大小在发送过程中为固定值</strong></p><ol type="1"><li>后退N帧协议：GBN</li><li>选择重传协议：SR</li></ol><p><img src="/images/AssetMarkdown/image-20221117211302482.png" alt="image-20221117211302482" style="zoom:67%;" /></p></li></ol><table><thead><tr class="header"><th style="text-align: center;">协议</th><th style="text-align: center;">发送窗口大小</th><th style="text-align: center;">接收窗口大小</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">停止-等待协议</td><td style="text-align: center;">=1</td><td style="text-align: center;">=1</td></tr><tr class="even"><td style="text-align: center;">后退N帧协议：GBN</td><td style="text-align: center;">&gt;1</td><td style="text-align: center;">=1</td></tr><tr class="odd"><td style="text-align: center;">选择重传协议：SR</td><td style="text-align: center;">&gt;1</td><td style="text-align: center;">&gt;1</td></tr></tbody></table><h4 id="可靠传输流量控制滑动窗口">3.4.1.3可靠传输、流量控制、滑动窗口</h4><ol type="1"><li>可靠传输：发送端发啥，接收端收啥</li><li>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧</li><li>滑动窗口解决：<ol type="1"><li>流量控制：收不下就不给确认，想发也发不了</li><li>可靠传输：发送方自动重传</li></ol></li></ol><h3 id="停止-等待协议">3.4.2 停止-等待协议</h3><ol type="1"><li>为什么要有停止-等待协议?<ol type="1"><li>除了比特出差错，底层信道还会出现丢包问题。</li><li>丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失</li></ol></li><li>研究停等协议的前提?<ol type="1"><li>虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据(发送方)，一方接收数据(接收方)</li><li>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的</li><li>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</li></ol></li><li>停等协议有几种应用情况?<ol type="1"><li>无差错情况&amp;有差错情况</li></ol></li></ol><h4 id="停止-等待协议无差错情况">3.4.2.1 停止-等待协议：无差错情况</h4><p><img src="/images/AssetMarkdown/image-20221117212318210.png" alt="image-20221117212318210" style="zoom:80%;" /></p><h4 id="停止-等待协议有差错情况">3.4.2.2 停止-等待协议：有差错情况</h4><ol type="1"><li><p>数据帧丢失 / 检测到帧出错</p><p><img src="/images/AssetMarkdown/image-20221117212602243.png" alt="image-20221117212602243" style="zoom: 67%;" /></p></li><li><p>ACK丢失</p><p><img src="/images/AssetMarkdown/image-20221117212647980.png" alt="image-20221117212647980" style="zoom:67%;" /></p></li><li><p>ACK迟到</p><p><img src="/images/AssetMarkdown/image-20221117212727252.png" alt="image-20221117212727252" style="zoom:67%;" /></p></li></ol><h4 id="停止-等待协议性能分析">3.4.2.3 停止-等待协议：性能分析</h4><p>优点：</p><ol type="1"><li>简单</li></ol><p>缺点：</p><ol type="1"><li>信道利用率太低</li></ol><p><img src="/images/AssetMarkdown/image-20221117212856763.png" alt="image-20221117212856763" style="zoom:80%;" /></p><h4 id="信道利用率">3.4.2.4 信道利用率</h4><p>信道利用率：发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率</p><ol type="1"><li>信道利用率 = <span class="math inline">\((L / C)/T\)</span></li><li><span class="math inline">\(L\)</span>：<spanclass="math inline">\(T\)</span>时间内发送<spanclass="math inline">\(L\)</span>比特数据</li><li><span class="math inline">\(C\)</span>：发送方数据传输率</li><li><spanclass="math inline">\(T\)</span>：发送周期，从开始发送数据，到收到第一个确认帧为止</li></ol><p>信道吞吐率 = 信道利用率 × 发送方的发送速率</p><p><img src="/images/AssetMarkdown/image-20221117213239451.png" alt="image-20221117213239451" style="zoom:80%;" /></p><h4 id="总结-8">3.4.2.5 总结</h4><p><img src="/images/AssetMarkdown/image-20221117213301011.png" alt="image-20221117213301011" style="zoom:80%;" /></p><h3 id="后退n帧协议-go-back-n">3.4.3 后退N帧协议 Go Back N</h3><h4 id="停止等待协议的弊端">3.4.3.1 停止等待协议的弊端</h4><ol type="1"><li>信道利用率过低</li></ol><p><img src="/images/AssetMarkdown/image-20221117220840158.png" alt="image-20221117220840158" style="zoom: 67%;" /></p><h4 id="后退n帧协议中的滑动窗口">3.4.3.2 后退N帧协议中的滑动窗口</h4><ol type="1"><li>发送窗口：发送方维持一组连续的允许发送的帧的序号</li><li>接收窗口：接收方维持一组连续的允许接收的帧的序号</li></ol><p><img src="/images/AssetMarkdown/image-20221117221239590.png" alt="image-20221117221239590" style="zoom:67%;" /></p><h4 id="gbn发送方">3.4.3.3 GBN发送方</h4><ol type="1"><li>上层的调用<ol type="1"><li>上层要发送数据时，发送方先检查发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧并将其发送</li><li>如果窗口<strong>已满</strong>，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送</li><li>实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧</li></ol></li><li>收到了一个ACK<ol type="1"><li>GBN协议中，对n号帧的确认采用<strong>累积确认</strong>的方式，标明接收方已经收到n号帧和它之前的全部帧。</li></ol></li><li>超时事件<ol type="1"><li>协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为</li><li>就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失</li><li>如果出现超时，发送方重传所有已发送但未被确认的帧</li></ol></li></ol><h4 id="gbn接收方">3.4.3.4 GBN接收方</h4><ol type="1"><li>如果正确收到n号帧，并且<strong>按序</strong>，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层</li><li>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK<ol type="1"><li>接收方无需缓存任何失序帧，只需要维护一个信息：expectedseqnum(下一个按序接收的帧序号)</li></ol></li></ol><h4 id="运行中的gbn协议">3.4.3.5 运行中的GBN协议</h4><p><img src="/images/AssetMarkdown/image-20221117222217016.png" alt="image-20221117222217016" style="zoom:80%;" /></p><h4 id="滑动窗口长度发送窗口最大为2n-1接收窗口为1">3.4.3.6滑动窗口长度：发送窗口最大为<spanclass="math inline">\(2^{n}-1\)</span>，接收窗口为1</h4><p>窗口大小和序号大小相比，窗口大小过大时，可能导致</p><ol type="1"><li>接收方并不知道收到的0号帧是新的还是旧的</li></ol><h4 id="gbn协议重点总结">3.4.3.7 GBN协议重点总结</h4><ol type="1"><li>累计确认：ACK N表示0~N都已经正常收到</li><li>捎带确认：将确认帧放到接收方要发送的数据中</li><li>接收方只按顺序接收帧，不按序都丢弃</li><li>确认序列号最大的、按序到达的帧</li><li>发送窗口最大为<spanclass="math inline">\(2^{n}-1\)</span>，接收窗口大小为1</li></ol><p><img src="/images/AssetMarkdown/image-20221117223002240.png" alt="image-20221117223002240" style="zoom:80%;" /></p><h4 id="gbn协议性能分析">3.4.3.8 GBN协议性能分析</h4><p>优点：</p><ol type="1"><li>因连续发送数据帧而提高了信道利用率</li></ol><p>缺点：</p><ol type="1"><li>在重传时必须把原来已经正确传送的数据帧重传，是传送效率降低</li></ol><h4 id="总结-9">3.4.3.9 总结</h4><p><img src="/images/AssetMarkdown/image-20221117223109038.png" alt="image-20221117223109038" style="zoom:80%;" /></p><h3 id="选择重传协议-selective-repeat">3.4.4 选择重传协议 SelectiveRepeat</h3><h4 id="gbn协议的弊端">3.4.4.1 GBN协议的弊端</h4><ol type="1"><li>累计确认 ==&gt; 批量重传</li><li>解决方法：只重传出错的帧<ol type="1"><li>设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧</li></ol></li></ol><h4 id="选择重传协议中的滑动窗口">3.4.4.2 选择重传协议中的滑动窗口</h4><p><img src="/images/AssetMarkdown/image-20221117214705045.png" alt="image-20221117214705045" style="zoom:80%;" /></p><h4 id="sr发送方">3.4.4.3 SR发送方</h4><ol type="1"><li><p>上层的调用</p><ol type="1"><li>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧</li><li>否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输</li></ol></li><li><p>收到了一个ACK</p><ol type="1"><li>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收</li><li>如果该帧序号是窗口的下界(最左边第一个窗口对应的序号)，则窗口向前移动到具有最小序号的未确认帧处</li><li>如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧</li></ol><p><img src="/images/AssetMarkdown/image-20221117215330140.png" alt="image-20221117215330140" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221117215306773.png" alt="image-20221117215306773" style="zoom:80%;" /></p></li><li><p>超时事件</p><ol type="1"><li>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧</li></ol></li></ol><h4 id="sr接收方">3.4.4.4 SR接收方</h4><p>来者不拒(窗口内的帧)</p><ol type="1"><li>SR接收方将<strong>确认一个正确接收的帧</strong>而<strong>不管其是否按序</strong></li><li>失序的帧将被<strong>缓存</strong>，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有帧(即序号更小的帧)皆被收到为止</li><li>这时才可以将一批帧按序交付给上层，然后向前移动滑动窗口</li></ol><p><img src="/images/AssetMarkdown/image-20221117215537537.png" alt="image-20221117215537537" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221117215630148.png" alt="image-20221117215630148" style="zoom:80%;" /></p><h4 id="运行中的sr">3.4.4.5 运行中的SR</h4><p><img src="/images/AssetMarkdown/image-20221117215928586.png" alt="image-20221117215928586" style="zoom:80%;" /></p><h4 id="滑动窗口长度发送窗口接收窗口最大为2n-1">3.4.4.6滑动窗口长度：发送窗口=接收窗口，最大为<spanclass="math inline">\(2^{n-1}\)</span></h4><p>窗口大小和序号大小相比，窗口大小过大时，可能导致</p><ol type="1"><li>接收方并不知道收到的0号帧是新的还是旧的</li></ol><p><img src="/images/AssetMarkdown/image-20221117220136622.png" alt="image-20221117220136622" style="zoom:80%;" /></p><p>滑动窗口大小的设置：</p><ol type="1"><li>发送窗口最好等于接收窗口<ol type="1"><li>大了会溢出，小了没意义</li></ol></li><li><span class="math inline">\(W_{Tmax}=W_{Rmax}=2^{n-1}\)</span><ol type="1"><li><span class="math inline">\(n\)</span>为编号的位数</li></ol></li></ol><h4 id="sr协议重点总结">3.4.4.7 SR协议重点总结</h4><ol type="1"><li>对数据逐一确认，收一个确认一个</li><li>只重传出错帧</li><li>接收方有缓存</li><li><span class="math inline">\(W_{Tmax}=W_{Rmax}=2^{n-1}\)</span></li></ol><p><img src="/images/AssetMarkdown/image-20221117220548869.png" alt="image-20221117220548869" style="zoom:80%;" /></p><h4 id="总结-10">3.4.4.8 总结</h4><p><img src="/images/AssetMarkdown/image-20221117220607511.png" alt="image-20221117220607511" style="zoom:80%;" /></p><h2 id="介质访问控制">3.5 介质访问控制</h2><p><img src="/images/AssetMarkdown/image-20221122113957794.png" alt="image-20221122113957794" style="zoom:80%;" /></p><h3 id="信道划分介质访问控制">3.5.1 信道划分介质访问控制</h3><h4 id="传输数据使用的两种链路">3.5.1.1 传输数据使用的两种链路</h4><ol type="1"><li>点对点链路<ol type="1"><li>两个相邻节点通过一个链路相连，没有第三者</li><li>应用：PPP协议，常用于<strong>广域网</strong></li></ol></li><li>广播式电路<ol type="1"><li>所有主机共享通信介质</li><li>应用：早期的总线以太网、无线局域网，常用于<strong>局域网</strong></li><li>典型拓扑结构：<ol type="1"><li>总线型</li><li>星型：逻辑总线型，中心一般是一个集线器，更加灵活</li></ol></li></ol></li></ol><h4 id="介质访问控制-1">3.5.1.2 介质访问控制</h4><p>介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况</p><ol type="1"><li>静态划分信道：信道划分介质访问控制<ol type="1"><li>频分多路复用 FDM</li><li>时分多路复用 TDM</li><li>波分多路复用 WDM</li><li>码分多路复用 CDM</li></ol></li><li>动态划分信道<ol type="1"><li>轮询访问介质控制<ol type="1"><li>令牌传递协议</li></ol></li><li>随机访问介质访问控制<ol type="1"><li>ALOHA协议</li><li>CSMA协议</li><li>CSMA/CD协议</li><li>CSMA/CA协议</li></ol></li></ol></li></ol><h4 id="信道划分介质访问控制-1">3.5.1.3 信道划分介质访问控制</h4><ol type="1"><li>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的<strong>通信隔离开</strong>，把<strong>时域和频域资源</strong>合理的分配给网络上的设备</li><li>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备<strong>共享信道资源</strong>，提高信道利用率</li><li><strong>实际就是把广播信道转变为点对点信道</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221122101917849.png" alt="image-20221122101917849" style="zoom:80%;" /></p><h5 id="频分多路复用-fdm">3.5.1.3.1 频分多路复用 FDM</h5><ol type="1"><li>所有用户在同样时间，占用不同的带宽(频率带宽)资源</li></ol><p><img src="/images/AssetMarkdown/image-20221122102140039.png" alt="image-20221122102140039" style="zoom:80%;" /></p><h5 id="时分多路复用-tdm">3.5.1.3.2 时分多路复用 TDM</h5><ol type="1"><li>将时间划分为一段段等长的时分复用帧(TDM帧)</li><li>每个用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道</li><li>若一个TDM帧为8000b/s，则每个人最高2000b/s</li></ol><p><img src="/images/AssetMarkdown/image-20221122102417465.png" alt="image-20221122102417465" style="zoom:80%;" /></p><h5 id="改进的时分复用统计时分复用-stdm">3.5.1.3.3改进的时分复用：统计时分复用 STDM</h5><ol type="1"><li>若一个STDM帧为8000b/s，则每个人最高8000b/s</li></ol><p><img src="/images/AssetMarkdown/image-20221122102547421.png" alt="image-20221122102547421" style="zoom:80%;" /></p><h5 id="波分多路复用-wdm">3.5.1.3.4 波分多路复用 WDM</h5><ol type="1"><li>波分多路复用：就是<strong>光的频分多路复用</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221122102939945.png" alt="image-20221122102939945" style="zoom:80%;" /></p><h5 id="码分多路复用-cdm重点">3.5.1.3.5 码分多路复用CDM(<strong>重点</strong>)</h5><ol type="1"><li><p><strong>码分多址CDMA</strong>：码分复用的一种方式</p></li><li><p>1个比特分为多个码片/芯片(chip)，每个站点指定一个唯一的m位的芯片序列</p></li><li><p>发送1时站点发送芯片序列，发送0时发送芯片序列的反码(通常把0写成-1)</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">A</th><th style="text-align: center;">B</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">芯片序列</td><td style="text-align: center;">+1 -1 -1 +1 +1 +1 +1 -1</td><td style="text-align: center;">-1 +1 -1 +1 -1 +1 +1 +1</td></tr><tr class="even"><td style="text-align: center;">反码</td><td style="text-align: center;">-1 +1 +1 -1 -1 -1 -1 +1</td><td style="text-align: center;">+1 -1 +1 -1 +1 -1 -1 -1</td></tr></tbody></table></li><li><p><strong>如何不打架</strong>：多个站点同时发送数据时，要求每个站点<strong>芯片序列相互正交</strong>(规格内积化为0)</p><ol type="1"><li>即A和B发送的数据，对应位相乘再相加，结果为0</li></ol></li><li><p><strong>如何合并</strong>：各路数据在信道中被<strong>线性相加</strong></p><ol type="1"><li>如A发送0，B发送1，则为(-2 +2 0 0 -2 0 0 +2)</li></ol></li><li><p><strong>如何分离</strong>：合并的数据与源站的芯片序列规格化内积</p><ol type="1"><li>A发送的数据：(+1 -1 -1 +1 +1 +1 +1 -1) · (-2 +2 0 0 -2 0 0 +2) / 8 =-1 ==&gt; 0</li><li>B发送的数据：(-1 +1 -1 +1 -1 +1 +1 +1) · (-2 +2 0 0 -2 0 0 +2) / 8 =1 ==&gt; 1</li></ol></li></ol><h4 id="cd还是cs">3.5.1.4 CD还是CS</h4><p><img src="/images/AssetMarkdown/image-20221122104208664.png" alt="image-20221122104208664" style="zoom:80%;" /></p><h3 id="aloha协议">3.5.2 ALOHA协议</h3><h4 id="纯aloha协议">3.5.2.1 纯ALOHA协议</h4><p>纯ALOHA协议思想：不监听信道，不按时间发送，随即重发。<strong>想发就发</strong></p><ol type="1"><li>冲突检测：如果发生冲突，接收方就会检测出差错，然后不予确认，发送方在一定时间内收不到ACK就判断发生冲突</li><li>冲突解决：超时后等一段随机的时间，然后重传</li></ol><p><img src="/images/AssetMarkdown/image-20221122104659713.png" alt="image-20221122104659713" style="zoom:80%;" /></p><h4 id="时隙aloha协议">3.5.2.2 时隙ALOHA协议</h4><p>时隙ALOHA协议思想：把时间分为若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，如果发生冲突，则必须等到下一个时间片开始时刻再发送。<strong>控制想发就发的随意性</strong></p><p><img src="/images/AssetMarkdown/image-20221122105526808.png" alt="image-20221122105526808" style="zoom:80%;" /></p><h4 id="关于aloha协议">3.5.2.3 关于ALOHA协议</h4><ol type="1"><li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低</li><li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发</li></ol><h3 id="csma协议">3.5.3 CSMA协议</h3><p>CSMA：载波监听多路访问协议，carrier sense multiple access</p><ol type="1"><li><strong>CS</strong>：载波侦听/监听，每一个站在<strong>发送数据之前</strong>要检测一下总线上是否有其他计算机在发送数据<ol type="1"><li>检测方法：当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</li></ol></li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>协议思想</strong>：发送帧之前，<strong>监听</strong>信道</li><li>监听结果：<ol type="1"><li>信道空闲：发送完整帧<ol type="1"><li>1-坚持CSMA</li><li>非坚持CSMA</li><li>p-坚持CSMA</li></ol></li><li>信道忙：推迟发送</li></ol></li></ol><h4 id="坚持csma">3.5.3.1 1-坚持CSMA</h4><ol type="1"><li>坚持：指的是对于<strong>监听信道忙</strong>之后的坚持</li><li>1-坚持CSMA思想：<ol type="1"><li>如果一个主机要发送消息，那么它先监听信道</li><li><strong>空闲则直接传输，不必等待</strong></li><li><strong>忙则一直监听，直到空闲马上传输</strong></li><li>如果<strong>有冲突</strong>(一段时间内未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程</li></ol></li><li><strong>优点</strong>：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失</li><li><strong>缺点</strong>：假如有两个或两个以上的站点有数据要发送，冲突就不可避免</li></ol><h4 id="非坚持csma">3.5.3.2 非坚持CSMA</h4><ol type="1"><li>非坚持：指的是对于<strong>监听信道忙</strong>之后就不继续监听</li><li>非坚持CSMA思想：<ol type="1"><li>如果一个主机要发送消息，那么它先监听信道</li><li><strong>空闲则直接传输，不必等待</strong></li><li><strong>忙则等待一个随机的时间，之后再进行监听</strong></li></ol></li><li>优点：采用随机的重发延迟时间可以减少冲突发生的可能性</li><li>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低</li></ol><h4 id="p-坚持csma">3.5.3.3 p-坚持CSMA</h4><ol type="1"><li>p-坚持指的是对于监听信道空闲的处理</li><li>p-坚持CSMA思想:<ol type="1"><li>如果一个主机要发送消息，那么它先监听信道</li><li><strong>空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输</strong></li><li><strong>忙则等待一个随机的时间之后再进行监听</strong></li></ol></li><li>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案</li><li>缺点：发生冲突后无法及时发现，仍会坚持把数据帧发完，造成浪费</li></ol><h4 id="三种csma对比总结">3.5.3.4 三种CSMA对比总结</h4><p><img src="/images/AssetMarkdown/image-20221122112151722.png" alt="image-20221122112151722" style="zoom: 80%;" /></p><h3 id="csmacd协议">3.5.4 CSMA/CD协议</h3><p>CSMA/CD：载波监听多点接入/碰撞检测，carrier sense multiple accesswith collision detection</p><ol type="1"><li><strong>CS</strong>：载波侦听/监听，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>要检测一下总线上是否有其他计算机在发送数据</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。<strong>总线型网络</strong></li><li><strong>CD</strong>：碰撞检测(冲突检测)，<strong>“边发送边监听”</strong>，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。<strong>半双工网络</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221122114347472.png" alt="image-20221122114347472" style="zoom:80%;" /></p><h4 id="传播时延对载波监听的影响">3.5.4.1 传播时延对载波监听的影响</h4><ol type="1"><li><span class="math inline">\(\tau\)</span>：端到端传播时延</li><li><spanclass="math inline">\(2\tau\)</span>：总线的端到端往返传播时延/争用期/冲突窗口/碰撞窗口</li><li>只要经过<spanclass="math inline">\(2\tau\)</span>时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞</li></ol><p><img src="/images/AssetMarkdown/image-20221122121634471.png" alt="image-20221122121634471" style="zoom:80%;" /></p><h4 id="如何确定碰撞后的重传时机">3.5.4.2 如何确定碰撞后的重传时机</h4><p><strong>阶段二进制指数规避算法</strong>：</p><ol type="1"><li>确定<strong>基本退避(推迟)时间</strong>为：争用期<spanclass="math inline">\(2\tau\)</span></li><li>定义参数k，它等于<strong>重传次数</strong>，但k不超过10，即<strong>k=min[重传次数，10]</strong><ol type="1"><li>当重传次数不超过10时，k等于重传次数</li><li>当重传次数大于10时，k就不再增大而一直等于10</li></ol></li><li>从离散的整数集合<strong>[0， 1， …，2<sup>k</sup>-1]</strong>中随机取出一个数r，重传所需要退避的时间就是<strong>r倍的基本退避时间</strong>，即<spanclass="math inline">\(2r\ \tau\)</span></li><li>当重传达<strong>16次</strong>仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错</li></ol><p><img src="/images/AssetMarkdown/image-20221122122233091.png" alt="image-20221122122233091" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221122122321761.png" alt="image-20221122122321761" style="zoom: 67%;" /></p><h4 id="最小帧长-2tau-数据传输速率">3.5.4.3 最小帧长 = <spanclass="math inline">\(2\tau\)</span> × 数据传输速率</h4><ol type="1"><li>帧的传输时延至少要两倍于信号在总线中的传播时延</li><li><strong>最小帧长 = <span class="math inline">\(2\tau\)</span> ×数据传输速率</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221122122456786.png" alt="image-20221122122456786" style="zoom:80%;" /></p><h4 id="总结-11">3.5.4.4 总结</h4><p><img src="/images/AssetMarkdown/image-20221122122600976.png" alt="image-20221122122600976" style="zoom:80%;" /></p><h3 id="csmaca协议">3.5.5 CSMA/CA协议</h3><p>CSMA/CA：载波监听多点接入/碰撞避免，carrier sense multiple accesswith collision avoidance</p><ol type="1"><li>应用：无线局域网<ol type="1"><li>无法做到360°全面检测碰撞</li><li>隐蔽站：当A和C都检测不到信号，认为信道空闲时，同时向B发送数据帧，就会导致冲突</li></ol></li></ol><h4 id="csmaca协议工作原理">3.5.5.1 CSMA/CA协议工作原理</h4><ol type="1"><li>发送数据前，先检测信道是否空闲<ol type="1"><li>信道空闲：发出<strong>RTS (request to send)</strong>，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息</li><li>信道忙：等待</li></ol></li><li>接收端收到RTS后，将响应<strong>CTS (clear to send)</strong></li><li>发送端收到CTS后，开始发送数据帧(同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据)</li><li>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应<strong>ACK帧</strong></li><li>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止(采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间)</li></ol><h4 id="csmaca协议避免冲突的方法">3.5.5.2 CSMA/CA协议避免冲突的方法</h4><ol type="1"><li>预约信道</li><li>ACK帧</li><li>RTS/CTS帧：解决隐蔽站的问题，可以不使用</li></ol><h4 id="csmacd与csmaca">3.5.5.3 CSMA/CD与CSMA/CA</h4><p>相同点:</p><ol type="1"><li>CSMA/CD与CSMA/CA机制都从属于CSMA的思路，其核心是<strong>先听再说</strong></li><li>换言之，两个在接入信道之前都须要进行监听。当发现信道空闲后，才能进行接入</li></ol><p>不同点:</p><ol type="1"><li><strong>传输介质不同</strong>：CSMA/CD用于总线式以太网【有线】，而CSMA/CA用于无线局域网【无线】</li><li><strong>载波检测方式不同</strong>：因传输介质不同，CSMA/CD与CSMA/CA的检测方式也不同。<ol type="1"><li>CSMA/CD：通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化</li><li>CSMA/CA：采用能量检测(ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式</li></ol></li><li><strong>CSMA/CD检测冲突，CSMA/CA避免冲突</strong>，二者出现冲突后都会进行<strong>有上限的重传</strong></li></ol><h3 id="轮询访问介质访问控制">3.5.6 轮询访问介质访问控制</h3><ol type="1"><li>信道划分介质访问控制(<strong>MAC，Multiple AccessControl</strong>)协议：<strong>无冲突</strong><ol type="1"><li>基于<strong>多路复用技术</strong>划分资源</li><li>网络负载重：共享信道效率高，且公平</li><li>网络负载轻：共享信道效率低</li></ol></li><li>随机访问MAC协议：<strong>会发生冲突</strong><ol type="1"><li>用户根据意愿<strong>随机</strong>发送信息，发送信息时可独占信道带宽。</li><li>网络负载重：产生冲突开销</li><li>网络负载轻：共享信道效率高，单个结点可利用信道全部带宽</li></ol></li><li>轮询访问MAC协议/轮流协议/轮转访问MAC协议：<strong>无冲突</strong><ol type="1"><li>既要<strong>不产生冲突</strong>，又要发送时<strong>占全部带宽</strong></li><li>分为：轮询协议、令牌传递协议</li></ol></li></ol><h4 id="轮询协议">3.5.6.1 轮询协议</h4><p><strong>主节点轮流要求从属节点发送数据</strong></p><p><img src="/images/AssetMarkdown/image-20221122112756494.png" alt="image-20221122112756494" style="zoom:80%;" /></p><p>缺点：</p><ol type="1"><li>轮询开销</li><li>等待延迟</li><li>单点故障：主节点宕机后，所有节点都无法发送数据</li></ol><h4 id="令牌传递协议">3.5.6.2 令牌传递协议</h4><p><img src="/images/AssetMarkdown/image-20221122113100341.png" alt="image-20221122113100341" style="zoom:80%;" /></p><ol type="1"><li>令牌：一个特殊格式的MAC控制帧，不含任何信息<ol type="1"><li>控制信道的使用，确保同一时刻只有一个结点独占信道</li></ol></li><li>令牌环网无碰撞</li><li>发送过程：<ol type="1"><li>空闲时，令牌会在令牌环网中循环传递</li><li>当主机D要发送数据时，会修改令牌的标志位，同时将数据A附加到令牌上</li><li>令牌会按照令牌环的顺序，在令牌环网上循环一周</li><li>接收方收到包含数据的令牌时，会将数据拷贝一份，并且将自己得到的数据重新附加到令牌上</li><li>发送方再次接收到令牌时，查看令牌上的数据与自己发送的数据是否相同，判断是否发送成功</li></ol></li><li>每个节点都可以在一定时间(令牌持有时间)内获得发送数据的权力，并不是无限制的持有令牌</li><li>缺点：<ol type="1"><li>令牌开销</li><li>等待延迟</li><li>单点故障：一个节点故障，所有节点都无法发送数据</li></ol></li><li>应用于令牌环网<ol type="1"><li>物理：星型拓扑结构</li><li>逻辑：环形拓扑结构</li></ol></li><li>常用于<strong>负载较重、通信量较大</strong>的网络中</li></ol><h3 id="mac协议总结">3.5.7 MAC协议总结</h3><p><img src="/images/AssetMarkdown/image-20221122113644706.png" alt="image-20221122113644706" style="zoom:80%;" /></p><h2 id="局域网以太网无线局域网">3.6 局域网、以太网、无线局域网</h2><h3 id="局域网的基本概念和体系结构">3.6.1局域网的基本概念和体系结构</h3><h4 id="局域网">3.6.1.1 局域网</h4><p>局域网(Local AreaNetwork)：简称<strong>LAN</strong>，是指在<strong>某一区域</strong>内由多台计算机互联成的计算机组，使用<strong>广播信道</strong></p><p>特点</p><ol type="1"><li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内</li><li>使用专门铺设的传输介质(双绞线、同轴电缆)进行联网，数据传输速率高(10Mb/s~10Gb/s)</li><li>通信延迟时间短，误码率低，可靠性较高</li><li>各站为平等关系，共享传输信道</li><li>多采用分布式控制和广播式通信，能进行广播和组播</li></ol><p>决定局域网的主要要素：</p><ol type="1"><li>网络拓扑</li><li>传输介质</li><li>介质访问控制方法</li></ol><h4 id="局域网拓扑结构">3.6.1.2 局域网拓扑结构</h4><p><img src="/images/AssetMarkdown/image-20221122193904955.png" alt="image-20221122193904955" style="zoom:80%;" /></p><h4 id="局域网传输介质">3.6.1.3 局域网传输介质</h4><ol type="1"><li>有线局域网：双绞线、同轴电缆、光纤</li><li>无线局域网：电磁波</li></ol><h4 id="局域网介质访问控制方法">3.6.1.4 局域网介质访问控制方法</h4><ol type="1"><li>CSMA/CD：常用于<strong>总线型局域网</strong>，也用于树型网络</li><li>令牌总线：常用于<strong>总线型局域网</strong>，也用于树型网络<ol type="1"><li>它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环</li><li>只有令牌持有者才能控制总线，才有发送信息的权力</li></ol></li><li>令牌环：常用于<strong>环形局域网</strong>，如令牌环网</li></ol><h4 id="局域网的分类">3.6.1.5 局域网的分类</h4><ol type="1"><li><strong>以太网</strong><ol type="1"><li>以太网是应用最为广泛的局域网，包括标准以太网(10Mbps)、快速以太网(100Mbps)千兆以太网(1000Mbps)和10G以太网</li><li>它们都符合<strong>IEEE802.3</strong>系列标准规范</li><li>逻辑拓扑总线型，物理拓扑是星型或拓展星型</li><li>使用CSMA/CD.</li></ol></li><li><strong>令牌环网</strong><ol type="1"><li>物理上采用了星形拓扑结构，逻辑上是环形拓扑结构</li><li>已是“明日黄花”</li></ol></li><li>FDDI网(Fiber Distributed Data Interface)<ol type="1"><li>物理上采用了双环拓扑结构，逻辑上是环形拓扑结构</li></ol></li><li>ATM网(Asynchronous Transfer Mode)<ol type="1"><li>较新型的单元交换技术，使用53字节固定长度的单元进行交换</li></ol></li><li><strong>无线局域网</strong>(Wireless Local Area Network;<strong>WLAN</strong>)<ol type="1"><li>采用<strong>IEEE 802.11</strong>标准。</li></ol></li></ol><h4 id="ieee-802标准">3.6.1.6 IEEE 802标准</h4><ol type="1"><li>IEEE 802系列标准：是IEEE 802 LAN/MAN标准委员会制定的局域网、城域网技术标准(1980年2月成立)</li><li>其中最广泛使用的有以太网、令牌环、无线局域网等</li><li>这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责</li></ol><table><thead><tr class="header"><th style="text-align: center;">标准名</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">IEEE 802.3</td><tdstyle="text-align: center;"><strong>以太网</strong>的介质访问控制协议(CSMA/CD)、物理层技术规范</td></tr><tr class="even"><td style="text-align: center;">IEEE 802.5</td><tdstyle="text-align: center;"><strong>令牌环网</strong>的介质访问控制协议、物理层技术规范</td></tr><tr class="odd"><td style="text-align: center;">IEEE 802.8</td><td style="text-align: center;"><strong>光纤</strong>技术咨询组</td></tr><tr class="even"><td style="text-align: center;">IEEE 802.11</td><tdstyle="text-align: center;"><strong>无线局域网</strong>(WLAN)的介质访问控制协议、物理层技术规范</td></tr></tbody></table><h4 id="mac子层和llc子层">3.6.1.7 MAC子层和LLC子层</h4><ol type="1"><li><strong>LLC子层</strong>：逻辑链路控制子层，为<strong>网络层</strong>提供服务<ol type="1"><li>识别网络层协议，并进行封装</li><li>LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做如何处理</li><li>为网络层提供服务：无确认无连接、面向连接、带确认无连接、高速传送</li></ol></li><li><strong>MAC子层</strong>：介质访问控制子层，与<strong>物理层</strong>相关<ol type="1"><li>数据帧的封装/卸装</li><li>帧的寻址和识别</li><li>帧的接收与发送</li><li>链路的管理</li><li>帧的差错控制</li><li>屏蔽了不同物理链路种类的差异性</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221122194906726.png" alt="image-20221122194906726" style="zoom:80%;" /></p><h4 id="总结-12">3.6.1.8 总结</h4><p><img src="/images/AssetMarkdown/image-20221122194932952.png" alt="image-20221122194932952" style="zoom:80%;" /></p><h3 id="以太网-ethernet">3.6.2 以太网 Ethernet</h3><h4 id="以太网概述">3.6.2.1 以太网概述</h4><ol type="1"><li>以太网(<strong>Ethernet</strong>)指的是：由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的<strong>基带总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准</li><li>以太网络使用<strong>CSMA/CD</strong>(载波监听多路访问及冲突检测)技术</li><li>以太网在局域网各种技术中占统治性地位:<ol type="1"><li>造价低廉(以太网网卡不到100块)</li><li>是应用最广泛的局域网技术</li><li>比令牌环网、ATM网便宜，简单</li><li><strong>满足网络速率要求: 10Mb/s~10Gb/s</strong></li></ol></li><li>以太网两个标准<ol type="1"><li><strong>DIX Ethernet V2</strong>：第一个局域网产品(以太网)规约</li><li><strong>IEEE 802.3</strong>：IEEE802委员会802.3工作组制定的第一个IEEE的以太网标准，格式有一丢丢改动</li></ol></li><li>以太网，也叫802.3局域网</li></ol><h4 id="以太网提供无连接不可靠的服务">3.6.2.2以太网提供无连接、不可靠的服务</h4><ol type="1"><li><strong>无连接</strong>：发送方和接收方之间无“握手过程”</li><li><strong>不可靠</strong>：不对发送方的数据顿编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责</li><li><strong>以太网只实现无差错接收，不实现可靠传输</strong><ol type="1"><li>无差错接收：保证接收到的帧均正确，不正确的帧直接丢弃</li><li>可靠传输：保证所有帧都正确接收</li></ol></li></ol><h4 id="以太网传输介质与拓扑结构的发展">3.6.2.3以太网传输介质与拓扑结构的发展</h4><p><img src="/images/AssetMarkdown/image-20221122195826747.png" alt="image-20221122195826747" style="zoom:80%;" /></p><h4 id="base-t以太网">3.6.2.4 10BASE-T以太网</h4><p>10BASE-T是传送<strong>基带信号</strong>的双绞线以太网，T表示采用<strong>双绞线</strong>，现10BASE-T采用的是<strong>无屏蔽双绞线(UTP)</strong>，传输速率是<strong>10Mb/s</strong></p><ol type="1"><li><strong>物理上采用星型拓扑，逻辑上总线型</strong>，每段双绞线最长为<strong>100m</strong></li><li>采用<strong>曼彻斯特编码</strong></li><li>采用<strong>CSMA/CD</strong>介质访问控制</li></ol><h4 id="适配器与mac地址">3.6.2.5 适配器与MAC地址</h4><ol type="1"><li>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的<ol type="1"><li>网络接口板</li><li>网络接口卡NIC (network interface card)</li><li>NOW，不再使用单独网卡</li><li>适配器上装有处理器和存储器(包括RAM和ROM)</li><li>ROM上有计算机硬件地址<strong>MAC地址</strong></li></ol></li><li>在局域网中，<strong>硬件地址</strong>又称为<strong>物理地址</strong>，或<strong>MAC地址</strong>【实际上是标识符】</li><li><strong>MAC地址</strong>：每个适配器有一个<strong>全球唯一</strong>的<strong>48位二进制地址</strong>，前24位代表厂家(由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8c-e4-b1-21<ol type="1"><li>换网卡之后，MAC地址也会变化</li><li>带电脑出差，MAC地址不会变化</li></ol></li></ol><h4 id="以太网mac帧">3.6.2.6 以太网MAC帧</h4><p>最常用的MAC帧是<strong>以太网V2</strong>的格式</p><p><img src="/images/AssetMarkdown/image-20221122201120733.png" alt="image-20221122201120733" style="zoom:80%;" /></p><ol type="1"><li>前导码：<ol type="1"><li>前同步码：由101010组成，用于接收方同步时钟</li><li>帧开始定界符：结尾是11，表示MAC帧的开始</li></ol></li><li>目的地址：<ol type="1"><li>单播地址：即专有网卡地址</li><li>广播地址：每一位均为1，即FFFFFFFFFFFF</li><li>多播地址</li></ol></li><li>类型：<ol type="1"><li>表示上面网络层使用的协议</li></ol></li><li>数据：<ol type="1"><li>长度可变</li><li>最多为1500，即MTU</li><li>最小为46，要满足以太网的最短帧长64B</li></ol></li><li>FCS：<ol type="1"><li>帧检验序列</li></ol></li><li>没有帧结束定界符：<ol type="1"><li>采用曼彻斯特编码，当不发送数据时，没有电压变化</li><li>两个帧之间会有最小间隔</li></ol></li></ol><p>与IEEE 802.3的区别：</p><ol type="1"><li>第三个字段是长度/类型</li><li>当长度/类型字段小于0x0600时，数据字段必须装入LLC子层</li></ol><h4 id="高速以太网">3.6.2.7 高速以太网</h4><p>速率<spanclass="math inline">\(\ge\)</span><strong>100Mb/s</strong>的以太网，称为高速以太网</p><p><img src="/images/AssetMarkdown/image-20221122201306224.png" alt="image-20221122201306224" style="zoom:80%;" /></p><h4 id="总结-13">3.6.2.8 总结</h4><p><img src="/images/AssetMarkdown/image-20221122201323708.png" alt="image-20221122201323708" style="zoom:80%;" /></p><h3 id="无线局域网">3.6.3 无线局域网</h3><h4 id="ieee-802.11">3.6.3.1 IEEE 802.11</h4><p><strong>IEEE802.11</strong>是<strong>无线局域网</strong>通用的标准，它是由IEEE所定义的无线网络通信的标准。</p><p><img src="/images/AssetMarkdown/image-20221122201506771.png" alt="image-20221122201506771" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221231171825181.png" alt="image-20221231171825181" style="zoom:80%;" /></p><h4 id="的mac帧头格式">3.6.3.2 802.11的MAC帧头格式</h4><p><img src="/images/AssetMarkdown/image-20221122201541222.png" alt="image-20221122201541222" style="zoom:80%;" /></p><p><strong>AP</strong>：无线接入点，也叫基站</p><p>例：若设备A向设备B发送消息，距离A近的基站为AP1，距离B近的基站为AP2，则</p><ol type="1"><li>A会将数据通过电磁波发送给AP1</li><li>AP1将数据发送给AP2</li><li>AP2通过电磁波将数据发送给B</li><li>在此过程中，MAC帧头为<ol type="1"><li><strong>DA</strong>目的地址：mac(B)</li><li><strong>SA</strong>源地址：mac(A)</li><li><strong>RA</strong>接收端：mac(AP2)</li><li><strong>TA</strong>发送端：mac(AP1)</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221122202022344.png" alt="image-20221122202022344" style="zoom:80%;" /></p><h4 id="无线局域网的分类">3.6.3.3 无线局域网的分类</h4><ol type="1"><li><p>有固定基础设施的无线局域网</p><ol type="1"><li>BSS：基本服务集</li><li>ESS：扩展服务集</li></ol><p><img src="/images/AssetMarkdown/image-20221122202351956.png" alt="image-20221122202351956" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221122202413035.png" alt="image-20221122202413035" style="zoom:80%;" /></p></li><li><p>无固定基础设施的无线局域网的自组织网络</p><p><img src="/images/AssetMarkdown/image-20221122202439934.png" alt="image-20221122202439934" style="zoom:80%;" /></p></li></ol><h2 id="广域网">3.7 广域网</h2><h3 id="广域网概述">3.7.1 广域网概述</h3><ol type="1"><li>广域网(WAN， Wide Area Network)，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络</li><li>广域网的通信子网主要使用<strong>分组交换</strong>技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来，达到<strong>资源共享</strong>的目的。如因特网(Internet)是世界范围内最大的广域网</li><li>广域网与局域网的区别<ol type="1"><li>广域网覆盖的网络体系结构层次：物理层、链路层、网络层</li><li>局域网覆盖的网络体系结构层次：物理层、链路层</li><li>广域网普遍采用点对点，通过一个链路相连，全双工或者半双工</li><li>局域网普遍采用多点接入技术</li><li>广域网强调资源共享</li><li>局域网强调数据传输</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221122202816704.png" alt="image-20221122202816704" style="zoom:80%;" /></p><h3 id="ppp协议面向字节">3.7.2 PPP协议：面向字节</h3><h4 id="ppp协议的特点">3.7.2.1 PPP协议的特点</h4><p>点对点协议PPP(Point-to-PointProtocol)：是目前使用最广泛的数据链路层协议</p><ol type="1"><li>用户使用拨号电话接入因特网时，一般都使用PPP协议</li><li><strong>只支持全双工链路</strong></li></ol><h4 id="ppp协议应满足的要求">3.7.2.2 PPP协议应满足的要求</h4><ol type="1"><li><strong>简单</strong>：对于链路层的帧，无需纠错，无需序号，无需流量控制。</li><li><strong>封装成帧</strong>：帧定界符</li><li><strong>透明传输</strong>：与帧定界符一样比特组合的数据应该如何处理异步线路用字节填充，同步线路用比特填充</li><li><strong>多种网络层协议</strong>：封装的IP数据报可以采用多种协议。</li><li><strong>多种类型链路</strong>：串行/并行，同步/异步，电/光</li><li><strong>差错检测</strong>：错就丢弃</li><li><strong>检测连接状态</strong>：链路是否正常工作</li><li><strong>最大传送单元</strong>：数据部分最大长度MTU，一般不超过1500B</li><li><strong>网络层地址协商</strong>：知道通信双方的网络层地址</li><li><strong>数据压缩协商</strong></li></ol><h4 id="ppp协议无需满足的要求">3.7.2.3 PPP协议无需满足的要求</h4><ol type="1"><li><strong>纠错</strong></li><li><strong>流量控制</strong></li><li><strong>序号</strong></li><li><strong>不支持多点线路</strong></li></ol><h4 id="ppp协议的三个组成部分">3.7.2.4 PPP协议的三个组成部分</h4><ol type="1"><li>一个将IP数据报封装到串行链路(同步串行/异步串行)的方法</li><li>链路控制协议<strong>LCP</strong>：建立并维护数据链路连接。<strong>身份验证</strong></li><li>网络控制协议<strong>NCP</strong>：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</li></ol><h4 id="ppp协议的状态图">3.7.2.5 PPP协议的状态图</h4><p><img src="/images/AssetMarkdown/image-20221122203858835.png" alt="image-20221122203858835" style="zoom:80%;" /></p><h4 id="ppp协议的帧格式">3.7.2.6 PPP协议的帧格式</h4><p><img src="/images/AssetMarkdown/image-20221122204013649.png" alt="image-20221122204013649" style="zoom:80%;" /></p><h3 id="hdlc协议面向比特">3.7.3 HDLC协议：面向比特</h3><h4 id="hdlc协议简介">3.7.3.1 HDLC协议简介</h4><ol type="1"><li><strong>高级数据链路控制(High-Level Data LinkControl或简称HDLC)</strong>：是一个在同步网上传输数据、<strong>面向比特</strong>的数据链路层协议<ol type="1"><li>由国际标准化组织(<strong>ISO</strong>)根据IBM公司的SDLC(SynchronousDataLink Control)协议扩展开发而成的</li></ol></li><li>数据报文可透明传输，用于实现透明传输的"<strong>0比特插入法</strong>”易于硬件实现</li><li><strong>采用全双工通信</strong></li><li>所有帧采用<strong>CRC检验</strong>，对信息帧进行顺序<strong>编号</strong>，可防止漏收或重份，传输可靠性高</li></ol><h4 id="hdlc的站">3.7.3.2 HDLC的站</h4><ol type="1"><li><strong>主站</strong>：主要功能是发送命令(包括数据信息)帧、接收响应帧，并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等。</li><li><strong>从站</strong>：主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li><li><strong>复合站</strong>：主要功能是既能发送，又能接收命令帧和响应顿，并且负责整个链路的控制。</li></ol><p>三种数据操作方式</p><ol type="1"><li>正常响应方式：从站发送数据，要先经过主站的同意</li><li>异步平衡方式：每个复合站均可以进行数据传输，每个站地位平等</li><li>异步响应方式：从站可以不经过主站的同意，就发送数据</li></ol><h4 id="hdlc的帧格式">3.7.3.3 HDLC的帧格式</h4><p><img src="/images/AssetMarkdown/image-20221122204727226.png" alt="image-20221122204727226" style="zoom:80%;" /></p><h3 id="ppp协议-hdlc协议">3.7.4 PPP协议 &amp; HDLC协议</h3><p>相同点：</p><ol type="1"><li>均只支持<strong>全双工</strong>链路</li><li>都可以实现透明传输</li><li>都可以实现差错检测，但不纠正差错</li></ol><p>不同点：</p><p><img src="/images/AssetMarkdown/image-20221122204853951.png" alt="image-20221122204853951" style="zoom:80%;" /></p><h3 id="总结-14">3.7.5 总结</h3><p><img src="/images/AssetMarkdown/image-20221122204947587.png" alt="image-20221122204947587" style="zoom:80%;" /></p><h2 id="链路层设备">3.8 链路层设备</h2><h3 id="物理层扩展以太网">3.8.1 物理层扩展以太网</h3><p><img src="/images/AssetMarkdown/image-20221122205436676.png" alt="image-20221122205436676" style="zoom:80%;" /></p><h3 id="链路层扩展以太网网桥">3.8.2 链路层扩展以太网：网桥</h3><p>链路层扩展以太网的设备：网桥&amp;交换机</p><p><img src="/images/AssetMarkdown/image-20221122205855504.png" alt="image-20221122205855504" style="zoom:80%;" /></p><ol type="1"><li><strong>网桥</strong>：根据<strong>MAC帧的目的地址</strong>对帧进行<strong>转发</strong>和<strong>过滤</strong><ol type="1"><li>当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该顿转发到哪一个接口，或者是把它丢弃(即过滤)</li></ol></li><li><strong>网段</strong>：一般指一个计算机网络中使用同一物理层设备(传输介质，中继器，集线器等)能够直接通讯的那一部分</li><li>网桥的优点：<ol type="1"><li>过滤通信量，增大吞吐量</li><li>扩大了物理传输范围</li><li>提高了可靠性：一个主机故障，通常只影响一个网段</li><li>可互连不同物理层、不同MAC子层和不同速率的以太网</li></ol></li></ol><h4 id="网桥分类透明网桥">3.8.2.1 网桥分类：透明网桥</h4><p><strong>透明网桥</strong>：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备--<strong>自学习</strong></p><ol type="1"><li>每过一段时间，就会将转发表情况，然后更新最新的转发表</li></ol><p><img src="/images/AssetMarkdown/image-20221122210837783.png" alt="image-20221122210837783" style="zoom:80%;" /></p><blockquote><ol type="1"><li>若A向B发送一个数据：<ol type="1"><li>A广播式发送数据，当前网段内所有主机均收到该数据，但只有B会处理这个数据</li><li>该数据包到达网桥1的1接口时<ol type="1"><li>A为发送方，因此将（地址A， 接口1）填入转发表</li><li>B为接收方，转发表中没有，因此网桥1会将这个数据包发送到除接口1外的所有接口</li></ol></li><li>该数据包到达CD网段，CD均丢弃该数据包</li><li>该数据包到达网桥2的1接口时<ol type="1"><li>A为发送方，因此将（地址A， 接口1）填入转发表</li><li>B为接收方，转发表中没有，因此网桥2会将这个数据包发送到除接口1外的所有接口</li></ol></li><li>该数据包到达EF网段，EF均丢弃该数据包</li></ol></li><li>然后F向C发送一个数据：<ol type="1"><li>F广播式发送数据，当前网段内所有主机均收到该数据，均丢弃</li><li>该数据包到达网桥2的2接口时<ol type="1"><li>F为发送方，因此将（地址F， 接口2）填入转发表</li><li>C为接收方，转发表中没有，因此网桥2会将这个数据包发送到除接口2外的所有接口</li></ol></li><li>该数据包到达CD网段，C收到数据，D丢弃数据</li><li>该数据包到达网桥1的2号接口时<ol type="1"><li>F为发送方，因此将（地址F， 接口2）填入转发表</li><li>C为接收方，转发表中没有，因此网桥1会将这个数据包发送到除接口2外的所有接口</li></ol></li><li>该数据包到达AB段，AB均丢弃该数据包</li></ol></li><li>然后B向A发送一个数据<ol type="1"><li>B广播式发送数据，当前网段内所有主机均收到该数据，但只有A会处理这个数据</li><li>该数据包到达网桥1的1接口时<ol type="1"><li>B为发送方，因此将（地址B， 接口1）填入转发表</li><li>A为接收方，转发表中存在，且为接口1，因此网桥1不会再转发</li></ol></li></ol></li></ol></blockquote><h4 id="网桥分类源路由网桥">3.8.2.2 网桥分类：源路由网桥</h4><ol type="1"><li><strong>源路由网桥</strong>：在发送帧时，把详细的<strong>最佳路由信息</strong>(路由最少/时间最短)放在<strong>帧的首部</strong>中</li><li><strong>方法</strong>：源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong><ol type="1"><li>发现帧会原路返回</li><li>发现帧中会存储经过路由数量/时间，由发送方进行比较选择</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221122211055595.png" alt="image-20221122211055595" style="zoom:80%;" /></p><h3 id="多接口网桥以太网交换机">3.8.3 多接口网桥：以太网交换机</h3><h4 id="以太网交换机的简介">3.8.3.1 以太网交换机的简介</h4><p>独占传输媒体带宽：</p><ol type="1"><li>若使用集线器<ol type="1"><li>假设一个冲突域的带宽为10Mb/s，则每个主机的带宽为2.5Mb/s</li></ol></li><li>若使用集线器以太网交换机<ol type="1"><li>假设以太网交换机的带宽为10Mb/s，则每个冲突域的带宽均为10Mb/s</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221122211448383.png" alt="image-20221122211448383" style="zoom:80%;" /></p><h4 id="以太网交换机的两种交换方式">3.8.3.2以太网交换机的两种交换方式</h4><ol type="1"><li>直通式交换机<ol type="1"><li>查完<strong>目的地址(6B)</strong>就<strong>立刻转发</strong></li><li><strong>延迟小</strong>，可靠性低，无法支持具有不同速率的端口的交换</li></ol></li><li>存储转发式交换机<ol type="1"><li>将帧放入<strong>高速缓存</strong>，并检查否正确，正确则转发，错误则丢弃</li><li><strong>延迟大</strong>，可靠性高，可以支持具有不同速率的端口的交换</li></ol></li></ol><h3 id="冲突域和广播域">3.8.4 冲突域和广播域</h3><ol type="1"><li><strong>冲突域</strong>：在同一个冲突域中的每一个节点都能收到所有被发送的帧<ol type="1"><li>简单的说，就是同一时间内只能有一台设备发送信息的范围</li></ol></li><li><strong>广播域</strong>：网络中能接收任一设备发出的广播帧的所有设备的集合<ol type="1"><li>简单的说，如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221122211925798.png" alt="image-20221122211925798" style="zoom:80%;" /></p><blockquote><ol type="1"><li>广播域的个数：看有几个路由器</li><li>冲突域的个数：看以太网交换机的端口，一个端口对应一个冲突域</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20221122212044265.png" alt="image-20221122212044265" style="zoom:80%;" /></p><h3 id="生成树网桥">3.8.5 生成树网桥</h3><p><img src="/images/AssetMarkdown/image-20221231172045308.png" alt="image-20221231172045308" style="zoom:80%;" /></p><ol type="1"><li>为了防止广播风暴，会使用生成树的算法，保证没有回路</li></ol><h3 id="总结-15">3.8.6 总结</h3><p><img src="/images/AssetMarkdown/image-20221122212056169.png" alt="image-20221122212056169" style="zoom:80%;" /></p><h2 id="virtual-lans-虚拟网">3.9 Virtual LANs 虚拟网</h2><p><img src="/images/AssetMarkdown/image-20221231172156368.png" alt="image-20221231172156368" style="zoom:80%;" /></p><ol type="1"><li>逻辑的局域网和多个交换机构成的物理局域网，相互之间有多对多的映射关系</li><li>这些交换机的端口被分为两大类：<ol type="1"><li>接入端口：隶属于某一个指定的虚拟网，跑的是标准的以太网协议</li><li>中继端口trunk：用于传输交换机之间的数据，这里的数据会属于不同的虚拟网，需要识别出当前帧到底是归属于哪个虚拟网的，因此出现了<strong>IEEE802.1Q</strong>协议</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221231172604512.png" alt="image-20221231172604512" style="zoom:80%;" /></p><h2 id="第三章总结">3.9 第三章总结</h2><p><img src="/images/AssetMarkdown/image-20221122212157715.png" alt="image-20221122212157715"  /></p><h1 id="chapter-4网络层">Chapter 4：网络层</h1><p>互联网是无中心、有层次的</p><h2 id="网络层概述">4.1 网络层概述</h2><h3 id="网络层功能概述">4.1.1 网络层功能概述</h3><ol type="1"><li>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务</li><li>网络层传输单位是<strong>数据报</strong></li><li>功能：<ol type="1"><li><strong>路由选择与分组转发</strong>：最佳路径</li><li><strong>异构网络互联</strong></li><li><strong>拥塞控制</strong>：若<strong>所有结点</strong>都来不及接受分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态。因此要采取一定措施，缓解这种拥塞<ol type="1"><li>开环控制：静态控制</li><li>闭环控制：动态调整</li></ol></li></ol></li></ol><h3 id="数据交换方式">4.1.2 数据交换方式</h3><h4 id="网络的核心路由器">4.1.2.1 网络的核心：路由器</h4><p><img src="/images/AssetMarkdown/image-20221122214424641.png" alt="image-20221122214424641" style="zoom:80%;" /></p><h4 id="为什么需要数据交换">4.1.2.2 为什么需要数据交换</h4><p><img src="/images/AssetMarkdown/image-20221122214358680.png" alt="image-20221122214358680" style="zoom:80%;" /></p><h4 id="电路交换">4.1.2.3 电路交换</h4><p><img src="/images/AssetMarkdown/image-20221122214748051.png" alt="image-20221122214748051" style="zoom:80%;" /></p><p>电路交换的阶段：</p><ol type="1"><li>建立连接</li><li>通信</li><li>释放连接</li></ol><p>特点：<strong>独占资源</strong></p><ol type="1"><li>当A和B建立连接后，即使不说话，也不能有第三方抢占电路</li></ol><p>优点：</p><ol type="1"><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>实时性强</li></ol><p>缺点：</p><ol type="1"><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差</li><li>无差错控制能力</li></ol><h4 id="报文交换">4.1.2.4 报文交换</h4><p>报文：源应用发送的信息整体</p><p><img src="/images/AssetMarkdown/image-20221123214912638.png" alt="image-20221123214912638" style="zoom:80%;" /></p><p>优点：</p><ol type="1"><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高</li><li>线路利用率较高：一段一段的占用线路</li><li>多目标服务</li></ol><p>缺点：</p><ol type="1"><li>有存储转发时延</li><li>报文大小不定，需要网络节点有较大的缓存空间</li></ol><h4 id="分组交换">4.1.2.5 分组交换</h4><p>分组：把大的数据块分割成小的数据块</p><p><img src="/images/AssetMarkdown/image-20221123215116919.png" alt="image-20221123215116919" style="zoom:80%;" /></p><p>优点：</p><ol type="1"><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高：数据变小之后，出错的概率也变小了</li><li>线路利用率较高：一段一段的占用线路</li><li>相对于报文交换，存储管理更容易</li></ol><p>缺点：</p><ol type="1"><li>有存储转发时延</li><li>需要传输额外的信息量：源地址、目的地址、分组编号等</li><li>乱序到达目的主机时，需要对分组排序重组</li></ol><h4 id="报文交换分组交换例题">4.1.2.6 报文交换&amp;分组交换例题</h4><p><img src="/images/AssetMarkdown/image-20221123221031383.png" alt="image-20221123221031383" style="zoom:80%;" /></p><p>报文交换：</p><ol type="1"><li>发送时延/传输时延为：<span class="math inline">\(\frac{10000\bit}{1000\ bps}=10s\)</span></li><li>传输时延和接收时延均忽略不计</li><li>因此总传输时间为：<span class="math inline">\(10\ s × 3=30\s\)</span></li></ol><p>分组交换：</p><ol type="1"><li>每一个分组的发送时延/传输时延为：<spanclass="math inline">\(\frac{10\ bit}{1000\ bps}=0.01s\)</span></li><li>传输时延和接收时延均忽略不计</li><li>由于每个分组连续发送，因此只需要考虑第1个分组开始发送，到最后1个分组到达所需的时间即可<ol type="1"><li>第1个分组开始发送~最后1个分组开始发送：<spanclass="math inline">\(\frac{10000\ bit}{1000\ bps}=10s\)</span></li><li>最后1个分组开始发送~最后1个分组到达：<spanclass="math inline">\(2×0.01\ s=0.02\ s\)</span></li></ol></li><li>因此总传输时间为：<span class="math inline">\(10\ s + 0.02\ s=10.02\s\)</span></li></ol><h4 id="三种数据交换方式比较总结">4.1.2.7 三种数据交换方式比较总结</h4><p><img src="/images/AssetMarkdown/image-20221123221146496.png" alt="image-20221123221146496" style="zoom:80%;" /></p><h3 id="数据报与虚电路">4.1.3 数据报与虚电路</h3><ol type="1"><li><strong>数据报</strong>：为网络层提供<strong>无连接服务</strong><ol type="1"><li>无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同</li></ol></li><li><strong>虚电路</strong>：为网络层提供<strong>连接服务</strong><ol type="1"><li>连接服务：首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接</li></ol></li></ol><h4 id="几种传输单元的名词解析">4.1.3.1 几种传输单元的名词解析</h4><table><thead><tr class="header"><th style="text-align: center;">层次</th><th style="text-align: center;">传输单元</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">应用层</td><td style="text-align: center;">报文</td></tr><tr class="even"><td style="text-align: center;">传输层</td><td style="text-align: center;">报文段</td></tr><tr class="odd"><td style="text-align: center;">网络层</td><td style="text-align: center;">IP数据报，分组</td></tr><tr class="even"><td style="text-align: center;">数据链路层</td><td style="text-align: center;">帧</td></tr><tr class="odd"><td style="text-align: center;">物理层</td><td style="text-align: center;">比特流</td></tr></tbody></table><h4 id="数据报因特网使用">4.1.3.2 数据报（因特网使用）</h4><ol type="1"><li><strong>无连接服务</strong>：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同</li><li><strong>每个分组携带源和目的地址</strong></li><li><strong>路由器根据分组的目的地址转发分组</strong>：<ol type="1"><li>基于路由协议/算法构建转发表</li><li>检索转发表</li><li>每个分组独立性选路</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221129165604477.png" alt="image-20221129165604477" style="zoom:80%;" /></p><h4 id="虚电路">4.1.3.3 虚电路</h4><ol type="1"><li>虚电路将数据报方式和电路交换方式结合，以发挥两者优点</li><li><strong>虚电路</strong>：一条源主机到目的主机类似于电路的路径(逻辑链接)，路径上所有节点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息</li><li>通信过程：</li></ol><p><img src="/images/AssetMarkdown/image-20221129182313654.png" alt="image-20221129182313654" style="zoom:80%;" /></p><h4 id="数据报虚电路">4.1.3.4 数据报&amp;虚电路</h4><p><img src="/images/AssetMarkdown/image-20221129182340378.png" alt="image-20221129182340378" style="zoom:80%;" /></p><h2 id="ip协议">4.2 IP协议</h2><h3 id="ip数据报格式">4.2.1 IP数据报格式</h3><h4 id="tcpip协议栈">4.2.1.1 TCP/IP协议栈</h4><p><img src="/images/AssetMarkdown/image-20221129183834673.png" alt="image-20221129183834673" style="zoom:80%;" /></p><h4 id="ip数据报格式-1">4.2.1.2 IP数据报格式</h4><p><img src="/images/AssetMarkdown/image-20221129183918389.png" alt="image-20221129183918389" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221129183929489.png" alt="image-20221129183929489" style="zoom:80%;" /></p><table><colgroup><col style="width: 14%" /><col style="width: 5%" /><col style="width: 15%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th style="text-align: center;">位置</th><th style="text-align: center;">长度</th><th style="text-align: center;">名称</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">第1个4B：00~03</td><td style="text-align: center;">4bit</td><td style="text-align: center;">版本</td><td style="text-align: center;">4位数据，表示IPv4/IPv6</td></tr><tr class="even"><td style="text-align: center;">第1个4B：04~07</td><td style="text-align: center;">4bit</td><td style="text-align: center;">首部长度</td><tdstyle="text-align: center;">单位为<strong>4B</strong>，最小为5(此时首部长度为5*4B=20B)</td></tr><tr class="odd"><td style="text-align: center;">第1个4B：08~15</td><td style="text-align: center;">8bit</td><td style="text-align: center;">区分服务</td><tdstyle="text-align: center;">表示期望获得<strong>哪种类型的服务</strong></td></tr><tr class="even"><td style="text-align: center;">第1个4B：16~31</td><td style="text-align: center;">16bit</td><td style="text-align: center;">总长度</td><tdstyle="text-align: center;">首部+数据部分的大小，单位为<strong>1B</strong></td></tr><tr class="odd"><td style="text-align: center;">第2个4B：00~15</td><td style="text-align: center;">16bit</td><td style="text-align: center;">标识</td><tdstyle="text-align: center;">同一数据报的分片使用同一标识，表示为<strong>同一个IP数据报</strong></td></tr><tr class="even"><td style="text-align: center;">第2个4B：16~18</td><td style="text-align: center;">3bit</td><td style="text-align: center;">标志</td><td style="text-align: center;">只有2位有意义，<strong>× DFMF</strong></td></tr><tr class="odd"><td style="text-align: center;">第2个4B：19~31</td><td style="text-align: center;">13bit</td><td style="text-align: center;">片偏移</td><tdstyle="text-align: center;">当前分片在原分组中的相对位置，单位为<strong>8B</strong></td></tr><tr class="even"><td style="text-align: center;">第3个4B：00~07</td><td style="text-align: center;">8bit</td><td style="text-align: center;">生存时间<strong>TTL</strong></td><tdstyle="text-align: center;">IP分组的保质期，经过一个路由器-1，变成0则丢弃，防止无法交付的数据报在链路中无限传递</td></tr><tr class="odd"><td style="text-align: center;">第3个4B：08~15</td><td style="text-align: center;">8bit</td><td style="text-align: center;">协议</td><tdstyle="text-align: center;">数据部分的协议，如<strong>TCP(6)</strong>、<strong>UDP(17)</strong></td></tr><tr class="even"><td style="text-align: center;">第3个4B：16~31</td><td style="text-align: center;">16bit</td><td style="text-align: center;">首部检验和</td><tdstyle="text-align: center;">二进制求和，只检验首部，不检验数据部分</td></tr><tr class="odd"><td style="text-align: center;">第4个4B：00~31</td><td style="text-align: center;">32bit</td><td style="text-align: center;">源地址</td><td style="text-align: center;">IPv4的地址长度：32位</td></tr><tr class="even"><td style="text-align: center;">第5个4B：00~31</td><td style="text-align: center;">32bit</td><td style="text-align: center;">目的地址</td><td style="text-align: center;">IPv4的地址长度：32位</td></tr><tr class="odd"><td style="text-align: center;">可变部分</td><td style="text-align: center;">0~40B</td><td style="text-align: center;">可选字段</td><td style="text-align: center;">用来支持排错、测量、安全等措施</td></tr><tr class="even"><td style="text-align: center;">可变部分</td><td style="text-align: center;"></td><td style="text-align: center;">填充</td><td style="text-align: center;">全0，把首部补成4B的整数倍</td></tr></tbody></table><p>协议：</p><p><img src="/images/AssetMarkdown/image-20221129184949335.png" alt="image-20221129184949335"  /></p><p>三个长度：</p><ol type="1"><li><strong>总</strong>长度：单位为<strong>1B</strong></li><li><strong>片</strong>偏移：单位为<strong>8B</strong></li><li><strong>首</strong>部长度：单位为<strong>4B</strong></li></ol><blockquote><p><strong>1总8片的首4</strong></p></blockquote><h3 id="ip数据报分片">4.2.2 IP数据报分片</h3><h4 id="最大传送单元mtu">4.2.2.1 最大传送单元MTU</h4><ol type="1"><li><strong>MTU</strong>：链路层数据帧可封装数据的上限<ol type="1"><li>以太网的MTU位1500字节</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221129185458558.png" alt="image-20221129185458558" style="zoom:80%;" /></p><h4 id="ip数据报分片-1">4.2.2.2 IP数据报分片</h4><ol type="1"><li>标志：× _ _<ol type="1"><li>中间位<strong>DF</strong>(Don’t Fragment)<ol type="1"><li>DF=1：禁止分片</li><li>DF=0：允许分片</li></ol></li><li>最低位<strong>MF</strong>(More Fragment)<ol type="1"><li>MF=1：后面还有分片</li><li>MF=0：当前分片为最后一片</li></ol></li></ol></li><li>片偏移：<ol type="1"><li>当前分片在原分组中的相对位置，以<strong>8B</strong>为单位</li><li>除最后一个分片外，每个分片的大小均为8B的整数倍</li></ol></li></ol><h4 id="ip数据报分片例题">4.2.2.3 IP数据报分片例题</h4><p><img src="/images/AssetMarkdown/image-20221129190407709.png" alt="image-20221129190407709" style="zoom:80%;" /></p><h3 id="ipv4地址">4.2.3 IPv4地址</h3><h4 id="ip编址的历史阶段">4.2.3.1 IP编址的历史阶段</h4><ol type="1"><li>分类的IP地址</li><li>子网的划分</li><li>构成超网：无分类编址方法</li></ol><h4 id="分类的ip地址">4.2.3.2 分类的IP地址</h4><ol type="1"><li><p>IP地址：全世界唯一的<strong>32位/4字节</strong>标识符，标识路由器主机的接口</p></li><li><p>IP地址：{<网络号> <主机号>}<strong>点分十进制表示方法</strong></p><p><img src="/images/AssetMarkdown/image-20221129191038841.png" alt="image-20221129191038841" style="zoom:80%;" /></p></li></ol><h4 id="互联网中的ip地址">4.2.3.3 互联网中的IP地址</h4><p><img src="/images/AssetMarkdown/image-20221129191227138.png" alt="image-20221129191227138" style="zoom:80%;" /></p><ol type="1"><li>同一个局域网中，网络号相同</li><li>网桥不分割广播域：因此通过网桥连接起来的设备仍是一个局域网</li><li>路由器分割广播域：路由器的每一个接口都会有一个不同的IP地址</li><li>绿色的部分：无编号(无名)网络，是逻辑上的网络</li><li>整个图中共有6个逻辑上的网络<ol type="1"><li>橙色部分：3个</li><li>绿色部分：3个</li></ol></li></ol><h4 id="分类的ip地址-1">4.2.3.4 分类的IP地址</h4><p><img src="/images/AssetMarkdown/image-20221129192446002.png" alt="image-20221129192446002" style="zoom:80%;" /></p><h4 id="特殊的ip地址">4.2.3.5 特殊的IP地址</h4><p><img src="/images/AssetMarkdown/image-20221129191949926.png" alt="image-20221129191949926" style="zoom:80%;" /></p><h4 id="私有ip地址">4.2.3.6 私有IP地址</h4><p><img src="/images/AssetMarkdown/image-20221129192023872.png" alt="image-20221129192023872" style="zoom:80%;" /></p><ol type="1"><li>路由器对目的地址是私有IP地址的数据报一律不进行转发</li></ol><h3 id="网络地址转换nat">4.2.4 网络地址转换NAT</h3><p>网络地址转换NAT(Network Address Translation)：</p><ol type="1"><li>在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装NAT软件</li><li>安装了NAT软件的路由器称为<strong>NAT路由器</strong>，它至少有一个有效的<strong>外部全球IP地址</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221129193233306.png" alt="image-20221129193233306" style="zoom:80%;" /></p><h3 id="子网划分与子网验码">4.2.5 子网划分与子网验码</h3><h4 id="子网划分">4.2.5.1 子网划分</h4><p>分类IP地址的缺点：</p><ol type="1"><li>IP地址空间的利用率有时很低</li><li>两级IP地址不够灵活</li></ol><p><img src="/images/AssetMarkdown/image-20221129193445186.png" alt="image-20221129193445186" style="zoom:80%;" /></p><ol type="1"><li>划分子网后，对外仍<strong>表现为一个网络</strong>，即外单位的网络看不到本单位内的子网划分</li><li>主机号至少要有2位</li><li>主机号不能全0/全1：这两种分别表示当前网络/广播地址</li><li><strong>子网号能否全0/1要看情况</strong></li></ol><h4 id="子网划分的示例">4.2.5.2 子网划分的示例</h4><p><img src="/images/AssetMarkdown/image-20221129193712879.png" alt="image-20221129193712879" style="zoom:80%;" /></p><h4 id="子网掩码">4.2.5.3 子网掩码</h4><p><img src="/images/AssetMarkdown/image-20221129194026929.png" alt="image-20221129194026929" style="zoom:80%;" /></p><ol type="1"><li>网络号/子网号对应位置：填1</li><li>主机号对应位置：填0</li><li>子网掩码与IP地址逐位相与，就得到了子网网络的地址</li></ol><h4 id="子网掩码的示例">4.2.5.4 子网掩码的示例</h4><p><img src="/images/AssetMarkdown/image-20221129194211056.png" alt="image-20221129194211056" style="zoom:80%;" /></p><ol type="1"><li>同一个IP地址，不同子网掩码，求出的网络地址可以是相同的</li><li>但是含义不同，表示子网可划分的主机数不同</li></ol><p><img src="/images/AssetMarkdown/image-20221129194517726.png" alt="image-20221129194517726" style="zoom:80%;" /></p><h4 id="使用子网时分组的转发">4.2.5.5 使用子网时分组的转发</h4><p><img src="/images/AssetMarkdown/image-20221129194827532.png" alt="image-20221129194827532" style="zoom:80%;" /></p><h3 id="无分类编址cidr">4.2.6 无分类编址CIDR</h3><h4 id="cidr的特点及使用方法">4.2.6.1 CIDR的特点及使用方法</h4><p>无分类域间路由选择CIDR：</p><ol type="1"><li>消除了传统的A类，B类和C类地址以及划分子网的概念</li><li>融合了子网地址和子网掩码，方便子网划分</li></ol><p>CIDR的使用方法：</p><ol type="1"><li><p>CIDR记法：IP地址后加上”/”，然后写上网络前缀的位数，如128.14.22.0<strong>/20</strong></p><p><img src="/images/AssetMarkdown/image-20221129195328293.png" alt="image-20221129195328293" style="zoom:80%;" /></p></li><li><p>CIDR地址块：<strong>网络前缀都相同</strong>的连续的IP地址</p></li><li><p><strong>CIDR技术中，子网号可以是全0/1的</strong></p><p><img src="/images/AssetMarkdown/image-20221129195541159.png" alt="image-20221129195541159" style="zoom:80%;" /></p></li></ol><h4 id="构成超网">4.2.6.2 构成超网</h4><ol type="1"><li><strong>构成超网</strong>：将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合</li><li>方法：将网络前缀缩短</li></ol><p><img src="/images/AssetMarkdown/image-20221129200027765.png" alt="image-20221129200027765" style="zoom:80%;" /></p><h4 id="最长前缀匹配">4.2.6.3 最长前缀匹配</h4><ol type="1"><li>使用CIDR时，查找路由表可能得到几个匹配的结果，应该选择具有最长网络前缀的路由</li><li>前缀越长，地址块越小，路由越具体</li></ol><p><img src="/images/AssetMarkdown/image-20221129200432306.png" alt="image-20221129200432306" style="zoom:80%;" /></p><h4 id="习题">4.2.6.4 习题</h4><p><img src="/images/AssetMarkdown/image-20221129200628326.png" alt="image-20221129200628326" style="zoom:80%;" /></p><h3 id="arp协议">4.2.7 ARP协议</h3><h4 id="发送数据的过程">4.2.7.1 发送数据的过程</h4><p>同一局域网内，不知道接收方的MAC地址：</p><ol type="1"><li>发送方：发送广播ARP请求分组，广播查询接收方IP3的MAC地址</li><li>接收方：IP3返回单波ARP相应分组</li><li>发送方接收到接收方的回应后，将接收方的MAC地址MAC3填入帧中</li></ol><p><img src="/images/AssetMarkdown/image-20221129201246544.png" alt="image-20221129201246544" style="zoom:80%;" /></p><p>不在同一局域网内，不知道接收方的MAC地址：</p><ol type="1"><li>发送方：发送广播ARP请求分组，广播查询默认网关IP6的MAC地址</li><li>接收方：IP6返回单波ARP相应分组</li><li>发送方接收到接收方的回应后，将接收方的MAC地址MAC6填入帧中</li></ol><p><img src="/images/AssetMarkdown/image-20221129201841358.png" alt="image-20221129201841358" style="zoom: 80%;" /></p><p><img src="/images/AssetMarkdown/image-20221129201908628.png" alt="image-20221129201908628" style="zoom:80%;" /></p><h4 id="arp协议-1">4.2.7.2 ARP协议</h4><ol type="1"><li>产生原因：在实际网络的链路上传送数据顿时，最终必须使用MAC地址</li><li><strong>ARP协议</strong>：完成主机或路由器IP地址到MAC地址的映射。解决下一跳走哪的问题</li><li>ARP协议使用过程：<ol type="1"><li>检查<strong>ARP高速缓存</strong>，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并<strong>广播ARP请求分组</strong></li><li><strong>同一局域网中</strong>所有主机都能收到该请求</li><li>目的主机收到请求后就会向源主机<strong>单播一个ARP响应分组</strong></li><li>源主机收到后将此映射<strong>写入ARP缓存</strong>(10-20min更新一次)</li></ol></li><li>ARP协议4种典型情况：<ol type="1"><li><strong>主机</strong>A发给<strong>本网络</strong>上的主机B：用ARP找到<strong>主机B</strong>的硬件地址</li><li><strong>主机</strong>A发给<strong>另一网络</strong>上的主机B：用ARP找到本网络上一个<strong>路由器(网关)</strong>的硬件地址</li><li><strong>路由器</strong>发给<strong>本网络</strong>的主机A：用ARP找到<strong>主机A</strong>的硬件地址</li><li><strong>路由器</strong>发给<strong>另一网络</strong>的主机B：用ARP找到本网络上的一个<strong>路由器</strong>的硬件地址</li></ol></li><li>ARP协议自动进行</li></ol><h4 id="习题-1">4.2.7.3 习题</h4><p><img src="/images/AssetMarkdown/image-20221129202543897.png" alt="image-20221129202543897" style="zoom:80%;" /></p><h3 id="dhcp协议">4.2.8 DHCP协议</h3><h4 id="主机如何获得ip地址">4.2.8.1 主机如何获得IP地址</h4><ol type="1"><li>静态配置：IP地址、子网掩码、默认网关</li><li>动态配置：</li></ol><p><img src="/images/AssetMarkdown/image-20221129203124440.png" alt="image-20221129203124440" style="zoom:80%;" /></p><h4 id="dhcp协议-1">4.2.8.2 DHCP协议</h4><p>动态主机配置协议DHCP：</p><ol type="1"><li>是<strong>应用层</strong>协议，使用<strong>客户/服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，基于<strong>UDP</strong></li><li>DHCP提供<strong>即插即用</strong>联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址</li><li>允许<strong>地址重用</strong>，支持<strong>移动用户加入网络</strong>，支持<strong>在用地址续租</strong></li></ol><p>DHCP协议的过程：</p><ol type="1"><li><strong>主机</strong>广播<strong>DHCP发现报文</strong>：试图找到网络中的服务器，服务器获得一个IP地址</li><li><strong>DHCP服务器</strong>广播<strong>DHCP提供报文</strong>：服务器拟分配给主机一个IP地址及相关配置，先到先得</li><li><strong>主机</strong>广播<strong>DHCP请求报文</strong>：主机向服务器请求提供IP地址</li><li><strong>DHCP服务器</strong>广播<strong>DHCP确认报文</strong>：正式将IP地址分配给主机</li></ol><h3 id="icmp协议">4.2.9 ICMP协议</h3><h4 id="网际控制报文协议icmp">4.2.9.1 网际控制报文协议ICMP</h4><p><img src="/images/AssetMarkdown/image-20221129203735584.png" alt="image-20221129203735584" style="zoom:80%;" /></p><h4 id="icmp差错报告报文5种">4.2.9.2 ICMP差错报告报文(5种)</h4><ol type="1"><li><strong>终点不可达</strong>：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。<strong>无法交付</strong></li><li><strong>源点抑制</strong>：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。<strong>拥塞丢数据(不再使用)</strong></li><li><strong>时间超过</strong>：当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就<strong>把已收到的数据报片都丢弃</strong>，并向源点发送时间超过报文。<strong>TTL=0</strong></li><li><strong>参数问题</strong>：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。<strong>首部字段有问题</strong></li><li><strong>改变路由(重定向)</strong>：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。<strong>值得更好的路由</strong></li></ol><h4 id="icmp差错报告报文数据字段">4.2.9.3 ICMP差错报告报文数据字段</h4><p><img src="/images/AssetMarkdown/image-20221129204209685.png" alt="image-20221129204209685" style="zoom:80%;" /></p><h4 id="不应发送icmp差错报文的情况">4.2.9.4不应发送ICMP差错报文的情况</h4><ol type="1"><li>对<strong>ICMP差错报告报文</strong>不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有<strong>后续数据报片</strong>都不发送ICMP差错报告报文</li><li>对具有<strong>组播地址</strong>的数据报都不发送ICMP差错报告报文<ol type="1"><li>组播：一点到多点</li><li>广播：一点到所有点</li></ol></li><li>对具有<strong>特殊地址(如127.0.0.0或0.0.0.0)</strong>的数据报不发送ICMP差错报告报文</li></ol><h4 id="icmp询问报文">4.2.9.5 ICMP询问报文</h4><ol type="1"><li><strong>回送请求和回答报文</strong>：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<strong>测试目的站是否可达以及了解其相关状态</strong></li><li><strong>时间截请求和回答报文</strong>：请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间</strong></li><li>掩码地址请求和回答报文</li><li>路由器询问和通告报文</li></ol><h4 id="icmp的应用">4.2.9.6 ICMP的应用</h4><ol type="1"><li><strong>PING</strong>：测试两个主机之间的连通性，使用了<strong>ICMP回送请求和回答报文</strong></li><li><strong>Traceroute</strong>：跟踪一个分组从源点到终点的路径，使用了<strong>ICMP时间超过差错报告报文</strong></li></ol><h2 id="ipv6">4.3 IPv6</h2><h3 id="为什么有ipv6">4.3.1 为什么有IPv6</h3><p><img src="/images/AssetMarkdown/image-20221129204933309.png" alt="image-20221129204933309" style="zoom:80%;" /></p><h3 id="ipv6数据报格式">4.3.2 IPv6数据报格式</h3><p><img src="/images/AssetMarkdown/image-20221129205002582.png" alt="image-20221129205002582" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221129205023299.png" alt="image-20221129205023299" style="zoom:80%;" /></p><table><colgroup><col style="width: 19%" /><col style="width: 8%" /><col style="width: 16%" /><col style="width: 54%" /></colgroup><thead><tr class="header"><th style="text-align: center;">位置</th><th style="text-align: center;">长度</th><th style="text-align: center;">名称</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">第1个4B：00~03</td><td style="text-align: center;">4bit</td><td style="text-align: center;">版本</td><td style="text-align: center;">协议版本，总是6</td></tr><tr class="even"><td style="text-align: center;">第1个4B：04~11</td><td style="text-align: center;">8bit</td><td style="text-align: center;">优先级</td><td style="text-align: center;">区分数据报的类别、优先级</td></tr><tr class="odd"><td style="text-align: center;">第1个4B：12~31</td><td style="text-align: center;">20bit</td><td style="text-align: center;">流标签</td><td style="text-align: center;">表面当前数据报属于哪个“流”</td></tr><tr class="even"><td style="text-align: center;">第2个4B：00~15</td><td style="text-align: center;">16bit</td><td style="text-align: center;">有效载荷长度</td><tdstyle="text-align: center;">有效载荷部分(<strong>扩展首部+数据</strong>)的长度</td></tr><tr class="odd"><td style="text-align: center;">第2个4B：16~23</td><td style="text-align: center;">8bit</td><td style="text-align: center;">下一个首部</td><tdstyle="text-align: center;">标识<strong>下一个扩展首部</strong>/<strong>上层协议首部</strong></td></tr><tr class="even"><td style="text-align: center;">第2个4B：24~31</td><td style="text-align: center;">8bit</td><td style="text-align: center;">跳数限制</td><td style="text-align: center;">相当于IPv4的TTL</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">128bit</td><td style="text-align: center;">源地址</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">128bit</td><td style="text-align: center;">目的地址</td><td style="text-align: center;"></td></tr></tbody></table><p>流：</p><ol type="1"><li>互联网上从特定源点到特定终点的一系列数据报</li><li>所有属于同一个流的数据报都具有相同的流标签</li></ol><h3 id="ipv6和ipv4">4.3.2 IPv6和IPv4</h3><ol type="1"><li>IPv6将地址从32位(4B)扩大到<strong>128位(16B)</strong>，更大的地址空间</li><li>IPv6将IPv4的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间</li><li>IPv6将IPv4的可选字段移出首部，变成了<strong>扩展首部</strong>，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率</li><li>IPv6支持<strong>即插即用</strong>(即自动配置) ，不需要DHCP协议</li><li>IPv6首部长度必须是<strong>8B的整数倍</strong>，IPv4首部是4B的整数倍</li><li>IPv6<strong>只能在主机处分片</strong>，IPv4可以在路由器和主机处分片</li><li>ICMPv6：附加报文类型“分组过大”。</li><li>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用</li><li>IPv6取消了协议字段，改成下一个首部字段</li><li>IPv6取消了总长度字段，改用有效载荷长度字段</li><li>IPv6取消了服务类型字段</li></ol><h3 id="ipv6地址表示形式">4.3.4 IPv6地址表示形式</h3><ol type="1"><li><strong>一般形式</strong>：<strong>冒号十六进制记法</strong></li><li><strong>压缩形式</strong>：</li><li><strong>零压缩</strong>：一连串连续的0可以被一对冒号取代，双冒号只能在一个地址中出现一次</li></ol><p><img src="/images/AssetMarkdown/image-20221129210458220.png" alt="image-20221129210458220" style="zoom:80%;" /></p><h3 id="ipv6基本地址类型">4.3.5 IPv6基本地址类型</h3><ol type="1"><li><strong>单播</strong>：一对一通信，可以做源地址+目的地址</li><li><strong>多播</strong>：一对多通信，可以做目的地址</li><li><strong>任播</strong>：一对多中的一个通信，可以做目的地址</li></ol><p><img src="/images/AssetMarkdown/image-20221129210629760.png" alt="image-20221129210629760" style="zoom:80%;" /></p><h3 id="ipv6向ipv4过渡的策略">4.3.6 IPv6向IPv4过渡的策略</h3><ol type="1"><li>双栈协议<ol type="1"><li>双协议栈技术就是指在一台设备上<strong>同时启用IPv4协议栈和IPv6协议栈</strong></li><li>这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信</li><li>如果这台设备是一个<strong>路由器</strong>：那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络</li><li>如果这台设备是一个<strong>计算机</strong>：那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能</li></ol></li><li>隧道技术<ol type="1"><li>通过使用互联网络的基础设施在网络之间传递数据的方式</li><li>使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包<strong>重新封装</strong>然后通过隧道发送</li></ol></li></ol><h3 id="总结-16">4.3.7 总结</h3><p><img src="/images/AssetMarkdown/image-20221129210938055.png" alt="image-20221129210938055" style="zoom:80%;" /></p><h2 id="路由算法与路由协议概述">4.4 路由算法与路由协议概述</h2><h3 id="路由算法">4.4.1 路由算法</h3><p>最佳路由：某一种特定要求下得出的较为合理的选择</p><p><img src="/images/AssetMarkdown/image-20221129182835879.png" alt="image-20221129182835879" style="zoom:80%;" /></p><h3 id="路由算法的分类">4.4.2 路由算法的分类</h3><ol type="1"><li><strong>静态路由算法</strong>(非自适应路由算法)：管理员手工配置路由信息<ol type="1"><li>优点：<ol type="1"><li>简便、可靠</li><li>在负荷稳定、拓扑变化不大的网络中运行效果很好</li><li>广泛用于高度安全性的军事网络和较小的商业网络</li></ol></li><li>缺点：<ol type="1"><li>路由更新慢，不适用于大型网络</li></ol></li></ol></li><li><strong>动态路由算法</strong>(自适应路由算法)：路由器间彼此交换信息，按照路由算法优化出路由表项<ol type="1"><li>优点：<ol type="1"><li>路由更新快</li><li>适用大型网络</li><li>及时响应链路费用或网络拓扑变化</li></ol></li><li>缺点：<ol type="1"><li>算法复杂，增加网络负担</li></ol></li></ol></li></ol><p>动态路由算法的分类：</p><ol type="1"><li>全局性：链路状态路由算法<strong>OSPF</strong><ol type="1"><li>所有路由器掌握完整的网络拓扑和链路费用信息</li></ol></li><li>分散性：距离向量路由算法<strong>RIP</strong><ol type="1"><li>路由器只掌握物理相连的邻居及链路费用</li></ol></li></ol><h3 id="分层次的路由选择协议">4.4.3 分层次的路由选择协议</h3><p>原因：</p><ol type="1"><li>因特网规模很大</li><li>许多单位不想让外界知道自己的路由选择协议，但还想连入因特网</li></ol><p><strong>自治系统AS</strong>：</p><ol type="1"><li>在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由</li><li>一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通</li></ol><p>路由选择协议：</p><ol type="1"><li>内部网关协议IGP：一个AS内使用的，如<strong>RIP、OSPF</strong></li><li>外部网关协议EGP：AS之间使用的，如<strong>BGP</strong></li></ol><h2 id="路由选择协议">4.5 路由选择协议</h2><p><img src="/images/AssetMarkdown/image-20221129211300849.png" alt="image-20221129211300849" style="zoom:80%;" /></p><h3 id="rip协议及距离向量算法">4.5.1 RIP协议及距离向量算法</h3><h4 id="rip协议">4.5.1.1 RIP协议</h4><ol type="1"><li>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是简单</li><li>RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong>(即一组距离)</li><li>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此<strong>距离为16表示网络不可达</strong></li><li>RIP协议只适用于<strong>小互联网</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221129212207355.png" alt="image-20221129212207355" style="zoom:80%;" /></p><h4 id="rip协议和谁交换多久交换一次交换什么">4.5.1.2RIP协议和谁交换？多久交换一次？交换什么？</h4><ol type="1"><li>仅和<strong>相邻路由器</strong>交换信息</li><li>路由器交换的信息是<strong>自己的路由表</strong></li><li><strong>每30秒</strong>交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表</li><li>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息</li><li>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“<strong>收敛</strong>”</li></ol><h4 id="距离向量算法">4.5.1.3 距离向量算法</h4><p><img src="/images/AssetMarkdown/image-20221129212928474.png" alt="image-20221129212928474" style="zoom:80%;" /></p><ol type="1"><li>修改相邻路由器发来的RIP报文中<strong>所有表项</strong><ol type="1"><li>对地址为x的相邻路由器发来的RIP报文，修改此报文中的所有项目：</li><li>把“下一跳”字段中的地址改为X，并把<strong>所有的“距离”字段+1</strong></li></ol></li><li>对修改后的RIP报文中的每一个项目，进行以下步骤:<ol type="1"><li>R1路由表中若没有Net3，则把该项目填入R1路由表</li><li>R1路由表中若有Net3，则查看下一跳路由器地址<ol type="1"><li>若下一跳是X，则用收到的项目替换源路由表中的项目</li><li>若下一跳不是X，原来距离比从X走的距离远则更新，否则不作处理</li></ol></li></ol></li><li>若<strong>180s</strong>还没收到相邻路由器X的更新路由表，则把x记为不可达的路由器，即把距离设置为16</li><li>返回</li></ol><h4 id="例题">4.5.1.4 例题</h4><p><img src="/images/AssetMarkdown/image-20221129213125318.png" alt="image-20221129213125318" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221129213401526.png" alt="image-20221129213401526" style="zoom:80%;" /></p><h4 id="rip协议的报文格式">4.5.1.5 RIP协议的报文格式</h4><p><img src="/images/AssetMarkdown/image-20221129213537077.png" alt="image-20221129213537077" style="zoom:80%;" /></p><ol type="1"><li>RIP是<strong>应用层协议</strong>，使用<strong>UDP</strong>传送数据</li><li>一个RIP报文最多可以包括25个路由，如果超过，则不许再用一个RIP报文传送</li></ol><h4 id="rip协议好消息传得快坏消息传得慢">4.5.1.6RIP协议：好消息传得快，坏消息传得慢</h4><p>RIP的特点：当网络出现故障时，要经过比较长的事件才能将此消息传送到所有的路由器，<strong>慢收敛</strong></p><p><img src="/images/AssetMarkdown/image-20221129213606257.png" alt="image-20221129213606257" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221129213808530.png" alt="image-20221129213808530" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221129213832003.png" alt="image-20221129213832003" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221129213838273.png" alt="image-20221129213838273" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221129213849121.png" alt="image-20221129213849121" style="zoom:80%;" /></p><h4 id="总结-17">4.5.1.7 总结</h4><p><img src="/images/AssetMarkdown/image-20221129213933023.png" alt="image-20221129213933023" style="zoom:80%;" /></p><h3 id="ospf协议与链路状态算法">4.5.2 OSPF协议与链路状态算法</h3><h4 id="ospf协议">4.5.2.1 OSPF协议</h4><p><strong>开放最短路径优先OSPF协议</strong>:</p><ol type="1"><li>“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的</li><li>“最短路径优先”·是因为使用了Dijkstra提出的最短路径算法SPF</li></ol><p>OSPF最主要的特征：</p><ol type="1"><li>使用分布式的<strong>链路状态协议</strong></li></ol><p>OSPF的特点：</p><ol type="1"><li><strong>和谁交换</strong>：使用<strong>洪泛法</strong>向自治系统内<strong>所有路由器</strong>发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。<strong>广播</strong><ol type="1"><li>最终整个区域内所有路由器都得到了这个信息的一个副本</li></ol></li><li><strong>交换什么</strong>：发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>(本路由器和哪些路由器相邻，以及该链路的度量/代价：费用、距离、时延、带宽等)</li><li><strong>多久交换</strong>：只有当<strong>链路状态发生变化</strong>时，路由器才向所有路由器洪泛发送此信息</li><li>最后，所有路由器都能建立一个<strong>链路状态数据库</strong>，即<strong>全网拓扑图</strong></li></ol><h4 id="链路状态算法">4.5.2.2 链路状态算法</h4><ol type="1"><li>每个路由器发现它的邻居结点【<strong>HELLO问候分组</strong>】，并了解邻居节点的网络地址</li><li>设置到它的每个邻居的<strong>成本度量metric</strong></li><li>构造【<strong>DD数据库描述分组</strong>】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>如果DD分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【<strong>LSR链路状态请求分组</strong>】请求自己没有的和比自己更新的信息</li><li>收到邻站的LSR分组后，发送【<strong>LSU链路状态更新分组</strong>】进行更新</li><li>更新完毕后，邻站返回一个【<strong>LSAck链路状态确认分组</strong>】进行确认</li></ol><p>只要一个路由器的链路状态发生变化:</p><ol start="5" type="1"><li>泛洪发送【<strong>LSU链路状态更新分组</strong>】进行更新</li><li>更新完毕后，其他站返回一个【<strong>LSAck链路状态确认分组</strong>】进行确认</li><li>使用Dijkstra根据自己的链路状态数据库<strong>构造到其他节点间的最短路径</strong></li></ol><h4 id="ospf的区域">4.5.2.3 OSPF的区域</h4><p><img src="/images/AssetMarkdown/image-20221129214835703.png" alt="image-20221129214835703" style="zoom:80%;" /></p><h4 id="ospf分组">4.5.2.4 OSPF分组</h4><ol type="1"><li>OSPF直接使用<strong>IP数据报</strong>传送</li></ol><p><img src="/images/AssetMarkdown/image-20221129214958641.png" alt="image-20221129214958641" style="zoom:80%;" /></p><h4 id="ospf其他特点">4.5.2.5 OSPF其他特点</h4><ol type="1"><li>每隔30min，要刷新一次数据库中的链路状态</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多</li><li>OSPF不存在坏消息传的慢的问题，它的收敛速度很快</li></ol><h3 id="bgp协议">4.5.3 BGP协议</h3><h4 id="bgp协议和谁交换多久交换一次交换什么">4.5.3.1BGP协议和谁交换？多久交换一次？交换什么？</h4><ol type="1"><li><strong>和谁交换</strong>：与其它AS的邻站BGP发言人交换信息</li><li><strong>交换什么</strong>：交换网络可达性的信息，即要到达某个网络所要经过的一系列AS</li><li><strong>多久交换</strong>：发生变化时<strong>更新有变化</strong>的部分</li></ol><p><img src="/images/AssetMarkdown/image-20221206155545414.png" alt="image-20221206155545414" style="zoom:80%;" /></p><h4 id="bgp协议交换信息的过程">4.5.3.2 BGP协议交换信息的过程</h4><ol type="1"><li><p>BGP所交换的网络可达性的信息：<strong>要到达某个网络所要经过的一系列AS</strong></p></li><li><p>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的<strong>较好路由</strong></p><p><img src="/images/AssetMarkdown/image-20221206155653004.png" alt="image-20221206155653004" style="zoom:80%;" /></p></li><li><p>BGP发言人交换<strong>路径向量</strong>：</p><ol type="1"><li><p>自治系统AS<sub>2</sub>的BGP发言人通知主干网AS<sub>1</sub>的BGP发言人:“要到达网络N1、 N2、N3、N4可经过AS<sub>2</sub>。”</p><p><img src="/images/AssetMarkdown/image-20221206155919276.png" alt="image-20221206155919276" style="zoom:80%;" /></p></li><li><p>主干网还可发出通知：“要到达网络N5、N6和N7可沿路径(AS<sub>1</sub>，AS<sub>3</sub>)。”</p><p><img src="/images/AssetMarkdown/image-20221206160217081.png" alt="image-20221206160217081" style="zoom:80%;" /></p></li></ol></li></ol><h4 id="bgp协议报文格式">4.5.3.3 BGP协议报文格式</h4><ol type="1"><li>一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就要<strong>先建立TCP连接</strong>，即通过TCP传送，然后在此连接上交换BGP报文以建立BGP会话(session)，利用BGP会话交换路由信息</li></ol><p><img src="/images/AssetMarkdown/image-20221206160353750.png" alt="image-20221206160353750" style="zoom:80%;" /></p><h4 id="bgp协议特点">4.5.3.4 BGP协议特点</h4><ol type="1"><li>BGP支持<strong>CIDR</strong>，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</li><li>在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在<strong>发生变化时更新有变化的部分</strong>。这样做对节省网络带宽和减少路由器的处理开销都有好处。</li></ol><h4 id="bgp-4的四种报文">4.5.3.5 BGP-4的四种报文</h4><ol type="1"><li><strong>OPEN(打开)报文</strong>：用来与相邻的另一个BGP发言人建立关系，并认证发送方</li><li><strong>UPDATE(更新)报文</strong>：通告新路径或撤销原路径</li><li><strong>KEEPALIVE(保活)报文</strong>：在无UPDATE时，周期性证实邻站的连通性;也作为OPEN的确认</li><li><strong>NOTIFICATION(通知)报文</strong>：报告先前报文的差错;也被用于关闭连接</li></ol><h3 id="三种路由协议的比较">4.5.4 三种路由协议的比较</h3><table><colgroup><col style="width: 6%" /><col style="width: 33%" /><col style="width: 29%" /><col style="width: 30%" /></colgroup><thead><tr class="header"><th style="text-align: center;">协议</th><th style="text-align: center;">RIP</th><th style="text-align: center;">OSPF</th><th style="text-align: center;">BGP</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">类型</td><td style="text-align: center;">内部</td><td style="text-align: center;">内部</td><td style="text-align: center;">外部</td></tr><tr class="even"><td style="text-align: center;">路由算法</td><td style="text-align: center;">距离-向量</td><td style="text-align: center;">链路状态</td><td style="text-align: center;">路径-向量</td></tr><tr class="odd"><td style="text-align: center;">传递协议</td><td style="text-align: center;">UDP</td><td style="text-align: center;">IP</td><td style="text-align: center;">TCP</td></tr><tr class="even"><td style="text-align: center;">路径选择</td><td style="text-align: center;">跳数最少</td><td style="text-align: center;">代价最低</td><td style="text-align: center;">较好，非最佳</td></tr><tr class="odd"><td style="text-align: center;">交换节点</td><td style="text-align: center;">和本结点相邻的路由器</td><td style="text-align: center;">网络中的所有路由器</td><td style="text-align: center;">和本结点相邻的路由器</td></tr><tr class="even"><td style="text-align: center;">交换内容</td><tdstyle="text-align: center;">当前本路由器知道的全部信息，即自己的路由表</td><tdstyle="text-align: center;">与本路由器相邻的所有路由器的链路状态</td><tdstyle="text-align: center;">首次：整个路由表；非首次：有变化的部分</td></tr></tbody></table><h2 id="ip组播">4.6 IP组播</h2><h3 id="ip数据报的三种传输方式">4.6.1 IP数据报的三种传输方式</h3><ol type="1"><li><p><strong>单播</strong>：单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种<strong>点对点</strong>传输方式</p><p><img src="/images/AssetMarkdown/image-20221206192249707.png" alt="image-20221206192249707" style="zoom: 67%;" /></p></li><li><p><strong>广播</strong>：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种<strong>点对多点</strong>传输方式</p></li><li><p><strong>组播(多播)</strong>：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据<strong>到达距离用户端尽可能近的节点后才开始复制和分发</strong>，是一种<strong>点对多点</strong>传输方式</p><p><img src="/images/AssetMarkdown/image-20221206192330579.png" alt="image-20221206192330579" style="zoom: 67%;" /></p></li></ol><h3 id="ip组播地址">4.6.2 IP组播地址</h3><ol type="1"><li>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配<strong>一个组播组IP地址</strong>(<strong>一群共同需求主机的相同标识</strong>)</li><li>组播地址范围为224.0.0.0~239.255.255.255(D类地址)，一个D类地址表示一个组播组。只能用作分组的<strong>目标地址</strong>。<strong>源地址总是为单播地址</strong></li></ol><p>组播的特点：</p><ol type="1"><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于<strong>UDP</strong></li><li>对组播数据报不产生ICMP差错报文</li><li>并非所有D类地址都可以作为组播地址，有的地址被定义为永久组播地址</li></ol><p><img src="/images/AssetMarkdown/image-20221206192712826.png" alt="image-20221206192712826" style="zoom:80%;" /></p><h3 id="硬件组播">4.6.3 硬件组播</h3><ol type="1"><li>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送顿。</li><li><strong>地址的转换</strong>：组播MAC地址以十六进制值<strong>01-00-5E</strong>打头，余下的6个十六进制位是IP组播组地址的<strong>最后23位</strong></li><li>TCP/IP协议使用的以太网多播地址的范围是：<strong>01-00-5E-00-00-00</strong>到<strong>01-00-5E-7F-FF-FF</strong></li><li></li></ol><p><img src="/images/AssetMarkdown/image-20221206193244101.png" alt="image-20221206193244101" style="zoom:80%;" /></p><h3 id="igmp协议与组播路由选择协议">4.6.4IGMP协议与组播路由选择协议</h3><ol type="1"><li><strong>IGMP协议</strong>：判断一个路由器所连的局域网中，是否有主机参加/退出某个组播组</li><li><strong>组播路由选择协议</strong>：路由器之间进行路径选择</li></ol><h4 id="网际组管理协议-igmp">4.6.4.1 网际组管理协议 IGMP</h4><p><img src="/images/AssetMarkdown/image-20221206193546317.png" alt="image-20221206193546317" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221206193641440.png" alt="image-20221206193641440" style="zoom:80%;" /></p><p>IGMP工作的两个阶段：</p><ol type="1"><li>ROUND 1<ol type="1"><li>某主机要加入组播组时，该主机向组播组的<strong>组播地址</strong>发送一个IGMP报文，声明自己要称为该组的成员</li><li>本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器</li></ol></li><li>ROUND 2<ol type="1"><li>本地组播路由器<strong>周期性探询</strong>本地局域网上的主机，以便知道这些主机是否还是组播组的成员</li><li><strong>只要有一个主机</strong>对某个组响应，那么组播路由器就认为这个组是活跃的;如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器</li></ol></li><li><strong>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员</strong>，并不会反应该组播组成员有多少个，因为路由器页不知道</li></ol><h4 id="组播路由选择协议">4.6.4.2 组播路由选择协议</h4><ol type="1"><li><p>目的：找出以源主机为根节点的组播转发树</p></li><li><p>构造树可以避免在路由器之间兜圈子</p></li><li><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树</p><p><img src="/images/AssetMarkdown/image-20221206195118352.png" alt="image-20221206195118352" style="zoom:80%;" /></p></li><li><p>三种算法：</p><ol type="1"><li>基于链路状态的路由选择</li><li>基于距离-向量的路由选择</li><li>协议无关的组播(稀疏/密集)</li></ol></li></ol><h3 id="总结-18">4.6.5 总结</h3><p><img src="/images/AssetMarkdown/image-20221206195344098.png" alt="image-20221206195344098" style="zoom:80%;" /></p><h2 id="移动ip">4.7 移动IP</h2><ol type="1"><li>动态IP：通过使用DHCP协议，在一个局域网内部的主机可以动态的获得一个IP地址</li><li>移动IP：物理位置改变，但IP地址不变</li></ol><h3 id="移动ip相关术语">4.7.1 移动IP相关术语</h3><ol type="1"><li>移动IP技术：是移动结点(计算机/服务器等)以<strong>固定的网络IP地址</strong>，实现跨越不同网段的<strong>漫游</strong>功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变</li><li><strong>移动节点</strong>：具有永久IP地址的移动设备</li><li><strong>归属代理(本地代理)</strong>：一个移动结点拥有的就“居所”称为<strong>归属网络</strong>，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理</li><li><strong>外部代理(外地代理)</strong>：在<strong>外部网络</strong>中帮助移动节点完成移动管理功能的实体称为外部代理</li><li><strong>永久地址(归属地址/主地址)</strong>：移动站点在归属网络中的原始地址</li><li><strong>转交地址(辅地址)</strong>：移动站点在外部网络使用的临时地址</li></ol><h3 id="移动ip通信过程">4.7.2 移动IP通信过程</h3><p><img src="/images/AssetMarkdown/image-20221212185925655.png" alt="image-20221212185925655" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221212190018543.png" alt="image-20221212190018543" style="zoom:80%;" /></p><h2 id="网络层设备">4.8 网络层设备</h2><h3 id="路由器">4.8.1 路由器</h3><ol type="1"><li>路由器：是一种具有多个输入端口和多个输出端口的专用计算机<ol type="1"><li>任务：转发分组</li></ol></li><li>路由选择：根据所选定的路由选择协议<strong>构造路由表</strong>，同时经常或定期和相邻路由器交换路由信息而不断地<strong>更新和维护路由表</strong></li><li>交换结构：根据<strong>转发表(由路由表得来)</strong>对分组进行转发</li><li>转发 vs 路由选择：<ol type="1"><li>转发：是一个路由器内部，确定数据应该被发向哪个端口</li><li>路由选择：是路由器决定数据下一个应当去往哪个路由器</li></ol></li><li>如果收到RIP/OSPF分组，则把分组送往路由选择处理机；若收到数据分组，则查找转发表并输出</li></ol><p><img src="/images/AssetMarkdown/image-20221212190813832.png" alt="image-20221212190813832" style="zoom:80%;" /></p><h4 id="输入端口对线路上收到的分组的处理">4.8.1.1输入端口对线路上收到的分组的处理</h4><p>输入端口中，查找和转发功能在路由器的交换功能中是最重要的</p><p><img src="/images/AssetMarkdown/image-20221212190838959.png" alt="image-20221212190838959" style="zoom:80%;" /></p><h4 id="输出端口将交换结构传送来的分组发送到线路">4.8.1.2输出端口将交换结构传送来的分组发送到线路</h4><ol type="1"><li>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃</li><li><strong>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221212191008504.png" alt="image-20221212191008504" style="zoom:80%;" /></p><h3 id="三层设备的区别">4.8.2 三层设备的区别</h3><ol type="1"><li><strong>路由器</strong>：可以互联两个不同网络层协议的网段</li><li><strong>网桥</strong>：可以互联两个物理层和链路层不同的网段</li><li><strong>集线器</strong>：不能互联两个物理层不同的网段</li><li><strong>任何层次的设备都能互联它所在的层次以及以下层次不同协议的网段(×，集线器不可以)</strong></li></ol><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">能否隔离冲突域</th><th style="text-align: center;">能否隔离广播域</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">物理层设备(中继器、集线器)</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td></tr><tr class="even"><td style="text-align: center;">链路层设备(网桥、交换机)</td><td style="text-align: center;">√</td><td style="text-align: center;">×</td></tr><tr class="odd"><td style="text-align: center;">网络层设备(路由器)</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr></tbody></table><h3 id="路由表与路由转发">4.8.3 路由表与路由转发</h3><ol type="1"><li><strong>路由表</strong>：根据<strong>路由选择算法</strong>得出，主要用于路由选择，总用软件实现</li><li><strong>转发表</strong>：根据<strong>路由表</strong>得出，可以用软件实现，也可以用特殊的硬件来实现。转发表必须包含完成转发功能所必需的信息，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息的映射</li></ol><p><img src="/images/AssetMarkdown/image-20221212191556123.png" alt="image-20221212191556123" style="zoom:80%;" /></p><h2 id="补充">4.9 补充</h2><h3 id="网络互联隧道-tunneling">4.9.1 网络互联：隧道 Tunneling</h3><p><img src="/images/AssetMarkdown/image-20221231174433620.png" alt="image-20221231174433620" style="zoom:80%;" /></p><ol type="1"><li>多个相同类型的网络，通过不同类型的网络进行互联</li></ol><h3 id="包的切割">4.9.2 包的切割</h3><p><img src="/images/AssetMarkdown/image-20221231174618356.png" alt="image-20221231174618356" style="zoom:80%;" /></p><ol type="1"><li>允许切割<ol type="1"><li>不透明：切完以后不还原，到目的地还原</li><li>透明：切完以后还原</li></ol></li><li>不允许切割<ol type="1"><li>IPv6选择不允许切割，如果包太大，就直接踢回去，让源主机切割</li></ol></li></ol><h3 id="软件定义网络sdnsoftware-defined-networking">4.9.3软件定义网络SDN：Software-Defined Networking</h3><p><img src="/images/AssetMarkdown/image-20221231174855353.png" alt="image-20221231174855353" style="zoom:80%;" /></p><ol type="1"><li>数据平面：通常是分布式的</li><li>管理平面：通常是集中式的</li><li>SDN：管理平面集中在一个软件控制器中，软件控制器为每个路由计算其路由表，路由从软件控制器中下载路由表使用</li></ol><h3 id="标记交换-label-switching">4.9.4 标记交换 Label Switching</h3><p><img src="/images/AssetMarkdown/image-20221231175606687.png" alt="image-20221231175606687" style="zoom:80%;" /></p><h1 id="chapter-5传输层-transport-layer">Chapter 5：传输层 TransportLayer</h1><h2 id="传输层概述">5.1 传输层概述</h2><ol type="1"><li>只有主机才有</li><li>为应用层提供通信服务，使用网络层的服务</li><li>传输层的功能：<ol type="1"><li>提供<strong>进程与进程之间</strong>的逻辑通信(网络层提供的是主机之间的逻辑通信)</li><li>复用与分用<ol type="1"><li>复用：不同进程使用同一传输层协议进行传输</li><li>分用：将传来的报文段送交给某个进程</li></ol></li><li>对收到的<strong>报文</strong>进行<strong>差错检测</strong></li></ol></li></ol><h3 id="传输层的两种协议tcpudp">5.1.1 传输层的两种协议：TCP、UDP</h3><p><img src="/images/AssetMarkdown/image-20221212193149384.png" alt="image-20221212193149384" style="zoom:80%;" /></p><h3 id="传输层的寻址与端口">5.1.2 传输层的寻址与端口</h3><ol type="1"><li><p><strong>复用</strong>：应用层所有的应用进程，都能够通过传输层在传输到网络层</p></li><li><p><strong>分用</strong>：传输层从网络层收到数据后，交付给指明的应用程序</p></li><li><p><strong>端口/逻辑端口/软件端口</strong>：是传输层的SAP，标识主机中的应用进程</p><ol type="1"><li>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的</li><li>端口号长度为16bit，能表示65536个不同的端口号</li></ol></li><li><p>端口号按范围分：</p><p><img src="/images/AssetMarkdown/image-20221212193708560.png" alt="image-20221212193708560" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221212193745221.png" alt="image-20221212193745221" style="zoom:80%;" /></p></li><li><p><strong>套接字Socket = (主机IP地址，端口号)</strong></p><ol type="1"><li>在网络中采用发送方和接收方的套接字组合来识别端点</li><li>套接字唯一标识了网络中的一个主机和它上面的一个进程</li></ol></li></ol><h2 id="udp协议">5.2 UDP协议</h2><ol type="1"><li>UDP在IP数据报服务之上，仅添加了复用分用、差错检测功能</li><li>UDP的主要特点：<ol type="1"><li><strong>无连接</strong>，减小开销和发送数据之前的时延</li><li><strong>不保证可靠交付</strong></li><li><strong>面向报文</strong>，适合一次性传输少量数据，如果太大需要网络层分片</li><li><strong>无拥塞控制</strong>，适合很多实时应用</li><li><strong>首部开销小</strong>，只有8B(TCP为20B)</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212194133114.png" alt="image-20221212194133114" style="zoom:80%;" /></p><h3 id="udp首部格式">5.2.1 UDP首部格式</h3><p><img src="/images/AssetMarkdown/image-20221212194537991.png" alt="image-20221212194537991" style="zoom:80%;" /></p><ol type="1"><li><strong>源端口号</strong>：可有可无，想要回复则填上</li><li><strong>UDP长度</strong>：整个UDP用户数据报的长度</li><li><strong>UDP检验和</strong>：检测整个UDP</li><li>丢弃情况：<ol type="1"><li>UDP检验和错误，则丢弃报文</li><li>分用时，找不到目的端口号，则丢弃报文，并发送给发送方ICMP”端口不可达”差错报告报文</li></ol></li></ol><h3 id="udp检验">5.2.2 UDP检验</h3><h4 id="伪首部">5.2.2.1 伪首部</h4><p><img src="/images/AssetMarkdown/image-20221212194907694.png" alt="image-20221212194907694" style="zoom:80%;" /></p><ol type="1"><li>伪IP首部</li><li>只有在计算校验和的时候出现，不向下传送也不向上递交</li><li>17：封装UDP报文的IP数据报首部协议字段是17</li><li>UDP长度：UDP首部8B + 数据部分的长度，不包括伪首部</li></ol><h4 id="校验方式">5.2.2.2 校验方式</h4><p><img src="/images/AssetMarkdown/image-20221212195051240.png" alt="image-20221212195051240" style="zoom:80%;" /></p><ol type="1"><li>发送端：<ol type="1"><li>填上伪首部</li><li>检验和：填充为全0</li><li>数据部分：不足4B的用0补齐</li><li>伪首部 + 首部 + 数据部分 用二进制反码求和(此时校验和全0)</li><li>检验和：将求和结果的反码填入</li><li>删除伪首部，然后发送</li></ol></li><li>接收端：<ol type="1"><li>填上伪首部</li><li>伪首部 + 首部 + 数据部分 用二进制反码求和(此时校验和是有数的)</li><li>结果全为1则无差错，否则丢弃数据报 / 交给应用层并附上差错的警告</li></ol></li></ol><h2 id="tcp协议">5.3 TCP协议</h2><h3 id="tcp协议特点">5.3.1 TCP协议特点</h3><ol type="1"><li>TCP是<strong>面向连接</strong>(虚连接)的传输层协议</li><li>每一条TCP连接只能有2个端点，每一条TCP连接只能是点对点的</li><li>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序抵达：<strong>可靠有序，不丢不重</strong></li><li>TCP提供<strong>全双工通信</strong>：两端均有发送缓存、接收缓存<ol type="1"><li>发送缓存：准备发送的数据 &amp; 已经发送但尚未收到确认的数据</li><li>接收缓存：不按序到达的数据 &amp;按序到达但尚未被应用程序读取的数据</li></ol></li><li>TCP面向<strong>字节流</strong><ol type="1"><li>流：流入到进程 / 从进程流出的数据</li><li>TCP把应用层交下来的数据看成仅仅是一连串的<strong>无结构的字节流</strong></li></ol></li></ol><h3 id="tcp报文段首部格式重点">5.3.2TCP报文段首部格式(<strong>重点</strong>)</h3><p><img src="/images/AssetMarkdown/image-20221212200021591.png" alt="image-20221212200021591"  /></p><ol type="1"><li><strong>序号seq</strong> 4B：<ol type="1"><li>在一个TCP连接中，传送的字节流中的每一个字节都按顺序编号，本字段表示<strong>本报文段</strong>所发送数据的<strong>第一个字节的序号</strong></li><li>如当前TCP报文发送的是文件的第4、5、6字节，则此处的序号填4</li></ol></li><li><strong>确认号ack</strong> 4B：<ol type="1"><li><strong>期望</strong>收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明0~N-1的所有数据均已正确收到</li></ol></li><li><strong>数据偏移(首部长度) </strong> 4bit：<ol type="1"><li>TCP报文段的数据起始处距离TCP报文段的起始处有多远，<strong>单位为4B</strong></li></ol></li><li><strong>控制位</strong> 6bit：<ol type="1"><li><strong>紧急位URG</strong>：URG=1时，表明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队。配合紧急指针字段使用（发送端的优先处理）</li><li><strong>确认位ACK</strong>：ACK=1时，确认号有效，在连接建立后，所有传送的报文段都必须把ACK置为1</li><li>推送位PSH：PSH=1时，接收方应尽快交付接收应用进程，不再等到缓存填充满再向上交付（接收端的优先处理）</li><li>复位RST：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输连接</li><li><strong>同步位SYN</strong>：SYN=1时，表明是一个<strong>连接请求/连接接受报文</strong></li><li><strong>终止位FIN</strong>：FIN=1时，表明此报文段发送方数据已发完，要求释放连接</li></ol></li><li><strong>窗口</strong> 2B：<ol type="1"><li>发送方的接收窗口，即现在允许对方发送的数据量</li><li>窗口大小最高为65536</li><li>如果确认号为701，窗口为1000，则发送方的接收窗口的缓存队列应为701~1700</li></ol></li><li><strong>检验和</strong> 2B：<ol type="1"><li>检验首部 +数据，检验时要加上12B的伪首部，伪首部的第四个字段为<strong>6</strong></li></ol></li><li><strong>紧急指针</strong> 2B：<ol type="1"><li>URG=1时才有意义</li><li>指出本报文段中紧急数据的字节数（紧急数据的末尾在报文段中的位置）</li><li>如果紧急指针为50，则0~50均为紧急数据</li></ol></li><li><strong>选项</strong>：<ol type="1"><li>最大报文段长度MSS：每个TCP报文段中数据字段的最大长度</li><li>窗口扩大、时间戳、选择确认</li></ol></li><li><strong>填充</strong>：<ol type="1"><li>TCP首部长度为<strong>4B的整数倍</strong>，一般填充全0</li></ol></li></ol><h3 id="tcp连接管理">5.3.3 TCP连接管理</h3><p>TCP连接传输的三个阶段：</p><ol type="1"><li>连接建立</li><li>数据传输</li><li>连接释放</li></ol><p>TCP连接的建立采用的是<strong>客户服务器方式</strong>：</p><ol type="1"><li>客户：主动发起连接建立的应用进程</li><li>服务器：被动等待连接建立的应用进程</li></ol><h4 id="tcp的连接建立三次握手">5.3.3.1TCP的连接建立(<strong>三次握手</strong>)</h4><blockquote><p><img src="/images/AssetMarkdown/image-20221212221059360.png" alt="image-20221212221059360" style="zoom:80%;" /></p></blockquote><p>假设运行在一台主机(客户)上的一个进程想与另一台主机(服务器)上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接：</p><ol type="1"><li>客户端发送<strong>连接请求报文段</strong>，无应用层数据<ol type="1"><li><strong>SYN=1，seq=x(随机数)，ACK=0</strong></li></ol></li><li>服务器端为该TCP连接<strong>分配缓存和变量</strong>，并向服务器端返回<strong>确认报文段</strong>，允许连接，无应用层数据<ol type="1"><li><strong>SYN=1，ACK=1，seq=y(随机数)，ack=x+1</strong></li></ol></li><li>客户端为该TCP连接<strong>分配缓存和变量</strong>，并向服务器端返回确认的确认，可以携带数据<ol type="1"><li><strong>SYN=0，ACK=1，seq=x+1，ack=y+1</strong></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212220257670.png" alt="image-20221212220257670" style="zoom:80%;" /></p><p>SYN洪泛攻击</p><ol type="1"><li>SYN洪泛攻击发生在<strong>OSI第四层</strong>，这种方式利用<strong>TCP协议</strong>的特性，就是<strong>三次握手</strong></li><li>攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者，这样更加会浪费服务器的资源</li><li>攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了</li></ol><p>解决方法：SYN cookie</p><h4 id="tcp的连接释放四次握手">5.3.3.2TCP的连接释放(<strong>四次握手</strong>)</h4><blockquote><p><img src="/images/AssetMarkdown/image-20221212221038391.png" alt="image-20221212221038391" style="zoom:80%;" /></p></blockquote><p>参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”(缓存和变量)将被释放：</p><ol type="1"><li>客户端发送<strong>连接释放报文段</strong>，停止发送数据，主动关闭TCP连接<ol type="1"><li><strong>FIN=1，seq=u(客户端发送到的地方)</strong></li></ol></li><li>服务端回送一个<strong>确认报文段</strong>，<strong>客户到服务端</strong>这个方向的连接就释放了：<strong>半关闭</strong>状态<ol type="1"><li><strong>ACK=1，seq=v(服务器发送到的地方)，ack=u+1</strong></li></ol></li><li>服务器端发完数据，就发出<strong>连接释放报文段</strong>，主动关闭TCP连接<ol type="1"><li><strong>FIN=1，ACK=1，seq=w，ack=u+1</strong></li></ol></li><li>客户端回送一个<strong>确认报文段</strong>，再等到<strong>时间等待计时器</strong>设置的<strong>2MSL(最长报文段寿命)</strong>后，连接彻底关闭<ol type="1"><li><strong>ACK=1，seq=u+1，ack=w+1</strong></li><li>如果服务器无法收到客户端回送的确认报文段，客户端会在2MSL之内收到重传的报文段，客户端然后重传确认，并且重新启动2MSL的计时器</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212220312555.png" alt="image-20221212220312555" style="zoom:80%;" /></p><h3 id="tcp可靠传输">5.3.4 TCP可靠传输</h3><ol type="1"><li>网络层：尽最大努力交付，不可靠传输</li><li>传输层：使用TCP实现可靠传输</li><li><strong>可靠</strong>：保证接收方进程从缓存区中读出的字节流与发送方发出的字节流是完全一样的</li><li>TCP实现可靠传输的机制：<ol type="1"><li>校验：与UDP校验一样，<strong>添加伪首部</strong></li><li>序号</li><li>确认</li><li>重传</li></ol></li></ol><h4 id="序号">5.3.4.1 序号</h4><ol type="1"><li>TCP面向字节流，因此会将字节编号，发送时将多个字节拼在一起形成一个报文段</li><li>一个字节占一个序号</li><li><strong>序号字段</strong>：一个报文段第一个字节的序号</li></ol><p><img src="/images/AssetMarkdown/image-20221212221544009.png" alt="image-20221212221544009" style="zoom:80%;" /></p><h4 id="确认">5.3.4.2 确认</h4><ol type="1"><li>接收方发送确认报文段，告诉发送方已经正确接收</li><li>TCP使用累计确认：<ol type="1"><li>正常接收78，但确认报文段表示接收方期待4</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212222154032.png" alt="image-20221212222154032" style="zoom:80%;" /></p><h4 id="重传">5.3.4.3 重传</h4><ol type="1"><li>TCP的发送方在<strong>规定的时间</strong>内没有收到确认，就要重传已发送的报文段：<strong>超时重传</strong>，该时间称为<strong>重传时间</strong></li><li>TCP采用自适应算法，动态改变重传时间<strong>RTTs(加权平均往返时间)</strong></li></ol><p><img src="/images/AssetMarkdown/image-20221212222443344.png" alt="image-20221212222443344" style="zoom:80%;" /></p><p><strong>冗余ACK(冗余确认)</strong></p><ol type="1"><li>每当比期望序号大的失序报文段到达时，发送一个<strong>冗余ACK</strong>，指明下一个期待字节的序号<ol type="1"><li>发送方已发送1，2，3，4，5报文段</li><li>接收方收到1，返回给1的确认(确认号为2的第一个字节)</li><li>接收方收到3，返回给1的确认(确认号为2的第一个字节)</li><li>接收方收到4，返回给1的确认(确认号为2的第一个字节)</li><li>接收方收到5，返回给1的确认(确认号为2的第一个字节)</li><li>发送方收到<strong>3个对于报文段1的冗余ACK</strong> →认为报文段2丢失，重传2号报文段</li></ol></li><li>称为<strong>快速重传</strong>机制</li></ol><h3 id="tcp流量控制重点">5.3.5 TCP流量控制(<strong>重点</strong>)</h3><ol type="1"><li>流量控制：让<strong>发送方慢点</strong>，要让接收方来得及接收</li><li>TCP使用<strong>滑动窗口</strong>机制实现流量控制<ol type="1"><li>在通信过程中，接收方根据自己<strong>接收缓存的大小</strong>，动态地调整发送方的发送窗口大小，即<strong>接收窗口rwnd</strong>(接收方设置确认报文段的<strong>窗口字段</strong>来将rwnd通知给发送方)</li><li>发送方的<strong>发送窗口</strong>为：<strong>min{接收窗口rwnd，拥塞窗口cwnd}</strong></li><li>建立连接时，接收方返回的确认报文段中包含自己的接收窗口大小，发送方根据上述公式确定发送窗口</li><li>发送窗口的大小可以动态变化</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212223450799.png" alt="image-20221212223450799" style="zoom:80%;" /></p><blockquote><p>A向B发送数据，连接建立时，B告诉A：“我的rwnd=400B”</p><p>设每一个报文段为100B，报文段序号初始值为1</p></blockquote><figure><img src="/images/AssetMarkdown/image-20221212224030365.png"alt="image-20221212224030365" /><figcaption aria-hidden="true">image-20221212224030365</figcaption></figure><p>解决零窗口通知后，新的窗口大小的报文段丢失，导致两个主机相互等待的问题：</p><ol type="1"><li>TCP为每一个连接设有一个<strong>持续计时器</strong>，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器</li><li>若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>。接收方收到探测报文段时给出现在的窗口值</li><li>若窗口仍然是0，那么发送方就重新设置持续计时器</li></ol><h3 id="tcp拥塞控制重点">5.3.6 TCP拥塞控制(<strong>重点</strong>)</h3><ol type="1"><li>出现拥塞的条件：对资源需求的总和 &gt; 可用资源</li><li>网络中有许多资源同时呈现供应不足 → 网络性能变坏 →网络吞吐量将随输入负荷的增大而下降</li><li>拥塞控制：防止过多数据注入网络中<ol type="1"><li><strong>全局性问题</strong></li><li>协调使用资源的所有主机</li><li>发送方发送的数据无法到达接收端</li></ol></li><li>流量控制：<ol type="1"><li><strong>点对点问题</strong></li><li>接收端接收到的数据太多，无法处理</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212224630161.png" alt="image-20221212224630161" style="zoom:80%;" /></p><p>假定：</p><ol type="1"><li>数据单方向传送，另一个方向只传送确认</li><li>接收方总有足够大的缓存空间，因而发送窗口大小取决于拥塞程度<ol type="1"><li><strong>接收窗口</strong>：<strong>接收方</strong>根据接受缓存设置的值，并告知给发送方，反映<strong>接收方容量</strong></li><li><strong>拥塞窗口</strong>：<strong>发送方</strong>根据自己估算的网络拥塞程度而设置的窗口值，反映<strong>网络当前容量</strong></li></ol></li></ol><h4 id="拥塞控制的四种算法慢开始-拥塞避免-tcp-tahoe">5.3.6.1拥塞控制的四种算法：慢开始 &amp; 拥塞避免 (TCP Tahoe)</h4><ol type="1"><li>一个<strong>传输轮次</strong>：<ol type="1"><li>发送了<strong>一批</strong>报文段，并收到它们的确认时间</li><li>一个往返时延<strong>RTT</strong></li><li>开始发送一批拥塞窗口内的报文段，到开始发送下一批拥塞窗口内的报文段的时间</li></ol></li><li><strong>慢开始</strong>：<ol type="1"><li>每经过一个传输轮次，拥塞窗口翻倍，<strong>指数增长</strong></li><li>翻倍的时间：收到报文段的确认之后立即翻倍</li></ol></li><li><strong>拥塞避免</strong>：<ol type="1"><li>当拥塞窗口的大小达到<strong>ssthresh(拥塞窗口门限值)</strong>时，每经过一个传输轮次，拥塞窗口加1，<strong>加法增长</strong></li></ol></li><li>当出现网络拥塞时<ol type="1"><li>将拥塞窗口设置为1</li><li>修改<strong>ssthresh(拥塞窗口门限值)</strong>，新的<code>ssthresh</code>变为原来的一半</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212230102426.png" alt="image-20221212230102426" style="zoom:80%;" /></p><h4 id="拥塞控制的四种算法快重传-快恢复-tcp-reno">5.3.6.2拥塞控制的四种算法：快重传 &amp; 快恢复 (TCP Reno)</h4><ol type="1"><li><strong>快重传</strong>：<ol type="1"><li>收到同一个报文段的4个ACK报文后，立即重传，不用等待计时器</li></ol></li><li><strong>快恢复</strong>：<ol type="1"><li>快重传后，将拥塞窗口的大小降到新的<strong>ssthresh(拥塞窗口门限值)</strong>即可</li><li>新的<strong>ssthresh(拥塞窗口门限值)</strong>：出现快重传时，将当时的拥塞窗口门限值减半</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221212230427800.png" alt="image-20221212230427800" style="zoom:80%;" /></p><h4 id="tcp-cubic">5.3.6.3 TCP CUBIC</h4><p><img src="/images/AssetMarkdown/image-20221231183050251.png" alt="image-20221231183050251" style="zoom:80%;" /></p><h4 id="bbr">5.3.6.4 BBR</h4><ol type="1"><li>测出整个路径上的瓶颈带宽、往返时延</li><li>窗口大小 = 往返时延 * 瓶颈带宽</li></ol><h1 id="chapter-6应用层">Chapter 6：应用层</h1><h2 id="网络应用模型">6.1 网络应用模型</h2><h3 id="应用层概述">6.1.1 应用层概述</h3><ol type="1"><li>应用层对应用程序的通信提供服务</li><li>应用层协议定义：<ol type="1"><li>应用进程交换的报文类型，请求还是响应?</li><li>各种报文类型的语法，如报文中的各个字段及其详细描述</li><li>字段的语义，即包含在字段中的信息的含义</li><li>进程何时、如何发送报文，以及对报文进行响应的规则</li></ol></li><li>应用层功能：<ol type="1"><li>文件传输、访问、管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ol></li><li>应用层的重要协议<ol type="1"><li>FTP</li><li>SMTP、POP3</li><li>HTTP</li><li>DNS</li></ol></li></ol><h3 id="网络应用模型-1">6.1.2 网络应用模型</h3><ol type="1"><li>客户/服务器模型：Client/Server</li><li>P2P模型：Peer-to-Peer</li></ol><h4 id="客户服务器模型">6.1.2.1 客户/服务器模型</h4><p><img src="/images/AssetMarkdown/image-20221213112452536.png" alt="image-20221213112452536" style="zoom:80%;" /></p><ol type="1"><li>服务器：<strong>提供计算服务</strong>的设备<ol type="1"><li>永久提供服务</li><li>永久性访问地址/域名</li></ol></li><li>客户机：<strong>请求计算服务</strong>的主机<ol type="1"><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可能使用动态IP地址</li><li>不与其它客户机直接通信</li></ol></li><li>应用：Web、FTP、远程登录、电子邮件</li></ol><h4 id="p2p模型">6.1.2.2 P2P模型</h4><p><img src="/images/AssetMarkdown/image-20221213112651763.png" alt="image-20221213112651763" style="zoom:80%;" /></p><ol type="1"><li>不存在永远在线的服务器</li><li>每个主机既可以<strong>提供服务</strong>，也可以<strong>请求服务</strong></li><li>任意端系统/节点之间可以<strong>直接通讯</strong></li><li>节点间歇性接入网络</li><li>节点可能改变IP地址</li><li>可拓展性好：主机多了，提供服务的也多了，不会受到服务器带宽的限制</li><li>网络健壮性强：一台主机坏了，对于其它主机影响不大，而C/S模型中服务器坏了就都无法使用服务了</li></ol><h2 id="dns系统">6.2 DNS系统</h2><p><img src="/images/AssetMarkdown/image-20221213113331407.png" alt="image-20221213113331407" style="zoom:80%;" /></p><h3 id="域名">6.2.1 域名</h3><blockquote><ol type="1"><li>通过<strong>.</strong>区分标号，每个标号不能超过63个字符(通常不超过12个字符)</li><li>每一个标号的字符不区分大小写，只能包括字母、数字、-</li><li>越靠右，级别越高</li></ol></blockquote><p><img src="/images/AssetMarkdown/image-20221213124047973.png" alt="image-20221213124047973"  /></p><ol type="1"><li><strong>根</strong>：在顶级域名之后的一个<strong>.</strong></li><li><strong>顶级域名</strong>：<ol type="1"><li>国家顶级域名：<code>cn</code>，<code>us</code>，<code>uk</code></li><li>通用顶级域名：<code>com</code>(公司/企业)，<code>net</code>(提供信息服务)，<code>org</code>(非盈利性组织)，<code>gov</code>(政府)，<code>int</code>(国际组织)，<code>aero</code>(航空)，<code>museum</code>(博物馆)，<code>travel</code>(旅游业)</li><li>基础结构域名/反向域名：<code>arpa</code>(反向域名解析--IP地址解析为域名)</li></ol></li><li><strong>二级域名</strong>：<ol type="1"><li>类别域名：<code>ac</code>(科研机构)，<code>com</code>(公司/企业)，<code>edu</code>(教育)，<code>gov</code>(政府)，<code>mil</code>(中国国防机构)，<code>net</code>(提供信息服务)，<code>org</code>(非盈利性组织)</li><li>行政区域名：用于我国各省、自治区、直辖市，<code>bj</code>、<code>js</code></li><li>自己注册的域名：<code>cctv</code>、<code>cskaoyan</code></li></ol></li><li><strong>三级域名</strong>：</li><li><strong>四级域名</strong>：</li></ol><p><img src="/images/AssetMarkdown/image-20221213125200402.png" alt="image-20221213125200402" style="zoom:80%;" /></p><h3 id="域名服务器">6.2.2 域名服务器</h3><p><img src="/images/AssetMarkdown/image-20221213185014293.png" alt="image-20221213185014293" style="zoom:80%;" /></p><ol type="1"><li>根域名服务器：知道顶级域名服务器所对应的IP地址<ol type="1"><li>因特网一共有13个根域名服务器域名，分别为<code>a.rootservers.net</code>~<code>m.rootservers.net</code></li></ol></li><li>顶级域名服务器：管理该顶级域名服务器注册的所有二级域名</li><li>权限域名服务器：负责一个<strong>区</strong>的域名服务器<ol type="1"><li>区：一台域名服务器所管辖的实际范围</li><li>图中<code>abc.org</code>和<code>y.abc.org</code>是两个平等的区，由两个权限域名服务器控制</li></ol></li><li>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器</li></ol><h3 id="域名解析过程">6.2.3 域名解析过程</h3><p><img src="/images/AssetMarkdown/image-20221213185458020.png" alt="image-20221213185458020" style="zoom:80%;" /></p><ol type="1"><li>递归查询：<strong>靠别人</strong><ol type="1"><li>查询顺序：主机 =&gt; 本地域名服务器 =&gt; 根域名服务器 =&gt;顶级域名服务器 =&gt; 权限域名服务器</li><li>返回顺序：权限域名服务器 =&gt; 顶级域名服务器 =&gt; 根域名服务器=&gt; 本地域名服务器 =&gt; 主机</li></ol></li><li>迭代查询：<strong>靠自己</strong><ol type="1"><li>查询顺序：主机 =&gt; 本地域名服务器 =&gt; 根域名服务器 =&gt;本地域名服务器 =&gt; 顶级域名服务器 =&gt; 本地域名服务器 =&gt;权限域名服务器</li><li>返回顺序：本地域名服务器 =&gt; 主机</li></ol></li><li><strong>高速缓存</strong>：<ol type="1"><li>本机域名服务器/主机中的高速缓存</li><li>存放最近查询到的域名，以及从何处得到的该域名信息的记录</li><li>会定期更新</li></ol></li></ol><h2 id="文件传输协议ftp">6.3 文件传输协议FTP</h2><ol type="1"><li>文件传输协议FTP：File Transfer Protocol<ol type="1"><li>提供不同种类主机系统之间的文件传输能力</li><li>硬件、软件体系等都可以不同</li><li>是一种拷贝：上传 &amp; 下载</li></ol></li><li>简单文件传输协议TFTP：Trivial File Transfer Protocol</li></ol><h3 id="ftp服务器和用户端">6.3.1 FTP服务器和用户端</h3><ol type="1"><li>FTP是基于客户/服务器(C/S)的协议</li><li>用户通过一个客户机程序连接到在远程计算机上运行的服务器端程序</li><li><strong>FTP服务器</strong>：依照FTP协议提供服务，进行文件传输的计算机</li><li><strong>FTP客户端</strong>：连接FTP服务器，遵循FTP协议与服务器传送文件的电脑</li></ol><h3 id="ftp工作原理">6.3.2 FTP工作原理</h3><ol type="1"><li>登陆：<ol type="1"><li>ftp地址<ol type="1"><li>用户名 &amp; 密码</li><li>匿名登陆<ol type="1"><li>互连网中有很大一部分FTP服务器被称为“匿名” (Anonymous) FTP服务器</li><li>这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权</li><li><code>Anonymous</code>(匿名文件传输)能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户</li><li>用户使用特殊的用户名“<code>anonymous</code>"登陆FTP服务，就可访问远程主机上公开的文件</li></ol></li></ol></li></ol></li><li><strong>FTP</strong>使用<strong>TCP</strong>实现可靠传输</li><li>FTP服务器进程<ol type="1"><li>1个主进程：负责接收新的请求<ol type="1"><li>打开服务器的熟知端口<code>21</code></li><li>等待客户程序进行连接请求</li></ol></li><li>n个从属进程：负责与客户程序进行文件传输</li></ol></li><li>控制进程、数据传送进程 均为 从属进程<ol type="1"><li><strong>控制</strong>连接<strong>始终</strong>保持</li><li><strong>数据</strong>连接只保持一会</li><li>是否使用<code>TCP 20</code>端口建立<strong>数据连接</strong>，与<strong>传输模式</strong>有关<ol type="1"><li><strong>主动</strong>方式，使用<code>TCP 20</code>端口</li><li><strong>被动</strong>方式，由服务器与客户端自行协商决定(端口&gt;1024)</li></ol></li></ol></li><li>FTP传输模式<ol type="1"><li>文本模式：ASCII模式，以文本序列传输数据</li><li>二进制模式：Binary模式，以二进制序列传输数据</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221213210724859.png" alt="image-20221213210724859" style="zoom:80%;" /></p><h2 id="电子邮件">6.4 电子邮件</h2><h3 id="电子邮件的信息格式">6.4.1 电子邮件的信息格式</h3><ol type="1"><li>电子邮件<ol type="1"><li>信封：<ol type="1"><li>收件人的邮箱，如<code>abc@163.com</code></li><li><code>abc</code>是收件人在网易邮箱服务器中注册的用户名</li><li><code>@163.com</code>表示使用的是网易邮箱服务器</li></ol></li><li>内容：<ol type="1"><li>首部：<ol type="1"><li>发送给谁，如<code>To: abc@163.com</code></li><li>邮件的主题，如<code>Subject: Hello!</code></li><li>会自动生成一部分内容</li></ol></li><li>主体</li></ol></li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221213211407410.png" alt="image-20221213211407410" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221231183411062.png" alt="image-20221231183411062" style="zoom:80%;" /></p><h3 id="组成结构">6.4.2 组成结构</h3><ol type="1"><li><strong>用户代理</strong>：电子邮件客户端软件<ol type="1"><li>撰写邮件</li><li>显示邮件</li><li>处理邮件：发送/接收/转发…</li><li>通信：将邮件发送出去</li></ol></li><li><strong>邮件服务器</strong>：<ol type="1"><li>发送&amp;接收邮件</li><li>向发件人报告邮件传送结果</li><li>使用C/S模式，既可以作客户，也可以作服务器</li></ol></li><li><strong>协议</strong>：<ol type="1"><li>SMTP：发送邮件</li><li>POP3、IMAP：接收邮件</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221213211750601.png" alt="image-20221213211750601" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221213212943898.png" alt="image-20221213212943898" style="zoom:80%;" /></p><h3 id="简单邮件传送协议smtp">6.4.3 简单邮件传送协议SMTP</h3><p><strong>TCP连接、端口号25、C/S模式</strong></p><ol type="1"><li>SMTP规定了：在两个相互通信的<strong>SMTP进程</strong>之间应如何交换信息</li><li><strong>SMTP客户</strong>：负责发送邮件的SMTP进程</li><li><strong>SMTP服务器</strong>：负责接收邮件的进程</li><li>SMTP规定了14条命令(几个字母)和21种应答信息(三位数字代码+简单文字说明)</li></ol><p>SMTP通信的三个阶段：</p><ol type="1"><li><p>连接建立</p><p><img src="/images/AssetMarkdown/image-20221213220911757.png" alt="image-20221213220911757" style="zoom:80%;" /></p></li><li><p>邮件传送</p><p><img src="/images/AssetMarkdown/image-20221213221648198.png" alt="image-20221213221648198" style="zoom:80%;" /></p></li><li><p>连接释放</p><p><img src="/images/AssetMarkdown/image-20221213221701568.png" alt="image-20221213221701568" style="zoom:80%;" /></p></li><li><p>SMTP缺点：</p><ol type="1"><li>SMTP不能传送可执行文件或者其他二进制对象</li><li>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字</li><li>SMTP服务器会拒绝超过一定长度的邮件。</li></ol></li></ol><h3 id="通用因特网邮件扩充mime">6.4.4 通用因特网邮件扩充MIME</h3><p><img src="/images/AssetMarkdown/image-20221213221912921.png" alt="image-20221213221912921" style="zoom:80%;" /></p><ol type="1"><li>使电子邮件系统可以支持声音、图像、视频、多种国家语言等等</li><li>使得传输内容丰富多彩</li></ol><h3 id="邮局协议pop3">6.4.5 邮局协议POP3</h3><p><strong>TCP连接、端口号110、C/S模式</strong></p><p>接收端邮件服务器 =&gt; 用户代理</p><p>POP3工作方式：</p><ol type="1"><li>下载并保留(在服务器)</li><li>下载并删除</li></ol><h3 id="网际报文存取协议imap">6.4.6 网际报文存取协议IMAP</h3><p>接收端邮件服务器 =&gt; 用户代理</p><ol type="1"><li>IMAP协议比POP协议复杂</li><li>当用户PC上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上</li><li>IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分(先看正文，有WiFi的时候再下载附件)</li></ol><h3 id="基于万维网的电子邮件">6.4.7 基于万维网的电子邮件</h3><p><img src="/images/AssetMarkdown/image-20221213222250513.png" alt="image-20221213222250513" style="zoom:80%;" /></p><ol type="1"><li>用户代理 =&gt; 邮件服务器：HTTP</li><li>邮件服务器 =&gt; 邮件服务器：SMTP</li><li>邮件服务器 =&gt; 用户代理：HTTP</li></ol><h2 id="万维网-http协议">6.5 万维网 &amp; HTTP协议</h2><h3 id="万维网概述">6.5.1 万维网概述</h3><ol type="1"><li>万维网WWW(World WideWeb)：是一个大规模的、联机式的信息储藏所/<strong>资料空间</strong>，是无数个网络站点和网页的集合</li><li><strong>资源</strong>：文字、音频、视频…</li><li>访问资源的方式：<strong>统一资源定位符URL</strong></li><li>URL的一般形式：<code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code>，URL不区分大小写<ol type="1"><li>协议：http、ftp等</li><li>主机：域名、IP地址</li><li>用户通过点击超链接获取资源，这些资源通过<strong>超文本传输协议HTTP</strong>传送给使用者</li></ol></li><li>万维网以<strong>客户/服务器</strong>方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序</li><li>万维网使用<strong>超文本标记语言HTML</strong>，使得万维网页面设计者可以很方便地从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来</li></ol><h3 id="超文本传输协议http">6.5.2 超文本传输协议HTTP</h3><ol type="1"><li>HTTP协议：定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</li><li>服务器：一个服务器进程监听<code>TCP 80</code>端口</li><li>用户浏览界面的方法：<ol type="1"><li>输入URL</li><li>点击超链接</li></ol></li></ol><h4 id="具体过程">6.5.2.1 具体过程</h4><ol type="1"><li>浏览器分许URL</li><li>浏览器向DNS请求解析IP地址</li><li>DNS解析出IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器响应</li><li>释放TCP连接</li><li>浏览器显示：浏览器可以只下载文本部分，之后再下载音频等内容</li></ol><p><img src="/images/AssetMarkdown/image-20221213223009351.png" alt="image-20221213223009351" style="zoom:80%;" /></p><h4 id="http协议的特点">6.5.2.2 HTTP协议的特点</h4><ol type="1"><li>HTTP协议是<strong>无状态</strong>的，不会记录用户的登录信息</li><li>通过使用<strong>Cookie</strong>记录用户的信息<ol type="1"><li>Cookie是存储在用户主机中的文本文件，记录一段时间内某用户(使用识别码识别，如“123456”)的访问记录</li><li>从而可以提供个性化服务</li></ol></li><li>采用<strong>TCP</strong>作为运输层协议，但<strong>HTTP协议本身是无连接的</strong>，通信双方再交换HTTP报文之前不需要先建立HTTP连接</li></ol><h4 id="http的连接方式">6.5.2.3 HTTP的连接方式</h4><ol type="1"><li>持久连接Keep-alive：<ol type="1"><li>非流水线：收到响应之后，才能发送下一个请求</li><li>流水线：可以连续发送请求，服务器依次返回请求</li></ol></li><li>非持久连接Close：</li></ol><p><img src="/images/AssetMarkdown/image-20221213223706488.png" alt="image-20221213223706488" style="zoom:80%;" /></p><h4 id="http报文结构">6.5.2.4 HTTP报文结构</h4><p>HTTP报文是<strong>面向文本</strong>的，因此在报文中的每一个字段都是一些ASCII码串</p><p>HTTP报文分为：请求报文、响应报文</p><ol type="1"><li>开始行：请求报文对应请求行，响应报文对应状态行<ol type="1"><li>方法：即命令，被请求的对象应执行什么操作</li></ol></li><li>首部行：说明浏览器、服务器、报文主题的一些信息</li><li>状态码：<ol type="1"><li><code>1xx</code>：表示<strong>通知信息</strong>，如请求收到了或正在处理</li><li><code>2xx</code>：表示<strong>成功</strong>，如接受或知道了<ol type="1"><li>如：<code>202 Accepted</code></li></ol></li><li><code>3xx</code>：表示<strong>重定向</strong>，如要完成请求还必须采取进一步的行动<ol type="1"><li>如：<code>301 Move Permanently</code></li></ol></li><li><code>4xx</code>：表示<strong>客户的差错</strong>，如请求中有错误的语法或不能完成<ol type="1"><li>如：<code>404 Not Found</code></li></ol></li><li><code>5xx</code>：表示<strong>服务器的差错</strong>，如服务器失效无法完成请求</li></ol></li></ol><p><img src="/images/AssetMarkdown/image-20221213224022037.png" alt="image-20221213224022037" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221213224256280.png" alt="image-20221213224256280" style="zoom:80%;" /></p><h2 id="流媒体-streaming-audio-and-video">6.6 流媒体 Streaming Audio andVideo</h2><ol type="1"><li>都是压缩的</li><li>都是边收边发</li></ol><h1 id="chapter-7网络安全">Chapter 7：网络安全</h1><h2 id="网络安全的5个方面">7.1 网络安全的5个方面</h2><p>传统密码学：机密性问题、不可否认性问题、完整性问题、认证问题</p><ol type="1"><li><p>机密性问题：Confidentiality</p><ol type="1"><li>保证发送的数据让非特权用户无法理解</li><li>默认：发送的数据所有人都可以收到</li></ol></li><li><p>不可否认性问题：Nonrepudiation</p><ol type="1"><li>数字签名</li></ol></li><li><p>完整性问题：Integrity</p><ol type="1"><li>保证接收到的数据，与发送的数据相同</li><li>消息摘要</li></ol></li><li><p>认证问题：Authentication</p><ol type="1"><li>证书</li></ol></li><li><p>可用性问题：Availability</p><ol type="1"><li>保证系统可以使用</li></ol></li></ol><h2 id="网络攻击的方式">7.2 网络攻击的方式</h2><h3 id="四个步骤">7.2.1 四个步骤</h3><ol type="1"><li>侦察 Reconnaissance：<ol type="1"><li>传统为扫描，找到攻击的目标</li></ol></li><li>嗅探和窥探 Sniffing and snooping：<ol type="1"><li>嗅探：将网络上的包保存下来</li><li>窥探：冲到系统里面，把里面的数据保存下来</li></ol></li><li>欺骗 Spoofing：<ol type="1"><li>让不应该发到我这里的包，发送到我这里</li><li>修改DNS</li><li>让交换机的转发表溢出，从而让交换机不得不广播数据</li></ol></li><li>破坏 Disruption</li></ol><h3 id="分布式拒绝服务攻击-ddos">7.2.2 分布式拒绝服务攻击 DDoS</h3><ol type="1"><li>TCP的三次握手，会占用服务器较多的资源</li><li>网络攻击的手段：控制多个僵尸网络，同时向服务器发送TCP连接建立请求，然后僵尸网络不回复，通常TCP连接建立的超时时间有2分钟，在这段时间内，服务器会进行等待</li><li>对应手段：SCTP协议<ol type="1"><li>连接建立时，服务器进行数据的加密，做成cookie，放到连接建立请求的确认包中，返回给发送方</li><li>客户端进行二次确认时，要把cookie再送回来</li><li>服务区把送回的数据解密，然后对对应的客户建立服务</li><li>相当于服务器没有维持状态，而是将状态放到包中</li></ol></li></ol><h2 id="防火墙">7.3 防火墙</h2><p><img src="/images/AssetMarkdown/image-20221231185157942.png" alt="image-20221231185157942" style="zoom:80%;" /></p><ol type="1"><li>目的：避免公网上的火烧到内网</li><li>方式：<ol type="1"><li>对进出的包进行过滤</li><li>对网络通信的行为进行分析，判断连接让进还是不让进</li></ol></li><li>DeMilitarizedzone：非军事区，将内网的一部分内容放在防火墙外面，让公网的人能够访问</li></ol><h2 id="密码学-cryptography">7.4 密码学 Cryptography</h2><h3 id="密码学加密模型">7.4.1 密码学加密模型</h3><p><img src="/images/AssetMarkdown/image-20221231192141222.png" alt="image-20221231192141222" style="zoom:80%;" /></p><ol type="1"><li>通信双方：Alice、Bob</li><li>概念<ol type="1"><li>明文 Plaintext：想要发送的原始数据，是保密的</li><li>密文 Ciphertext：加密后的数据，是公开的</li><li>加密函数 Encryption method</li><li>解密函数 Decryption method：两个函数是逆运算</li><li>加密密钥 Encryption key</li><li>解密密钥 Decryption key</li></ol></li><li>Alice会将明文发送给加密函数，进行加密，获得密文</li><li>Bob收到密文后，会将其发送给解密函数，进行解密，获取明文</li><li>加密的目标：敌人得到密文后，得不到对应的明文<ol type="1"><li>两种敌人：<ol type="1"><li>将密文偷偷截取下来</li><li>将密文截取下来后，发送另一个密文</li></ol></li><li>通常，加密和解密的函数都是公开的，甚至是标准化的</li><li>密钥是保密的</li><li>通常，加密密钥和解密密钥是同一个，或者很容易转换</li></ol></li><li>加密系统的强度<ol type="1"><li>加密/解密函数的强度</li><li>密钥不能重复使用，不能容易猜出</li></ol></li></ol><h3 id="加密解密函数">7.4.2 加密/解密函数</h3><ol type="1"><li><p>任何加密/解密函数，都是基于两个操作的迭代</p><ol type="1"><li><p>替换：将一个字母用另一个字母替换</p><ol type="1"><li>单替换可以通过词频统计来破译</li></ol></li><li><p>转置：将明文按照n个一组写成一行一行的，然后交换某些列，得到密文</p><ol type="1"><li>可以通过计算机枚举，获得明文</li></ol><p><img src="/images/AssetMarkdown/image-20221231194615466.png" alt="image-20221231194615466" style="zoom:80%;" /></p></li></ol></li></ol><h4 id="des标准the-data-encryption-standard">7.4.2.1 DES标准：The DataEncryption Standard</h4><ol type="1"><li><p>将明文切块，分别进行加密</p><ol type="1"><li>DES的块的大小为8字节</li></ol></li><li><p>IBM的原始设计：每次加密做了16次迭代，128 bit的密钥</p></li><li><p>经过NSA的修正：每次加密做了16次迭代，64bit的密钥，并且不能公开函数的设计的思路</p></li><li><p>Triple DES：将DES做三次，但只有两个密钥</p><p><img src="/images/AssetMarkdown/image-20221231195717835.png" alt="image-20221231195717835" style="zoom:80%;" /></p></li></ol><h4 id="aes标准the-advanced-encryption-standard">7.4.2.2 AES标准：TheAdvanced Encryption Standard</h4><ol type="1"><li>密钥长度：128，192，256 bits</li><li>也是分块加密</li></ol><h3 id="密钥不能被猜出来">7.4.3 密钥不能被猜出来</h3><ol type="1"><li>要尽可能随机<ol type="1"><li>伪随机数：通过函数计算出来，在一定时间后一定会发生重复</li><li>发生重复越晚，随机数生成算法更好</li></ol></li><li>不能重复使用</li></ol><h4 id="cipher-mode">7.4.3.1 Cipher Mode</h4><blockquote><p>将P<sub>i</sub>计算出的密文，与P<sub>i+1</sub>异或</p></blockquote><p><img src="/images/AssetMarkdown/image-20221231200230170.png" alt="image-20221231200230170" style="zoom:80%;" /></p><blockquote><p>将刚刚计算出的6个字节的密文再次加密，获得最左边的字节，然后与P<sub>10</sub>进行异或，得到C<sub>10</sub></p></blockquote><p><img src="/images/AssetMarkdown/image-20221231200355111.png" alt="image-20221231200355111" style="zoom:80%;" /></p><blockquote><p>给定初始值和密钥，生成密文，生成的密文会参与下一次的加密计算</p></blockquote><p><img src="/images/AssetMarkdown/image-20221231200527884.png" alt="image-20221231200527884" style="zoom:80%;" /></p><h3 id="传统密码体制-对称密码体制">7.4.4 传统密码体制 /对称密码体制</h3><ol type="1"><li>密钥是对称的、函数也是对称的</li><li>缺点：密钥的分发存在困难</li></ol><h3 id="现代密码体制-公钥体制">7.4.5 现代密码体制 / 公钥体制</h3><p>相同点：</p><ol type="1"><li>加密函数、解密函数仍然是逆运算，也是公开的</li></ol><p>不同点：</p><ol type="1"><li>加密密钥、解密密钥是不同的</li><li>加密密钥：公开的，也叫公钥</li><li>解密密钥：私有的，也叫私钥</li><li>算法上保证公钥推出私钥的难度很大</li><li>公钥体制的计算量很大，一般用于要加密的内容较少的地方/特殊用途</li></ol><h4 id="rsa算法">7.4.5.1 RSA算法</h4><p>算法详情：</p><ol type="1"><li>选择两个质数<span class="math inline">\(p\)</span>和<spanclass="math inline">\(q\)</span></li><li>计算<span class="math inline">\(n=p*q\)</span>，<spanclass="math inline">\(z=(p-1)*(q-1)\)</span></li><li>选择一个与<spanclass="math inline">\(z\)</span>接近的素数，称为<spanclass="math inline">\(d\)</span></li><li>找到满足<span class="math inline">\(e*d=1\ (mod\ z)\)</span>的<spanclass="math inline">\(e\)</span></li></ol><h2 id="反拒认数字签名">7.5 反拒认：数字签名</h2><h3 id="big-brother">7.5.1 Big Brother</h3><p><img src="/images/AssetMarkdown/image-20221231202218898.png" alt="image-20221231202218898" style="zoom:80%;" /></p><ol type="1"><li>Alice将借条给Big Brother</li><li>Big Brother将借条给Bob</li><li>Bob要债时，Big Brother作为公证人，证明借条的有效性</li></ol><h3 id="公钥数字签名">7.5.2 公钥数字签名</h3><p><img src="/images/AssetMarkdown/image-20221231202412942.png" alt="image-20221231202412942" style="zoom:80%;" /></p><ol type="1"><li>Alice将借条的明文P，通过Alice的解密函数和私钥进行加密，得到密文D<sub>A</sub>(P)<ol type="1"><li>D<sub>A</sub>(P)即为经过数字签名的借条</li></ol></li><li>Alice还会将D<sub>A</sub>(P)，通过Bob的加密函数和公钥进行加密，得到密文E<sub>B</sub>(D<sub>A</sub>(P))</li><li>E<sub>B</sub>(D<sub>A</sub>(P))在公网上进行传输，发送给Bob</li><li>E<sub>B</sub>(D<sub>A</sub>(P))发送给Bob后，Bob用过Bob的的解密函数和私钥进行解密，得到密文D<sub>A</sub>(P)</li><li>Bob然后通过Alice的加密函数和公钥进行解密，得到借条的明文P</li><li>反拒认：Bob将D<sub>A</sub>(P)给到法官，法官通过Alice的加密函数和公钥进行解密，得到借条的明文<ol type="1"><li>由于Alice的公钥和私钥唯一，且私钥不可知，因此该借条不可能被伪造</li></ol></li></ol><h2 id="数据的完整性防篡改消息摘要">7.6数据的完整性(防篡改)：消息摘要</h2><h3 id="消息摘要">7.6.1 消息摘要</h3><ol type="1"><li>给定P，计算MD(P)</li><li>MD(P)，很难计算P</li><li>如果P有轻微变化，MD(P)会变化非常大</li><li>为了防止摘要被篡改，所有摘要都是有数字签名的</li></ol><p><img src="/images/AssetMarkdown/image-20221231213122180.png" alt="image-20221231213122180" style="zoom:80%;" /></p><h2 id="认证问题证书">7.7 认证问题：证书</h2><p><img src="/images/AssetMarkdown/image-20221231213604914.png" alt="image-20221231213604914" style="zoom:80%;" /></p><ol type="1"><li>保证证书的真实性：找发证书的机构，对证书进行一次摘要，然后附加到证书上</li><li>证书中，除了有该节点的信息，还会该节点的公钥</li></ol><h3 id="x.509">7.7.1 X.509</h3><p><img src="/images/AssetMarkdown/image-20221231213821030.png" alt="image-20221231213821030" style="zoom:80%;" /></p><ol type="1"><li>发证书的实际机构是：CA</li><li>CA的证书由RA颁发，RA的证书由Root颁发</li><li>一般浏览器会预置一部分根证书，根证书也可以通过自己添加</li></ol><h2 id="基本应用">7.8 基本应用</h2><h3 id="通信安全">7.8.1 通信安全</h3><ol type="1"><li><p>IPsec：将认证信息，添加到IP数据报中</p><p><img src="/images/AssetMarkdown/image-20221231214424189.png" alt="image-20221231214424189" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221231214403935.png" alt="image-20221231214403935" style="zoom:80%;" /></p></li><li><p>Virtual Private Network：VPN，虚拟私有网</p><ol type="1"><li>是一个叠加网，在公网上建立一个叠加网，添加一些认证方式</li></ol><p><img src="/images/AssetMarkdown/image-20221231214510234.png" alt="image-20221231214510234" style="zoom:80%;" /></p></li><li><p>Wireless Security：无线安全</p></li></ol><h3 id="邮件安全">7.8.2 邮件安全</h3><p>PGP：Pretty Good Privacy</p><ol type="1"><li>明文P计算摘要，然后使用Alice的私钥进行签名，计算结果与P结合，形成P1</li><li>将P1压缩，形成P1.Z</li><li>Alice选择一个随机数K<sub>M</sub>，对P1.Z使用AES进行加密</li><li>同时，使用Bob的公钥，对K<sub>M</sub>进行加密，与加密后的P1.Z一起发送给Bob</li><li>最后使用Base64，将内容发送</li></ol><p><img src="/images/AssetMarkdown/image-20221231214636769.png" alt="image-20221231214636769" style="zoom:80%;" /></p><h3 id="web安全">7.8.3 WEB安全</h3><ol type="1"><li><p>DNS的安全问题：</p><ol type="1"><li>内容不能被造假</li><li>访问数据属于隐私问题</li></ol></li><li><p>WEB安全</p><ol type="1"><li>HTTP协议没有安全保证</li><li>HTTPS：Secure HTTP</li><li>Security(SSL)：安全套接子层</li><li>TLS：Transport Layer Security</li></ol><p><img src="/images/AssetMarkdown/image-20221231215524381.png" alt="image-20221231215524381" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221231215605132.png" alt="image-20221231215605132" style="zoom:80%;" /></p><p><img src="/images/AssetMarkdown/image-20221231215619602.png" alt="image-20221231215619602" style="zoom:80%;" /></p></li><li><p>运行代码安全</p><ol type="1"><li>WEB的代码是在客户端本地运行的，可能对客户端产生安全威胁</li><li>使用虚拟机</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
