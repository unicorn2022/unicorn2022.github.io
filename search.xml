<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>佳昕大定理（doge）</title>
      <link href="/2024/07/01/%E4%BD%B3%E6%98%95%E5%A4%A7%E5%AE%9A%E7%90%86%EF%BC%88doge%EF%BC%89/"/>
      <url>/2024/07/01/%E4%BD%B3%E6%98%95%E5%A4%A7%E5%AE%9A%E7%90%86%EF%BC%88doge%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一朋友的阶段理论">一、朋友的阶段理论</h1><blockquote><p>叠甲：本理论仅仅是我根据自己的感受，总结的经验。如有雷同，纯属巧合。杠就是你对</p></blockquote><table><colgroup><col style="width: 14%" /><col style="width: 14%" /><col style="width: 35%" /><col style="width: 16%" /><col style="width: 17%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">描述</th><th style="text-align: center;">相处心态</th><th style="text-align: center;">组局</th><th style="text-align: center;">性格&amp;三观</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>第-阶段</strong></td><td style="text-align: center;">感觉不如不认识</td><td style="text-align: center;">能不见就不见</td><td style="text-align: center;">局里有这些人基本上就不想去了</td><td style="text-align: center;">性格相冲，三观相悖</td></tr><tr><td style="text-align: center;"><strong>第0阶段</strong></td><td style="text-align: center;">陌生人</td><td style="text-align: center;">不认识，爱咋咋地</td><td style="text-align: center;">不认识，爱咋咋地</td><td style="text-align: center;">？？？</td></tr><tr><td style="text-align: center;"><strong>第1阶段</strong></td><td style="text-align: center;">点头之交</td><tdstyle="text-align: center;">伪装好自己，他们看到的只是自己想要让他们看到的一面</td><td style="text-align: center;">不主动，但也不抗拒</td><td style="text-align: center;">没有严重的冲突，但也不一定契合</td></tr><tr><td style="text-align: center;"><strong>第2阶段</strong></td><td style="text-align: center;">熟人</td><td style="text-align: center;">部分伪装</td><td style="text-align: center;">会主动叫</td><td style="text-align: center;">有一定的契合</td></tr><tr><td style="text-align: center;"><strong>第3阶段</strong></td><td style="text-align: center;">朋友</td><td style="text-align: center;">开始逐步展露一点自己的真实想法</td><td style="text-align: center;">会主动叫</td><td style="text-align: center;">有一定的契合</td></tr><tr><td style="text-align: center;"><strong>第4阶段</strong></td><td style="text-align: center;">好朋友</td><tdstyle="text-align: center;">展露真实的自己，但可能会选择性隐瞒部分事情</td><td style="text-align: center;">优先叫</td><td style="text-align: center;">基本契合</td></tr><tr><td style="text-align: center;"><strong>第5阶段</strong></td><td style="text-align: center;">至交</td><tdstyle="text-align: center;">完全放弃伪装，展示最真实的自己，相处十分融洽，基本上无话不谈</td><td style="text-align: center;">来不了会伤心的</td><td style="text-align: center;">完全契合</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><ul><li>随着接触时间的变长，朋友的关系总会一点一点的进入下一阶段<ul><li>接触的时间不够，很难了解这个朋友</li><li>在不了解的情况下，总会保守一点</li></ul></li><li>交朋友，实际上是在匹配双方的性格和三观<ul><li>如果三观不和，会主动避免与之接触，接触时间很难变长</li></ul></li><li>舍友关系类似放大镜<ul><li>如果没有严重的冲突，很容易将关系推进至2~3阶段，甚至第4第5阶段</li><li>一旦有了冲突，关系很容易就跌落到-阶段</li><li>毕竟舍友是相对来说接触时间最长的朋友，随着时间的积累，好和不好都会被放大</li></ul></li><li>绝大部分的人都会停留在第1~2阶段，只有第3阶段以后的人，才能真的称得上是朋友<ul><li>随着时间的推移，第1~2阶段的熟人会逐渐失去联系</li><li>没有联系的朋友，可能只是熟人，并非朋友</li></ul></li><li>真正的朋友是不会随着时间的推移而走散的<ul><li>虽然大家都会有各自的事情，导致联系逐渐变少，但是真正的朋友，依旧会在遇到相关的事情时，想到彼此的</li></ul></li></ul><h1 id="二一个游戏">二、一个游戏</h1><blockquote><p>本游戏是初中时和同学一起创造出来的，但当时仅仅是口口相传，现在记录下来，作为回忆</p></blockquote><h2 id="基本概念">2.1 基本概念</h2><ul><li><strong>地图设定</strong>：<ul><li><strong>地图分层</strong>：<ul><li>地图共分为4层</li><li>每个玩家在某一时刻仅可能位于唯一一层</li><li>初始时，每位玩家均处在第1层</li><li>玩家所在层数会影响玩家的行为</li></ul></li><li><strong>环境buff</strong>：<ul><li>每一层会有自己的环境buff，不同层之间的环境buff可能相同，初始时没有buff</li><li>buff会在每一回合所有玩家行动后进行计算</li><li>部分角色的技能能够更改环境buff</li></ul></li></ul></li><li><strong>玩家设定</strong>：<ul><li><strong>血量</strong>：每位玩家初始拥有10点血量，血量归零视为淘汰</li><li><strong>技能点</strong>：每位玩家初始拥有0个技能点，最多拥有3个技能点</li><li>每位玩家最多拥有4个技能：被动技能、1技能点技能、2技能点技能、3技能点技能</li></ul></li><li><strong>游戏胜利判定</strong>：<ul><li><strong>单人赛</strong>：其他玩家血量归零，则自己获胜</li><li><strong>组队赛</strong>：其他队伍玩家血量归零，则本组获胜</li><li><strong>BOSS战</strong>：BOSS血量归零，则挑战者获胜</li></ul></li><li><strong>行动判定</strong>：<ul><li>每一回合，每位玩家均会通过某种方式，判定自己是否能够进行一次行动</li><li>如：石头剪刀布</li></ul></li><li><strong>单次行动</strong>：分为以下几种<ul><li><strong>普攻</strong>：对单一目标造成<code>2</code>点伤害，并使其降低一层。攻击范围：层数差<code>0~1</code></li><li><strong>跳跃</strong>：玩家所在层数<code>+1</code>，通过此方法最多移动至第<code>3</code>层</li><li><strong>攒气</strong>：技能点<code>+1</code>，每位玩家最多拥有<code>3</code>个技能点</li><li><strong>释放技能</strong>：释放所选角色的某一个技能，消耗对应的技能点数，造成对应的效果</li><li><strong>下坠</strong>：对单一目标造成<code>己方层数-目标层数+1</code>的伤害，并移动至目标所在层</li><li><strong>破</strong>：解除受到的某一控制技能</li><li><strong>等</strong>：跳过这次行动</li></ul></li><li><strong>状态设定</strong>：<ul><li><strong>强控</strong>：下次行动只能进行<strong>破</strong>或<strong>等</strong></li><li><strong>昏迷</strong>：在指定回合内，下次行动只能进行<strong>破</strong>或<strong>等</strong></li><li><strong>屏障</strong>：每层屏障等效为1滴血量，但会吸收额外伤害，即单次攻击最多使屏障破碎，不能对玩家造成额外伤害<ul><li>屏障外的玩家攻击屏障内的玩家，必须优先击破屏障，2&amp;3技能点的技能不受影响</li><li>屏障内的玩家攻击屏障外的玩家，必须优先击破屏障，2&amp;3技能点的技能不受影响</li></ul></li><li><strong>隐身</strong>：<ul><li>所有玩家的攻击无法伤害到自己，自己的攻击也无法伤害到其他人</li><li>隐身状态可以主动退出，也可以被其他玩家消耗一次行动值</li><li>隐身状态下受到伤害，自动退出隐身状态</li></ul></li></ul></li></ul><h2 id="角色技能">2.2 角色技能</h2><h3 id="龙族角色">2.2.1 《龙族》角色</h3><blockquote><p>卡塞尔学院</p></blockquote><table><colgroup><col style="width: 9%" /><col style="width: 22%" /><col style="width: 22%" /><col style="width: 22%" /><col style="width: 22%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">被动技能</th><th style="text-align: center;">1技能点</th><th style="text-align: center;">2技能点</th><th style="text-align: center;">3技能点</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>路明非</strong></td><tdstyle="text-align: center;"><font color="blue"><strong>龙化</strong></font><br>消耗3技能点进入<strong>龙化</strong>状态：所有受到的伤害降低1点，普通攻击造成的伤害增加1点</td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>龙化</strong></font><br/>进入<strong>龙化</strong>状态</td><td style="text-align: center;">无</td></tr><tr><td style="text-align: center;"><strong>楚子航</strong></td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>默认技能</strong></font><br>指定敌方单体受到3点伤害</td><tdstyle="text-align: center;"><font color="blue"><strong>小君焰</strong></font><br>指定某一层，使其中的所有敌方受到4点伤害</td><tdstyle="text-align: center;"><font color="blue"><strong>大君焰</strong></font><br>指定某一层，使其中的所有敌方受到6点伤害</td></tr><tr><td style="text-align: center;"><strong>凯撒</strong></td><tdstyle="text-align: center;"><font color="blue"><strong>镰鼬</strong></font><br/>消耗2技能点进入<strong>镰鼬</strong>状态：所有攻击无视距离</td><tdstyle="text-align: center;"><font color="blue"><strong>默认技能</strong></font><br>指定敌方单体受到3点伤害</td><tdstyle="text-align: center;"><font color="blue"><strong>隐身</strong></font><br/>进入<strong>镰鼬</strong>状态<br/></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><strong>诺诺</strong></td><tdstyle="text-align: center;"><font color="blue"><strong>弗利加子弹</strong></font><br>普通攻击更改为弗利加子弹：<br>对指定敌方单体造成1点伤害，并使其陷入<strong>昏迷</strong>状态，持续2回合</td><tdstyle="text-align: center;"><font color="blue"><strong>默认技能</strong></font><br>指定敌方单体受到3点伤害</td><tdstyle="text-align: center;"><font color="blue"><strong>侧写</strong></font><br>？？？</td><td style="text-align: center;">无</td></tr><tr><td style="text-align: center;"><strong>昂热</strong></td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>折刀</strong></font><br>指定敌方单体受到3点伤害</td><tdstyle="text-align: center;"><font color="blue"><strong>时零</strong></font><br>再进行一个回合的判定，同时可以指定这两个回合判定的生效顺序</td><td style="text-align: center;">无</td></tr><tr><td style="text-align: center;"><strong>帕西</strong></td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>贤者之石</strong></font><br/>指定敌方单体受到2点伤害，并陷入<strong>强控</strong>状态</td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>无尘之地</strong></font><br/>使敌方全体陷入<strong>特殊控制</strong>状态：每回合损失1点血量，直到破除控制</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p>路明泽势力</p></blockquote><table><colgroup><col style="width: 10%" /><col style="width: 25%" /><col style="width: 26%" /><col style="width: 26%" /><col style="width: 10%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">被动技能</th><th style="text-align: center;">1技能点</th><th style="text-align: center;">2技能点</th><th style="text-align: center;">3技能点</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>零</strong></td><td style="text-align: center;">无</td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>复刻</strong></font><br>选择任意一个已经被使用过的技能，复刻其效果</td><td style="text-align: center;">无</td></tr><tr><td style="text-align: center;"><strong>酒德麻衣</strong></td><tdstyle="text-align: center;">处在<strong>隐身</strong>状态时，可以攻击同时处在<strong>隐身</strong>状态的其他玩家</td><tdstyle="text-align: center;"><font color="blue"><strong>狙击</strong></font><br>指定敌方单体受到3点伤害，可以在隐身状态下对未隐身的玩家使用</td><tdstyle="text-align: center;"><font color="blue"><strong>隐身</strong></font><br>进入<strong>隐身</strong>状态<br>若已处在<strong>隐身</strong>状态，则可以指定某一目标一同进入<strong>隐身</strong>状态</td><td style="text-align: center;">无</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p>龙王</p></blockquote><table><colgroup><col style="width: 9%" /><col style="width: 22%" /><col style="width: 22%" /><col style="width: 22%" /><col style="width: 22%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">被动技能</th><th style="text-align: center;">1技能点</th><th style="text-align: center;">2技能点</th><th style="text-align: center;">3技能点</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>康斯坦丁</strong></td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>火焰屏障</strong></font><br>指定一个目标，生成2层屏障</td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>冰封国度</strong></font><br/>指定一个目标，生成10层特殊屏障<br/>特殊屏障内的玩家如果没有破除屏障，则每回合损失1点生命值</td></tr><tr><td style="text-align: center;"><strong>夏弥</strong></td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>飞</strong></font><br>移动至第4层</td><tdstyle="text-align: center;"><font color="blue"><strong>风王之瞳</strong></font><br>指定敌方单体受到4点伤害，并陷入<strong>强控</strong>状态</td><td style="text-align: center;">无</td></tr><tr><td style="text-align: center;"><strong>奥丁</strong></td><tdstyle="text-align: center;"><font color="blue"><strong>镜中世界</strong></font><br>奥丁默认处于镜中世界，仅可通过<strong>镜子</strong>与该层的其他玩家进行交互</td><tdstyle="text-align: center;"><font color="blue"><strong>镜子</strong></font><br>在某一层放置一面镜子，镜子可被打碎</td><tdstyle="text-align: center;"><font color="blue"><strong>昆古尼尔</strong></font><br>指定敌方单体受到4点伤害</td><td style="text-align: center;">无</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p>日本分部</p></blockquote><table><colgroup><col style="width: 12%" /><col style="width: 12%" /><col style="width: 30%" /><col style="width: 12%" /><col style="width: 30%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">被动技能</th><th style="text-align: center;">1技能点</th><th style="text-align: center;">2技能点</th><th style="text-align: center;">3技能点</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>上杉绘梨衣</strong></td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>默认技能</strong></font><br>指定敌方单体受到3点伤害</td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>审判</strong></font><br>指定一个目标，进行10次判定<br>每次判定成功，使其损失1点生命值</td></tr><tr><td style="text-align: center;"><strong>上杉越</strong></td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>默认技能</strong></font><br>指定敌方单体受到3点伤害</td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>黑日</strong></font><br>指定一个某一层，施加环境buff：处于该层的敌方玩家每回合损失1点血量，buff可叠加</td></tr><tr><td style="text-align: center;"><strong>源稚生</strong></td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>童子切</strong></font><br>指定敌方单体受到3点伤害</td><td style="text-align: center;">无</td><tdstyle="text-align: center;"><font color="blue"><strong>王权</strong></font><br>所有敌方目标掉落至第1层，并受到<code>层数差+1</code>的伤害，并陷入<strong>强控</strong>状态</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><h3 id="龙族boss战">2.2.2 《龙族》BOSS战</h3><p><strong>黑王</strong></p><ul><li>黑王初始拥有30点血量，并且每一回合可以进行<code>玩家人数/2</code>次判定</li><li>黑王永久处于<strong>龙化</strong>状态：所有受到的伤害降低1点，普通攻击造成的伤害增加1点</li><li>黑王视为拥有所有角色的技能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 佳昕大定理（doge） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 佳昕大定理（doge） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS15：外排</title>
      <link href="/2024/06/18/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/15.%E5%A4%96%E6%8E%92/"/>
      <url>/2024/06/18/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/15.%E5%A4%96%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="externalsorting-外排">ExternalSorting 外排</h1><h2 id="一总体思想">一、总体思想</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153348320.png" alt="image-20240611153348320" style="zoom:80%;" /></p><p><strong>Run</strong>：将内存中的数据排序</p><p><strong>Pass</strong>：将内存中的数据导入硬盘 /从硬盘中读入数据到内存</p><ol type="1"><li>将硬盘中的数据依次读入内存，然后进行排序，写入到<strong>2</strong>个不同的磁带中</li><li>将<strong>2</strong>个磁带的内容进行合并，写入到另外<strong>2</strong>个不同的磁带中</li><li>重复2，直到排序完成</li><li>一共需要至少<strong>4</strong>个磁带，<strong>Pass</strong>的次数：<spanclass="math inline">\(1+\lceil \log_2(\frac{N}{M})\rceil\)</span></li></ol><p>优化目标</p><ol type="1"><li>减少<strong>Pass</strong>的次数</li></ol><h2 id="二k-way合并">二、k-way合并</h2><ol type="1"><li>将硬盘中的数据依次读入内存，然后进行排序，写入到<strong>k</strong>个不同的磁带中</li><li>将<strong>k</strong>个磁带的内容进行合并，写入到另外<strong>k</strong>个不同的磁带中</li><li>重复2，直到排序完成</li><li>一共需要至少<strong>2k</strong>个磁带，<strong>Pass</strong>的次数：<spanclass="math inline">\(1+\lceil \log_k(\frac{N}{M})\rceil\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153358722.png" alt="image-20240611153358722" style="zoom:80%;" /></p><h2 id="三使用3个tape实现2-way合并">三、使用3个tape实现2-way合并</h2><ol type="1"><li>按照<strong>斐波那契数列</strong>，将排序后的数据不平均的分给其余<strong>2</strong>个磁带<spanclass="math inline">\(F_n=F_{n-1}+F_{n-2}\)</span></li><li><strong>2</strong>个磁带合并时，将前<spanclass="math inline">\(F_{n-2}\)</span>个数合并，放到空余的<strong>1</strong>个磁带，此时变成了<spanclass="math inline">\(F_{n-1}\)</span>与<spanclass="math inline">\(F_{n-2}\)</span></li><li>重复第<strong>2</strong>步</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153405445.png" alt="image-20240611153405445" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153409384.png" alt="image-20240611153409384" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153413772.png" alt="image-20240611153413772" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153417551.png" alt="image-20240611153417551" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153422030.png" alt="image-20240611153422030" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153426295.png" alt="image-20240611153426295" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153429704.png" alt="image-20240611153429704" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153432749.png" alt="image-20240611153432749" style="zoom:80%;" /></p><h2 id="四使用k1个tape实现k-way合并">四、使用k+1个tape实现k-way合并</h2><p>以<strong>3-way</strong>合并为例</p><ol type="1"><li>按照斐波那契数列，将排序后的数据不平均的分给其余3个磁带，此时3个磁带分别为<ol type="1"><li><span class="math inline">\(F_{n-1}+F_{n-2}+F_{n-3}\)</span></li><li><span class="math inline">\(F_{n-1}+F_{n-2}\)</span></li><li><span class="math inline">\(F_{n-1}\)</span></li><li>原有的数据个数为：<spanclass="math inline">\(t_n=3F_{n-1}+2F_{n-2}+F_{n-3}\)</span></li></ol></li><li>3个磁带合并时，将前<spanclass="math inline">\(F_{n-1}\)</span>个数合并，放到空余的1个磁带，此时3个磁带分别为<ol type="1"><li><spanclass="math inline">\(F_{n-2}+F_{n-3}+F_{n-4}\)</span>（上一步产生的<spanclass="math inline">\(F_{n-1}\)</span>分解为三项：<spanclass="math inline">\(F_{n-2}+F_{n-3}+F_{n-4}\)</span>）</li><li><span class="math inline">\(F_{n-2}+F_{n-3}\)</span></li><li><span class="math inline">\(F_{n-2}\)</span></li></ol></li><li>重复第2步</li></ol><h2id="五处理run时长度超过内存的大小">五、处理Run时长度超过内存的大小</h2><h3 id="input-buffer和output-buffer">5.1 input buffer和outputbuffer</h3><ol type="1"><li>将内存分为<strong>input buffer</strong>和<strong>outputbuffer</strong></li><li>每一次比较，将结果放入<strong>output buffer</strong></li><li>当<strong>output bufer</strong>满时，将其输出到内存</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153439195.png" alt="image-20240611153439195" style="zoom:80%;" /></p><h3 id="对于k-way的合并">5.2 对于k-way的合并</h3><ol type="1"><li>通常情况下，执行<strong>k-way</strong>合并需要<strong>2k</strong>个<strong>inputbuffer</strong>和<strong>2</strong>个<strong>output buffer</strong></li><li>当<strong>k</strong>变大但内存不变时，需要的<strong>inputbuffer</strong>数目上升，因此每个<strong>buffer</strong>的大小降低，从而导致硬盘中每个<strong>block</strong>的大小降低，从而导致<strong>seek</strong>的时间增加</li><li>当超过某个<strong>k</strong>值后，尽管传递次数减少，但<strong>IO</strong>时间实际上会增加</li><li><strong>k</strong>的最佳值显然取决于磁盘参数和缓冲区可用的内部内存量。</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153444097.png" alt="image-20240611153444097" style="zoom:80%;" /></p><h3 id="产生一个长的run">5.3 产生一个长的Run</h3><ol type="1"><li>假设内存中只能存放<strong>3</strong>个数据</li><li>将<strong>inputtape</strong>中前<strong>3</strong>个数据输入内存中</li><li>将内存中的最小数据输出到一条新的<strong>outputtape</strong>中，并且从<strong>inputtape</strong>中输入<strong>1</strong>个数据到内存中</li><li>将内存中<span class="math inline">\(\ge\)</span>上一个输出的数据 的最小数据，输出到上一次的<strong>outputtape</strong>中，并且从<strong>inputtape</strong>中输入<strong>1</strong>个数据到内存中</li><li>如果内存中的所有数据均比上一次输出的数小，则换一条新的<strong>outputtape</strong>进行输出</li></ol><p>在这种替换策略下，每一个<strong>run</strong>的平均长度为：<strong>L=2M</strong></p><ol type="1"><li>其中<strong>M</strong>为内存能够容纳的数据的个数</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153449886.png" alt="image-20240611153449886" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153454072.png" alt="image-20240611153454072" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153458299.png" alt="image-20240611153458299" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153503582.png" alt="image-20240611153503582" style="zoom:80%;" /></p><h3 id="使用huffman-tree减少merge的时间">5.4 使用HuffmanTree减少Merge的时间</h3><p>如果<strong>run</strong>的长度不一样，怎样减小<strong>merge</strong>的时间：使用<strong>HuffmanTree</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153508674.png" alt="image-20240611153508674" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS14：并行算法</title>
      <link href="/2024/06/17/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/14.%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/17/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/14.%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="parallel-algorithms">Parallel Algorithms</h1><h2 id="一并行算法的描述">一、并行算法的描述</h2><h3 id="pramparallel-random-access-machine">1.1 PRAM：Parallel RandomAccess Machine</h3><p>机器资源有多少，就算多少</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153210967.png" alt="image-20240611153210967" style="zoom:80%;" /></p><p>解决访问冲突：</p><ol type="1"><li><strong>EREW</strong>：Exclusive-Read Exclusive-Write</li><li><strong>CREW</strong>：Concurrent-Read Exclusive-Write</li><li><strong>CRCW</strong>：Concurrent-Read Concurrent-Write<ol type="1"><li><strong>Arbitrary rule</strong>：随机写</li><li><strong>Priority rule</strong> (P with the smallestnumber)：根据优先级判断</li><li><strong>Common rule</strong> (if all the processors are trying towrite the same value)：将相同的运算并行计算</li></ol></li></ol><h3 id="wdwork-depth">1.2 WD：Work-Depth</h3><p>只计算真正被调用的资源</p><ol type="1"><li>Work：真正被调用的核</li><li>Depth：并行算法消耗的时间</li></ol><h3 id="衡量指标">1.3 衡量指标</h3><ol type="1"><li><strong>Work Load</strong>：W(n)，总计操作数</li><li><strong>Worst-case Running Time</strong>：T(n)<ol type="1"><li>有<strong>W(n)</strong>个操作，<strong>T(n)</strong>的时间</li><li><strong>P(n)</strong> = <strong>W(n)/T(n)</strong> processors and<strong>T(n)</strong> time (on a PRAM)</li><li><strong>W(n)/p</strong> time using any number of <strong>p ≤W(n)/T(n)</strong> processors (on a PRAM)</li><li><strong>W(n)/p + T(n)</strong> time using any number of<strong>p</strong> processors (on a PRAM)</li></ol></li></ol><h2 id="二求和问题">二、求和问题</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153216847.png" alt="image-20240611153216847" style="zoom:80%;" /></p><h3 id="pram-model">2.1 PRAM model</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153221180.png" alt="image-20240611153221180" style="zoom:80%;" /></p><ol type="1"><li>随着时间的推移，有很多核没有被使用</li></ol><h3 id="work-depth-presentation">2.2 Work-Depth Presentation</h3><p>计算过程：</p><ol type="1"><li>并行运算：<span class="math inline">\(B(0,i)=A(i)\)</span></li><li><span class="math inline">\(h\)</span>从<spanclass="math inline">\(1 \rightarrow \log n\)</span>，并行运算：<spanclass="math inline">\(B(h,i)=B(h-1,2i-1)+B(h-1,2i)\)</span></li><li>并行运算：输出<span class="math inline">\(B(\log n,1)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153226575.png" alt="image-20240611153226575" style="zoom:80%;" /><span class="math display">\[\begin{aligned}T(n)&amp;=1+\log n+1=\log n+2 \\W(n)&amp;=n+\frac{n}{2}+\frac{n}{2^2}+...+\frac{n}{2^k}+1=2n\end{aligned}\]</span></p><h3 id="wd-presentation充分性定理">2.3 WD-presentation充分性定理</h3><p>​ WD模式下的算法可以由任意<strong>P(n)</strong>处理器在<spanclass="math inline">\(O(\frac{W(n)}{P(n)} +T(n))\)</span>时间内实现，使用与WD表示相同的并发写入约定。</p><h2 id="三前缀和-prefix-sums">三、前缀和 Prefix-Sums</h2><h3 id="问题描述">3.1 问题描述</h3><p>输入：A(1)，A(2)，……，A(n)</p><p>输出：<span class="math inline">\(\sum_{i=1}^1 A(i)\)</span>，<spanclass="math inline">\(\sum_{i=1}^2 A(i)\)</span>n，……，<spanclass="math inline">\(\sum_{i=1}^n A(i)\)</span></p><h3 id="工具平衡二叉树">3.2 工具：平衡二叉树</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240618142902160.png" alt="image-20240618142902160" style="zoom:80%;" /></p><p><strong>C(h,i)</strong>表示：第h层前i个元素的前缀和，从最<strong>高</strong>层向<strong>低</strong>层计算<span class="math display">\[C(h,i)=\begin{cases}C(h+1,i/2) &amp;i是偶数\\C(h+1,(i-1)/2)+B(h,i) &amp;i是奇数\end{cases}\]</span></p><p><span class="math display">\[\begin{aligned}T(n)&amp;=T(\frac{n}{2})+O(1)=O(\log n) \\W(n)&amp;=W(\frac{n}{2})+n=O(n)\end{aligned}\]</span></p><p>计算过程：</p><ol type="1"><li>执行一遍<strong>求和问题</strong>的操作，得到所有<spanclass="math inline">\(B(h,i)\)</span><ol type="1"><li><span class="math inline">\(T(n)=\log n+2\)</span></li><li><span class="math inline">\(W(n)=2n\)</span></li></ol></li><li><span class="math inline">\(h\)</span>从<spanclass="math inline">\(\log n \rightarrow 0\)</span>，并行运算<ol type="1"><li><span class="math inline">\(i\)</span>为<spanclass="math inline">\(1\rightarrow \frac{n}{2^h}\)</span>中的偶数：<spanclass="math inline">\(C(h,i)=C(h+1,\frac{i}{2})\)</span></li><li><span class="math inline">\(i\)</span>为<spanclass="math inline">\(1\)</span>：<spanclass="math inline">\(C(h,i)=B(h,i)\)</span></li><li><span class="math inline">\(i\)</span>为<spanclass="math inline">\(3\rightarrow \frac{n}{2^h}\)</span>中的奇数：<spanclass="math inline">\(C(h,i)=C(h+1,\frac{i-1}{2})+B(h,i)\)</span></li></ol></li><li>并行运算：输出<span class="math inline">\(C(0,i)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153241823.png" alt="image-20240611153241823" style="zoom:80%;" /></p><h2 id="四归并排序">四、归并排序</h2><h3 id="主要思想">4.1 主要思想</h3><p>使用并行算法，将<strong>Merge</strong>的过程的时间复杂度降下来</p><h3 id="基础算法将merge转为rank">4.2 基础算法：将Merge转为Rank</h3><p>设<strong>Merge</strong>时，两个数组分别为<spanclass="math inline">\(A_1,A_2...A_n\)</span>和<spanclass="math inline">\(B_1,B_2,...B_n\)</span></p><p>将<strong>Merge</strong>的过程转变为<strong>Rank</strong>的过程</p><ol type="1"><li><p>找到<span class="math inline">\(A_1,...A_n\)</span>分别在<spanclass="math inline">\(B_1,...B_n\)</span>的位置，<spanclass="math inline">\(B_1,...B_n\)</span>分别在<spanclass="math inline">\(A_1,...A_n\)</span>的位置</p><ol type="1"><li><p>对每一个数<span class="math inline">\(A_i\)</span>或<spanclass="math inline">\(B_i\)</span>，使用二分查找</p></li><li><p>并行计算所有的<span class="math inline">\(A_i\)</span>和<spanclass="math inline">\(B_i\)</span>，得到<spanclass="math inline">\(Rank(i,B),Rank(i,A)\)</span></p></li><li><p><span class="math inline">\(T(n)=O(\log n)\)</span></p></li><li><p><span class="math inline">\(W(n)=O(n \log n)\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153248657.png" alt="image-20240611153248657" style="zoom:80%;" /></p></li></ol></li><li><p>根据<strong>Rank</strong>的值，将<spanclass="math inline">\(A_1,A_2...A_n\)</span>和<spanclass="math inline">\(B_1,B_2,...B_n\)</span>并行放入结果数组<spanclass="math inline">\(C_1,...C_{2n}\)</span>中</p><ol type="1"><li><span class="math inline">\(A_i\)</span>在<spanclass="math inline">\(C\)</span>中的位置：<spanclass="math inline">\(Pos=i+Rank(i,B)\)</span></li><li><span class="math inline">\(B_i\)</span>在<spanclass="math inline">\(C\)</span>中的位置：<spanclass="math inline">\(Pos=i+Rank(i,A)\)</span></li><li><span class="math inline">\(T(n)=O(1)\)</span></li><li><span class="math inline">\(W(n)=O(n)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153259851.png" alt="image-20240611153259851" style="zoom:80%;" /></p></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153303071.png" alt="image-20240611153303071" style="zoom:80%;" /></p><ol start="3" type="1"><li>总的<span class="math inline">\(T(n)\)</span>与<spanclass="math inline">\(W(n)\)</span>：<ol type="1"><li><span class="math inline">\(T(n)=O(\log n)\)</span></li><li><span class="math inline">\(W(n)=O(n \log n)\)</span></li></ol></li></ol><h3 id="优化求解rank的过程使用log-n将数组分块分为pfracnlog-n块">4.3优化求解Rank的过程：使用<span class="math inline">\(\logn\)</span>将数组分块，分为<span class="math inline">\(p=\frac{n}{\logn}\)</span>块</h3><p>对并行使用二分查找的优化：</p><ol type="1"><li>分块<strong>Partitioning</strong>，块数<spanclass="math inline">\(p=\frac{n}{\log n}\)</span><ol type="1"><li>从<span class="math inline">\(A\)</span>数组中，选出的第<spanclass="math inline">\(i\)</span>个数<spanclass="math inline">\(A[i]\)</span>为<spanclass="math inline">\(A[1+(i-1)\log n]\)</span>，<spanclass="math inline">\(1\le i \le p\)</span></li><li>从<span class="math inline">\(B\)</span>数组中，选出的第<spanclass="math inline">\(i\)</span>个数<spanclass="math inline">\(B[i]\)</span>为<spanclass="math inline">\(B[1+(i-1)\log n]\)</span>，<spanclass="math inline">\(1\le i \le p\)</span></li><li>使用二分查找，找到选出的数对应在另一个数组中的位置</li><li><span class="math inline">\(T(n)=O(\log n)\)</span></li><li><span class="math inline">\(W(n)=O(p\log n)=O(n)\)</span></li></ol></li><li>计算每个数的<strong>Ranking</strong><ol type="1"><li>根据<span class="math inline">\(A[i]\)</span>、<spanclass="math inline">\(B[i]\)</span>分别的<strong>rank</strong>，我们可以将两个数组分成至多<spanclass="math inline">\(2p\)</span>块，每块的大小为<spanclass="math inline">\(O(\log n)\)</span>，且每个块之间相互独立</li><li>这样，我们就将问题划分成了<spanclass="math inline">\(2p\)</span>个大小为<spanclass="math inline">\(O(\log n)\)</span>的子问题</li><li>并行运算：对每个大小为<span class="math inline">\(O(\logn)\)</span>的块执行归并操作</li><li><span class="math inline">\(T(n)=O(\log n)\)</span></li><li><span class="math inline">\(W(n)=O(p\log n)=O(n)\)</span></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153309236.png" alt="image-20240611153309236" style="zoom:80%;" /></p><h2 id="五找最大值">五、找最大值</h2><h3 id="基础算法比较所有的pair">5.1 基础算法：比较所有的pair</h3><p>并行运算：对任意两个数<span class="math inline">\(A_i\)</span>和<spanclass="math inline">\(A_j\)</span>，如果<spanclass="math inline">\(A_i&lt;A_j\)</span>，则将<spanclass="math inline">\(B_i\)</span>赋值为1</p><ol type="1"><li>由于只可能将<spanclass="math inline">\(B_i\)</span>从0赋值为1，因此可以忽略冲突</li><li><span class="math inline">\(T(n)=O(1)\)</span></li><li><span class="math inline">\(W(n)=O(n^2)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240618154320562.png" alt="image-20240618154320562" style="zoom:80%;" /></p><h3 id="优化使用sqrt-n将n个数字分块分为sqrt-n块">5.2 优化：使用<spanclass="math inline">\(\sqrt n\)</span>将n个数字分块，分为<spanclass="math inline">\(\sqrt n\)</span>块</h3><ol type="1"><li>并行运算：对于每一个大小为<span class="math inline">\(\sqrtn\)</span>的块，递归计算出最大值<ol type="1"><li>计算块<span class="math inline">\(M_i\)</span>的开销为：<spanclass="math inline">\(T(\sqrt n),W(\sqrt n)\)</span></li><li>一共需要并行计算<span class="math inline">\(\sqrtn\)</span>个块</li></ol></li><li>对于<span class="math inline">\(\sqrt n\)</span>个块找出的<spanclass="math inline">\(\sqrtn\)</span>个最大值，使用<strong>5.1</strong>的算法，找出最大值<ol type="1"><li><span class="math inline">\(T(n)=O(1)\)</span></li><li><span class="math inline">\(W(n)=O(\sqrt n^2)=O(n)\)</span></li></ol></li><li>总的开销为<ol type="1"><li><span class="math inline">\(T(n)=T(\sqrt n)+O(1)=O(\log \logn)\)</span></li><li><span class="math inline">\(W(n)=\sqrt n W(\sqrt n)+O(n)=O(n\log\log n)\)</span></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153319383.png" alt="image-20240611153319383" style="zoom:80%;" /></p><h3 id="优化使用hlog-log-n将n个数组分块分为fracnh块">5.3 优化：使用<spanclass="math inline">\(h=\log \log n\)</span>将n个数组分块，分为<spanclass="math inline">\(\frac{n}{h}\)</span>块</h3><ol type="1"><li>并行运算：对于每一个大小为<span class="math inline">\(h=\log \logn\)</span>的块，顺序遍历计算出最大值<ol type="1"><li><span class="math inline">\(T(n)=O(h)=O(\log \log n)\)</span></li><li><span class="math inline">\(W(n)=O(h*\frac{n}{h})=O(n)\)</span></li></ol></li><li>对于<span class="math inline">\(\frac{n}{h}\)</span>个块找出的<spanclass="math inline">\(\frac{n}{h}\)</span>个最大值，使用<strong>5.2</strong>的算法，找出最大值<ol type="1"><li><span class="math inline">\(T(n)=O(\log \log\frac{n}{h})\)</span></li><li><span class="math inline">\(W(n)=O(\frac{n}{h}*\log \log\frac{n}{h})=O(n)\)</span></li></ol></li><li>总的开销为<ol type="1"><li><span class="math inline">\(T(n)=O(h+\log \log \frac{n}{h})=O(\log\log n)\)</span></li><li><span class="math inline">\(W(n)=O(h*\frac{n}{h}+\frac{n}{h}*\log\log \frac{n}{h})=O(n)\)</span></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153323814.png" alt="image-20240611153323814" style="zoom:80%;" /></p><h3 id="random-sampling">5.4 Random Sampling</h3><ol type="1"><li>从A数组中，随机选出<spanclass="math inline">\(n^{\frac{7}{8}}\)</span>个元素，组成B数组<ol type="1"><li><span class="math inline">\(T=O(1)\)</span></li><li><span class="math inline">\(W=O(n^{\frac{7}{8}})\)</span></li></ol></li><li>将B数组按照<spanclass="math inline">\(n^{\frac{1}{8}}\)</span>分块分为<spanclass="math inline">\(n^{\frac{3}{4}}\)</span>块，每一块使用<strong>5.1</strong>的算法计算最大值<ol type="1"><li><span class="math inline">\(T(n)=O(1)\)</span></li><li><span class="math inline">\(W=(n^\frac{3}{4}) *O((n^{\frac{1}{8}})^2)=(n^\frac{3}{4}) *O(n^{\frac{1}{4}})=O(n)\)</span></li></ol></li><li>对于第2步算出的<spanclass="math inline">\(n^{\frac{3}{4}}\)</span>个元素，按照<spanclass="math inline">\(n^{\frac{1}{4}}\)</span>分块分为<spanclass="math inline">\(n^{\frac{1}{2}}\)</span>块，每一块使用<strong>5.1</strong>的算法计算最大值<ol type="1"><li><span class="math inline">\(T(n)=O(1)\)</span></li><li><span class="math inline">\(W=(n^\frac{1}{2}) *O((n^{\frac{1}{4}})^2)=(n^\frac{1}{2}) *O(n^{\frac{1}{2}})=O(n)\)</span></li></ol></li><li>总的开销为<ol type="1"><li><span class="math inline">\(T(n)=O(1)\)</span></li><li><span class="math inline">\(W(n)=O(n)\)</span></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153328451.png" alt="image-20240611153328451" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153332394.png" alt="image-20240611153332394" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS13：随机算法</title>
      <link href="/2024/06/16/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/13.%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/16/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/13.%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="randomized-algorithms">Randomized Algorithms</h1><h2 id="一招聘问题-hiring-problem">一、招聘问题 Hiring Problem</h2><h3 id="问题描述">1.1 问题描述</h3><p>每天面试一个不同的面试者，持续<spanclass="math inline">\(N\)</span>天</p><p>面试一个面试者的代价为<spanclass="math inline">\(C_i\)</span>，招聘一个面试者的代价为<spanclass="math inline">\(C_h\)</span></p><p>一共招聘<spanclass="math inline">\(M\)</span>个面试者，求面试并招聘完所有的面试者所需要的代价</p><h3 id="离线算法">1.2 离线算法</h3><p>先面试完所有的面试者，然后再选择招聘的人：<spanclass="math inline">\(O(NC_i+MC_h)\)</span></p><h3 id="在线算法">1.3 在线算法</h3><p>面试一个面试者，然后与之前面试过的面试者进行比较，如果更优，则招聘：<spanclass="math inline">\(O(NC_h)\)</span></p><h3 id="随机算法--离线">1.4 随机算法--离线</h3><p>假设所有的面试者以一个随机的顺序到来 <span class="math display">\[X_i=\left\{\begin{aligned}1 &amp;\ 面试者i被招聘\\0 &amp;\ 面试者i没有被招聘\end{aligned}\right.\]</span> 设<spanclass="math inline">\(X\)</span>表示：招聘的人数，则<spanclass="math inline">\(X=\sum_{i=1}^N X_i\)</span></p><p><span class="math inline">\(E[X_i]=\frac{1}{i}\)</span></p><p><span class="math inline">\(E[X]=E[\sum_{i=1}^N X_i]=\sum_{i=1}^NE[X_i]=\sum_{i=1}^N \frac{1}{i}=\ln N+O(1)\)</span></p><p>最后的代价为：<span class="math inline">\(O(C_h \lnN+NC_i)\)</span></p><h3 id="随机算法--在线">1.5 随机算法--在线</h3><p>面试每一个面试者，在面试的时候要立即做决定：</p><ol type="1"><li>首先观察<spanclass="math inline">\(k\)</span>个面试者，找出他们中最优的一位，但是这<spanclass="math inline">\(k\)</span>个面试者都不招聘</li><li>从第<spanclass="math inline">\(k+1\)</span>个面试者开始，如果当前的面试者比之前<spanclass="math inline">\(k\)</span>个面试者中最优的面试者好，则直接招聘</li><li>如果找不到，则招聘最后一个面试者</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">OnlineHiring</span><span class="params">(EventType C[], <span class="type">int</span> N, <span class="type">int</span> k )</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> Best = N;</span><br><span class="line">    <span class="type">int</span> BestQ = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++)&#123;</span><br><span class="line">        Qi = <span class="built_in">interview</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (Qi&gt;BestQ) BestQ = Qi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=k+<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">        Qi = <span class="built_in">interview</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (Qi&gt;BestQ)&#123;</span><br><span class="line">            Best = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> Best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析">算法分析：</h4><p>设<span class="math inline">\(S_i\)</span>表示：第<spanclass="math inline">\(i\)</span>个面试者是最好的</p><ol type="1"><li>设事件<spanclass="math inline">\(A\)</span>表示：最好的面试者在第<spanclass="math inline">\(i\)</span>个位置 ==&gt; <spanclass="math inline">\(Pr[A]=\frac{1}{N}\)</span></li><li>设事件<span class="math inline">\(B\)</span>表示：从<spanclass="math inline">\((k+1) →(i-1)\)</span>的面试者均没有被招聘，即前<spanclass="math inline">\(i-1\)</span>个人中的最大值在前<spanclass="math inline">\(k\)</span>个人之中 ==&gt; <spanclass="math inline">\(Pr[B]=\frac{k}{i-1}\)</span></li><li>易得，事件<span class="math inline">\(A\)</span>和事件<spanclass="math inline">\(B\)</span>是独立的</li></ol><p>则<span class="math inline">\(Pr[S_i] =Pr[A∩B]=Pr[A]*Pr[B]=\frac{k}{N*(i-1)}\)</span></p><p>​ <spanclass="math inline">\(Pr[S]=\sum_{i=k+1}^{N}Pr[S_i]=\sum_{i=k+1}^{N}\frac{k}{N*(i-1)}=\frac{k}{N}\sum_{i=k}^{N-1}\frac{1}{i}\)</span></p><p>可得：<span class="math inline">\(\frac{k}{N}ln(\frac{N}{k}) \lePr[S] \le \frac{k}{N}ln(\frac{N-1}{k-1})\)</span></p><h2 id="二快排-quick-sort">二、快排 Quick Sort</h2><h3 id="算法分析1">算法分析1</h3><p><span class="math display">\[X_{ij}=\left\{\begin{aligned}1 &amp;\ a_i和a_j进行了比较\\0 &amp;\ a_i和a_j没有进行比较\end{aligned}\right.\]</span></p><ol type="1"><li>设<spanclass="math inline">\(X=\sum_{j=1}^N\sum_{i=1}^{j}x_{ij}\)</span>，则<spanclass="math inline">\(E[X] = \sum_{j=1}^N\sum_i^{j}E[x_{ij}] =\sum_{j=1}^N\sum_{i=1}^{j}Pr[x_{ij}=1]\)</span></li><li>而对于<span class="math inline">\(Pr[x_{ij}=1]\)</span>，<spanclass="math inline">\(a_i\)</span>和<spanclass="math inline">\(a_j\)</span>会进行比较，当且仅当：<spanclass="math inline">\(a_i\)</span>和<spanclass="math inline">\(a_j\)</span>在有且仅有一个子过程中，<spanclass="math inline">\(a_i\)</span>或<spanclass="math inline">\(a_j\)</span>被选中为<spanclass="math inline">\(pivot\)</span>，且<spanclass="math inline">\(a_{i+1} → a_{j-1}\)</span>没有被选中为<spanclass="math inline">\(pivot\)</span></li><li>由于算法保证每个<span class="math inline">\(a_i\)</span>被取为<spanclass="math inline">\(pivot\)</span>的概率为均等的，因此<spanclass="math inline">\(Pr[x_{ij}]=\frac{2}{j-i+1}\)</span></li><li>可得：<span class="math inline">\(X =\sum_{j=1}^N\sum_{i=1}^{j}\frac{2}{j-i+1} = O(n \log n)\)</span></li></ol><h3 id="算法分析2">算法分析2</h3><ol type="1"><li><p>设<strong>centralsplitter</strong>：表示可以将<strong>n</strong>个数分为两边，每一边至少有<spanclass="math inline">\(\frac{n}{4}\)</span>个元素的<strong>pivot</strong></p></li><li><p><strong>ModifiedQuickSort</strong>：每一步总是选择<strong>centralsplitter</strong></p></li><li><p>在每一次选择<strong>pivot</strong>的时候，选中<strong>centralsplitter</strong>的概率为<spanclass="math inline">\(p=\frac{1}{2}\)</span>，则选中<strong>centralsplitter</strong>的期望次数为<spanclass="math inline">\(E=\frac{1}{p}=2\)</span> (几何分布的期望)</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153139033.png" alt="image-20240611153139033" style="zoom:80%;" /></p></li><li><p><strong>Type j</strong>：如果<spanclass="math inline">\(N(\frac{3}{4})^{j+1} \le |S| \leN(\frac{3}{4})^j\)</span>，则称子问题<spanclass="math inline">\(S\)</span>为<strong>type j</strong>的</p></li><li><p>定理：最多有<spanclass="math inline">\((\frac{4}{3})^{j+1}\)</span>个<strong>typej</strong>的子问题</p></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153143078.png" alt="image-20240611153143078" style="zoom:80%;" /></p><h2 id="课后题">课后题</h2><ol type="1"><li>给定一个有n个节点的链表，我们的任务是删除链表中的所有元素。在每一步中，我们随机的选择当前链表中的一个节点，删除它及它之后的所有节点。假设我们每一次选择节点都是在剩下的节点中等概率的选取一个点，则我们期望需要多少步能够删除完所有的节点<ul><li>答案：<span class="math inline">\(O(\log N)\)</span></li><li>设需要<span class="math inline">\(T(N)\)</span>步，则<spanclass="math inline">\(T(N)=\frac{1}{N}(T(1)+T(2)+...+T(N-1))+1\)</span></li></ul></li><li>在在线招聘算法中，<spanclass="math inline">\(C[i]\)</span>的权值是平均的。若<spanclass="math inline">\(N=271,k=90\)</span>，则选中第<spanclass="math inline">\(N\)</span>个求职者的概率为<ul><li>答案：<span class="math inline">\(\frac{1}{3}\)</span></li><li>如果要雇佣第271个，则要求前270个中，最好的必须要落在前k个，因此，概率为<spanclass="math inline">\(\frac{90}{270}=\frac{1}{3}\)</span></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS12：局部搜索</title>
      <link href="/2024/06/15/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/12.%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2/"/>
      <url>/2024/06/15/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/12.%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第12章-local-search">第12章 Local Search</h1><h2 id="一定义">一、定义</h2><p><strong>Local</strong></p><ol type="1"><li>定义可行解的<strong>neighborhoods</strong></li><li>局部最优解<strong>localoptimum</strong>：在一个<strong>neighborhoods</strong>中的最优解</li></ol><p><strong>Search</strong></p><ol type="1"><li>从一个可行的解决方案开始，在附近寻找一个更好的</li><li>如果没有改进的可能，则达到局部最优</li></ol><p><strong>Local Search 对NP-hard问题很难找到最优解</strong></p><h2 id="二顶点覆盖问题">二、顶点覆盖问题</h2><h3 id="算法1优先选择度最大的顶点">2.1 算法1：优先选择度最大的顶点</h3><h3 id="算法2任意选一条边将两个顶点加入集合">2.2算法2：任意选一条边，将两个顶点加入集合</h3><p>近似比为2</p><ol type="1"><li>算法选出的边，都不相交</li><li>由于都不相交，最优解至少要用一半的顶点完成覆盖</li><li>因此这个算法的近似比<span class="math inline">\(\le 2\)</span></li></ol><h3 id="metropolis算法">2.3 Metropolis算法</h3><p>模拟退火</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240612220233843.png" alt="image-20240612220233843" style="zoom:80%;" /></p><h2 id="三hopfield-neural-networks">三、Hopfield Neural Networks</h2><h3 id="问题描述">3.1 问题描述</h3><p>设<span class="math inline">\(G=(V,E)\)</span></p><ol type="1"><li><span class="math inline">\(E\)</span>中的每一条边<spanclass="math inline">\(e\)</span>有一个权值<spanclass="math inline">\(w\)</span>，<spanclass="math inline">\(w\)</span>可以为正也可以为负。</li><li><span class="math inline">\(V\)</span>中的每一个顶点<spanclass="math inline">\(v\)</span>可以是正，也可以是负</li></ol><p>对于每一个顶点，如果<span class="math inline">\(\sum_{v:e=(u,v)\inE}w_e s_u s_v \le 0\)</span>，则称这个点为<spanclass="math inline">\(satisfied\)</span></p><p>对于每一条边<span class="math inline">\(e=(u,v)\)</span>，如果<spanclass="math inline">\(w_e s_u s_v &lt; 0\)</span>，则称这条边为<spanclass="math inline">\(good\)</span></p><h3 id="state-flipping-algorithm">3.2 State-flipping Algorithm</h3><ol type="1"><li>从任意一个状态<span class="math inline">\(S\)</span>出发</li><li>如果<span class="math inline">\(S\)</span>不满足条件，则找到<spanclass="math inline">\(S\)</span>中任意一个不<spanclass="math inline">\(satisified\)</span>的节点u，将节点u的状态取反，并更新<spanclass="math inline">\(S\)</span></li><li>直到<span class="math inline">\(S\)</span>满足条件</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240612220256379.png" alt="image-20240612220256379" style="zoom:80%;" /></p><h3 id="定理">3.3 定理</h3><ol type="1"><li>上述算法一定能够停止在一个稳定的状态</li><li>最多需要<span class="math inline">\(W=\sum_e|w_e|\)</span>次迭代<ol type="1"><li>设<spanclass="math inline">\(\Phi(S)=\sum_{e是good}|w_e|\)</span></li><li>每次迭代，u的临边中，原来是good的边变成了bad，原来是bad的边变成了good</li><li>因此，<spanclass="math inline">\(\Phi(S&#39;)=\Phi(S)-\sum_{e为u的临边且为bad}|w_e|+\sum_{e为u的临边且为good}|w_e|\)</span></li><li>由于每次找的点u是<spanclass="math inline">\(unsatisfied\)</span>的，即后面的和$$1</li><li>因此，<span class="math inline">\(\Phi(S&#39;) \ge\Phi(S)+1\)</span>，最多需要<spanclass="math inline">\(W=\sum_e|w_e|\)</span>次迭代</li></ol></li></ol><h3 id="local-search算法">3.4 Local Search算法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240612220332044.png" alt="image-20240612220332044" style="zoom:80%;" /></p><h2 id="四the-maximum-cut-problem-最大割问题">四、The Maximum CutProblem 最大割问题</h2><h3 id="问题描述-1">4.1 问题描述</h3><p>给定一个无向图<spanclass="math inline">\(G=(V,E)\)</span>，每条边的边权为正数</p><p>将所有点分为两部分<spanclass="math inline">\((A,B)\)</span>，让所有连接<spanclass="math inline">\(A,B\)</span>之间的边的边权和最大</p><p><span class="math inline">\(w(A,B)=\sum_{u \in A, v \inB}w_{uv}\)</span></p><h3 id="local-search-算法">4.2 Local Search 算法</h3><ol type="1"><li>从<span class="math inline">\(A\)</span>中选择一个点<spanclass="math inline">\(u\)</span>，满足 割边的边权和 &gt;内边的边权和，则将<span class="math inline">\(u\)</span>放入<spanclass="math inline">\(B\)</span>中</li><li>这样，当状态转换的时候，与<spanclass="math inline">\(u\)</span>相连的边的状态会取反(割边变为内边，内边变为割边)</li></ol><h3 id="定理-1">4.3 定理</h3><p>局部最优解 至少为 全局最优解 的<spanclass="math inline">\(\frac{1}{2}\)</span>，即：<spanclass="math inline">\(w(A,B)  \ge \frac{1}{2} w(A^*,B^*)\)</span></p><ol type="1"><li>由于(A,B)是局部最优解，则对于A中的任意一个点<spanclass="math inline">\(u\)</span>，与A内的节点相连的边权和<spanclass="math inline">\(\le\)</span>与B内的节点相连的边权和<spanclass="math inline">\(\sum_{v\in A}w_{uv} \le \sum_{v\inB}w_{uv}\)</span></li><li>将上式对所有<span class="math inline">\(u \inA\)</span>求和得：<spanclass="math inline">\(2\sum_{A中的所有边(u,v)}w_{uv} \le \sum_{u\inA}\sum_{v\in B}w_{uv}=w(A,B)\)</span></li><li>可得：<span class="math inline">\(2\sum_{A中的所有边(u,v)}w_{uv} \lew(A,B)\)</span>，<spanclass="math inline">\(2\sum_{B中的所有边(u,v)}w_{uv} \lew(A,B)\)</span></li><li>所以：<span class="math inline">\(w(A^*,B^*)\le\sum_{A中的所有边(u,v)}w_{uv} + \sum_{B中的所有边(u,v)}w_{uv}\le2w(A,B)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240612220505453.png" alt="image-20240612220505453" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240612220441986.png" alt="image-20240612220441986" style="zoom:80%;" /></p><h3 id="big-improvement-flip">4.4 Big-improvement-flip</h3><ol type="1"><li>只有当选出的这个点换到<spanclass="math inline">\(B\)</span>中，导致新的答案至少是<spanclass="math inline">\(\frac{2\epsilon}{|V|}w(A,B)\)</span>时，才将这个点换过去</li><li>局部最优解 至少是 全局最优解 的<spanclass="math inline">\(\frac{1}{2+\epsilon}\)</span>，即：<spanclass="math inline">\(w(A,B)  \ge \frac{1}{2+\epsilon}w(A^*,B^*)\)</span></li><li>最多进行<span class="math inline">\(O(\frac{n}{\epsilon} \logW)\)</span>次迭代</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240612220412128.png" alt="image-20240612220412128" style="zoom:80%;" /></p><h3 id="k-l-heuristic">4.5 K-L heuristic</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240612220421237.png" alt="image-20240612220421237" style="zoom:80%;" /></p><p>LKH算法：TSP</p><h2 id="课后题">课后题：</h2><p>对于下图中给出的图，如果我们从删除黑色顶点开始，那么局部搜索总是可以找到最小顶点覆盖</p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/150"alt="150" /><figcaption aria-hidden="true">150</figcaption></figure><p>答案：<strong>T</strong></p><p>在平面上有<span class="math inline">\(n\)</span>个点<spanclass="math inline">\(S=\{s_1,...s_n\}\)</span>，我们想要构造一个有<spanclass="math inline">\(k\)</span>个中心点的点集<spanclass="math inline">\(C=\{c_1,...c_k\}\)</span>，使得从所有点到最近的中心点的距离最小。这里<spanclass="math inline">\(c_i\)</span>可以是平面中的任意点</p><p>一个<strong>local search</strong>算法会首先任意选择<spanclass="math inline">\(k\)</span>个点作为中心点，然后</p><ul><li>将<span class="math inline">\(S\)</span>分为<spanclass="math inline">\(k\)</span>个集合，<spanclass="math inline">\(S_i\)</span>是<strong>以<spanclass="math inline">\(c_i\)</span>为最近中心点的所有顶点</strong>的集合</li><li>对于每一个<spanclass="math inline">\(S_i\)</span>，计算出其中心点作为<spanclass="math inline">\(S_i\)</span>的新的中心点</li></ul><p>如果上述两个步骤导致了覆盖半径严格减少，则进行下一次迭代，否则终止计算</p><p>问：当上述局部搜索算法终止时，其解的覆盖半径是否为最优覆盖半径的2倍</p><p>答案：<strong>F</strong></p><p>解析：构造一个反例</p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS11：近似算法</title>
      <link href="/2024/06/14/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/11.%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/14/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/11.%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="approximation-近似解">Approximation 近似解</h1><h2 id="一approximation-ratio-近似比">一、Approximation Ratio近似比</h2><p><span class="math inline">\(\rho(n)\)</span>近似算法 <strong><spanclass="math inline">\(\rho(n)-approximation\algorithm\)</span></strong></p><ol type="1"><li>设近似解的答案为<spanclass="math inline">\(C\)</span>，最优解的答案为<spanclass="math inline">\(C^*\)</span>，则近似算法的近似比<spanclass="math inline">\(\rho(n)=max(\frac{C}{C^*},\frac{C*}{C})\)</span></li><li>对于任意输入<spanclass="math inline">\(I\)</span>，近似解为求一个上确界<ul><li>求极小值：<spanclass="math inline">\(\alpha=sup(\frac{C(I)}{OPT(I)})\)</span></li><li>求极大值：<spanclass="math inline">\(\alpha=sup(\frac{OPT(I)}{C(I)})\)</span></li><li>一般情况下，<spanclass="math inline">\(C(I)\)</span>是可以直接计算出来的，而<spanclass="math inline">\(OPT(I)\)</span>需要通过放缩得到一个不等式</li></ul></li></ol><p><span class="math inline">\(1+\epsilon\)</span>近似算法 <strong><spanclass="math inline">\((1+\epsilon)-approximation\algorithm\)</span></strong></p><ol type="1"><li>近似算法的近似比为<spanclass="math inline">\(1+\epsilon\)</span></li><li>时间复杂度：多项式时间</li></ol><p>多项式近似方案 <strong><span class="math inline">\(polynomial-time\approximation\ scheme(PTAS)\)</span></strong></p><ol type="1"><li>给定一个常数<spanclass="math inline">\(\epsilon\)</span>，算法的近似比为<spanclass="math inline">\(1+\epsilon\)</span></li><li>时间复杂度：多项式时间，为<spanclass="math inline">\(O(n^k)\)</span>，k与<spanclass="math inline">\(\epsilon\)</span>有关</li><li>例：<span class="math inline">\(O(n^{2/\epsilon})\)</span></li></ol><p>完全多项式近似方案 <strong><span class="math inline">\(fully\polynomial-time\ approximation\ scheme(FPTAS)\)</span></strong></p><ol type="1"><li>给定一个常数<spanclass="math inline">\(\epsilon\)</span>，算法的近似比为<spanclass="math inline">\(1+\epsilon\)</span></li><li>时间复杂度：多项式时间，为<spanclass="math inline">\(O(k*n^\alpha)\)</span>，k与<spanclass="math inline">\(\epsilon\)</span>有关，<spanclass="math inline">\(\alpha\)</span>为常数</li><li>例：<span class="math inline">\(O((\frac{1}{\epsilon})^2n^3)\)</span></li></ol><h2 id="二approximate-bin-packing-近似装箱问题">二、Approximate BinPacking 近似装箱问题</h2><h3 id="问题描述">2.1 问题描述</h3><ol type="1"><li>给定<strong>n</strong>个<strong>size</strong>为<spanclass="math inline">\(S_1,S_2,...S_n(0&lt; S_i \le1)\)</span>的物品，物品不可分割，将这<strong>n</strong>个物品用最少的箱子装出来，求最少需要多少个箱子</li><li>是<strong>NPC</strong>问题</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240612213446436.png" alt="image-20240612213446436" style="zoom:80%;" /></p><h3 id="算法">2.2 算法</h3><h4 id="nextfit来一个物品装入当前箱子装不下去就新开一个箱子">2.2.1NextFit：来一个物品，装入当前箱子，装不下去就新开一个箱子</h4><ul><li><p>算法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NextFit</span> <span class="params">( )</span></span>&#123;   </span><br><span class="line">    read item1;</span><br><span class="line">    <span class="keyword">while</span> (read item2)&#123;</span><br><span class="line">        <span class="keyword">if</span> (item2 can be packed in the same bin as item1 )</span><br><span class="line">place item2 in the bin;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">create a <span class="keyword">new</span> bin <span class="keyword">for</span> item2;</span><br><span class="line">        item1 = item2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定理：如果<strong>M</strong>是最优解，则这个算法的解不超过<strong>2M-1</strong></p></li><li><p>证明：即证，如果<strong>NextFit</strong>算法使用了<strong>2M</strong>个箱子，则最优解一定至少使用<strong>M+1</strong>个箱子</p><ul><li>在极端情况下，最优解算法求出的每个箱子都是满的，即最优解<spanclass="math inline">\(\ge\)</span>所有箱子都是满的情况</li><li>设<spanclass="math inline">\(S(B_i)\)</span>为<strong>NextFit</strong>算法求出的第<strong>i</strong>个箱子的大小，则</li><li><span class="math inline">\(S(B_1)+S(B_2)&gt;1,\ ...\,S(B_{2M-1})+S(B_{2M})&gt;1\)</span></li><li><span class="math inline">\(\therefore \sum_{i=1}^{2M}S(B_i)&gt;M\)</span></li><li><span class="math inline">\(\therefore\)</span> 最优解最少需要<spanclass="math inline">\(M+1\)</span>个箱子</li></ul></li><li><p>近似比为<strong>2</strong>的例子：</p><ul><li>物品的大小为<span class="math inline">\(\frac{1}{2}\)</span>、<spanclass="math inline">\(\epsilon\)</span></li><li>输入：<span class="math inline">\(\frac{1}{2}\)</span>、<spanclass="math inline">\(\epsilon\)</span>交替输入，共<strong>2n</strong>组(<spanclass="math inline">\(n \rightarrow \inf\)</span>)</li><li>最优解：将<spanclass="math inline">\(\frac{1}{2}\)</span>成对放入箱子中，然后将所有<spanclass="math inline">\(\epsilon\)</span>放入另一个箱子，共需要<strong>n+1</strong>个箱子</li><li><strong>NextFit</strong>的解：将每一组分别放入一个箱子，共需要<strong>2n</strong>个箱子</li><li>近似比：<span class="math inline">\(\alpha = \frac{2n}{n+1}\rightarrow 2\)</span></li></ul></li></ul><h4id="firstfit来一个物品从第一个箱子开始找找到首个能够装进去的箱子">2.2.2FirstFit：来一个物品，从第一个箱子开始找，找到首个能够装进去的箱子</h4><ul><li><p>算法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FirstFit</span> <span class="params">( )</span></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(read item)&#123;</span><br><span class="line">        scan <span class="keyword">for</span> the first bin that is large enough <span class="keyword">for</span> item;</span><br><span class="line">        <span class="comment">//维护一个区间最大值(剩余容量),但是平衡树的key是箱子的编号</span></span><br><span class="line">        <span class="keyword">if</span> (found)</span><br><span class="line">place item in that bin;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">create a <span class="keyword">new</span> bin <span class="keyword">for</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定理：如果<strong>M</strong>是最优解，则<strong>FirstFit</strong>算法的解不超过<strong><spanclass="math inline">\(\frac{17M}{10}\)</span></strong>，且存在一种输入，使得近似解为<strong><spanclass="math inline">\(\frac{17(M-1)}{10}\)</span></strong></p></li><li><p><strong>1.7</strong>的例子：<spanclass="math inline">\(\frac{1}{6}-\epsilon\)</span>、<spanclass="math inline">\(\frac{1}{3}-\epsilon\)</span>、<spanclass="math inline">\(\frac{1}{2}+\epsilon\)</span></p><ul><li>物品大小为：<spanclass="math inline">\(\frac{1}{6}-\epsilon\)</span>、<spanclass="math inline">\(\frac{1}{3}-\epsilon\)</span>、<spanclass="math inline">\(\frac{1}{2}+\epsilon\)</span></li><li>输入：n个<spanclass="math inline">\(\frac{1}{6}-\epsilon\)</span>、n个<spanclass="math inline">\(\frac{1}{3}-\epsilon\)</span>、n个<spanclass="math inline">\(\frac{1}{2}+\epsilon\)</span></li><li>最优解：以<spanclass="math inline">\(\frac{1}{6}-\epsilon\)</span>、<spanclass="math inline">\(\frac{1}{3}-\epsilon\)</span>、<spanclass="math inline">\(\frac{1}{2}+\epsilon\)</span>为一组，共需要<spanclass="math inline">\(n\)</span>个箱子</li><li><strong>FirstFit</strong>的解：<spanclass="math inline">\(\frac{n}{6}+\frac{n}{3}+n\)</span></li><li>近似比：<span class="math inline">\(\alpha =\frac{\frac{n}{6}+\frac{n}{3}+n}{n} =\frac{1}{6}+\frac{1}{3}+1=1.5\)</span></li></ul></li></ul><h4 id="bestfit来一个物品找到空余内存最少的箱子将物品装进去">2.2.3BestFit：来一个物品，找到空余内存最少的箱子，将物品装进去</h4><h4 id="on-line-algorithm在线算法">2.2.4 On-lineAlgorithm：在线算法</h4><ul><li>在装完上一个物品后，就不能再改变了，且装上一个物品时不知道之后的物品的大小</li><li>定理：任何一个在线算法的近似比，一定<spanclass="math inline">\(\ge\frac{5}{3}\)</span></li><li>证明：<strong>对手法</strong>，对每一种近似算法，找到一组输入，让近似比<spanclass="math inline">\(\ge\frac{5}{3}\)</span><ul><li>假设有34个体积为1的物体，箱子的容量为50</li><li>如果算法无法将这些物体放到一个箱子里，则近似比<spanclass="math inline">\(\ge\frac{5}{3}\)</span>（最优解为1，而该算法的解至少为2）</li><li>如果可以，则添加2个物体(17,17)<ul><li>如果将这两个17装进2个箱子，则再添加2个物体(34,34)，此时近似比<spanclass="math inline">\(\ge\frac{5}{3}\)</span>（最优解为3，而该算法的解至少为5）</li><li>如果将这两个17装进1个箱子，则再添加3个物体(26,26,26)，此时近似比<spanclass="math inline">\(\ge\frac{5}{3}\)</span>（最优解为3，而该算法的解至少为5）</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153043569.png" alt="image-20240611153043569" style="zoom:80%;" /></p><h4 id="离线算法">2.2.6 离线算法</h4><p>定理：离线算法的近似比，一定<span class="math inline">\(\ge1.5\)</span></p><h2 id="三背包问题">三、背包问题</h2><h3 id="问题描述-1">3.1 问题描述</h3><p>有<spanclass="math inline">\(n\)</span>个物体，每个物体有两个属性：体积<spanclass="math inline">\(w_i\)</span>，价值<spanclass="math inline">\(p_i\)</span>，选择一部分物体，要求体积和不超过<spanclass="math inline">\(M\)</span>，且最后的价值和最大</p><h3 id="算法-1">3.2 算法</h3><h4 id="算法1优先选择单位价值最大的物体">3.2.1算法1：优先选择单位价值最大的物体</h4><p>求解近似比：找一个特例，则近似比不会比这个小</p><ol type="1"><li>假设背包体积为w，有两个物体，一个物体为(<spanclass="math inline">\(w=1,p=2\)</span>)，另一个物体为(<spanclass="math inline">\(w=w,p=w\)</span>)</li><li>最优解：选择(w,w)的物体，总价值为w</li><li>该算法：选择(1,2)的物体，总价值为2</li><li>近似比为<span class="math inline">\(\frac{2}{w}\)</span></li></ol><h4 id="算法2优先选择价值最大的物体">3.2.2算法2：优先选择价值最大的物体</h4><h4 id="算法3选择上述两种算法中更优的一个解">3.2.3算法3：选择上述两种算法中，更优的一个解</h4><p>设<span class="math inline">\(\frac{p_1}{w_1} \ge \frac{p_2}{w_2} \ge... \ge \frac{p_n}{w_n}\)</span>，根据算法1，装到第<spanclass="math inline">\(k\)</span>个时就装不下去了，则</p><ol type="1"><li><spanclass="math inline">\(Greedy_1=p_1+p_2+...+p_{k-1}\)</span>，算法1会选择1~(k-1)</li><li><span class="math inline">\(Greedy_2 \gep_k\)</span>，算法2会从n开始选，直到装不下，至少选择的价值会大于<spanclass="math inline">\(p_k\)</span></li></ol><p>可以证明：<span class="math inline">\(OPT \lep_1+p_2+...+p_{k-1}+p_k=Greedy_1+Greedy_2\)</span></p><p>因此，该算法的近似比为<span class="math inline">\(\epsilon =\frac{OPT}{max(Greedy_1,Greedy_2)} \le\frac{Greedy_1+Greedy_2}{max(Greedy_1,Greedy_2)} \le 2\)</span></p><h2 id="四load-balancing">四、load balancing</h2><h3 id="问题描述-2">4.1 问题描述</h3><p>有m个人，n个工作，每个工作有一个时间<spanclass="math inline">\(p_i\)</span>，要求每个人的最大工作时间尽可能小</p><h3 id="算法-2">4.2 算法</h3><p>求近似比，要先对<spanclass="math inline">\(OPT\)</span>进行估计，估计出上界/下界</p><ol type="1"><li><span class="math inline">\(OPT \gep_n\)</span>，每个人的最大工作时间至少为最长的那个工作</li><li><span class="math inline">\(OPT \ge\frac{mx+p_n}{m}=x+\frac{p_n}{m}\)</span></li></ol><p><span class="math inline">\(AIG=x+\frac{p_n}{m}+(1-\frac{1}{m})p_m\le OPT+(1-\frac{1}{m})OPT=(2-\frac{1}{m})OPT\)</span></p><p><span class="math inline">\(\epsilon \le 2-\frac{1}{m}\)</span></p><h2 id="错题">错题</h2><h3 id="最大生成树">1 最大生成树</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153053696.png" alt="image-20240611153053696" style="zoom:80%;" /></p><p>S：每个点的临边中，边权最大的边的集合</p><p>T：图的最大生成树</p><p>证明C：最大生成树中的每一条边，至少是某一个顶点的最大临边</p><h3 id="旅行商问题-tsp">2 旅行商问题 TSP</h3><p><strong>TSP</strong>问题：找一条路径，经过所有节点至少一遍，最后回到起点，并且使边权和最小</p><p>算法：找到图的最小生成树，从起点开始，按照先根/后根/中序遍历，走完整个生成树</p><p>近似比：设该算法的答案为<spanclass="math inline">\(C\)</span>，最优解为<spanclass="math inline">\(C^*\)</span>，则<spanclass="math inline">\(C&lt;C^*&lt;2C\)</span></p><ol type="1"><li>最优解一定比<spanclass="math inline">\(C\)</span>大：因为最小生成树是TSP问题的一个松弛解(要求更低的解)</li></ol>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS10：NP完全性</title>
      <link href="/2024/06/13/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/10.NP%E5%AE%8C%E5%85%A8%E6%80%A7/"/>
      <url>/2024/06/13/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/10.NP%E5%AE%8C%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="np完全性-np-completeness">NP完全性 NP-Completeness</h1><h2 id="一基础概念">一、基础概念</h2><h3 id="可计算的问题">1.1 可计算的问题</h3><ol type="1"><li><strong>computationalproblem</strong>：可以通过计算机，一步一步的在有限时间内解出答案。分为以下4类<ol type="1"><li>Decision problem：判断是否存在一个可行解</li><li>Search problem：找到一个可行解</li><li>Optimization problem：找到一个最优的可行解</li><li>Counting problem：计算有多少种可行解</li></ol></li><li>事实：<ol type="1"><li>Decision problem比Optimization problem简单<ol type="1"><li>如果优化问题有解，则判定问题必然有解</li><li>如果判定问题很难，则优化问题必然很难</li></ol></li><li>对于每一个优化问题<spanclass="math inline">\(X\)</span>，通过加一些边界，可以将其转化为一个判定问题<spanclass="math inline">\(X&#39;\)</span></li></ol></li><li>当我们定义<span class="math inline">\(P\)</span>和<spanclass="math inline">\(NP\)</span>问题的时候，我们只考虑判定问题</li></ol><h3 id="简单or难问题">1.2 简单or难问题</h3><ol type="1"><li>easy problem：多项式时间内，可以解决</li><li>hard problem：指数时间甚至更长</li></ol><h3 id="问题的编码">1.3 问题的编码</h3><ol type="1"><li>通过二进制字符串，将问题的输入重新编码<strong>encode</strong></li><li><strong>InputSize</strong>：将输入编码为二进制串后，输入的大小即为二进制串的长度</li><li><strong>polynomial-time algorithm</strong>：最坏的运行时间为<spanclass="math inline">\(O(n^k)\)</span></li><li><strong>Polynomial-Time SolvableProblems</strong>：存在一个多项式时间的算法，可以正确的解决所有的输入</li></ol><h2 id="二machine计算的模型">二、Machine：计算的模型</h2><h3 id="turing-machine">2.1 Turing machine</h3><ol type="1"><li><strong>Turingmachine</strong>：有若干条纸带和若干个针头，下一步取决于之前的状态，有限个状态的控制</li></ol><h3 id="random-access-machineram">2.2 Random Access Machine(RAM)</h3><ol type="1"><li><p><strong>Random Access Machine(RAM)</strong>：</p><ol type="1"><li>有一个控制器，多个寄存器，一个内存</li><li>每个寄存器和内存存储一个整数</li><li>对寄存器进行算术/比较运算，通过一个特殊的寄存器，从内存中读取/存入值，这些都视为一步</li><li>循环和子程序不考虑简单操作，他们是一系列单步运算</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611152934642.png" alt="image-20240611152934642" style="zoom:80%;" /></p></li><li><p>广义邱奇-图灵论题：</p><ol type="1"><li>任何可以在物理上由一个计算机<strong>M</strong>在<strong>T(n)</strong>的时间内解决的<strong>language</strong>，都可以通过图灵机在<strong><spanclass="math inline">\(O(T(n)^k)\)</span></strong>的时间内解决</li><li>其中，<strong>k</strong>只与<strong>M</strong>有关</li></ol></li></ol><h3 id="language等价决策问题">2.3 Language：等价决策问题</h3><ol type="1"><li><strong>A language L over <spanclass="math inline">\(\sum\)</span></strong>：由Σ中的字符定义的任意一个字符串</li><li><strong>A language</strong>：语言是问题的形式化表达</li><li>图灵机<strong>M</strong>判定语言<strong>L</strong>：<ol type="1"><li>当任意一个输入<strong><span class="math inline">\(x \inL\)</span></strong>时，<strong>M</strong>停止在<strong>accepting</strong>的状态</li><li>当任意一个输入<strong><span class="math inline">\(x \notinL\)</span></strong>时，<strong>M</strong>停止在<strong>rejecting</strong>的状态</li></ol></li><li>算法<strong>A</strong>接受<strong>x</strong>：<strong>A(x) =1</strong>；算法<strong>A</strong>拒绝<strong>x</strong>：<strong>A(x) =0</strong></li><li>算法<strong>A</strong>判定语言<strong>L</strong>：<ol type="1"><li>所有在<strong>L</strong>中的二进制串都被<strong>A</strong>接受</li><li>所有不在<strong>L</strong>中的二进制串都被<strong>A</strong>拒绝</li></ol></li><li><strong>Decision problem or language X</strong><ol type="1"><li>问题<strong>X</strong>是一个字符串的集合</li><li>实例<strong>s</strong>是一个字符串</li><li>算法<strong>A</strong>决定问题<strong>X</strong>：<spanclass="math inline">\(A(s)=yes \harr s\in X\)</span></li></ol></li></ol><h3 id="nondeterministic-turing-machine非确定性图灵机">2.4Nondeterministic Turing Machine：非确定性图灵机</h3><p>​从历史上看，<strong>NDTM</strong>和标准<strong>TM</strong>之间的唯一区别是<strong>NDTM</strong>有两个转换函数<strong>δ0</strong>和<strong>δ1</strong>，<strong>NDTM</strong>可以在它们之间进行选择。</p><p>​我们赋予它一种神奇的能力，可以分裂成两个副本，每个副本都有不同的部分告诉它接下来要做什么。这些副本可以进一步分裂成指数级的副本或分支。</p><p>​如果任何一个分支接受了，那么我们就说机器作为一个整体接受了；如果没有，机器就会报废。</p><p>​一个非确定性图灵机可以自由地从一个有限集合中选择它的下一步。如果这些步骤中有一个找到了解决方案，它总是会选择正确的那一个。</p><ol type="1"><li><strong>witness</strong>：提供了一系列选择，引导机器走向<strong>accepting</strong>的分支</li><li>语言<strong>L</strong> 被 非确定性图灵机 判定：<ol type="1"><li>对于任意<strong><span class="math inline">\(x \inL\)</span></strong>，存在一个<strong>witnessw</strong>使得<strong>M(x,w)</strong>接受</li><li>对任意<strong><span class="math inline">\(x \notinL\)</span></strong>，不存在一个<strong>witnessw</strong>使得<strong>M(x,w)</strong>接受</li></ol></li><li><strong>A verification algorithm A(x,y)：</strong>验证算法<strong>A(x,y)</strong><ol type="1"><li><strong>x</strong>：正常的输入</li><li><strong>y</strong>：证书</li><li>算法判断对于<strong>x</strong>，是否存在一个<strong>y</strong>，使得<strong>A(x,y)=1</strong></li></ol></li></ol><h2 id="三-complexity-class">三、 Complexity class</h2><ol type="1"><li><strong>P</strong>：可以在多项式时间内，解决的判定、解决问题<ol type="1"><li>存在一个多项式时间的确定性算法<strong>A</strong>，能够判定<strong>L</strong></li></ol></li><li><strong>NP</strong>：可以在多项式时间内，判定是否为Yes；不能在多项式时间内，计算出来结果<ol type="1"><li>存在一个非确定性多项式时间算法<strong>A</strong>，能够判定<strong>L</strong><ol type="1"><li>对于任意<strong><span class="math inline">\(x \inL\)</span></strong>，<strong>A</strong>有一些不确定的走法选择，使<strong>A</strong>接受<strong>x</strong><br /></li><li>对任意<strong><span class="math inline">\(x \notinL\)</span></strong>，没有走法选择，使<strong>A</strong>接受<strong>x</strong></li></ol></li><li>语言<strong>L</strong>有一个有效的证明者<strong>A(x,y)</strong>，算法<strong>A</strong>在多项式时间内验证语言<strong>L</strong><ol type="1"><li>对于任意<strong><span class="math inline">\(x \inL\)</span></strong>，存在一个长度为<strong>|x|</strong>的多项式复杂度内的<strong>certificate</strong><strong>y</strong>，使得<strong>A(x,y) = 1</strong></li><li>对任意<strong><span class="math inline">\(x \notinL\)</span></strong>，不存在<strong>y</strong>，使得<strong>A(x,y) =1</strong></li></ol></li></ol></li><li><strong>co-NP</strong>：可以在多项式时间内，判定是否为No，是<strong>NP</strong>问题的反面</li><li>定理：判断问题<strong><span class="math inline">\(X \in P \harr\overline X \notin P\)</span> </strong></li><li>问题是否容易处理<ol type="1"><li><strong>tractable</strong>易处理的：多项式时间内可以解决</li><li><strong>intractable</strong>不易处理的：需要指数的时间来解决</li></ol></li></ol><h2id="四reductions-and-np-complete-problems归约和np完全问题">四、Reductionsand NP-complete problems：归约和NP完全问题</h2><ol type="1"><li>(<strong>Turing归约</strong>)问题<strong>A</strong> 可以归约到问题<strong>B</strong>：<span class="math inline">\(A \le_T B\)</span><ol type="1"><li>解决<strong>B</strong>的算法 可以用来 解决<strong>A</strong></li><li><strong>A</strong> 比 <strong>B</strong> 容易</li><li>问题<strong>A</strong>可以转化为问题<strong>B</strong>的一个子问题</li></ol></li><li>(<strong>Cook归约</strong>)问题<strong>A</strong> 可以多项式归约到问题<strong>B</strong>：<span class="math inline">\(A \le_P B\)</span><ol type="1"><li>问题<strong>A</strong> 可以 归约到 <strong>B</strong></li><li>可以通过多项式次调用<strong>B</strong>的子进程，然后进行多项式次运算得到问题A的答案</li><li><strong>A</strong> 比 <strong>B</strong> 容易</li></ol></li><li>(<strong>Karp归约</strong>)：<ol type="1"><li>如果存在一个多项式时间可以计算的函数<strong>f</strong>，使得对任意<strong><spanclass="math inline">\(x∈L1 \harrf(x)∈L2\)</span></strong>，则<strong>L1</strong>可以多项式归约到<strong>L2</strong></li></ol></li><li>证明<strong>A</strong>可以多项式归约到<strong>B</strong>：<ol type="1"><li>找到一个可以在多项式时间内计算的函数<spanclass="math inline">\(f\)</span></li><li>证明：若<span class="math inline">\(x∈A\)</span>，则<spanclass="math inline">\(f(x)∈B\)</span></li><li>证明：若<span class="math inline">\(f(x)∈B\)</span>，则<spanclass="math inline">\(x∈A\)</span>；或者证明：若<spanclass="math inline">\(x\notin A\)</span>，则<spanclass="math inline">\(f(x)\notin B\)</span></li></ol></li><li><strong>NP-Hard</strong>问题<ol type="1"><li><span class="math inline">\(\forall L&#39;\in NP,L&#39;\le_PL\)</span></li></ol></li><li><strong>NP-Complete</strong>问题：<ol type="1"><li><span class="math inline">\(\forall L&#39;\in NP,L&#39;\le_PL\)</span></li><li><span class="math inline">\(L \in NP\)</span></li></ol></li><li>证明一个问题是<strong>NP-Complete</strong>问题<ol type="1"><li>证明：<span class="math inline">\(L∈NP\)</span></li><li>选择一个<strong>NPC</strong>问题<strong>L‘</strong>，证明<strong>L’</strong>可以多项式归约到 <strong>L</strong></li></ol></li></ol><h2 id="五npc问题">五、NPC问题</h2><h3 id="sat问题">5.1 SAT问题</h3><ol type="1"><li>给定一个<strong>CNF</strong>的关系式<strong>Φ</strong>，判断是否存在一组变量的取值，使得Φ为真</li><li><strong>k-SAT</strong>：<strong>Φ</strong>有<strong>k</strong>个变量</li></ol><h3 id="clique问题">5.2 clique问题</h3><ol type="1"><li><p>给定一个<strong>k</strong>，判断在图中是否有<strong>size</strong>为<strong>k</strong>的团</p></li><li><p>团：从图中选择一些点，这些点两两之间均有边相连</p></li><li><p>证明团问题是NPC问题：</p><ol type="1"><li><p>证明：<strong>clique <span class="math inline">\(\in\)</span>NP</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611152948403.png" alt="image-20240611152948403" style="zoom:80%;" /></p></li><li><p>证明：<strong>3-SAT <span class="math inline">\(\le_P\)</span>clique</strong>，即证明，<strong>3-SAT</strong>问题 可以转化成<strong>clique</strong>的一个子问题</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611152953066.png" alt="image-20240611152953066" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611152957959.png" alt="image-20240611152957959" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153003599.png" alt="image-20240611153003599" style="zoom:80%;" /></p></li></ol></li></ol><h3 id="顶点覆盖问题">5.3 顶点覆盖问题</h3><ol type="1"><li><p>给定一个无向图G和一个整数K，判断G是否存在一个不超过K个节点的节点集合V‘，使得G中所有的边至少有一个顶点在V’中</p></li><li><p>证明vertex cover是NPC问题</p><ol type="1"><li><p>证明：<strong>vertex cover</strong> <spanclass="math inline">\(\in\)</span> <strong>NP</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153009325.png" alt="image-20240611153009325" style="zoom:80%;" /></p></li><li><p>证明：<strong>clique</strong> <spanclass="math inline">\(\le_p\)</span> <strong>vertex cover</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611153013922.png" alt="image-20240611153013922" style="zoom:80%;" /></p></li></ol></li></ol><h2 id="六self-reduction">六、Self-reduction</h2><ol type="1"><li><strong>Self-reduction</strong>：一个问题是自归约的，当且仅当这个问题的搜索问题可以多项式规约到 判定问题</li><li><strong>SAT</strong>问题是<strong>self-reduction</strong>的<ol type="1"><li>对于<strong>k-SAT</strong>问题：通过任取一个变量<strong>xi</strong>，将其分别赋值为0和1，得到两个<strong>(k-1)-SAT</strong>问题，这一步骤是多项式时间的（最多有<strong>2n</strong>种情况）</li><li>而<strong>k-SAT</strong>问题 和 <strong>(k-1)-SAT</strong>问题都是<strong>SAT</strong>问题，因此 <strong>SAT</strong>问题可以多项式归约到 <strong>SAT</strong>问题</li></ol></li><li>所有的<strong>NPC</strong>问题都是<strong>self-reducible</strong></li></ol><h2 id="七例题">七、例题</h2><ol type="1"><li>如果<span class="math inline">\(L_1 \le_p L_2\)</span>并且<spanclass="math inline">\(L_2 \in NP\)</span>，则<spanclass="math inline">\(L_1\in NP\)</span><ul><li>答案：正确</li><li>解析：<span class="math inline">\(P \subeNP\)</span>是一定成立的</li></ul></li><li>所有NP问题，可以在一个非确定图灵机中，在多项式时间内解决<strong>solved</strong><ul><li>答案：正确</li><li>解析：所有NP问题均为判定问题，解决 ==&gt; 判定</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS09：贪心算法</title>
      <link href="/2024/06/12/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/9.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/12/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/9.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="贪心算法-greedy-algorithm">贪心算法 Greedy Algorithm</h1><h2 id="一优化问题-optimization-problems">一、优化问题 OptimizationProblems</h2><ol type="1"><li>给出一组约束条件和一个优化函数</li><li>可行解：满足约束条件的解称为可行解</li><li>最优解：优化函数具有最佳可能值的可行解称为最优解</li></ol><h2 id="二贪心算法-greedy-method">二、贪心算法 Greedy Method</h2><ol type="1"><li><p>在一定的贪心准则下，每个阶段做出最佳决策</p></li><li><p>在一个阶段做出的决定，在以后的阶段不会改变，所以每一个决定都应该确保可行性</p></li></ol><h2 id="三活动的选择问题-activity-selection-problem">三、活动的选择问题Activity Selection Problem</h2><h3 id="问题描述">3.1 问题描述</h3><p>给定一系列活动<spanclass="math inline">\(S=\{a_1,a_2,...a_n\}\)</span>，每个活动<spanclass="math inline">\(a_i\)</span>有一个持续区间<spanclass="math inline">\([s_i,f_i)\)</span></p><p>要求在活动的持续区间不重叠的情况下，选择数目最多的活动</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143137063.png" alt="image-20240611143137063" style="zoom:80%;" /></p><h3 id="dp算法">3.2 DP算法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143143164.png" alt="image-20240611143143164" style="zoom:80%;" /></p><h3 id="贪心算法">3.3 贪心算法</h3><h4 id="算法1找最先来的">3.3.1 算法1：找最先来的</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143147676.png" alt="image-20240611143147676" style="zoom:80%;" /></p><h4 id="算法2找最短的">3.3.2 算法2：找最短的</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143150842.png" alt="image-20240611143150842" style="zoom:80%;" /></p><h4 id="算法3找冲突最少的">3.3.3 算法3：找冲突最少的</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143155491.png" alt="image-20240611143155491" style="zoom:80%;" /></p><h4 id="算法4找结束最早的">3.3.4 算法4：找结束最早的</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143159061.png" alt="image-20240611143159061" style="zoom:80%;" /></p><h4 id="对算法4的证明">3.3.5 对算法4的证明</h4><p>证明思路：有一组最优解与算法4的结果相同</p><p>证明：假设贪心算法选出了n个活动<spanclass="math inline">\(G_n\)</span>，最优解选出了m个活动<spanclass="math inline">\(O_m\)</span>，且<span class="math inline">\(m\gen\)</span></p><ul><li><p>当选第1个活动的时候，由于算法要求，<spanclass="math inline">\(G_1\)</span>的结束时间一定<spanclass="math inline">\(\leq\)</span><spanclass="math inline">\(O_1\)</span>的结束时间</p></li><li><p>假设选第k个活动时，<spanclass="math inline">\(G_{1→k}\)</span>的结束时间均满足<spanclass="math inline">\(\leq\)</span><spanclass="math inline">\(O_{1→k}\)</span>的结束时间，则选第<spanclass="math inline">\(k+1\)</span>个活动的时候，根据贪心策略，<spanclass="math inline">\(G_{k+1}\)</span>的结束时间一定<spanclass="math inline">\(\leq\)</span><spanclass="math inline">\(O_{k+1}\)</span>的结束时间</p></li><li><p>根据上述要求，如果<spanclass="math inline">\(O_m\)</span>包含的点数比<spanclass="math inline">\(G_n\)</span>多，那么剩余的活动，<spanclass="math inline">\(G_n\)</span>也一定能够选择，产生了矛盾，因此<spanclass="math inline">\(G_n\)</span>包含的数目与<spanclass="math inline">\(O_n\)</span>相同</p></li></ul><h3 id="如果每个活动有一个权重要求权重和最大">3.4如果每个活动有一个权重，要求权重和最大</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143246959.png" alt="image-20240611143246959" style="zoom:80%;" /></p><h2 id="四哈夫曼编码-huffman-code">四、哈夫曼编码 Huffman Code</h2><h3 id="贪心思想">4.1 贪心思想</h3><p>将出现频率高的字母，赋予较短的编码</p><h3 id="二叉树表示">4.2 二叉树表示</h3><p>普通编码：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143252097.png" alt="image-20240611143252097" style="zoom:80%;" /></p><p>贪心算法：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143256845.png" alt="image-20240611143256845" style="zoom:80%;" /></p><h3 id="从编码翻译出原文">4.3 从编码翻译出原文</h3><p>要求：所有字母的编码，都不是另一个字母的编码的前缀<strong>prefix</strong></p><p>前缀<strong>prefix</strong>：一个字母的编码，完全包含另一个字母的编码</p><p>方法：将按照二叉树表示，让每一个字母作为二叉树的叶子节点，编码根据路径确定</p><h3 id="哈夫曼编码的算法">4.4 哈夫曼编码的算法</h3><ol type="1"><li>在<strong>n</strong>个节点的集合<spanclass="math inline">\(S\)</span>中，选择出现频率最低的两个点</li><li>频率较低的作为右儿子，较高的作为左儿子</li><li>为这两个点建立一个父节点，其频率为两个儿子的和，然后插入到原来的节点集合<spanclass="math inline">\(S\)</span>中</li><li>重复上述步骤，直到只剩下一个点</li><li>这样便建立出了<strong>Huffman Tree</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143302859.png" alt="image-20240611143302859" style="zoom:80%;" /></p><h3 id="最优解的证明">4.5 最优解的证明</h3><p><strong>引理1：频率低的节点一定放在最下面</strong></p><ol type="1"><li>设<spanclass="math inline">\(C\)</span>是一个字符集，每一个字符<spanclass="math inline">\(c\in C\)</span> 有一个频率<spanclass="math inline">\(c.freq\)</span></li><li>设<span class="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>为<spanclass="math inline">\(C\)</span>中频率最小的两个点</li><li>则存在一个最优的前缀编码，其中<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>的编码与贪心的编码长度相同，并且只有最后一位可能不同</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143307536.png" alt="image-20240611143307536" style="zoom:80%;" /></p><p><strong>引理2：将两个点压缩为一个点后，原来的最优解与现在的最优解相同</strong></p><ol type="1"><li>设<spanclass="math inline">\(C\)</span>是一个字符集，每一个字符<spanclass="math inline">\(c\in C\)</span> 有一个频率<spanclass="math inline">\(c.freq\)</span></li><li>设<span class="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>为<spanclass="math inline">\(C\)</span>中频率最小的两个点</li><li>将字符集<span class="math inline">\(C\)</span>中的<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>用<spanclass="math inline">\(z\)</span>替换(<spanclass="math inline">\(z.freq=x.freq+y.freq\)</span>)，产生一个新的字符集<spanclass="math inline">\(C&#39;\)</span></li><li>设<span class="math inline">\(T&#39;\)</span>表示字符集<spanclass="math inline">\(C&#39;\)</span>的一个最优前缀编码</li><li>将<span class="math inline">\(T&#39;\)</span>中表示<spanclass="math inline">\(z\)</span>的叶节点，替换成一个以<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>为子节点的叶节点，产生一个新的前缀编码<spanclass="math inline">\(T\)</span>，则<spanclass="math inline">\(T\)</span>表示<spanclass="math inline">\(C\)</span>的一个最优前缀编码</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240611143312498.png" alt="image-20240611143312498" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS08：动态规划</title>
      <link href="/2024/06/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/8.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/06/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/8.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="动态规划-dynamic-programming">动态规划 Dynamic Programming</h1><h2 id="一设计dp的方法">一、设计DP的方法</h2><p>(1)描述最优的解决方案</p><p>(2)递归定义最优解</p><p>(3)按照某一顺序进行计算</p><p>(4)重新构造解决策略</p><h2 id="二动态规划的要求">二、动态规划的要求</h2><p>(1)子问题之间有重复</p><p>(2)子结构之间保持最优性：问题由子问题的最优解构成</p><h2 id="三动态规划的方法">三、动态规划的方法</h2><p>(1)上到下：<strong>Memorization</strong>，记忆化，将计算过的结果储存下来</p><p>(2)下到上：<strong>Tabulation</strong>，表格法，迭代的方法构造问题的解</p><h2 id="四ordering-matrix-multiplications">四、Ordering MatrixMultiplications</h2><h3 id="矩阵乘法的定义">1 矩阵乘法的定义</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240521180937829.png" alt="image-20240521180937829" style="zoom:80%;" /></p><h3 id="矩阵链式相乘的顺序与计算次数的关系">2矩阵链式相乘的顺序与计算次数的关系</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240521180950325.png" alt="image-20240521180950325" style="zoom:80%;" /></p><h3 id="问题描述">3 问题描述</h3><p>我们用什么样的顺序，可以用最少的计算时间，来计算<strong>n</strong>个矩阵的乘积</p><h3 id="n个矩阵相乘的可能顺序">4 n个矩阵相乘的可能顺序</h3><p>(1)设<span class="math inline">\(b_n\)</span>表示：n个矩阵<spanclass="math inline">\(M_1*M_2*...*M_n\)</span>的可能顺序，则<spanclass="math inline">\(b_2=1,b_3=2,b_4=5\)</span>，可以计算出<spanclass="math inline">\(b_n=O(\frac{4^n}{n\sqrtn})\)</span>（卡特兰数）</p><p>(2)设<span class="math inline">\(M_{ij}=M_i*...*M_j\)</span>，则<spanclass="math inline">\(M_{1n}=M_1*...*M_n\)</span></p><p>(3)假设我们需要乘<strong>n</strong>个矩阵<spanclass="math inline">\(M_1*...*M_n\)</span>，其中<spanclass="math inline">\(M_i\)</span>是一个<spanclass="math inline">\(r_{i-1}*r_i\)</span>的矩阵</p><p>(4)设<span class="math inline">\(m_{ij}\)</span>表示：<spanclass="math inline">\(M_i*...*M_j\)</span>的最优解，则可以得到递归关系<span class="math display">\[m_{ij}=\begin{cases}0,&amp;\text{if\  i = j}\\min_{i\leq k &lt;j}\{m_{ik}+m_{kj}+r_{i-1}r_kr_j\},&amp;\text{if\  j&gt;i}\end{cases}\]</span></p><h2id="五floyd-warshall多源最短路算法没有负环">五、Floyd-Warshall多源最短路算法(没有负环)</h2><p>(1)设<span class="math inline">\(D^k[i][j]\)</span>表示：从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 的最短路，且只经过编号<spanclass="math inline">\(\leq k\)</span>的点</p><p>​ 且<span class="math inline">\(D^{-1}[i][j]\)</span>表示：从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 的边的边权</p><p>​ <span class="math inline">\(D^{n-1}[i][j]\)</span>表示：从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 的边的最短路</p><p>(2)子问题的转移：</p><p>​ (a)对于第k个点， 有两种情况</p><p>​ A. <span class="math inline">\(k\notin\)</span>最短路，则<spanclass="math inline">\(D^k[i][j]=D^{k-1}[i][j]\)</span></p><p>​ A. <span class="math inline">\(k\in\)</span>最短路，则<spanclass="math inline">\(D^k[i][j]=D^{k-1}[i][k]+D^{k-1}[k][j]\)</span></p><p>​ (b)因此，<span class="math inline">\(D^k[i][j]=min\{D^{k-1}[i][j],D^{k-1}[i][k]+D^{k-1}[k][j]\}\)</span></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            D[i][j]=a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                D[i][j]=<span class="built_in">min</span>(D[i][j],D[i][k]+D[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六最优二叉查找树">六、最优二叉查找树</h2><h3 id="问题描述-1">6.1 问题描述</h3><p>给定<span class="math inline">\(n\)</span>个数<spanclass="math inline">\(w_1&lt;w_2&lt;...&lt;w_n\)</span>，<spanclass="math inline">\(w_i\)</span>的查找频率为<spanclass="math inline">\(p_i\)</span></p><p>构造一个二叉查找树，满足查找的消耗最小</p><p>查找的消耗定义为：<span class="math inline">\(T(n)=\sum_{i=1}^np_i*(1+deep_i)\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240521181007300.png" alt="image-20240521181007300" style="zoom:80%;" /></p><h3 id="求解思路">6.2 求解思路</h3><p>(1)定义<span class="math inline">\(T_{ij}\)</span>表示：<spanclass="math inline">\(w_i...w_j\)</span>的最优二叉查找树</p><p>​ 定义<span class="math inline">\(c_{ij}\)</span>表示：<spanclass="math inline">\(T_{ij}\)</span>的消耗，<spanclass="math inline">\(c_{ii}=0\)</span></p><p>​ 定义<span class="math inline">\(r_{ij}\)</span>表示：<spanclass="math inline">\(T_{ij}\)</span>的根节点</p><p>​ 定义<span class="math inline">\(w_{i}\)</span>表示：<spanclass="math inline">\(T_{ij}\)</span>的权值和，<spanclass="math inline">\(w_{ij}=\sum_{k=i}^j p_k\)</span></p><p>(2)转移方程： <span class="math display">\[\begin{aligned}c_{ij}&amp;=(1*p_k)+(cost(L)+cost(R))+(weight(L)+weight(R)) \\      &amp;(查找根节点的开销)+(查找左右子树原来的开销)+(由于左右子树变深了一层,故其开销要变大)\\      &amp;=p_k+c_{i,k-1}+c_{k+1,j}+w_{i,k-1}+w_{k+1,j}\\      &amp;=w_{ij}+c_{i,k-1}+c_{k+1,j}\\      &amp;=min_{i&lt;k\leq j}\{ w_{ij}+c_{i,k-1}+c_{k+1,j} \} \\r_{ij}&amp;=k,当且仅当c_{ij}=w_{ij}+c_{i,k-1}+c_{k+1,j}在k时取得最小值\end{aligned}\]</span><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240521181020187.png" alt="image-20240521181020187" style="zoom:80%;" /></p><h2 id="七产品组装">七、产品组装</h2><h3 id="问题描述-2">7.1 问题描述</h3><p>同一辆车有两条生产线，每个阶段所需的时间不同</p><p>人们可以在阶段之间改变生产线，但是改变生产线需要一定的时间</p><p>求：最短的组装时间</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240521181033367.png" alt="image-20240521181033367" style="zoom:80%;" /></p><h3 id="解决思路">7.2 解决思路</h3><p>(1)定义<spanclass="math inline">\(f[i][j]\)</span>表示：从起点到状态<spanclass="math inline">\(t_{i,j}\)</span>所需的最短时间</p><p>(2)转移方程： <span class="math display">\[\begin{aligned}f[0][j]&amp;=min\{f[0][j-1]+t[0][j],f[1][j-1]+t[1-&gt;0][j-1] \} \\f[1][j]&amp;=min\{f[1][j-1]+t[1][j],f[0][j-1]+t[0-&gt;1][j-1] \}\end{aligned}\]</span></p><h2 id="八不能使用dp的问题">八、不能使用DP的问题</h2><p>(1)子问题之间有相互依赖关系：如从不同状态转移到当前状态，会导致当前状态的消耗不同</p><p>(2)子问题之间的依赖关系，会形成一个环</p><h2 id="例题背包问题">例题：背包问题</h2><p>有<strong>n</strong>个物品，每个物品的大小为<strong>size[i]</strong>，价值为<strong>value[i]</strong>，求当<strong>size</strong>和不超过<strong>C</strong>时的最大价值</p><ol type="1"><li>定义<strong>OPT(i,v)</strong>表示：在<strong>1~i</strong>中进行选择，总价值为<strong>v</strong>的时候占据的最小空间</li></ol><pre><code>$OPT(i,v)=\min\&#123;OPT(i-1,v), OPT(i-1,v-value[i])+size[i]\&#125;$</code></pre><ol start="2" type="1"><li>定义<strong>OPT(i,C)</strong>表示：在<strong>1~i</strong>中进行选择，占据空间不超过<strong>C</strong>时的最大价值</li></ol><pre><code>$OPT(i,C)=\max\&#123;OPT(i-1,C), OPT(i-1,C-size[i])+value[i]\&#125;$</code></pre>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS07：分治法</title>
      <link href="/2024/06/10/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/7.%E5%88%86%E6%B2%BB%E6%B3%95/"/>
      <url>/2024/06/10/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/7.%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="分治法">分治法</h1><h2 id="一主体思想">一、主体思想</h2><ul><li>将问题<span class="math inline">\(T(N)\)</span>分解为<spanclass="math inline">\(a\)</span>个子问题</li><li>通过递归的方法解决子问题，时间复杂度为<spanclass="math inline">\(T(\frac{N}{b})\)</span></li><li>将子问题的解合并，得到原始问题的解，时间复杂度为<spanclass="math inline">\(f(N)\)</span></li></ul><p>一般的递归：<span class="math inline">\(T(N)=aT(\frac{N}{b})+f(N)\)</span></p><p>降低算法时间的关键：<span class="math inline">\(f(N)\)</span></p><h2 id="二分析算法的时间复杂度">二、分析算法的时间复杂度</h2><h3 id="asymptotic-analysis-渐进分析">2.1 asymptotic analysis渐进分析</h3><ul><li>省略常数项</li><li>省略低阶项</li></ul><h3 id="random-access-modelram随机访问模式">2.2 Random AccessModel–RAM：随机访问模式</h3><p>单元操作，如**+、-、*、/、=、内存读取**，所需时间为常数</p><h2 id="三closest-points-problems">三、Closest Points Problems</h2><h3 id="问题描述">3.1 问题描述</h3><p>给定<strong>n</strong>个点，求这<strong>n</strong>个点两两之间的最短欧氏距离</p><h3 id="解决思路">3.2 解决思路</h3><ul><li>将<strong>n</strong>个点分成两组，每组<strong>n/2</strong>个点，满足<spanclass="math inline">\(x_1\leq x_2\leq...\leq x_n\)</span>，记为<spanclass="math inline">\(L_x,R_x\)</span></li><li>递归解决两组的最短距离</li><li>将子问题合并为原问题</li></ul><h3 id="合并操作">3.3 合并操作</h3><p>设<span class="math inline">\(\delta =min(CPP(L_x),CPP(R_x))\)</span>，将<spanclass="math inline">\(L_x,R_x\)</span>中，与中心距离<spanclass="math inline">\(&lt;\delta\)</span>的点分别取出，记为<spanclass="math inline">\(T_l,T_r\)</span>，令<spanclass="math inline">\(T=T_l \bigcup T_r\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200700159.png" alt="image-20240416200700159" style="zoom: 67%;" /></p><p>假设<span class="math inline">\(\exist P_l\in S_l,P_r \inS_r\)</span>，使得<spanclass="math inline">\(dist(P_l,P_r)=D&lt;\delta\)</span>，则可以得出以下性质</p><h4 id="性质1p_lin-t_lp_rin-t_r即这两点一定在中线两侧">性质1：<spanclass="math inline">\(P_l\in T_l,P_r\inT_r\)</span>，即这两点一定在中线两侧</h4><p>​ 如果<spanclass="math inline">\((P_l,P_r)\)</span>属于同一侧，表明在<spanclass="math inline">\(T_l\)</span>或<spanclass="math inline">\(T_r\)</span>的一侧能够找到两个点，使其距离&lt;<spanclass="math inline">\(\delta\)</span>，与<spanclass="math inline">\(\delta\)</span>的定义矛盾</p><h4id="性质2任意一对p_lp_r一定存在一个以中线为轴的2deltadelta的矩形区域将它们包含在内">性质2：任意一对<spanclass="math inline">\(P_l,P_r\)</span>，一定存在一个以中线为轴的<spanclass="math inline">\(2\delta*\delta\)</span>的矩形区域，将它们包含在内</h4><p>​ 假设<spanclass="math inline">\(P_l,P_r\)</span>没有位于该区域，以图中所示的红线相连的两个点为例</p><p>​ 可见，其距离一定会大于<spanclass="math inline">\(\delta\)</span>，即<spanclass="math inline">\(dist(P_l,P_r)&gt;\delta\)</span>，与<spanclass="math inline">\(dist(P_l,P_r)=D&lt;\delta\)</span>矛盾</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200713213.png" alt="image-20240416200713213" style="zoom:80%;" /></p><h4id="性质3以中线为轴的2deltadelta的矩形区域内至多包含t中的6个点且t_l和t_r中各至多有4个">性质3：以中线为轴的<spanclass="math inline">\(2\delta*\delta\)</span>的矩形区域内至多包含T中的6个点，且<spanclass="math inline">\(T_l\)</span>和<spanclass="math inline">\(T_r\)</span>中各至多有4个</h4><p>​ 取<spanclass="math inline">\(2\delta*\delta\)</span>矩形的右半边出来，即为<spanclass="math inline">\(\delta*\delta\)</span>的小矩形</p><p>​假设已经有4个点分布在这个矩形的四个角，那么矩形内部无法再有任何点的存在。因为这个小矩形<spanclass="math inline">\(\inT\)</span>，假设如果小矩形内还有一个红点，令其与其余四点的距离均最远，那么红点必定位于小矩形的中心位置，距离其余四点的距离为<spanclass="math inline">\(\frac{\sqrt{n}}{2}\delta\)</span>，与<spanclass="math inline">\(\delta\)</span>的定义矛盾。</p><p>​因此，左右两边的小矩形最多有4个点。而由于两个小矩形会有两个点重合，因此<spanclass="math inline">\(2\delta*\delta\)</span>的矩形区域内至多有6个点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200722688.png" alt="image-20240416200722688" style="zoom:80%;" /></p><p>根据上述性质，我们可以得出：</p><p>(1)如果把<span class="math inline">\(T\)</span>中的点按照<spanclass="math inline">\(Y\)</span>坐标升序排序，任取一点<spanclass="math inline">\(T[i]\)</span>，<spanclass="math inline">\(T[i+7]\)</span>与<spanclass="math inline">\(T[i]\)</span>的距离一定超过<spanclass="math inline">\(\delta\)</span></p><p>(2)如果把<span class="math inline">\(T_l\)</span>中的点按照<spanclass="math inline">\(Y\)</span>坐标升序排序，任取一点<spanclass="math inline">\(T_l[i]\)</span>，<spanclass="math inline">\(T_l[i+5]\)</span>与<spanclass="math inline">\(T_l[i]\)</span>的距离一定超过<spanclass="math inline">\(\delta\)</span>，<spanclass="math inline">\(T_r\)</span>同理</p><h3 id="合并的具体操作">合并的具体操作</h3><ol type="1"><li>设<span class="math inline">\(\delta =min(CPP(L_x),CPP(R_x))\)</span>，将<spanclass="math inline">\(L_x,R_x\)</span>中，与中心距离<spanclass="math inline">\(&lt;\delta\)</span>的点分别取出，记为<spanclass="math inline">\(T_l,T_r\)</span>，令<spanclass="math inline">\(T=T_l \bigcup T_r\)</span></li><li>将<span class="math inline">\(T\)</span>中的点按照<spanclass="math inline">\(Y\)</span>坐标升序排列，对每一个<spanclass="math inline">\(T[i]\)</span>，计算其与<spanclass="math inline">\(T[i+1] →T[i+6]\)</span>的距离，并更新答案</li></ol><h2 id="四递归树-recursion-tree-method">四、递归树 Recursion-treemethod</h2><ul><li>树的每一个节点，表示该节点消耗的时间</li><li>整个问题消耗的时间，为所有节点加起来的结果</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200742324.png" alt="image-20240416200742324" style="zoom:80%;" /></p><h3 id="例tn2tfracn2fracnlog-nrightarrow-onlog-log-n">例：<spanclass="math inline">\(T(n)=2T(\frac{n}{2})+\frac{n}{log\ n}\rightarrowO(nlog\ log\ n)\)</span></h3><p><span class="math display">\[\begin{aligned}T(n)&amp;=2T(\frac{n}{2})+\frac{n}{log\ n} \\    &amp;=\frac{n}{log\ n}+2*\frac{n/2}{log\n/2}+...+2^k*\frac{n/2^k}{log\ n/2^k} \\    &amp;=\sum_{k=0}^{log\ n}2^k*\frac{n/2^k}{log\ n/2^k} \\    &amp;=n*\sum_{k=0}^{log\ n} \frac{1}{log\ n/2^k} \\    &amp;=n*\sum_{k=0}^{log\ n} \frac{1}{log\ n - k*log\ 2} \\    &amp;=n*\sum_{k=0}^{log\ n}\frac{1}{log\ n - k} \\    &amp;=n*\sum_{k=0}^{log\ n}\frac{1}{k} \\    &amp;=n*(1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{log\ n})\\    &amp;=n*log log\ n\end{aligned}\]</span></p><h3 id="例tn8tfracn2o1n2geq-m-mn2-m-rightarrow-ofracn3sqrt-m">例：<spanclass="math inline">\(T(n)=8*T(\frac{n}{2})+O(1),n^2\geq m; m,n^2&lt; m\rightarrow O(\frac{n^3}{\sqrt m})\)</span></h3><p>建立递归树：</p><ul><li>树的每一个节点的时间复杂度为<spanclass="math inline">\(O(1)\)</span></li><li>树的每一层有<span class="math inline">\(8^k\)</span>个节点</li><li><span class="math inline">\(n^2&gt;m \rightarrow \frac{n}{\sqrtm}&gt;1\)</span>，因此树有<span class="math inline">\(log\frac{n}{\sqrtm}\)</span>层</li></ul><p>时间复杂度为：<span class="math inline">\(8^{log\frac{n}{\sqrtm}}*m=O(\frac{n^3}{\sqrt m})\)</span></p><h3 id="例tntfracn6tfrac7n9on-rightarrow-on">例：<spanclass="math inline">\(T(n)=T(\frac{n}{6})+T(\frac{7n}{9})+O(n)\rightarrow O(n)\)</span></h3><p><span class="math inline">\(T(n)=2T(\frac{n}{6}) +O(n)\)</span>：<spanclass="math inline">\(a=2,b=6,N^{log_ba}=N^{log_62}&lt;N\)</span> =&gt;<span class="math inline">\(T(N)=O(N)\)</span></p><p><span class="math inline">\(T(n) = 2T(\frac{7n}{9}) +O(n)\)</span>：<spanclass="math inline">\(a=2,b=\frac{9}{7},N^{log_ba}=N^{log_{\frac{9}{7}}2}&gt;N\)</span>=&gt; <spanclass="math inline">\(T(N)=O(N^{log_{\frac{9}{7}}2})=O(N^{2.75})\)</span></p><h2 id="五主定理">五、主定理</h2><h3 id="fn直接给出">5.1 f(N)直接给出</h3><p>设<spanclass="math inline">\(T(N)=aT(\frac{N}{b})+f(N)\)</span>，则</p><ul><li>若<spanclass="math inline">\(f(N)&lt;O(N^{log_ba})\)</span>，则<spanclass="math inline">\(T(N)=\Theta(N^{log_ba})\)</span></li><li>若<span class="math inline">\(f(N)=O(N^{log_ba})\)</span>，则<spanclass="math inline">\(T(N)=\Theta(f(N)*log_bN)\)</span></li><li>若<spanclass="math inline">\(f(N)&gt;O(N^{log_ba})\)</span>，则<spanclass="math inline">\(T(N)=\Theta(f(N))\)</span></li></ul><h3 id="fn为递归表示">5.2 f(N)为递归表示</h3><p>设<spanclass="math inline">\(T(N)=aT(\frac{N}{b})+f(N)\)</span>，则</p><ul><li>若<spanclass="math inline">\(f(N)&lt;af(\frac{N}{b})\)</span>，则<spanclass="math inline">\(T(N)=\Theta(N^{log_ba})\)</span></li><li>若<span class="math inline">\(f(N)=af(\frac{N}{b})\)</span>，则<spanclass="math inline">\(T(N)=\Theta(f(N)*log_bN)\)</span></li><li>若<spanclass="math inline">\(f(N)&gt;af(\frac{N}{b})\)</span>，则<spanclass="math inline">\(T(N)=\Theta(f(N))\)</span></li></ul><h3 id="fn直接给出-1">5.3 f(N)直接给出</h3><p>设<span class="math inline">\(T(N)=aT(\frac{N}{b})+\Theta(N^k log^pN)\)</span>，且<span class="math inline">\(a\geq 1,b&gt;1,p\geq0\)</span>，则</p><ul><li>若<span class="math inline">\(a&gt;b^k\)</span>，则<spanclass="math inline">\(T(N)=O(N^{log_b a})\)</span></li><li>若<span class="math inline">\(a=b^k\)</span>，则<spanclass="math inline">\(T(N)=O(N^k log^pN*log_bN)\)</span></li><li>若<span class="math inline">\(a&lt;b^k\)</span>，则<spanclass="math inline">\(T(N)=O(N^k log^{p}N)\)</span></li></ul><h1 id="例题">例题</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200924486.png" alt="image-20240416200924486" style="zoom:80%;" /><span class="math display">\[\begin{aligned}&amp;设m=log\ n,则2^m=n \rightarrow T(2^m)=2T(2^{\frac{m}{2}})+m \\&amp;设G(m)=T(2^m),则 \\&amp;原式转化为:G(m)=2G(\frac{m}{2})+m=O(mlog\ m)\\&amp;又\because m=log\ n\\&amp;\therefore T(n)=O(log\ n*log\ log\ n)\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS06：回溯&amp;搜索策略</title>
      <link href="/2024/06/09/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/6.%E5%9B%9E%E6%BA%AF&amp;%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/"/>
      <url>/2024/06/09/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/6.%E5%9B%9E%E6%BA%AF&amp;%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="back-tracking-回溯">Back Tracking 回溯</h1><h2 id="一基本思想">一、基本思想</h2><ul><li>假设有一个部分解<span class="math inline">\((x_1,...x_i)\inS_k\)</span>。</li><li>首先，我们添加<span class="math inline">\(x_{i+1} \inS_{i+1}\)</span></li><li>判断<spanclass="math inline">\((x_1,...,x_i,x_{i+1})\)</span>是否符合条件</li><li>如果符合条件，则接着添加<spanclass="math inline">\(x_{i+2}\)</span></li><li>如果所有<spanclass="math inline">\(x_{i+2}\)</span>均不符合条件，则将<spanclass="math inline">\(x_{i+1}\)</span>剔除<spanclass="math inline">\(S_{i+1}\)</span>，然后，选择另一个<spanclass="math inline">\(x_{i+1}\)</span></li></ul><h2 id="二八皇后问题">二、八皇后问题</h2><h3 id="约束">2.1 约束</h3><ul><li><span class="math inline">\(S_i={1,2,3,4,5,6,7,8}\)</span></li><li>若<span class="math inline">\(i \neq j\)</span>，则<spanclass="math inline">\(x_i \neq x_j\)</span></li><li><span class="math inline">\(\frac{x_i-x_j}{i-j}\neq\pm1\)</span></li></ul><h3 id="搜索树">2.2 搜索树</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200340070.png" alt="image-20240416200340070" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200352565.png" alt="image-20240416200352565" style="zoom:80%;" /></p><h2 id="三收费公路重建问题">三、收费公路重建问题</h2><h3 id="问题描述">3.1 问题描述</h3><p>给定<span class="math inline">\(x\)</span>轴上的n个点，坐标为<spanclass="math inline">\(x_1&lt;x_2&lt;...&lt;x_n\)</span></p><p>此时，每对点之间有<spanclass="math inline">\(\frac{n*(n-1)}{2}\)</span>个距离</p><p>假设<span class="math inline">\(x_1=0\)</span>，给定<spanclass="math inline">\(\frac{n*(n-1)}{2}\)</span>个距离，计算每个点的坐标</p><h3 id="搜索算法">3.2 搜索算法</h3><ul><li>找出最大距离，就是整条路经的长度(<span class="math inline">\(x_0==&gt; x_n\)</span>)</li><li>然后找出次大距离，这是下一个点到起点/终点的距离</li><li>接着在剩下的距离中找最大的距离，这是下一个点到起点/终点的距离</li><li>……</li></ul><p>在这种算法中，可以保证每一步的枚举，最多有两种可能性</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200411259.png" alt="image-20240416200411259" style="zoom:80%;" /></p><h3 id="代码">3.3 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reconstruct</span> <span class="params">( DistType X[ ], DistSet D, <span class="type">int</span> N, <span class="type">int</span> left, <span class="type">int</span> right )</span></span>&#123; </span><br><span class="line">    <span class="comment">/* X[1]...X[left-1] and X[right+1]...X[N] are solved */</span></span><br><span class="line">    <span class="type">bool</span> Found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">Is_Empty</span>( D ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">/* solved */</span></span><br><span class="line">    D_max = <span class="built_in">Find_Max</span>( D );</span><br><span class="line">    <span class="comment">/* option 1：X[right] = D_max */</span></span><br><span class="line">    <span class="comment">/* check if |D_max-X[i]|D is true for all X[i]’s that have been solved */</span></span><br><span class="line">    OK = <span class="built_in">Check</span>( D_max, N, left, right ); <span class="comment">/* pruning */</span></span><br><span class="line">    <span class="keyword">if</span> ( OK ) &#123; <span class="comment">/* add X[right] and update D */</span></span><br><span class="line">        X[right] = D_max;</span><br><span class="line">        <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;left; i++ )  <span class="built_in">Delete</span>( |X[right]-X[i]|, D);</span><br><span class="line">        <span class="keyword">for</span> ( i=right+<span class="number">1</span>; i&lt;=N; i++ )  <span class="built_in">Delete</span>( |X[right]-X[i]|, D);</span><br><span class="line">        Found = <span class="built_in">Reconstruct</span> ( X, D, N, left, right<span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( !Found ) &#123; <span class="comment">/* if does not work, undo */</span></span><br><span class="line">            <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;left; i++ )  <span class="built_in">Insert</span>( |X[right]-X[i]|, D);</span><br><span class="line">            <span class="keyword">for</span> ( i=right+<span class="number">1</span>; i&lt;=N; i++ )  <span class="built_in">Insert</span>( |X[right]-X[i]|, D);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* finish checking option 1 */</span></span><br><span class="line">    <span class="keyword">if</span> ( !Found ) &#123; <span class="comment">/* if option 1 does not work */</span></span><br><span class="line">        <span class="comment">/* option 2: X[left] = X[N]-D_max */</span></span><br><span class="line">        OK = <span class="built_in">Check</span>( X[N]-D_max, N, left, right );</span><br><span class="line">        <span class="keyword">if</span> ( OK ) &#123;</span><br><span class="line">            X[left] = X[N] – D_max;</span><br><span class="line">            <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;left; i++ )  <span class="built_in">Delete</span>( |X[left]-X[i]|, D);</span><br><span class="line">            <span class="keyword">for</span> ( i=right+<span class="number">1</span>; i&lt;=N; i++ )  <span class="built_in">Delete</span>( |X[left]-X[i]|, D);</span><br><span class="line">            Found = <span class="built_in">Reconstruct</span> (X, D, N, left+<span class="number">1</span>, right );</span><br><span class="line">            <span class="keyword">if</span> ( !Found ) &#123;</span><br><span class="line">                <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;left; i++ ) <span class="built_in">Insert</span>( |X[left]-X[i]|, D);</span><br><span class="line">                <span class="keyword">for</span> ( i=right+<span class="number">1</span>; i&lt;=N; i++ ) <span class="built_in">Insert</span>( |X[left]-X[i]|, D);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* finish checking option 2 */</span></span><br><span class="line">    &#125; <span class="comment">/* finish checking all the options */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四回溯的模板">四、回溯的模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Backtracking</span> <span class="params">( <span class="type">int</span> i )</span></span>&#123;   Found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; N )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// solved with (x1, …, xN) </span></span><br><span class="line">    <span class="keyword">for</span> ( each xi shu Si ) &#123; </span><br><span class="line">        <span class="comment">// check if satisfies the restriction R</span></span><br><span class="line">        OK = <span class="built_in">Check</span>((x1, …, xi) , R ); <span class="comment">// pruning </span></span><br><span class="line">        <span class="keyword">if</span> ( OK ) &#123;</span><br><span class="line">            Count xi in;</span><br><span class="line">            Found = <span class="built_in">Backtracking</span>( i+<span class="number">1</span> );</span><br><span class="line">            <span class="keyword">if</span> ( !Found )</span><br><span class="line">                <span class="built_in">Undo</span>( i ); <span class="comment">//recover to (x1, …, xi-1) </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( Found ) <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索策略">搜索策略</h1><p>先找更小的<span class="math inline">\(S_i\)</span></p><h2 id="一评估函数">一、评估函数</h2><p>井字棋的评估函数：</p><p>​ <span class="math inline">\(f(P)=W_{computer}-W_{Human}\)</span></p><p>​ 其中，<span class="math inline">\(W\)</span>表示在情况<spanclass="math inline">\(P\)</span>时，可能会赢的结果(横着三个/竖着三个/斜着三个)</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200504050.png" alt="image-20240416200504050" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200513187.png" alt="image-20240416200513187" style="zoom:80%;" /></p><h2 id="二alpha-beta剪枝">二、<spanclass="math inline">\(\alpha\)</span>-<spanclass="math inline">\(\beta\)</span>剪枝</h2><h3 id="alpha-pruning">2.1 <span class="math inline">\(\alpha\)</span>pruning</h3><p>根节点取子节点的最大值，子节点取其子节点的最小值</p><p>当一个子节点的子节点已经算出来小于同层次的其它值时，此时该节点一定会被放弃，因此不需要计算其它子节点了</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200525786.png" alt="image-20240416200525786" style="zoom:80%;" /></p><h3 id="beta-pruning">2.2 <span class="math inline">\(\beta\)</span>pruning</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200545800.png" alt="image-20240416200545800" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS05：堆--二项堆</title>
      <link href="/2024/06/08/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/5.%E5%A0%86--%E4%BA%8C%E9%A1%B9%E5%A0%86Binomial%20Queue/"/>
      <url>/2024/06/08/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/5.%E5%A0%86--%E4%BA%8C%E9%A1%B9%E5%A0%86Binomial%20Queue/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一定义">一、定义</h1><p>一个<strong>Binomial Queue</strong>是一个堆的集合{<spanclass="math inline">\({B_k,B_{k-1}...B_0}\)</span>}</p><ul><li><span class="math inline">\(B_k\)</span>一共有<spanclass="math inline">\(2^k\)</span>个节点</li><li><span class="math inline">\(B_k\)</span>的根节点有<spanclass="math inline">\(k\)</span>个子节点，分别是<spanclass="math inline">\(B_0,B_1...B_{k-1}\)</span></li><li><span class="math inline">\(B_k\)</span>中深度为d的节点个数为<spanclass="math inline">\(C_k^d\)</span></li></ul><p><span class="math display">\[\begin{aligned}&amp;设B_k中深度为x的节点个数为f(k,x),则\\&amp;\becauseB_k由两个B_{k-1}的树相连得到,其中一个树的根节点作为新树的根节点\\&amp;\therefore f(k,x)=f(k-1,x)+f(k-1,x-1)\\&amp;\therefore f(k,x)=C_k^d\end{aligned}\]</span></p><h1 id="二操作">二、操作</h1><h2 id="findmin">2.1 FindMin</h2><p>找所有根节点中的最小值，时间复杂度为<spanclass="math inline">\(O(log\ N)\)</span></p><p>也可以实时维护一个最小值，时间复杂度为<spanclass="math inline">\(O(1)\)</span></p><h2 id="merge">2.2 Merge</h2><p>类似于二进制加法，将对应的<spanclass="math inline">\(B_i\)</span>树合并</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416195858020.png" alt="image-20240416195858020" style="zoom:80%;" /></p><h2 id="insert">2.3 Insert</h2><p>进行<strong>m</strong>次合并，每一次是将一个树与一个节点合并</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416195952608.png" alt="image-20240416195952608" style="zoom:80%;" /></p><h2 id="delete">2.4 Delete</h2><ul><li>找到最小值</li><li>将最小值删除，此时最小值所在的<spanclass="math inline">\(B_i\)</span>分裂成一个新的<strong>BinomialQueue</strong></li><li>将新的<strong>Binomial Queue</strong>与原有的<strong>BinomialQueue</strong>合并</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200011300.png" alt="image-20240416200011300" style="zoom:80%;" /></p><h2 id="decrease-key">2.4 Decrease Key</h2><p>假设<strong>x</strong>在<spanclass="math inline">\(B_i\)</span>中，变换<strong>x</strong>的数值</p><h1 id="三ppt中的实现">三、PPT中的实现</h1><p>使用<strong>left-child-next-sibling</strong>将多叉树转化为二叉树，此时根节点必然只有左儿子，没有右儿子</p><h2 id="结构体">3.1 结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BinNode</span> *Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Collection</span> *BinQueue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BinNode</span> *BinTree; </span><br><span class="line"><span class="comment">// missing from p.176</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinNode</span> &#123; </span><br><span class="line">ElementType    Element;</span><br><span class="line">Position    LeftChild;</span><br><span class="line">Position     NextSibling;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Collection</span> &#123; </span><br><span class="line"><span class="type">int</span>CurrentSize;  <span class="comment">//total number of nodes</span></span><br><span class="line">BinTreeTheTrees[ MaxTrees ];</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><h2 id="二叉树合并">3.2 二叉树合并</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">CombineTrees</span><span class="params">( BinTree T1, BinTree T2 )</span></span>&#123;  <span class="comment">//merge equal-sized T1 and T2 </span></span><br><span class="line"><span class="comment">//attach the larger one to the smaller one </span></span><br><span class="line">    <span class="keyword">if</span> ( T1-&gt;Element &gt; T2-&gt;Element )</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CombineTrees</span>( T2, T1 );</span><br><span class="line"><span class="comment">//insert T2 to the front of the children list of T1</span></span><br><span class="line">T2-&gt;NextSibling = T1-&gt;LeftChild;</span><br><span class="line">T1-&gt;LeftChild = T2;</span><br><span class="line"><span class="keyword">return</span> T1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416200124758.png" alt="image-20240416200124758" style="zoom:80%;" /></p><h2 id="merge-1">3.3 Merge</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinQueue  <span class="title">Merge</span><span class="params">( BinQueue H1, BinQueue H2 )</span></span>&#123;</span><br><span class="line">    BinTree T1, T2, Carry = <span class="literal">NULL</span>; </span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">if</span> ( H1-&gt;CurrentSize + H2-&gt; CurrentSize &gt; Capacity )  <span class="built_in">ErrorMessage</span>();</span><br><span class="line">H1-&gt;CurrentSize += H2-&gt; CurrentSize;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>, j=<span class="number">1</span>; j&lt;= H1-&gt;CurrentSize; i++, j*=<span class="number">2</span> ) &#123;</span><br><span class="line">    T1 = H1-&gt;TheTrees[i]; T2 = H2-&gt;TheTrees[i]; <span class="comment">/*current trees */</span></span><br><span class="line">    <span class="keyword">switch</span>( <span class="number">4</span>*!!Carry + <span class="number">2</span>*!!T2 + !!T1 ) &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 000</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 001 </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 010 </span></span><br><span class="line">                H1-&gt;TheTrees[i] = T2; </span><br><span class="line">                H2-&gt;TheTrees[i] = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 100 </span></span><br><span class="line">                H1-&gt;TheTrees[i] = Carry; </span><br><span class="line">                Carry = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 011 </span></span><br><span class="line">                Carry = <span class="built_in">CombineTrees</span>( T1, T2 );</span><br><span class="line">                H1-&gt;TheTrees[i] = H2-&gt;TheTrees[i] = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 101 </span></span><br><span class="line">                Carry = <span class="built_in">CombineTrees</span>( T1, Carry );</span><br><span class="line">                H1-&gt;TheTrees[i] = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// 110 </span></span><br><span class="line">                Carry = <span class="built_in">CombineTrees</span>( T2, Carry );</span><br><span class="line">                H2-&gt;TheTrees[i] = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// 111 </span></span><br><span class="line">                H1-&gt;TheTrees[i] = Carry; </span><br><span class="line">                Carry = <span class="built_in">CombineTrees</span>( T1, T2 ); </span><br><span class="line">                H2-&gt;TheTrees[i] = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> H1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deletemin">3.4 DeleteMin</h2><h3 id="注意建立新的h的时候j从ind-1-rightarrow-0">注意：建立新的<spanclass="math inline">\(H&#39;&#39;\)</span>的时候，<spanclass="math inline">\(j\)</span>从<span class="math inline">\(Ind-1\rightarrow 0\)</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ElementType  <span class="title">DeleteMin</span><span class="params">( BinQueue H )</span></span>&#123;</span><br><span class="line">    BinQueue DeletedQueue; </span><br><span class="line">Position DeletedTree, OldRoot;</span><br><span class="line">ElementType MinItem = Infinity;  </span><br><span class="line">    <span class="comment">// the minimum item to be returned </span></span><br><span class="line"><span class="type">int</span> i, j, MinTree; </span><br><span class="line">    <span class="comment">// MinTree is the index of the tree with the minimum item </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">IsEmpty</span>( H ) )  &#123;  </span><br><span class="line">        <span class="built_in">PrintErrorMessage</span>();  </span><br><span class="line">        <span class="keyword">return</span> –Infinity; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MaxTrees; i++) &#123;  </span><br><span class="line">        <span class="comment">// Step 1: find the minimum item </span></span><br><span class="line">    <span class="keyword">if</span>( H-&gt;TheTrees[i] &amp;&amp; H-&gt;TheTrees[i]-&gt;Element &lt; MinItem ) &#123; </span><br><span class="line">MinItem = H-&gt;TheTrees[i]-&gt;Element;  </span><br><span class="line">            MinTree = i;    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">DeletedTree = H-&gt;TheTrees[ MinTree ];  </span><br><span class="line">H-&gt;TheTrees[ MinTree ] = <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="comment">// Step 2: remove the MinTree from H =&gt; H’  </span></span><br><span class="line">OldRoot = DeletedTree; </span><br><span class="line">    <span class="comment">// Step 3.1: remove the root </span></span><br><span class="line">DeletedTree = DeletedTree-&gt;LeftChild;   <span class="built_in">free</span>(OldRoot);</span><br><span class="line">DeletedQueue = <span class="built_in">Initialize</span>();   </span><br><span class="line">    <span class="comment">// Step 3.2: create H”</span></span><br><span class="line">DeletedQueue-&gt;CurrentSize = ( <span class="number">1</span>&lt;&lt;MinTree ) - <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// 2MinTree – 1</span></span><br><span class="line"><span class="keyword">for</span> ( j = MinTree - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --) &#123;  </span><br><span class="line">    DeletedQueue-&gt;TheTrees[j] = DeletedTree;</span><br><span class="line">    DeletedTree = DeletedTree-&gt;NextSibling;</span><br><span class="line">    DeletedQueue-&gt;TheTrees[j]-&gt;NextSibling = <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line">H-&gt;CurrentSize  -= DeletedQueue-&gt;CurrentSize + <span class="number">1</span>;</span><br><span class="line">H = <span class="built_in">Merge</span>( H, DeletedQueue );</span><br><span class="line">    <span class="comment">// Step 4: merge H’ and H”</span></span><br><span class="line"><span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1id="四连续插入n个点的时间复杂度证明">四、连续插入n个点的时间复杂度证明</h1><h2 id="aggregation综合分析">4.1 Aggregation综合分析</h2><p>设<strong>n</strong>为当前<strong>binomialqueue</strong>的大小，当我们插入一个新的节点时，消耗的时间是<strong>n</strong>的二进制表示中，结尾的<strong>1</strong>的个数</p><p>因此，<strong>n</strong>次插入所消费的时间为<strong>1~n</strong>中所有数字的二进制表示中，结尾的<strong>1</strong>的个数之和，而该数值为<spanclass="math inline">\(1*\frac{1}{2}+2*\frac{1}{2^2}+3*\frac{1}{2^3}=\sum_{i=1}^n\frac{i}{2^i}\leq 2\)</span></p><p>因此，总的时间消耗为<spanclass="math inline">\({n}*\sum_{i=1}^n  \frac{i}{2^i}\leq2N\)</span></p><h2 id="potential潜在分析">4.2 Potential潜在分析</h2><p>设合并两个同样大小的二叉树所需的时间为O(1)</p><p>设<spanclass="math inline">\(\Phi_i\)</span>表示：第<strong>i</strong>次合并后，剩余的树的个数，则<spanclass="math inline">\(\Phi_0=0\)</span></p><p>设<spanclass="math inline">\(C_i\)</span>表示：第<strong>i</strong>次合并的实际消耗时间，即<strong>1+被合并的树的个数</strong></p><p>设<span class="math inline">\(\hatC_i\)</span>表示：第<strong>i</strong>次合并的均摊消耗时间</p><p>则，<spanclass="math inline">\(C_i+(\Phi_i-\Phi_{i-1})=2\)</span></p><p>因此，<span class="math inline">\(\sum_{i=1}^{N}C_i + \Phi_N -\Phi_0=2N\)</span></p><p><strong>==&gt;</strong> <spanclass="math inline">\(\sum_{i=1}^{N}C_i= 2N- \Phi_N\leq2N=O(N)\)</span></p><p><span class="math inline">\(T_{worst}=O(log\ N)\)</span>，但是<spanclass="math inline">\(T_{amortized}=2\)</span></p><h1 id="五总代码">五、总代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinomialQueue</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> maxSize = <span class="number">100000</span> + <span class="number">10</span>;<span class="comment">//节点的最大数量</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> maxTrees = <span class="number">30</span>;<span class="comment">//每个BinQueue中包含的最多的BinTree数目</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> INTMIN = <span class="number">-2147483647</span>, INTMAX = <span class="number">2147483647</span>;</span><br><span class="line"><span class="comment">//BinomialQueue每一位的二叉堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinNode</span> &#123;</span><br><span class="line"><span class="type">int</span> element;</span><br><span class="line">BinNode* LeftChild;</span><br><span class="line">BinNode* NextSibling;</span><br><span class="line"><span class="built_in">BinNode</span>() &#123;</span><br><span class="line">element = <span class="number">0</span>;</span><br><span class="line">LeftChild = NextSibling = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BinNode</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">element = x;</span><br><span class="line">LeftChild = NextSibling = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> BinNode* BinTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BinomialQueue本体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line"><span class="type">int</span> CurrentTree;</span><br><span class="line"><span class="comment">//描述当前的BinTree的有哪些</span></span><br><span class="line"><span class="comment">//其二进制位数为1的位在Trees数组中有对应的树</span></span><br><span class="line">BinTree Trees[maxTrees];</span><br><span class="line"><span class="built_in">Collection</span>() &#123;</span><br><span class="line">CurrentTree = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxTrees; i++)</span><br><span class="line">Trees[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Collection</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">CurrentTree = <span class="number">1</span>;</span><br><span class="line">Trees[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">BinNode</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxTrees; i++)</span><br><span class="line">Trees[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第i个BinTree的根节点的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetVal</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Trees[i] == <span class="literal">NULL</span>)<span class="keyword">return</span> INTMAX;</span><br><span class="line"><span class="keyword">return</span> Trees[i]-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CurrentTree == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找当前Binomial Queue中的最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, bit = <span class="number">1</span>; bit &lt;= CurrentTree; i++, bit &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetVal</span>(i) &lt; ans)ans = <span class="built_in">GetVal</span>(i);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找当前Binomial Queue中的最小值对应的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMinIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = INTMAX;</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, bit = <span class="number">1</span>; bit &lt;= CurrentTree; i++, bit &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetVal</span>(i) &lt; ans)ans = <span class="built_in">GetVal</span>(i), index = i;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Collection* BinQueue;</span><br><span class="line"></span><br><span class="line">BinQueue now;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两棵大小相等的树T1,T2</span></span><br><span class="line"><span class="function">BinTree <span class="title">CombineTrees</span><span class="params">(BinTree T1, BinTree T2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将根节点大的树添加到根节点小的树的上面</span></span><br><span class="line"><span class="keyword">if</span> (T1-&gt;element &gt; T2-&gt;element)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CombineTrees</span>(T2, T1);</span><br><span class="line"><span class="comment">//此时,将T2添加到T1上面</span></span><br><span class="line">T2-&gt;NextSibling = T1-&gt;LeftChild;</span><br><span class="line">T1-&gt;LeftChild = T2;</span><br><span class="line"><span class="keyword">return</span> T1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个Binomial Queue</span></span><br><span class="line"><span class="function">BinQueue <span class="title">Merge</span><span class="params">(BinQueue H1, BinQueue H2)</span> </span>&#123;</span><br><span class="line">BinTree T1, T2, Carry = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (H1-&gt;CurrentTree + H2-&gt;CurrentTree &gt; maxSize) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Out of Space&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">H1-&gt;CurrentTree += H2-&gt;CurrentTree;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, bit = <span class="number">1</span>; bit &lt;= H1-&gt;CurrentTree; i++, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">T1 = H1-&gt;Trees[i];</span><br><span class="line">T2 = H2-&gt;Trees[i];</span><br><span class="line"><span class="keyword">switch</span> (<span class="number">4</span> * (!!Carry) + <span class="number">2</span> * (!!T2) + (!!T1)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//000,都没有 ==&gt; 不变</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//001,只有T1 ==&gt; 不变</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//010,只有T2 ==&gt; 将T2赋值给T1</span></span><br><span class="line">H1-&gt;Trees[i] = T2;</span><br><span class="line">H2-&gt;Trees[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//011,有T1,T2 ==&gt; 将T1,T2合并后,赋值给Carry</span></span><br><span class="line">Carry = <span class="built_in">CombineTrees</span>(T1, T2);</span><br><span class="line">H1-&gt;Trees[i] = <span class="literal">NULL</span>;</span><br><span class="line">H2-&gt;Trees[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//100,只有Carry ==&gt; 将Carry赋值给T1</span></span><br><span class="line">H1-&gt;Trees[i] = Carry;</span><br><span class="line">Carry = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//101,有T1,Carry ==&gt; 将T1,Carry合并后,赋值给Carry</span></span><br><span class="line">Carry = <span class="built_in">CombineTrees</span>(T1, Carry);</span><br><span class="line">H1-&gt;Trees[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//110,有T2,Carry ==&gt; 将T2,Carry合并后,赋值给Carry</span></span><br><span class="line">Carry = <span class="built_in">CombineTrees</span>(T2, Carry);</span><br><span class="line">H2-&gt;Trees[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//111,,有T1,T2,Carry ==&gt; 将Carry赋值给H1; 将T1,T2合并后,赋值给Carry</span></span><br><span class="line">H1-&gt;Trees[i] = Carry;</span><br><span class="line">Carry = <span class="built_in">CombineTrees</span>(T1, T2);</span><br><span class="line">H2-&gt;Trees[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> H1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除当前Binomial Queue中的最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteMin</span><span class="params">(BinQueue H)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (H-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Binomial Queue is empty\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到H的最小值,及其对应的下标</span></span><br><span class="line">BinNode* DeletedTree, * OldRoot;</span><br><span class="line"><span class="type">int</span> index = H-&gt;<span class="built_in">GetMinIndex</span>();</span><br><span class="line"><span class="type">int</span> minItem = H-&gt;<span class="built_in">GetVal</span>(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将该BinTree取出并删除</span></span><br><span class="line"><span class="comment">//删除该树后的BinQueue即为H&#x27;</span></span><br><span class="line">DeletedTree = H-&gt;Trees[index];</span><br><span class="line">H-&gt;Trees[index] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将该BinTree的根节点删除</span></span><br><span class="line">OldRoot = DeletedTree;</span><br><span class="line">DeletedTree = DeletedTree-&gt;LeftChild;</span><br><span class="line"><span class="keyword">delete</span> OldRoot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建H&#x27;&#x27;</span></span><br><span class="line">BinQueue DeletedQueue;</span><br><span class="line">DeletedQueue = <span class="keyword">new</span> <span class="built_in">Collection</span>();</span><br><span class="line"><span class="comment">//由于H&#x27;&#x27;是B_&#123;index&#125;树删除根节点之后的所有节点</span></span><br><span class="line"><span class="comment">//因此其包含了B_0 ~ B_&#123;index-1&#125;</span></span><br><span class="line">DeletedQueue-&gt;CurrentTree = (<span class="number">1</span> &lt;&lt; index) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将原来BinTree中的树拆开,赋值给H&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = index - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">DeletedQueue-&gt;Trees[j] = DeletedTree;</span><br><span class="line">DeletedTree = DeletedTree-&gt;NextSibling;</span><br><span class="line">DeletedQueue-&gt;Trees[j]-&gt;NextSibling = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算H&#x27;的CurrentTree</span></span><br><span class="line">H-&gt;CurrentTree -= DeletedQueue-&gt;CurrentTree + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将H&#x27;与H&#x27;&#x27;合并</span></span><br><span class="line">H = <span class="built_in">Merge</span>(H, DeletedQueue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BinomialQueue</span>() &#123;</span><br><span class="line">now = <span class="keyword">new</span> <span class="built_in">Collection</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">now = <span class="keyword">new</span> <span class="built_in">Collection</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">BinQueue tmp = <span class="keyword">new</span> <span class="built_in">Collection</span>(x);</span><br><span class="line">now = <span class="built_in">Merge</span>(now, tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> now-&gt;<span class="built_in">GetMin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">DeleteMin</span>(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">BinomialQueue q;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS04：堆--左偏堆&amp;斜堆</title>
      <link href="/2024/06/07/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/4.%E5%A0%86--%E5%B7%A6%E5%81%8F%E5%A0%86&amp;%E6%96%9C%E5%A0%86/"/>
      <url>/2024/06/07/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/4.%E5%A0%86--%E5%B7%A6%E5%81%8F%E5%A0%86&amp;%E6%96%9C%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p><strong>合并方法：</strong></p><ol type="1"><li>先将<span class="math inline">\(H_2\)</span>合并到<spanclass="math inline">\(H_1\)</span>的右子树中，记录每一步被当作<strong>根</strong>的节点</li><li>从最后一个被当作<strong>根</strong>的节点开始，向上回溯<ol type="1"><li>如果是左偏堆，则根据NPL判断是否需要交换左右子树</li><li>如果是斜堆，则始终交换左右子树</li></ol></li></ol><h1 id="左偏堆-leftist-heap">左偏堆 Leftist Heap</h1><h2 id="一基础概念">一、基础概念</h2><p><strong>Full Binary Tree</strong>：每个节点都有0/2个儿子</p><p><strong>Complete Binary Tree</strong>：除了最后一层，每一层都满了</p><p>堆<strong>Heap</strong>：</p><ul><li>任意一条从根到叶节点的路径，是有序的</li><li>结构性质、顺序性质</li><li>在<strong>O(n)</strong>的时间内，可以将两个堆合并</li></ul><h2 id="二性质">二、性质</h2><p>空路径长度<strong>null pathlength</strong>：<strong>Npl(X)</strong>：</p><ul><li>从节点<strong>x</strong>开始到叶节点的最短的路径长度</li><li><strong>Npl(x) = min{Npl(c) c为x的子节点} + 1</strong></li></ul><p>左偏堆<strong>Leftist Heap</strong>：</p><ul><li>满足顺序性质，但是不满足结构性质(左子树<strong>size</strong>&gt;右子树<strong>size</strong>)</li><li>对于左偏堆中的每个节点<strong>x</strong>，左子节点的空路径长度&gt;=右子节点</li></ul><blockquote><p>节点上的数字，表示当前节点的<strong>Npl</strong>值</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194844582.png" alt="image-20240416194844582" style="zoom:80%;" /></p><p>定理：如果左偏堆的右路径有<strong>r</strong>个节点，那么其至少有<strong><spanclass="math inline">\(2^r\)</span> - 1</strong>个节点 <spanclass="math display">\[\begin{aligned}证明：&amp;1.当r=1时，显然成立 \\     &amp;2.当r&gt;1时，假设k=r-1时，假设成立\\     &amp;设当前节点为a，左子节点为b，右子节点为c\\     &amp;对于此时的根节点，因为右路径为r，因此其NPL(c)\geq r-1\\     &amp;由于左偏堆的性质，此时左子树满足NPL(b)\geq r-1\\     &amp;由假设得，左右子树的节点个数均\geq 2^{r-1}-1 \\     &amp;因此该子树的节点个数\geq 2^r-1\end{aligned}\]</span></p><h2 id="三结构体">三、结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LHeap</span>&#123;</span><br><span class="line">    <span class="type">int</span> element;</span><br><span class="line">    LHeap* Left;</span><br><span class="line">    LHeap* Right;</span><br><span class="line">    <span class="type">int</span> NPL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四合并">四、合并</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LHeap* <span class="title">Merge</span><span class="params">(LHeap* H1, LHeap*H2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(H1 == <span class="literal">NULL</span>) <span class="keyword">return</span> H2;</span><br><span class="line">    <span class="keyword">if</span>(H2 == <span class="literal">NULL</span>) <span class="keyword">return</span> H1;</span><br><span class="line">    <span class="keyword">if</span>(H1-&gt;element &lt; H2-&gt;element) <span class="keyword">return</span> <span class="built_in">Merge1</span>(H1,H2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Merge1</span>(H2,H1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LHeap* <span class="title">Merge1</span><span class="params">(LHeap* H1, LHeap* H2 )</span></span>&#123; </span><br><span class="line"><span class="comment">//H1的根节点的值 &lt; H2的根节点的值</span></span><br><span class="line"><span class="keyword">if</span> (H1-&gt;Left == <span class="literal">NULL</span>)&#123;<span class="comment">//H1为单个节点</span></span><br><span class="line">H1-&gt;Left = H2;<span class="comment">//将H2作为H1的左子树,因为要满足左边的NPL大</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">H1-&gt;Right = <span class="built_in">Merge</span>(H1-&gt;Right,H2);<span class="comment">//将H2与H1的右子树合并</span></span><br><span class="line"><span class="keyword">if</span> (H1-&gt;Left-&gt;Npl &lt; H1-&gt;Right-&gt;Npl)</span><br><span class="line"><span class="built_in">SwapChildren</span>(H1);<span class="comment">//如果左子树的NPL小,则转换左右子树</span></span><br><span class="line">H1-&gt;Npl = H1-&gt;Right-&gt;Npl + <span class="number">1</span>;<span class="comment">//更新根节点的NPL值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> H1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194950545.png" alt="image-20240416194950545" style="zoom:80%;" /></p><h1 id="斜堆-skew-heap">斜堆 Skew Heap</h1><h2 id="一合并">一、合并</h2><h3 id="原理">1.1 原理</h3><p>总是交换左右子树，除非右面路径上的最大节点的子树没有被交换</p><p>任意<strong>M</strong>次连续操作，时间最多为<strong>O(M logN)</strong>，<strong>N=N1+N2</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416195348001.png" alt="image-20240416195348001" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416195402464.png" alt="image-20240416195402464" style="zoom:80%;" /></p><h3 id="代码">1.2 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* lch, * rch;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        data = x;</span><br><span class="line">        lch = rch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node* root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChildren</span><span class="params">(Node* H)</span> </span>&#123;</span><br><span class="line">    Node* temp = H-&gt;lch;</span><br><span class="line">    H-&gt;lch = H-&gt;rch;</span><br><span class="line">    H-&gt;rch = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">Merge</span><span class="params">(Node* H1, Node* H2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (H1 == <span class="literal">NULL</span>)<span class="keyword">return</span> H2;</span><br><span class="line">    <span class="keyword">if</span> (H2 == <span class="literal">NULL</span>)<span class="keyword">return</span> H1;</span><br><span class="line">    <span class="keyword">if</span> (H1-&gt;data &gt; H2-&gt;data) &#123;</span><br><span class="line">        Node* temp = H1;</span><br><span class="line">        H1 = H2;</span><br><span class="line">        H2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (H1-&gt;lch == <span class="literal">NULL</span>)<span class="comment">//H1是单个节点</span></span><br><span class="line">        H1-&gt;lch = H2;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        H1-&gt;rch = <span class="built_in">Merge</span>(H1-&gt;rch, H2);</span><br><span class="line">        <span class="built_in">SwapChildren</span>(H1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二时间复杂度证明">二、时间复杂度证明</h2><p><span class="math display">\[\begin{aligned}定义：&amp;如果节点p的右子树的后代至少为p的后代数的一半，则p为重节点\\     &amp;注意，p节点的后代数包括p本身\\\\     引理1:&amp;在H_1、H_2右路径中的重节点，在H_3中变为了轻节点\\     &amp;假设a为重节点,a要和b合并\\     &amp;(1)a&gt;b,则a的右子树与b合并,并且作为a的左子树,\\     &amp;合并后左子树比右子树大,a变为轻节点\\     &amp;(2)a&lt;b,则a与b的右子树合并,设b的右节点为c\\     &amp;如果a&gt;c,则变为(1)\\     &amp;如果a&lt;c,则变为(2),继续向下处理\\\\引理2:&amp;一棵树,如果其右路径有k个轻节点,则至少有2^k-1个节点\\     &amp;数学归纳法:当前树的节点数\geq 2(2^k-1)+1 \geq 2^{k+1}-1\\\\证明：&amp;设合并前为H_1,H_2，合并后为H_3\\     &amp;\Phi(H_i)=H_i树中，重节点的个数\\     &amp;设一共进行了m次递归,则\\     &amp;\sum_{i=1}^{m} \hat c_i = \sum_{i=1}^{m} c_i+\Phi(H_3)-\Phi(H_1)-\Phi(H_2) \\     &amp;设H_i的右路径中，轻节点有l_i个，重节点有h_i个，则\\     &amp;\sum_{i=1}^{m} c_i \leq l_1 + h_1 + l_2 + h_2 \\     &amp; 令\Delta \Phi=\Phi(H_3)-\Phi(H_1)-\Phi(H_2),由引理1得 \\     &amp;\Delta \Phi \leq l_1 + l_2 - (h_1 + h_2) \\     &amp;\therefore \sum_{i=1}^{m} \hat c_i \leq l_1 + h_1 + l_2 + h_2+ \Delta \Phi \\     &amp;\leq l_1 + h_1 + l_2 + h_2 +  l_1 + l_2 - (h_1 + h_2)\\     &amp;=2(l_1 + l_2),由引理2\\     &amp;=O(log\ n_1)+O(log\ n_2)\end{aligned}\]</span></p><h1 id="例题">例题</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416195550896.png" alt="image-20240416195550896" style="zoom:80%;" /></p><h2 id="右路径上重点轻点的个数为olog-n">右路径上重点、轻点的个数为O(logN)</h2><h1 id="斜堆的代码实现">斜堆的代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkewHeap</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">Node* lch, *rch;</span><br><span class="line"><span class="built_in">Node</span>() &#123;</span><br><span class="line">data = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">lch = rch = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">data = x;</span><br><span class="line">size = <span class="number">1</span>;</span><br><span class="line">lch = rch = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (lch != <span class="literal">NULL</span>) size += lch-&gt;size;</span><br><span class="line"><span class="keyword">if</span> (rch != <span class="literal">NULL</span>) size += rch-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> maxSize = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">Node* root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChildren</span><span class="params">(Node* H)</span> </span>&#123;</span><br><span class="line">Node* temp = H-&gt;lch;</span><br><span class="line">H-&gt;lch = H-&gt;rch;</span><br><span class="line">H-&gt;rch = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">(Node* u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> u-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">Merge</span><span class="params">(Node* H1, Node* H2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (H1 == <span class="literal">NULL</span>)<span class="keyword">return</span> H2;</span><br><span class="line"><span class="keyword">if</span> (H2 == <span class="literal">NULL</span>)<span class="keyword">return</span> H1;</span><br><span class="line"><span class="keyword">if</span> (H1-&gt;data &gt; H2-&gt;data) &#123;</span><br><span class="line">Node* temp = H1;</span><br><span class="line">H1 = H2;</span><br><span class="line">H2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (H1-&gt;lch == <span class="literal">NULL</span>)<span class="comment">//H1是单个节点</span></span><br><span class="line">H1-&gt;lch = H2;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">H1-&gt;rch = <span class="built_in">Merge</span>(H1-&gt;rch, H2);</span><br><span class="line"><span class="built_in">SwapChildren</span>(H1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SkewHeap</span>() &#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">root-&gt;data = x;</span><br><span class="line">root-&gt;size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* now = <span class="keyword">new</span> <span class="built_in">Node</span>(x);</span><br><span class="line">root = <span class="built_in">Merge</span>(root, now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">root = <span class="built_in">Merge</span>(root-&gt;lch, root-&gt;rch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS03：倒排文件索引</title>
      <link href="/2024/06/06/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/3.%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95/"/>
      <url>/2024/06/06/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/3.%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="inverted-file-index">Inverted File Index</h1><p>倒排文件索引</p><h1 id="一定义">一、定义</h1><p>索引<strong>Index</strong>：在文本中 定位给定术语<strong>term</strong> 的一种机制</p><p>倒排文件<strong>InvertedFile</strong>：包含一个指针列表(如页码)，指向文本中出现该术语的所有位置</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194403781.png" alt="image-20240416194403781" style="zoom:80%;" /></p><p>记录：出现频率<strong>Times</strong>、出现的位置</p><p>搜索：从最小频率的<strong>term</strong>开始求交</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(read a document D)&#123;</span><br><span class="line">    <span class="keyword">while</span>(read a term T in D)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Find</span>(Dictionary, T) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">Insert</span>(Dictionary, T);</span><br><span class="line">        &#125;</span><br><span class="line">        Get T<span class="number">&#x27;</span>s posting list;</span><br><span class="line">        Insert a node to T<span class="number">&#x27;</span>s posting list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Write the inverted index to disk;</span><br></pre></td></tr></table></figure><h1 id="二read-a-term">二、Read a term</h1><h2 id="word-stemming词干">2.1 word stemming词干</h2><p>对一个单词进行加工，使之只包含它的骨干</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194454236.png" alt="image-20240416194454236" style="zoom:80%;" /></p><h2 id="stop-words停用词">2.2 stop words停用词</h2><p>对于非常常用的词语，直接过滤掉</p><p>例如：<strong>a, the, it</strong></p><p>注意：<strong>to be or not to be</strong></p><h1 id="三accessing-a-term">三、Accessing a term</h1><p>方法一：Search trees</p><p>方法二：Hashing</p><h1 id="四index">四、Index</h1><h2 id="当空间不足时">4.1 当空间不足时</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BlockCnt = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> ( read a document D ) &#123;</span><br><span class="line">  <span class="keyword">while</span> ( read a term T in D ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( out of memory ) &#123;</span><br><span class="line">      Write BlockIndex[BlockCnt] to disk;</span><br><span class="line">      BlockCnt ++;</span><br><span class="line">      FreeMemory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">Find</span>( Dictionary, T ) == <span class="literal">false</span> )</span><br><span class="line">      <span class="built_in">Insert</span>( Dictionary, T );</span><br><span class="line">    Get T’s posting list;</span><br><span class="line">    Insert a node to T’s posting list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="distributed-indexing分布式索引">5.2 Distributedindexing分布式索引</h2><p>所有的节点保存集合的子集</p><ul><li>先将所有的文档随机分配</li><li>然后再建立索引</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194515555.png" alt="image-20240416194515555" style="zoom:80%;" /></p><h2 id="dynamic-indexing-动态索引">5.3 Dynamic indexing 动态索引</h2><ul><li>文档更新<ul><li>更新字典中已经存在的术语</li><li>向字典中加入新键值</li></ul></li><li>删除文档</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194540645.png" alt="image-20240416194540645" style="zoom:67%;" /></p><h2 id="compression-压缩索引">5.4 Compression 压缩索引</h2><p>保存每个索引与上一个索引位置的差值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194617819.png" alt="image-20240416194617819" style="zoom:80%;" /></p><h2 id="thresholding阈值">5.5 Thresholding阈值</h2><ul><li>文档：只保存通过键值排序的前<strong>x</strong>个文档</li><li>询问：根据查询词的频率升序排序，只根据原始查询条件的一部分</li></ul><h1 id="五搜索引擎的评价">五、搜索引擎的评价</h1><ul><li>编辑索引的速度</li><li>查询的速度</li><li>查询语句的复杂程度</li><li>数据检索性能评估(在正确建立之后)<ul><li>相应时间</li><li>索引空间</li></ul></li><li>信息检索性能评估<ul><li>结果与查询语句的相关性</li></ul></li></ul><h2 id="相关性衡量">5.1 相关性衡量</h2><p>相关性与搜索的人有关，而非与搜索的词语有关</p><ul><li>例如，有的人查“苹果”是为了吃，有的人是为了用</li></ul><p>相关性测量需要3个元素：</p><ul><li>一个测试的文档集<strong>benchmark document</strong></li><li>一个测试的查询集<strong>benchmark suite of queries</strong></li><li>对每隔查询文档进行相关/不相关的二进制评估<strong>binaryassessment</strong></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194704052.png" alt="image-20240416194704052" style="zoom:80%;" /></p><h2 id="precision-and-recall">5.2 Precision and Recall</h2><p><span class="math display">\[\begin{aligned}&amp;精准度Precision：P=\frac{R_R}{R_R+I_R},查询的准确度越多越好\\&amp;召回率Recall：R=\frac{R_R}{R_R+R_N},查询的正确结果越多越好\end{aligned}\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194716878.png" alt="image-20240416194716878" style="zoom:80%;" /></p><p>有的时候，精准度与召回率可能会<strong>同时满足</strong></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS02：平衡树(含实现)--红黑树</title>
      <link href="/2024/06/05/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/2.%E5%B9%B3%E8%A1%A1%E6%A0%91--Red-Black%E6%A0%91/"/>
      <url>/2024/06/05/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/2.%E5%B9%B3%E8%A1%A1%E6%A0%91--Red-Black%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p><ahref="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之原理和算法详细介绍 - 如果天空不死</a></p><h1 id="一定义">一、定义</h1><h2 id="平衡树的定义">1.1 平衡树的定义</h2><p>树的深度为<strong>O(log(n))</strong></p><h2 id="颜色定义">1.2 颜色定义：</h2><ul><li>每一个节点均为<strong>Red</strong>/<strong>Black</strong></li><li>根是<strong>Black</strong>的</li><li>叶节点是<strong>Black</strong>的<ul><li>这里的叶节点指的是为空的叶节点</li></ul></li><li>如果一个节点是<strong>Red</strong>的，那么他的子节点是<strong>Black</strong>的<ul><li>即：两个<strong>Red</strong>节点不能相连</li></ul></li><li>对于任意节点，该节点到后代叶节点的所有简单路径包含的<strong>Black</strong>节点个数相同</li></ul><h1 id="二性质">二、性质</h1><ul><li><strong>bh(x)</strong>：表示从<strong>x</strong>到叶节点的任意一条简单路径，包含的<strong>Black</strong>节点个数</li><li>引理：一个有<strong>n</strong>个内部节点的红黑树，高度最多为<strong>2log(n+1)</strong></li></ul><p>证明(数学归纳法)：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416193648786.png" alt="image-20240416193648786" style="zoom：80%;" /></p><h1 id="三插入">三、插入</h1><h2 id="插入节点">3.1 插入节点</h2><p>将红黑树当作一颗<strong>BST</strong>，将节点插入</p><h2 id="着色为red">3.2 着色为Red</h2><p>此时，新插入的点只可能违背定义(4)：</p><ul><li>如果一个节点是<strong>Red</strong>的，那么他的子节点是<strong>Black</strong>的</li></ul><h2 id="调整为红黑树">3.3 调整为红黑树</h2><p>通过一系列旋转/着色操作，使之重新成为一颗红黑树</p><h3 id="情况1父节点为red叔叔节点为red">3.3.1情况1：父节点为Red，叔叔节点为Red</h3><h4 id="父辈设为black祖先设为red">==&gt; 父辈设为Black，祖先设为Red</h4><h4 id="矛盾上移">==&gt; 矛盾上移</h4><ul><li><p>将 “父节点” 设为<strong>Black</strong></p></li><li><p>将 “叔叔节点” 设为<strong>Black</strong></p></li><li><p>将 “祖父节点” 设为<strong>Red</strong></p></li><li><p>将 “祖父节点” 设为 “当前节点” ，之后继续对 “当前节点”进行操作</p></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416193837380.png" alt="image-20240416193837380" style="zoom：80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416193843638.png" alt="image-20240416193843638" style="zoom：80%;" /></p><h3 id="情况2父节点为red叔叔节点为black当前节点为右儿子">3.3.2情况2：父节点为Red，叔叔节点为Black，当前节点为右儿子</h3><h4 id="左旋父节点">==&gt; 左旋父节点</h4><h4 id="转化为情况3">==&gt; 转化为情况3</h4><ul><li>将 “父节点” 作为 “新的当前节点”</li><li>以 “新的当前节点” 为支点进行 <strong>左旋</strong></li><li>从而变成了情况3</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416193909922.png" alt="image-20240416193909922" style="zoom：80%;" /></p><h3 id="情况3父节点为red叔叔节点为black当前节点为左儿子">3.3.3情况3：父节点为Red，叔叔节点为Black，当前节点为左儿子</h3><h4 id="父节点设为black祖父设为red">==&gt;父节点设为Black，祖父设为Red</h4><h4 id="右旋祖父矛盾解除">==&gt; 右旋祖父，矛盾解除</h4><ul><li><p>将 “父节点” 设为<strong>Black</strong></p></li><li><p>将 “祖父节点” 设为<strong>Red</strong></p></li><li><p>以 “祖父节点” 为支点进行<strong>右旋</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416193923312.png" alt="image-20240416193923312" style="zoom：80%;" /></p><h1 id="四删除">四、删除</h1><h2 id="删除节点">4.1 删除节点</h2><p>将红黑树当作一颗<strong>BST</strong>，将节点删除</p><ul><li><strong>叶节点</strong>：直接删除</li><li><strong>只有1个儿子</strong>：儿子直接顶替</li><li><strong>有2个儿子</strong>：<ul><li>找到 <strong>后继节点</strong></li><li>把 <strong>后继节点</strong> 的内容复制给<strong>该节点</strong>（不复制<strong>Color</strong>）</li><li>删除 <strong>后继节点</strong></li></ul></li></ul><h2 id="调整为红黑树x为左儿子">4.2 调整为红黑树(x为左儿子)</h2><ul><li>如果删除的节点是<strong>Red</strong>，直接删除即可</li><li>如果删除的节点是<strong>Black</strong>，分成4种情况</li></ul><p>设删除后取代原节点的点为<strong>x</strong>(为黑色)，其兄弟节点为<strong>W</strong>，父节点为<strong>A</strong></p><h3 id="情况1w为红色">4.2.1 情况1：w为红色</h3><h4 id="左旋a交换aw颜色">==&gt; 左旋A，交换A&amp;w颜色</h4><h4 id="转化为w为黑的情况">==&gt; 转化为w为黑的情况</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194105356.png" alt="image-20240416194105356" style="zoom:67%;" /></p><ul><li>将<strong>w</strong>和<strong>A</strong>交换颜色</li><li>对<strong>x</strong>的父节点进行左旋</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194115404.png" alt="image-20240416194115404" style="zoom:67%;" /></p><p>将<strong>x</strong>的新兄弟设为<strong>w</strong>，转换为后三种情况的任意一种</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194123965.png" alt="image-20240416194123965" style="zoom:67%;" /></p><h3 id="情况2w为黑色且w的子节点为黑色">4.2.2情况2：w为黑色，且w的子节点为黑色</h3><h4 id="w设为红">==&gt; w设为红</h4><h4 id="左右子树黑高均-1矛盾上移">==&gt; 左右子树黑高均-1，矛盾上移</h4><h4 id="结束时将根设为黑整颗子树黑高不变">==&gt;结束时将根设为黑，整颗子树黑高不变</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194131636.png" alt="image-20240416194131636" style="zoom:67%;" /></p><ul><li>将<strong>w</strong>变为<strong>Red</strong>，这样另一颗子树黑高-1</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194140267.png" alt="image-20240416194140267" style="zoom:67%;" /></p><p>将<strong>A</strong>点视为新的<strong>x</strong>，继续进行修复操作，直到<strong>x</strong>为根节点/为红色时退出。</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194150095.png" alt="image-20240416194150095" style="zoom:67%;" /></p><p>退出后，将<strong>x</strong>设为黑色，保证不会出现相邻红节点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194156042.png" alt="image-20240416194156042" style="zoom:67%;" /></p><h3 id="情况3w为黑色且w的子节点左红右黑">4.2.3情况3：w为黑色，且w的子节点左红，右黑</h3><h4 id="右旋w交换wc颜色">==&gt; 右旋w，交换w&amp;C颜色</h4><h4 id="转化为情况4">==&gt; 转化为情况4</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194202788.png" alt="image-20240416194202788" style="zoom:80%;" /></p><ul><li>令<strong>w</strong>为<strong>Red</strong>，左节点为<strong>Black</strong></li><li>对<strong>w</strong>进行右旋</li><li>转变为情况4：右子节点为红</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194214026.png" alt="image-20240416194214026" style="zoom:67%;" /></p><h3 id="情况4w为黑色且w的右红左任意">4.2.4情况4：w为黑色，且w的右红，左任意</h3><h4 id="w为a色ab设为黑左旋a">==&gt; w为A色，A&amp;B设为黑，左旋A</h4><h4 id="左右子树黑高不变">==&gt; 左右子树黑高不变</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194220460.png" alt="image-20240416194220460" style="zoom:67%;" /></p><p>(1)将<strong>w</strong>变为和<strong>x</strong>的父节点<strong>A</strong>同色</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">w.color = x.prt.color;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194227987.png" alt="image-20240416194227987" style="zoom:67%;" /></p><p>(2)将<strong>w</strong>的父节点<strong>A</strong>、<strong>w</strong>的右子节点<strong>B</strong>设为<strong>Black</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x.prt.color = BLACK;</span><br><span class="line">w.rch.color = BLACK;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194233778.png" alt="image-20240416194233778" style="zoom:67%;" /></p><p>(3)把<strong>x</strong>的父节点<strong>A</strong>进行左旋</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194242039.png" alt="image-20240416194242039" style="zoom: 67%;" /></p><h2 id="删除的时间复杂度">4.2 删除的时间复杂度</h2><ol type="1"><li>重新着色的时间：最坏情况是O(log n)，平均情况是O(1)</li><li>旋转的时间：最多3次</li></ol><h1 id="五作业题">五、作业题</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194253406.png" alt="image-20240416194253406" style="zoom:80%;" /></p><ul class="task-list"><li><label><input type="checkbox" checked="" />A.11是6的父节点，14是红节点</label></li><li><label><input type="checkbox" checked="" />B.8是15的父节点，7是黑节点</label></li><li><label><input type="checkbox" checked="" />C.11是15的父节点，一共有2个红节点</label></li><li><label><input type="checkbox" />D.8是15的父节点，一共有2个红节点</label></li></ul><p>删除之后10之后，有两种情况</p><ul><li>用8顶替10</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194302674.png" alt="image-20240416194302674" style="zoom:80%;" /></p><ul><li>用11顶替10</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416194316471.png" alt="image-20240416194316471" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS02：平衡树(含实现)--B+树</title>
      <link href="/2024/06/04/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/2.%E5%B9%B3%E8%A1%A1%E6%A0%91--B+%E6%A0%91/"/>
      <url>/2024/06/04/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/2.%E5%B9%B3%E8%A1%A1%E6%A0%91--B+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一定义">一、定义</h1><p><span class="math display">\[Depth(M,N)=O(\lceil log_{\lceil \frac{M}{2} \rceil} N \rceil)\]</span></p><p><strong>m</strong>阶<strong>B+</strong>树满足：</p><ul><li>根节点有<strong>2 ~m</strong>个子节点/<strong>0</strong>个子节点</li><li>所有非根非叶节点，有<strong><span class="math inline">\(\lceil\frac{m}{2} \rceil\)</span> ~ m</strong>个子节点</li><li>所有叶节点的深度相同</li><li><strong>非叶节点不保存数据，而是保存索引</strong><ul><li>索引保存对应子节点的最小值</li><li>若有<strong>x</strong>个子节点，则有<strong>x-1</strong>个索引</li></ul></li></ul><blockquote><p>B树的内部节点保存数据，而B+树不保存</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416191812794.png" alt="image-20240416191812794" style="zoom:80%;" /></p><h1 id="二查找">二、查找</h1><p><span class="math display">\[T_{Find}(M,N)=O(log\ N)\]</span></p><blockquote><p>如果有n个子节点，则对应n-1个key值</p></blockquote><ul><li>若<strong>x &lt;key[0]</strong>，则沿指针<strong>child[0]</strong>所指的子树继续查找</li><li>若<strong>key[i] &lt;= x &lt;key[i+1]</strong>，则沿指针<strong>child[i+1]</strong>所指的子树继续查找</li><li>若<strong>x &gt;=key[n-1]</strong>，则沿着指针<strong>child[n]</strong>所指的子树继续查找</li><li>直到找到叶节点为止</li></ul><h1 id="三插入">三、插入</h1><p><span class="math display">\[T(M,N)=O(\frac{M}{log\ M}log\ N)\]</span></p><h2 id="找到关键字x的插入节点">3.1 找到关键字x的插入节点</h2><p>注意：<strong>B+</strong>树的插入节点一定是<strong>叶节点</strong></p><h2 id="插入关键字x">3.2 插入关键字x</h2><ul><li>插入节点有空位置(即原关键字个数<strong>n &lt; m</strong>) ==&gt;直接把关键字<strong>x</strong>有序插入到该节点的合适位置</li><li>插入节点没有空位置(即原关键字个数<strong>n = m</strong>) ==&gt; 分裂<ul><li>将<strong>x</strong>插入，此时该叶节点有<strong>m+1</strong>个</li><li>将该叶节点从中间分裂，变为两个叶节点</li><li>在父节点中建立对应的索引</li></ul></li></ul><h2 id="例1父节点有位置">例1：父节点有位置</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416192331662.png" alt="image-20240416192331662" style="zoom:80%;" /></p><h2 id="例2父节点没有位置">例2：父节点没有位置</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416192412573.png" alt="image-20240416192412573" style="zoom:80%;" /></p><h1 id="四删除">四、删除</h1><h2 id="找到关键字x所在的叶节点">4.1 找到关键字x所在的叶节点</h2><h2 id="删除关键字x">4.2 删除关键字x</h2><ul><li>叶节点的关键字个数 <strong>&gt; ceiling(m/2)</strong> ==&gt;直接删除</li><li>叶节点的关键字个数 <strong>= ceiling(m/2)</strong> ==&gt;删除后，合并兄弟节点<ul><li>将<strong>x</strong>删除，此时该叶节点的关键字个数不足</li><li>将该叶节点与兄弟节点合并</li><li>删除父节点中的对应索引</li></ul></li></ul><h2id="例删除父节点中的索引后父节点个数不足">例：删除父节点中的索引后，父节点个数不足</h2><h1 id="五作业题">五、作业题</h1><p><strong>A B+ tree of order 3 with 21 numbers has at most __ nodes ofdegree 3.</strong></p><ul><li>题目意思：一个3阶B+树，有21个数字，最多有__个节点的度为3</li><li>答案：4</li><li>解答：3阶B+树，每个内点的度为2 or 3，可以是如下类型</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416192554834.png" alt="image-20240416192554834" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS01：平衡树(含实现)--Splay树</title>
      <link href="/2024/06/03/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/1.%E5%B9%B3%E8%A1%A1%E6%A0%91(%E5%90%AB%E5%AE%9E%E7%8E%B0)--Splay%E6%A0%91/"/>
      <url>/2024/06/03/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/1.%E5%B9%B3%E8%A1%A1%E6%A0%91(%E5%90%AB%E5%AE%9E%E7%8E%B0)--Splay%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一原理">一、原理</h1><p>通过伸展操作<strong>Splay(x)</strong>，将<strong>每一次查询的节点旋转到根部</strong>，以让BST尽可能平衡</p><h1 id="二伸展操作">二、伸展操作</h1><ul><li><strong>LL</strong>型：两次右旋，先<strong>x-&gt;prt</strong>，后<strong>x</strong></li><li><strong>RR</strong>型：两次左旋，先<strong>x-&gt;prt</strong>，后<strong>x</strong></li><li><strong>LR</strong>型：先左旋，后右旋，均旋转<strong>x</strong></li><li><strong>RL</strong>型：先右旋，后左旋，均旋转<strong>x</strong></li></ul><h1 id="三删除">三、删除</h1><ul><li><p>如果<strong>x</strong>为叶节点，直接删除</p></li><li><p>如果<strong>x</strong>只有一个子节点，直接删除</p></li><li><p>如果<strong>x</strong>有两个子节点，在<strong>x</strong>的左子树中找到最大的点<strong>y</strong>，将<strong>y</strong>伸展到根节点，然后将<strong>x</strong>的右子树接在<strong>y</strong>的右子树上</p></li></ul><h1 id="四代码实现">四、代码实现</h1><h2 id="伸展">4.1 伸展</h2><p>注意更新指针指向其新的父节点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SplayTree* <span class="title">RotateLeft</span><span class="params">(SplayTree* y)</span> </span>&#123;</span><br><span class="line">SplayTree* x = y-&gt;rch, *z = y-&gt;prt;</span><br><span class="line"><span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (z-&gt;lch == y)z-&gt;lch = x;</span><br><span class="line"><span class="keyword">else</span> z-&gt;rch = x;</span><br><span class="line">&#125;</span><br><span class="line">y-&gt;rch = x-&gt;lch; <span class="keyword">if</span>(x-&gt;lch!=<span class="literal">NULL</span>)x-&gt;lch-&gt;prt = y;</span><br><span class="line">x-&gt;lch = y; y-&gt;prt = x;</span><br><span class="line">x-&gt;prt = z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Update</span>(y);</span><br><span class="line"><span class="built_in">Update</span>(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">RotateRight</span><span class="params">(SplayTree* y)</span> </span>&#123;</span><br><span class="line">SplayTree* x = y-&gt;lch, * z = y-&gt;prt;</span><br><span class="line"><span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (z-&gt;lch == y)z-&gt;lch = x;</span><br><span class="line"><span class="keyword">else</span> z-&gt;rch = x;</span><br><span class="line">&#125;</span><br><span class="line">y-&gt;lch = x-&gt;rch; <span class="keyword">if</span>(x-&gt;rch!=<span class="literal">NULL</span>)x-&gt;rch-&gt;prt = y;</span><br><span class="line">x-&gt;rch = y; y-&gt;prt = x;</span><br><span class="line">x-&gt;prt = z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Update</span>(y);</span><br><span class="line"><span class="built_in">Update</span>(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">Splay</span><span class="params">(SplayTree* x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (x-&gt;prt != <span class="literal">NULL</span>) &#123;<span class="comment">//每一步需要找x-&gt;prt-&gt;prt,x-&gt;prt,x</span></span><br><span class="line">SplayTree* y = x-&gt;prt, * z = x-&gt;prt-&gt;prt;</span><br><span class="line"><span class="keyword">if</span> (z == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (y-&gt;lch == x)x = <span class="built_in">RotateRight</span>(x-&gt;prt);</span><br><span class="line"><span class="keyword">else</span> x = <span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (z-&gt;lch == y &amp;&amp; y-&gt;lch == x) &#123;<span class="comment">//LL型,右旋,先旋转父节点,再旋转x</span></span><br><span class="line">x-&gt;prt = <span class="built_in">RotateRight</span>(x-&gt;prt-&gt;prt);</span><br><span class="line">x = <span class="built_in">RotateRight</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;rch == y &amp;&amp; y-&gt;rch == x) &#123;<span class="comment">//RR型,左旋,先旋转父节点,再旋转x</span></span><br><span class="line">x-&gt;prt = <span class="built_in">RotateLeft</span>(x-&gt;prt-&gt;prt);</span><br><span class="line">x = <span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;lch == y &amp;&amp; y-&gt;rch == x) &#123;<span class="comment">//LR型,左旋、右旋</span></span><br><span class="line">x = <span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br><span class="line">x = <span class="built_in">RotateRight</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//RL型,右旋、左旋</span></span><br><span class="line">x = <span class="built_in">RotateRight</span>(x-&gt;prt);</span><br><span class="line">x = <span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入-bst-splayx">4.2 插入 = BST + Splay(x)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SplayTree* <span class="title">Insert</span><span class="params">(SplayTree* root, SplayTree* prt, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">SplayTree</span>();</span><br><span class="line">root-&gt;data = key;</span><br><span class="line">root-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;prt = prt;</span><br><span class="line">root-&gt;size = <span class="number">1</span>;</span><br><span class="line">root-&gt;sum = <span class="number">1</span>;</span><br><span class="line">now = root;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key == root-&gt;data) &#123;</span><br><span class="line">root-&gt;sum++;</span><br><span class="line">root-&gt;size++;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;data) &#123;<span class="comment">//插入到左子树</span></span><br><span class="line">root-&gt;lch = <span class="built_in">Insert</span>(root-&gt;lch, root, key);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//插入到右子树</span></span><br><span class="line">root-&gt;rch = <span class="built_in">Insert</span>(root-&gt;rch, root, key);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除">4.3 删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SplayTree* <span class="title">Merge</span><span class="params">(SplayTree* left, SplayTree* right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="literal">NULL</span>)<span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">if</span>(right==<span class="literal">NULL</span>)<span class="keyword">return</span> left;</span><br><span class="line">SplayTree* temp = left;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;rch != <span class="literal">NULL</span>)temp = temp-&gt;rch;<span class="comment">//找到左树中最大的数</span></span><br><span class="line">temp = <span class="built_in">Splay</span>(temp);<span class="comment">//将左树中的最大值旋转到根节点,此时根节点没有右儿子</span></span><br><span class="line">temp-&gt;rch = right;<span class="comment">//直接将右树接在左树的右儿子处即可</span></span><br><span class="line">right-&gt;prt = temp;</span><br><span class="line"><span class="built_in">Update</span>(temp);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">Delte</span><span class="params">(SplayTree* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;data)root = root-&gt;lch;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data)root = root-&gt;rch;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//找到该值,进行删除操作</span></span><br><span class="line">root = <span class="built_in">Splay</span>(root);<span class="comment">//将该数旋转到根节点</span></span><br><span class="line">root-&gt;sum--;</span><br><span class="line">root-&gt;size--;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;sum &gt; <span class="number">0</span>)<span class="keyword">return</span> root;</span><br><span class="line"><span class="comment">//根节点需要被删除,只需要将根节点的左右儿子合并即可 </span></span><br><span class="line">SplayTree* left = root-&gt;lch, *right = root-&gt;rch;</span><br><span class="line"><span class="keyword">if</span>(left!=<span class="literal">NULL</span>)left-&gt;prt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(right!=<span class="literal">NULL</span>)right-&gt;prt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">root = <span class="built_in">Merge</span>(left, right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询某数是第几大-bst-splayx">4.4 查询某数是第几大 = BST +Splay(x)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main函数调用时,使用Splay(x)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetRank</span><span class="params">(SplayTree* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (key == root-&gt;data)<span class="comment">//key == 当前节点的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetSize</span>(root-&gt;lch) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data)<span class="comment">//key &gt; 当前节点的值 ==&gt; 在右子树里面</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetSize</span>(root-&gt;lch) + root-&gt;sum + <span class="built_in">GetRank</span>(root-&gt;rch, key);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//key &lt; 当前节点的值 ==&gt; 在左子树里面 </span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetRank</span>(root-&gt;lch, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第k大数-bst-splayx">4.5 第k大数 = BST + Splay(x)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main函数调用时,使用Splay(x)</span></span><br><span class="line"><span class="function">SplayTree* <span class="title">FindByRank</span><span class="params">(SplayTree* root, <span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rank &gt; <span class="built_in">GetSize</span>(root-&gt;lch) + root-&gt;sum)<span class="comment">//比左子树+自己大 ==&gt; 在右子树里</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FindByRank</span>(root-&gt;rch, rank - <span class="built_in">GetSize</span>(root-&gt;lch) - root-&gt;sum);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank &gt; <span class="built_in">GetSize</span>(root-&gt;lch))<span class="comment">//比左子树大 ==&gt; 就是自己</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//比左子树小 ==&gt; 在左子树里</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FindByRank</span>(root-&gt;lch, rank);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前驱-bst-splayx">4.6 前驱 = BST + Splay(x)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main函数调用时,使用Splay(x)</span></span><br><span class="line"><span class="function">SplayTree* <span class="title">FindPre</span><span class="params">(SplayTree* root, <span class="type">int</span> key)</span> </span>&#123;<span class="comment">//找比key小的最大的数</span></span><br><span class="line">SplayTree* ans = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt;= root-&gt;data) &#123;<span class="comment">//root&gt;key,在左子树,注意等号成立时依旧需要向下找</span></span><br><span class="line">root = root-&gt;lch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//root&lt;key,在右子树 </span></span><br><span class="line"><span class="keyword">if</span> (ans == <span class="literal">NULL</span> || ans-&gt;data &lt; root-&gt;data)ans = root;</span><br><span class="line">root = root-&gt;rch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后继-bst-splayx">4.7 后继 = BST + Splay(x)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main函数调用时,使用Splay(x)</span></span><br><span class="line"><span class="function">SplayTree* <span class="title">FindNext</span><span class="params">(SplayTree* root, <span class="type">int</span> key)</span> </span>&#123;<span class="comment">//找比key大的最小的数</span></span><br><span class="line">SplayTree* ans = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;data) &#123;<span class="comment">//root&gt;key,在左子树 </span></span><br><span class="line"><span class="keyword">if</span> (ans == <span class="literal">NULL</span> || ans-&gt;data &gt; root-&gt;data)ans = root;</span><br><span class="line">root = root-&gt;lch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//root&lt;key,在右子树,注意等号成立时依旧需要向下找</span></span><br><span class="line">root = root-&gt;rch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五总代码">五、<ahref="https://darkbzoj.tk/problem/3224">总代码</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="comment">//Splay树</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SplayTree</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="type">int</span> size, sum;</span><br><span class="line">SplayTree* prt, * lch, * rch;</span><br><span class="line">&#125;;</span><br><span class="line">SplayTree* root, * now;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">(SplayTree*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(SplayTree*)</span></span>;</span><br><span class="line"><span class="function">SplayTree* <span class="title">RotateLeft</span><span class="params">(SplayTree*)</span></span>;</span><br><span class="line"><span class="function">SplayTree* <span class="title">RotateRight</span><span class="params">(SplayTree*)</span></span>;</span><br><span class="line"><span class="function">SplayTree* <span class="title">Merge</span><span class="params">(SplayTree*, SplayTree*)</span></span>;</span><br><span class="line"><span class="function">SplayTree* <span class="title">Splay</span><span class="params">(SplayTree*)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">SplayTree* <span class="title">Insert</span><span class="params">(SplayTree*, SplayTree*, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">SplayTree* <span class="title">Delte</span><span class="params">(SplayTree*, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetRank</span><span class="params">(SplayTree*, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">SplayTree* <span class="title">FindByRank</span><span class="params">(SplayTree*, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">SplayTree* <span class="title">FindPre</span><span class="params">(SplayTree*, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">SplayTree* <span class="title">FindNext</span><span class="params">(SplayTree*, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, op, x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">SplayTree* temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">root = <span class="built_in">Insert</span>(root, <span class="literal">NULL</span>, x);</span><br><span class="line">root = <span class="built_in">Splay</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">root = <span class="built_in">Delte</span>(root, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">GetRank</span>(root, x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">temp = <span class="built_in">FindByRank</span>(root, x);</span><br><span class="line">root = <span class="built_in">Splay</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) &#123;</span><br><span class="line">temp = <span class="built_in">FindPre</span>(root, x);</span><br><span class="line">root = <span class="built_in">Splay</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) &#123;</span><br><span class="line">temp = <span class="built_in">FindNext</span>(root, x);</span><br><span class="line">root = <span class="built_in">Splay</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">4</span> || op == <span class="number">5</span> || op == <span class="number">6</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">(SplayTree* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> root-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(SplayTree* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">root-&gt;size = <span class="built_in">GetSize</span>(root-&gt;lch) + <span class="built_in">GetSize</span>(root-&gt;rch) + root-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">RotateLeft</span><span class="params">(SplayTree* y)</span> </span>&#123;</span><br><span class="line">SplayTree* x = y-&gt;rch, * z = y-&gt;prt;</span><br><span class="line"><span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (z-&gt;lch == y)z-&gt;lch = x;</span><br><span class="line"><span class="keyword">else</span> z-&gt;rch = x;</span><br><span class="line">&#125;</span><br><span class="line">y-&gt;rch = x-&gt;lch; <span class="keyword">if</span> (x-&gt;lch != <span class="literal">NULL</span>)x-&gt;lch-&gt;prt = y;</span><br><span class="line">x-&gt;lch = y; y-&gt;prt = x;</span><br><span class="line">x-&gt;prt = z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Update</span>(y);</span><br><span class="line"><span class="built_in">Update</span>(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">RotateRight</span><span class="params">(SplayTree* y)</span> </span>&#123;</span><br><span class="line">SplayTree* x = y-&gt;lch, * z = y-&gt;prt;</span><br><span class="line"><span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (z-&gt;lch == y)z-&gt;lch = x;</span><br><span class="line"><span class="keyword">else</span> z-&gt;rch = x;</span><br><span class="line">&#125;</span><br><span class="line">y-&gt;lch = x-&gt;rch; <span class="keyword">if</span> (x-&gt;rch != <span class="literal">NULL</span>)x-&gt;rch-&gt;prt = y;</span><br><span class="line">x-&gt;rch = y; y-&gt;prt = x;</span><br><span class="line">x-&gt;prt = z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Update</span>(y);</span><br><span class="line"><span class="built_in">Update</span>(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">Splay</span><span class="params">(SplayTree* x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (x-&gt;prt != <span class="literal">NULL</span>) &#123;<span class="comment">//每一步需要找x-&gt;prt-&gt;prt,x-&gt;prt,x</span></span><br><span class="line">SplayTree* y = x-&gt;prt, * z = x-&gt;prt-&gt;prt;</span><br><span class="line"><span class="keyword">if</span> (z == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (y-&gt;lch == x)x = <span class="built_in">RotateRight</span>(x-&gt;prt);</span><br><span class="line"><span class="keyword">else</span> x = <span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (z-&gt;lch == y &amp;&amp; y-&gt;lch == x) &#123;<span class="comment">//LL型,右旋,先旋转父节点,再旋转x</span></span><br><span class="line">x-&gt;prt = <span class="built_in">RotateRight</span>(x-&gt;prt-&gt;prt);</span><br><span class="line">x = <span class="built_in">RotateRight</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;rch == y &amp;&amp; y-&gt;rch == x) &#123;<span class="comment">//RR型,左旋,先旋转父节点,再旋转x</span></span><br><span class="line">x-&gt;prt = <span class="built_in">RotateLeft</span>(x-&gt;prt-&gt;prt);</span><br><span class="line">x = <span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;lch == y &amp;&amp; y-&gt;rch == x) &#123;<span class="comment">//LR型,左旋、右旋</span></span><br><span class="line">x = <span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br><span class="line">x = <span class="built_in">RotateRight</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//RL型,右旋、左旋</span></span><br><span class="line">x = <span class="built_in">RotateRight</span>(x-&gt;prt);</span><br><span class="line">x = <span class="built_in">RotateLeft</span>(x-&gt;prt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">Merge</span><span class="params">(SplayTree* left, SplayTree* right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span>)<span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">if</span> (right == <span class="literal">NULL</span>)<span class="keyword">return</span> left;</span><br><span class="line">SplayTree* temp = left;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;rch != <span class="literal">NULL</span>)temp = temp-&gt;rch;<span class="comment">//找到左树中最大的数</span></span><br><span class="line">temp = <span class="built_in">Splay</span>(temp);</span><br><span class="line">temp-&gt;rch = right;</span><br><span class="line">right-&gt;prt = temp;</span><br><span class="line"><span class="built_in">Update</span>(temp);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SplayTree* <span class="title">Insert</span><span class="params">(SplayTree* root, SplayTree* prt, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">SplayTree</span>();</span><br><span class="line">root-&gt;data = key;</span><br><span class="line">root-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;prt = prt;</span><br><span class="line">root-&gt;size = <span class="number">1</span>;</span><br><span class="line">root-&gt;sum = <span class="number">1</span>;</span><br><span class="line">now = root;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key == root-&gt;data) &#123;</span><br><span class="line">root-&gt;sum++;</span><br><span class="line">root-&gt;size++;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;data) &#123;<span class="comment">//插入到左子树</span></span><br><span class="line">root-&gt;lch = <span class="built_in">Insert</span>(root-&gt;lch, root, key);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//插入到右子树</span></span><br><span class="line">root-&gt;rch = <span class="built_in">Insert</span>(root-&gt;rch, root, key);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">Delte</span><span class="params">(SplayTree* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;data)root = root-&gt;lch;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data)root = root-&gt;rch;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//找到该值,进行删除操作</span></span><br><span class="line">root = <span class="built_in">Splay</span>(root);</span><br><span class="line">root-&gt;sum--;</span><br><span class="line">root-&gt;size--;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;sum &gt; <span class="number">0</span>)<span class="keyword">return</span> root;</span><br><span class="line"><span class="comment">//根节点需要被删除,只需要将根节点的左右儿子合并即可 </span></span><br><span class="line">SplayTree* left = root-&gt;lch, * right = root-&gt;rch;</span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">NULL</span>)left-&gt;prt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (right != <span class="literal">NULL</span>)right-&gt;prt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">root = <span class="built_in">Merge</span>(left, right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetRank</span><span class="params">(SplayTree* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (key == root-&gt;data)<span class="comment">//key == 当前节点的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetSize</span>(root-&gt;lch) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data)<span class="comment">//key &gt; 当前节点的值 ==&gt; 在右子树里面</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetSize</span>(root-&gt;lch) + root-&gt;sum + <span class="built_in">GetRank</span>(root-&gt;rch, key);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//key &lt; 当前节点的值 ==&gt; 在左子树里面 </span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetRank</span>(root-&gt;lch, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">FindByRank</span><span class="params">(SplayTree* root, <span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rank &gt; <span class="built_in">GetSize</span>(root-&gt;lch) + root-&gt;sum)<span class="comment">//比左子树+自己大 ==&gt; 在右子树里</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FindByRank</span>(root-&gt;rch, rank - <span class="built_in">GetSize</span>(root-&gt;lch) - root-&gt;sum);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank &gt; <span class="built_in">GetSize</span>(root-&gt;lch))<span class="comment">//比左子树大 ==&gt; 就是自己</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//比左子树小 ==&gt; 在左子树里</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FindByRank</span>(root-&gt;lch, rank);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">FindPre</span><span class="params">(SplayTree* root, <span class="type">int</span> key)</span> </span>&#123;<span class="comment">//找比key小的最大的数</span></span><br><span class="line">SplayTree* ans = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt;= root-&gt;data) &#123;<span class="comment">//root&gt;key,在左子树 </span></span><br><span class="line">root = root-&gt;lch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//root&lt;key,在右子树 </span></span><br><span class="line"><span class="keyword">if</span> (ans == <span class="literal">NULL</span> || ans-&gt;data &lt; root-&gt;data)ans = root;</span><br><span class="line">root = root-&gt;rch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayTree* <span class="title">FindNext</span><span class="params">(SplayTree* root, <span class="type">int</span> key)</span> </span>&#123;<span class="comment">//找比key大的最小的数</span></span><br><span class="line">SplayTree* ans = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;data) &#123;<span class="comment">//root&gt;key,在左子树 </span></span><br><span class="line"><span class="keyword">if</span> (ans == <span class="literal">NULL</span> || ans-&gt;data &gt; root-&gt;data)ans = root;</span><br><span class="line">root = root-&gt;lch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//root&lt;key,在右子树 </span></span><br><span class="line">root = root-&gt;rch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS01：平衡树(含实现)--AVL树</title>
      <link href="/2024/06/02/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/1.%E5%B9%B3%E8%A1%A1%E6%A0%91(%E5%90%AB%E5%AE%9E%E7%8E%B0)--AVL%E6%A0%91/"/>
      <url>/2024/06/02/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/1.%E5%B9%B3%E8%A1%A1%E6%A0%91(%E5%90%AB%E5%AE%9E%E7%8E%B0)--AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一性质">一、性质</h1><ol type="1"><li>是一个二叉搜索树</li><li>左右子树高度之差的绝对值$$1</li><li>设<span class="math inline">\(n_h\)</span>为高度为<spanclass="math inline">\(h\)</span>的AVL树的最小节点数，则<spanclass="math inline">\(n_h = n_{h-1}+n_{h-2}+1\)</span><ol type="1"><li>可以求得，<spanclass="math inline">\(n_h=Fibonacci_{h+2}-1\)</span></li><li><span class="math inline">\(Fibonacci_{h+2} ≈\frac{1}{\sqrt5}(\frac{1+\sqrt 5}{2})^i\)</span></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170051348.png" alt="image-20240416170051348" style="zoom:80%;" /></p><h1 id="二插入">二、插入</h1><h2 id="bst-插入">2.1 BST 插入</h2><p>正常进行BST的插入操作，然后按照以下步骤调整AVL的平衡性</p><h2 id="平衡调整">2.2 平衡调整</h2><ul><li>找到平衡因子为±2的节点<ul><li>平衡因子 = 左子树高度 - 右子树高度</li></ul></li><li>找插入新节点后，失去平衡的最小子树（只考虑3个节点）<ul><li>距离插入节点最近</li><li>以平衡因子为±2的节点作为根</li><li>子节点的平衡因子为±1</li></ul></li><li>是哪一种类型，要根据 <strong>平衡因子为±2的节点 与插入的节点</strong> 的相对位置来判断</li></ul><h3 id="ll型右旋">2.2.1 LL型：右旋</h3><ul><li>B为根，B的右子树变为A的左子树（中为支，高右转）</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170233325.png" alt="image-20240416170233325" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170243571.png" alt="image-20240416170243571" style="zoom:80%;" /></p><h3 id="rr型左旋">2.2.2 RR型：左旋</h3><ul><li>B为根，B的左子树变为A的右子树（中为支，高左转）</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170254711.png" alt="image-20240416170254711" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170304573.png" alt="image-20240416170304573" style="zoom:80%;" /></p><h3 id="lr型左右旋">2.2.3 LR型：左右旋</h3><ul><li>C为根，C的左子树变为B的右子树，C的右子树变为A的左子树（下二整体先左转，后与LL同）</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170323821.png" alt="image-20240416170323821" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170331258.png" alt="image-20240416170331258" style="zoom:80%;" /></p><h3 id="rl型右左旋">2.2.4 RL型：右左旋</h3><ul><li>C为根，C的左子树变为A的右子树，C的右子树变为B的左子树（下二整体先右转，后与RR同）</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170339782.png" alt="image-20240416170339782" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416170347800.png" alt="image-20240416170347800" style="zoom:80%;" /></p><h1 id="三-删除">三、 删除</h1><h2 id="bst删除">3.1 BST删除</h2><ul><li><strong>叶节点</strong>：直接删除</li><li><strong>只有一个子节点</strong>：直接删除，子节点顶替父节点的位置</li><li><strong>有两个子节点</strong>：以下两种方法选一个即可<ul><li>找左子树的最右节点，顶替父节点的位置，然后删掉左子树的最右节点</li><li>找右子树的最左节点，顶替父节点的位置，然后删掉右子树的最左节点</li></ul></li></ul><h2 id="平衡调整-1">3.2 平衡调整</h2><ul><li>因为删除的是右子树中的节点，因此只可能是右子树的深度-1</li><li>左子树比右子树深2，因此只需要右旋一次即可</li></ul><h1 id="四代码实现">四、代码实现</h1><h2 id="旋转">4.1 旋转</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVL* <span class="title">RotateLeft</span><span class="params">(AVL* root)</span> </span>&#123;<span class="comment">//左旋,根的右儿子变成根,根变为左儿子</span></span><br><span class="line">AVL* temp = root-&gt;rch;</span><br><span class="line">root-&gt;rch = temp-&gt;lch;</span><br><span class="line">temp-&gt;lch = root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新树的高度</span></span><br><span class="line"><span class="comment">//只有被操作的两个节点(root,temp=root-&gt;rch)的高度会改变</span></span><br><span class="line"><span class="comment">//由于新树中temp为根,root为子节点,故先更新root的高度</span></span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line"><span class="built_in">Update</span>(temp);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVL* <span class="title">RotateRight</span><span class="params">(AVL* root)</span> </span>&#123;<span class="comment">//右旋,根的左儿子变为根,根变为右儿子</span></span><br><span class="line">AVL* temp = root-&gt;lch;</span><br><span class="line">root-&gt;lch = temp-&gt;rch;</span><br><span class="line">temp-&gt;rch = root;</span><br><span class="line"><span class="comment">//更新树的高度</span></span><br><span class="line"><span class="comment">//只有被操作的两个节点(root,temp=root-&gt;rch)的高度会改变</span></span><br><span class="line"><span class="comment">//由于新树中temp为根,root为子节点,故先更新root的高度</span></span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line"><span class="built_in">Update</span>(temp);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVL* <span class="title">RotateLeftRight</span><span class="params">(AVL* root)</span> </span>&#123;<span class="comment">//左右旋,先左旋左儿子,再右旋根</span></span><br><span class="line">root-&gt;lch = <span class="built_in">RotateLeft</span>(root-&gt;lch);</span><br><span class="line">root = <span class="built_in">RotateRight</span>(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVL* <span class="title">RotateRightLeft</span><span class="params">(AVL* root)</span> </span>&#123;<span class="comment">//右左旋,先右旋右儿子,再左旋根</span></span><br><span class="line">root-&gt;rch = <span class="built_in">RotateRight</span>(root-&gt;rch);</span><br><span class="line">root = <span class="built_in">RotateLeft</span>(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入">4.2 插入</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVL* <span class="title">Insert</span><span class="params">(AVL* root, <span class="type">int</span> data)</span> </span>&#123;<span class="comment">//插入data</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">AVL</span>();</span><br><span class="line">root-&gt;data = data;</span><br><span class="line">root-&gt;lch = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;height = <span class="number">1</span>;</span><br><span class="line">root-&gt;sum = <span class="number">1</span>;</span><br><span class="line">root-&gt;size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (data == root-&gt;data) &#123;</span><br><span class="line">root-&gt;sum++;</span><br><span class="line">root-&gt;size++;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;<span class="comment">//data插入到左子树</span></span><br><span class="line">root-&gt;lch = <span class="built_in">Insert</span>(root-&gt;lch, data);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line"><span class="comment">//因为插入在左子树,因此只可能是左子树的深</span></span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">GetBalance</span>(root) == <span class="number">2</span>) &#123;<span class="comment">//左子树过深</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetBalance</span>(root-&gt;lch) == <span class="number">-1</span>) &#123;<span class="comment">//LR型</span></span><br><span class="line">root = <span class="built_in">RotateLeftRight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//LL型</span></span><br><span class="line">root = <span class="built_in">RotateRight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">root-&gt;rch = <span class="built_in">Insert</span>(root-&gt;rch, data);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line"><span class="comment">//因为插入在右子树,因此只可能是右子树深</span></span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">GetBalance</span>(root) == <span class="number">-2</span>) &#123;<span class="comment">//右子树过深</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetBalance</span>(root-&gt;rch) == <span class="number">1</span>) &#123;<span class="comment">//RL型</span></span><br><span class="line">root = <span class="built_in">RotateRightLeft</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//RR型</span></span><br><span class="line">root = <span class="built_in">RotateLeft</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除">4.3 删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVL* <span class="title">Delte</span><span class="params">(AVL* root, <span class="type">int</span> key, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;data) &#123;</span><br><span class="line">root-&gt;lch = <span class="built_in">Delte</span>(root-&gt;lch, key, delta);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line"><span class="comment">//因为删除的是左子树中的节点,因此只可能是左子树的浅</span></span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">GetBalance</span>(root) == <span class="number">-2</span>) &#123;<span class="comment">//右子树过深</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetBalance</span>(root-&gt;rch) == <span class="number">1</span>) &#123;<span class="comment">//RL型</span></span><br><span class="line">root = <span class="built_in">RotateRightLeft</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//RR型</span></span><br><span class="line">root = <span class="built_in">RotateLeft</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data) &#123;</span><br><span class="line">root-&gt;rch = <span class="built_in">Delte</span>(root-&gt;rch, key, delta);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line"><span class="comment">//因为删除的是右子树中的节点,因此只可能是右子树浅</span></span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">GetBalance</span>(root) == <span class="number">2</span>) &#123;<span class="comment">//左子树过深</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetBalance</span>(root-&gt;lch) == <span class="number">-1</span>) &#123;<span class="comment">//LR型</span></span><br><span class="line">root = <span class="built_in">RotateLeftRight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//LL型</span></span><br><span class="line">root = <span class="built_in">RotateRight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//找到该值,进行删除操作</span></span><br><span class="line">root-&gt;sum -= delta;</span><br><span class="line">root-&gt;size -= delta;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;sum &gt; <span class="number">0</span>)<span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;lch != <span class="literal">NULL</span> &amp;&amp; root-&gt;rch != <span class="literal">NULL</span>) &#123;<span class="comment">//不是叶节点</span></span><br><span class="line">AVL* temp = <span class="built_in">FindNext</span>(root, key);<span class="comment">//找到比key大的最小的数</span></span><br><span class="line">root-&gt;data = temp-&gt;data;</span><br><span class="line">root-&gt;sum = temp-&gt;sum;<span class="comment">//将后继节点替换当前节点</span></span><br><span class="line">root-&gt;rch = <span class="built_in">Delte</span>(root-&gt;rch, temp-&gt;data, Inf);</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line"><span class="comment">//因为删除的是右子树中的节点,因此只可能是右子树的深度-1</span></span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">GetBalance</span>(root) == <span class="number">2</span>) &#123;<span class="comment">//左子树过深</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetBalance</span>(root-&gt;lch) == <span class="number">-1</span>) &#123;<span class="comment">//LR型</span></span><br><span class="line">root = <span class="built_in">RotateLeftRight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//LL型</span></span><br><span class="line">root = <span class="built_in">RotateRight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//删除的点的度数为0/1</span></span><br><span class="line">AVL* temp = root;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;lch == <span class="literal">NULL</span>)root = root-&gt;rch;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;rch == <span class="literal">NULL</span>)root = root-&gt;lch;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="built_in">Update</span>(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找某数是第几大">4.4 查找某数是第几大</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetRank</span><span class="params">(AVL* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (key == root-&gt;data)<span class="comment">//key == 当前节点的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetSize</span>(root-&gt;lch) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data)<span class="comment">//key &gt; 当前节点的值 ==&gt; 在右子树里面</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetSize</span>(root-&gt;lch) + root-&gt;sum + <span class="built_in">GetRank</span>(root-&gt;rch, key);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//key &lt; 当前节点的值 ==&gt; 在左子树里面 </span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetRank</span>(root-&gt;lch, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找第k大数">4.5 找第k大数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVL* <span class="title">FindByRank</span><span class="params">(AVL* root, <span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rank &gt; <span class="built_in">GetSize</span>(root-&gt;lch) + root-&gt;sum)<span class="comment">//比左子树+自己大 ==&gt; 在右子树里</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FindByRank</span>(root-&gt;rch, rank - <span class="built_in">GetSize</span>(root-&gt;lch) - root-&gt;sum);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank &gt; <span class="built_in">GetSize</span>(root-&gt;lch))<span class="comment">//比左子树大 ==&gt; 就是自己</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//比左子树小 ==&gt; 在左子树里</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FindByRank</span>(root-&gt;lch, rank);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前驱">4.6 前驱</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVL* <span class="title">FindPre</span><span class="params">(AVL* root, <span class="type">int</span> key)</span> </span>&#123;<span class="comment">//找比key小的最大的数</span></span><br><span class="line">AVL* ans = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt;= root-&gt;data)&#123;<span class="comment">//root&gt;key,在左子树,注意等号成立时依旧需要向下找 </span></span><br><span class="line">root = root-&gt;lch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//root&lt;key,在右子树 </span></span><br><span class="line"><span class="keyword">if</span>(ans==<span class="literal">NULL</span> || ans-&gt;data &lt; root-&gt;data)ans=root;</span><br><span class="line">root = root-&gt;rch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后继">4.7 后继</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AVL* FindNext(AVL* root, <span class="built_in">int</span> key) &#123;<span class="comment">//找比key大的最小的数</span></span><br><span class="line">AVL* ans = NULL;</span><br><span class="line"><span class="keyword">while</span> (root != NULL) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;data)&#123;<span class="comment">//root&gt;key,在左子树 </span></span><br><span class="line"><span class="keyword">if</span>(ans==NULL || ans-&gt;data &gt; root-&gt;data)ans=root;</span><br><span class="line">root = root-&gt;lch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//root&lt;key,在右子树,注意等号成立时依旧需要向下找</span></span><br><span class="line">root = root-&gt;rch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五作业题">五、作业题</h1><p><strong>For an AVL tree, the balance factors of all the non-leafnodes are 0 iff the tree is a complete binary tree.</strong></p><ul><li>题目意思：对于一棵 AVL树，当该树是完全二叉树时，所有非叶节点的平衡因子为 0</li><li>答案：F</li><li>解答：完全二叉树的最底层不一定是满的，满二叉树的最底层才是满的</li></ul><blockquote><p><strong>完全二叉树</strong>：设二叉树的深度为h</p><ul><li>除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数</li><li>第 h 层所有的结点都连续集中在最左边</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416191244884.png" alt="image-20240416191244884" style="zoom:80%;" /></p></blockquote><h1 id="附录-总代码">附录 <ahref="https://darkbzoj.tk/problem/3224">总代码</a></h1><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="comment">//AVL树</span></span><br><span class="line"><span class="meta">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"><span class="keyword">struct</span> AVL &#123;</span><br><span class="line"><span class="built_in">int</span> data;</span><br><span class="line"><span class="built_in">int</span> height;</span><br><span class="line"><span class="built_in">int</span> sum;</span><br><span class="line"><span class="built_in">int</span> size;</span><br><span class="line">AVL* lch, * rch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> Inf = <span class="number">1e5</span>;</span><br><span class="line">AVL* root = NULL;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetHeight</span>(<span class="params">AVL*</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetBalance</span>(<span class="params">AVL*</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetSize</span>(<span class="params">AVL*</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params">AVL*</span>)</span>;</span><br><span class="line">AVL* RotateLeft(AVL*);</span><br><span class="line">AVL* RotateRight(AVL*);</span><br><span class="line">AVL* RotateLeftRight(AVL*);</span><br><span class="line">AVL* RotateRightLeft(AVL*);</span><br><span class="line"></span><br><span class="line">AVL* Insert(AVL*, <span class="built_in">int</span>);</span><br><span class="line">AVL* Delte(AVL*, <span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"><span class="function"><span class="built_in">int</span>  <span class="title">GetRank</span>(<span class="params">AVL*, <span class="built_in">int</span></span>)</span>;</span><br><span class="line">AVL* FindByRank(AVL*, <span class="built_in">int</span>);</span><br><span class="line">AVL* FindPre(AVL*, <span class="built_in">int</span>);</span><br><span class="line">AVL* FindNext(AVL*, <span class="built_in">int</span>);</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="built_in">int</span> n, op, x;</span><br><span class="line">scanf(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">scanf(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">AVL* temp = NULL;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>)root = Insert(root, x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)root = Delte(root, x, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)printf(<span class="string">&quot;%d\n&quot;</span>, GetRank(root, x));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>)temp = FindByRank(root, x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>)temp = FindPre(root, x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>)temp = FindNext(root, x);</span><br><span class="line"><span class="keyword">if</span> (temp != NULL)printf(<span class="string">&quot;%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetHeight</span>(<span class="params">AVL* root</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == NULL)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetBalance</span>(<span class="params">AVL* root</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == NULL)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> GetHeight(root-&gt;lch) - GetHeight(root-&gt;rch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetSize</span>(<span class="params">AVL* root</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == NULL)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> root-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params">AVL* root</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == NULL)<span class="keyword">return</span>;</span><br><span class="line">root-&gt;height = max(GetHeight(root-&gt;lch), GetHeight(root-&gt;rch)) + <span class="number">1</span>;</span><br><span class="line">root-&gt;size = GetSize(root-&gt;lch) + GetSize(root-&gt;rch) + root-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line">AVL* RotateLeft(AVL* root) &#123;<span class="comment">//左旋,根的右儿子变成根,根变为左儿子</span></span><br><span class="line">AVL* temp = root-&gt;rch;</span><br><span class="line">root-&gt;rch = temp-&gt;lch;</span><br><span class="line">temp-&gt;lch = root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新树的高度</span></span><br><span class="line"><span class="comment">//只有被操作的两个节点(root,temp=root-&gt;rch)的高度会改变</span></span><br><span class="line"><span class="comment">//由于新树中temp为根,root为子节点,故先更新root的高度</span></span><br><span class="line">Update(root);</span><br><span class="line">Update(temp);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">AVL* RotateRight(AVL* root) &#123;<span class="comment">//右旋,根的左儿子变为根,根变为右儿子</span></span><br><span class="line">AVL* temp = root-&gt;lch;</span><br><span class="line">root-&gt;lch = temp-&gt;rch;</span><br><span class="line">temp-&gt;rch = root;</span><br><span class="line"><span class="comment">//更新树的高度</span></span><br><span class="line"><span class="comment">//只有被操作的两个节点(root,temp=root-&gt;rch)的高度会改变</span></span><br><span class="line"><span class="comment">//由于新树中temp为根,root为子节点,故先更新root的高度</span></span><br><span class="line">Update(root);</span><br><span class="line">Update(temp);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">AVL* RotateLeftRight(AVL* root) &#123;<span class="comment">//左右旋,先左旋左儿子,再右旋根</span></span><br><span class="line">root-&gt;lch = RotateLeft(root-&gt;lch);</span><br><span class="line">root = RotateRight(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">AVL* RotateRightLeft(AVL* root) &#123;<span class="comment">//右左旋,先右旋右儿子,再左旋根</span></span><br><span class="line">root-&gt;rch = RotateRight(root-&gt;rch);</span><br><span class="line">root = RotateLeft(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">AVL* Insert(AVL* root, <span class="built_in">int</span> data) &#123;<span class="comment">//插入data</span></span><br><span class="line"><span class="keyword">if</span> (root == NULL) &#123;</span><br><span class="line">root = <span class="keyword">new</span> AVL();</span><br><span class="line">root-&gt;data = data;</span><br><span class="line">root-&gt;lch = NULL;</span><br><span class="line">root-&gt;rch = NULL;</span><br><span class="line">root-&gt;height = <span class="number">1</span>;</span><br><span class="line">root-&gt;sum = <span class="number">1</span>;</span><br><span class="line">root-&gt;size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (data == root-&gt;data) &#123;</span><br><span class="line">root-&gt;sum++;</span><br><span class="line">root-&gt;size++;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;<span class="comment">//data插入到左子树</span></span><br><span class="line">root-&gt;lch = Insert(root-&gt;lch, data);</span><br><span class="line">Update(root);</span><br><span class="line"><span class="comment">//因为插入在左子树,因此只可能是左子树的深</span></span><br><span class="line"><span class="keyword">if</span> (root != NULL &amp;&amp; GetBalance(root) == <span class="number">2</span>) &#123;<span class="comment">//左子树过深</span></span><br><span class="line"><span class="keyword">if</span> (GetBalance(root-&gt;lch) == <span class="number">-1</span>) &#123;<span class="comment">//LR型</span></span><br><span class="line">root = RotateLeftRight(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//LL型</span></span><br><span class="line">root = RotateRight(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">root-&gt;rch = Insert(root-&gt;rch, data);</span><br><span class="line">Update(root);</span><br><span class="line"><span class="comment">//因为插入在右子树,因此只可能是右子树深</span></span><br><span class="line"><span class="keyword">if</span> (root != NULL &amp;&amp; GetBalance(root) == <span class="number">-2</span>) &#123;<span class="comment">//右子树过深</span></span><br><span class="line"><span class="keyword">if</span> (GetBalance(root-&gt;rch) == <span class="number">1</span>) &#123;<span class="comment">//RL型</span></span><br><span class="line">root = RotateRightLeft(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//RR型</span></span><br><span class="line">root = RotateLeft(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVL* Delte(AVL* root, <span class="built_in">int</span> key, <span class="built_in">int</span> delta) &#123;</span><br><span class="line"><span class="keyword">if</span> (root == NULL)<span class="keyword">return</span> NULL;</span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;data) &#123;</span><br><span class="line">root-&gt;lch = Delte(root-&gt;lch, key, delta);</span><br><span class="line">Update(root);</span><br><span class="line"><span class="comment">//因为删除的是左子树中的节点,因此只可能是左子树的浅</span></span><br><span class="line"><span class="keyword">if</span> (root != NULL &amp;&amp; GetBalance(root) == <span class="number">-2</span>) &#123;<span class="comment">//右子树过深</span></span><br><span class="line"><span class="keyword">if</span> (GetBalance(root-&gt;rch) == <span class="number">1</span>) &#123;<span class="comment">//RL型</span></span><br><span class="line">root = RotateRightLeft(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//RR型</span></span><br><span class="line">root = RotateLeft(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data) &#123;</span><br><span class="line">root-&gt;rch = Delte(root-&gt;rch, key, delta);</span><br><span class="line">Update(root);</span><br><span class="line"><span class="comment">//因为删除的是右子树中的节点,因此只可能是右子树浅</span></span><br><span class="line"><span class="keyword">if</span> (root != NULL &amp;&amp; GetBalance(root) == <span class="number">2</span>) &#123;<span class="comment">//左子树过深</span></span><br><span class="line"><span class="keyword">if</span> (GetBalance(root-&gt;lch) == <span class="number">-1</span>) &#123;<span class="comment">//LR型</span></span><br><span class="line">root = RotateLeftRight(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//LL型</span></span><br><span class="line">root = RotateRight(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//找到该值,进行删除操作</span></span><br><span class="line">root-&gt;sum -= delta;</span><br><span class="line">root-&gt;size -= delta;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;sum &gt; <span class="number">0</span>)<span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;lch != NULL &amp;&amp; root-&gt;rch != NULL) &#123;<span class="comment">//不是叶节点</span></span><br><span class="line">AVL* temp = FindNext(root, key);<span class="comment">//找到比key大的最小的数</span></span><br><span class="line">root-&gt;data = temp-&gt;data;</span><br><span class="line">root-&gt;sum = temp-&gt;sum;<span class="comment">//将后继节点替换当前节点</span></span><br><span class="line">root-&gt;rch = Delte(root-&gt;rch, temp-&gt;data, Inf);</span><br><span class="line">Update(root);</span><br><span class="line"><span class="comment">//因为删除的是右子树中的节点,因此只可能是右子树的深度-1</span></span><br><span class="line"><span class="keyword">if</span> (root != NULL &amp;&amp; GetBalance(root) == <span class="number">2</span>) &#123;<span class="comment">//左子树过深</span></span><br><span class="line"><span class="keyword">if</span> (GetBalance(root-&gt;lch) == <span class="number">-1</span>) &#123;<span class="comment">//LR型</span></span><br><span class="line">root = RotateLeftRight(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//LL型</span></span><br><span class="line">root = RotateRight(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//删除的点的度数为0/1</span></span><br><span class="line">AVL* temp = root;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;lch == NULL)root = root-&gt;rch;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;rch == NULL)root = root-&gt;lch;</span><br><span class="line">delete temp;</span><br><span class="line">Update(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetRank</span>(<span class="params">AVL* root, <span class="built_in">int</span> key</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == NULL)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (key == root-&gt;data)<span class="comment">//key == 当前节点的值</span></span><br><span class="line"><span class="keyword">return</span> GetSize(root-&gt;lch) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data)<span class="comment">//key &gt; 当前节点的值 ==&gt; 在右子树里面</span></span><br><span class="line"><span class="keyword">return</span> GetSize(root-&gt;lch) + root-&gt;sum + GetRank(root-&gt;rch, key);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//key &lt; 当前节点的值 ==&gt; 在左子树里面 </span></span><br><span class="line"><span class="keyword">return</span> GetRank(root-&gt;lch, key);</span><br><span class="line">&#125;</span><br><span class="line">AVL* FindByRank(AVL* root, <span class="built_in">int</span> rank) &#123;</span><br><span class="line"><span class="keyword">if</span> (rank &gt; GetSize(root-&gt;lch) + root-&gt;sum)<span class="comment">//比左子树+自己大 ==&gt; 在右子树里</span></span><br><span class="line"><span class="keyword">return</span> FindByRank(root-&gt;rch, rank - GetSize(root-&gt;lch) - root-&gt;sum);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank &gt; GetSize(root-&gt;lch))<span class="comment">//比左子树大 ==&gt; 就是自己</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//比左子树小 ==&gt; 在左子树里</span></span><br><span class="line"><span class="keyword">return</span> FindByRank(root-&gt;lch, rank);</span><br><span class="line">&#125;</span><br><span class="line">AVL* FindPre(AVL* root, <span class="built_in">int</span> key) &#123;<span class="comment">//找比key小的最大的数</span></span><br><span class="line">AVL* ans = NULL;</span><br><span class="line"><span class="keyword">while</span> (root != NULL) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt;= root-&gt;data) &#123;<span class="comment">//root&gt;key,在左子树 </span></span><br><span class="line">root = root-&gt;lch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//root&lt;key,在右子树 </span></span><br><span class="line"><span class="keyword">if</span> (ans == NULL || ans-&gt;data &lt; root-&gt;data)ans = root;</span><br><span class="line">root = root-&gt;rch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">AVL* FindNext(AVL* root, <span class="built_in">int</span> key) &#123;<span class="comment">//找比key大的最小的数</span></span><br><span class="line">AVL* ans = NULL;</span><br><span class="line"><span class="keyword">while</span> (root != NULL) &#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;data) &#123;<span class="comment">//root&gt;key,在左子树 </span></span><br><span class="line"><span class="keyword">if</span> (ans == NULL || ans-&gt;data &gt; root-&gt;data)ans = root;</span><br><span class="line">root = root-&gt;lch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//root&lt;key,在右子树 </span></span><br><span class="line">root = root-&gt;rch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS：摊还分析</title>
      <link href="/2024/06/01/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/0.Amortized%20Analysis/"/>
      <url>/2024/06/01/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/0.Amortized%20Analysis/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一aggregate-analysis-综合分析">一、Aggregate Analysis综合分析</h1><h2 id="主要思想">1.1 主要思想</h2><p>证明对于含有n个操作的序列，最坏情况下的总时间为<strong>T(n)</strong>，则每个操作的平均代价为<strong>T(n)/n</strong></p><h2 id="实例">1.2 实例</h2><p>证明：一个有多次删除功能的<strong>Stack</strong>，平均操作成本为<strong>O(1)</strong></p><p>对于一个初始为空的<strong>stack</strong>来说，对其进行<strong>n</strong>个操作(<strong>Push</strong>、<strong>Pop</strong>、<strong>MultiPop</strong>)，<strong>stack</strong>始终满足<strong>sizeof(S)≤ n</strong></p><p>因此，<strong>T = O(n)/n = O(1)</strong></p><h1 id="二accounting-method-核算法">二、Accounting method 核算法</h1><h2 id="主要思想-1">2.1 主要思想</h2><p>当操作的平均成本 &gt;实际成本时，将差额作为余额存储。余额可以帮助支付以后的操作成本。保证每一步：平均成本+ 余额 &gt; 实际成本</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416165455100.png" alt="image-20240416165455100" style="zoom:80%;" /></p><h2 id="实例-1">2.2 实例</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416165516506.png" alt="image-20240416165516506" style="zoom:80%;" /></p><h1 id="三potential-method-潜在法">三、Potential method 潜在法</h1><h2 id="主要思想-2">3.1 主要思想</h2>对于<strong>credit</strong>有： $$<span class="math display">\[\begin{aligned}\widehat{c}_{i} - {c}_{i} &amp;= Credit_{i} = \phi(D_i) - \phi(D_{i-1})\\\sum_{i=1}^{n} \widehat c_i &amp;= \sum_{i=1}^{n} (\widehat c_i +\phi(D_i) - \phi(D_{i-1})) \\    &amp;=(\sum_{i=1}^{n} \widehat c_i ) + \phi(D_i) - \phi(D_0)  \\          \end{aligned}\]</span><p>$$</p><p>因此，只需要保证 <span class="math inline">\(\phi(D_i) - \phi(D_0)\geq 0\)</span></p><h2 id="实例-2">3.2 实例</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416165758502.png" alt="image-20240416165758502" style="zoom:80%;" /></p><h1 id="四对于splay树的复杂度证明">四、对于Splay树的复杂度证明</h1><h2 id="插入">4.1 插入</h2><p>定义： <span class="math display">\[\phi(T) = \sum_{i\in T} log \ s(i) \\\]</span> 情况1：<strong>zig-zig</strong></p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416165932610.png" alt="image-20240416165932610" style="zoom:80%;" />$$<span class="math display">\[\begin{aligned}\hat c &amp;= c+\phi(T_2)-\phi(T_1) \\    &amp;=2+R_2(x)+R_2(p)+R_2(G)-R_1(x)-R_1(p)-R_1(G) \\    &amp;\leq 2+R_2(x)+R_2(G)-R_1(x)-R_1(p) \  [\because R_2(p)\leqR_1(G)]\\    &amp;\leq 2+R_2(x)+R_2(G)-2R_1(x) \ [\because R_1(x)&lt;R_1(p)]\\    &amp;\leq 3(R_2(x) - R_1(x))    \end{aligned}\]</span><span class="math display">\[最后一步的证明：\]</span><span class="math display">\[\begin{aligned}&amp;要证:2+R_2(x)+R_2(G)-2R_1(x)\leq 3(R_2(x) - R_1(x))\\&amp;即证:2+R_2(G) \leq 2R_2(x)-R_1(x)\\&amp;\because 当a+b\leq c时,有log \ a+log \ b-2log \ c \leq-2\\&amp;\therefore log(1+C+D)+log(1+A+B)-2log(3+A+B+C+D)\leq-2 \\&amp;\therefore R_2(G)+R_1(x)-2R_2(x)\leq-2 \\\end{aligned}\]</span><p>$$ 情况2：<strong>zig-zag</strong></p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20240416165943561.png" alt="image-20240416165943561" style="zoom:80%;" />$$<span class="math display">\[\begin{aligned}\hat c &amp;= c+\phi(T_2)-\phi(T_1) \\    &amp;=2+R_2(x)+R_2(p)+R_2(G)-R_1(x)-R_1(p)-R_1(G) \\    &amp;=2+R_2(p)+R_2(G)-2R_1(x)\\    &amp;\leq 2R_2(x)-2R_1(x) \\    &amp;\leq 3(R_2(x)-R_1(x))    \end{aligned}\]</span><p>$$</p>情况3：<strong>zig</strong> $$<span class="math display">\[\begin{aligned}\hat c &amp;= c+\phi(T_2)-\phi(T_1) \\    &amp;=1+R_2(x)+R_2(p)-R_1(x)-R_1(p) \\    &amp;\leq 1+R_2(x)-R_1(x) \\    &amp;\leq 1+3(R_2(x)-R_1(x))    \end{aligned}\]</span><span class="math display">\[对于一次**Splay(x)**\]</span><span class="math display">\[\begin{aligned}\hat c &amp;= \sum_{i=1}^{k} \hat c_i \\&amp;\leq 1+\sum_{i=1}^{k}3(R_{i}(x)-R_{i-1}(x)) \\&amp;\leq 1+3(R_k(x) - R_0(x)) \\\therefore \ &amp;\hat c(O_i) = O(log\ n) \\&amp;\sum_{i=1}^{m} \hat c(O_i) = \sum_{i=1}^m c_i+\phi(T_m)-\phi(T_0)\\&amp;\sum_{i=1}^{m} c_i \leq m\ log\ n+n\ log\ n\end{aligned}\]</span><p>$$</p><h1 id="五vector的时间复杂度证明">五、Vector的时间复杂度证明</h1><h2 id="插入-1">5.1 插入</h2><p>设<span class="math inline">\(\Phi(T)=2*num(T)-size(T)\)</span></p><p><span class="math inline">\(num(T)\)</span>：表示<spanclass="math inline">\(T\)</span>中包含的元素个数</p><p><span class="math inline">\(size(T)\)</span>：表示<spanclass="math inline">\(T\)</span>能够容纳的元素个数</p><p>插入：&gt;原有空间时，将空间<strong>double</strong></p><p>​ (1)若没有导致内存扩大，则：</p><p>​ <span class="math inline">\(c_i=1\)</span></p><p>​ <span class="math inline">\(\hatc_i=c_i+\Phi_i-\Phi_{i-1}\)</span></p><p>​ <spanclass="math inline">\(=1+(2num_i-size_i)-(2num_{i-1}-size_{i-1})\)</span></p><p>​ <span class="math inline">\(=3\)</span></p><p>​ (2)若导致了内存扩大，则</p><p>​ <span class="math inline">\(c_i=1+num_{i-1}\)</span></p><p>​ <span class="math inline">\(\hatc_i=c_i+\Phi_i-\Phi_{i-1}\)</span></p><p>​ <spanclass="math inline">\(=1+(i-1)+(2num_i-size_i)-(2num_{i-1}-size_{i-1})\)</span></p><p>​ <spanclass="math inline">\(=i+(2i-2(i-1))-(2(i-1)-(i-1))\)</span></p><p>​ <span class="math inline">\(=3\)</span></p><h2 id="删除">5.2 删除</h2><p>删除：&lt;原有空间的<strong>1/4</strong>时，将空间减半</p><p>设<span class="math inline">\(\alpha\)</span>：表示<spanclass="math inline">\(\frac{table中包含的元素个数}{table的大小}\)</span></p><p><span class="math inline">\(\Phi(T)=2num(T)-size(T)\\alpha&gt;=1/2\)</span></p><p>​ <span class="math inline">\(=size(T)/2-num(T)\\alpha\leq1/2\)</span></p>]]></content>
      
      
      <categories>
          
          <category> ADS学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADS学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raytracing The Rest of Your Life</title>
      <link href="/2023/11/03/RayTracing/RayTracingTheRestOfYourLife/"/>
      <url>/2023/11/03/RayTracing/RayTracingTheRestOfYourLife/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p><a href="https://0xc0de.fr/webppm/">在线查看器</a></p><p><ahref="https://www.cnblogs.com/lv-anchoret/p/10327692.html">参考教程</a></p><p><ahref="https://github.com/unicorn2022/RayTracingLearning">项目代码</a></p><h1 id="chapter-1a-simple-monte-carlo-program">Chapter 1：A Simple MonteCarlo Program</h1><p>蒙特卡罗方法（MC）是一种统计模拟方法，是一类很重要的数值计算方法，它是一种使用随机数解决好很多实际问题的方法</p><h2 id="估计pi">1.1 估计<span class="math inline">\(\pi\)</span></h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190127182524609-1040762097.png" alt="img" style="zoom:80%;" /></p><ul><li><p>假设你扔了很多随机的点到方框中，那么有一部分在圆内，其中圆内点和方框点的比例应该就是圆的面积和方框面积的比例，由此：<span class="math display">\[比例 = \frac{π * R * R}{(2R)*(2R)} = \frac{π}{4}\]</span></p></li><li><p>由于上式和R无关，我们任意取R = 1，圆心位于原点，则</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math/Random.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> estimate_π(<span class="type">const</span> <span class="type">size_t</span> points) &#123;</span><br><span class="line">    <span class="type">int</span> inside = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> x = <span class="number">2</span> * Random::<span class="built_in">rand01</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> y = <span class="number">2</span> * Random::<span class="built_in">rand01</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x*x + y*y &lt; <span class="number">1</span>) inside++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Estimate of π by&quot;</span> &lt;&lt; points &lt;&lt; <span class="string">&quot;test points is &quot;</span> &lt;&lt; <span class="number">4</span> * <span class="built_in">double</span>(inside) / points &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;　　</span><br><span class="line">    estimate_π(<span class="number">1000</span>);　　</span><br><span class="line">    estimate_π(<span class="number">10000</span>);　　</span><br><span class="line">    estimate_π(<span class="number">100000</span>);　　</span><br><span class="line">    estimate_π(<span class="number">1000000</span>);　　</span><br><span class="line">    estimate_π(<span class="number">10000000</span>);　　</span><br><span class="line">    estimate_π(<span class="number">10000000</span>/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分层方法">1.2 分层方法</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190127185809675-1323946342.png" alt="img" style="zoom:80%;" /></p><ul><li>一开始非常快速的逼近<spanclass="math inline">\(π\)</span>，之后变化就比较缓慢了，这是一个收益递减法(Lawof Diminishing Returns)的例子</li><li>即每一个样本对结果的收益少于后面一个，这个是MC的一个缺点，我们可以通过对样本进行分层来减轻这种递减收益，此法通常称为抖动</li><li>我们进行网格划分，并在每个网格中选取一个样本：</li></ul><blockquote><p>我们采用边长为1e4的方框进行测试</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">stratify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> inside&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">size_t</span> circle_stratified&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">size_t</span> sqrtAll = <span class="number">1e4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sqrtAll; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sqrtAll; ++j) &#123;</span><br><span class="line">            <span class="type">double</span> x = <span class="number">2</span> * Random::<span class="built_in">rand01</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">double</span> y = <span class="number">2</span> * Random::<span class="built_in">rand01</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x*x + y*y &lt; <span class="number">1</span>) inside++;</span><br><span class="line">            </span><br><span class="line">            x = <span class="number">2</span> * ((i + Random::<span class="built_in">rand01</span>()) / sqrtAll) - <span class="number">1</span>;</span><br><span class="line">            y = <span class="number">2</span> * ((j + Random::<span class="built_in">rand01</span>()) / sqrtAll) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x*x + y*y &lt; <span class="number">1</span>) circle_stratified++;</span><br><span class="line">        &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Regular Estimate of π by 1e8 test points is &quot;</span> &lt;&lt; <span class="number">4</span> * <span class="built_in">double</span>(inside) / <span class="number">1e8</span> &lt;&lt; stds endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stratified Estimate of π by 1e8 test points is &quot;</span> &lt;&lt; <span class="number">4</span> * <span class="built_in">double</span>(circle_stratified) / <span class="number">1e8</span> &lt;&lt; stds endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分层方法能更好地收敛于渐近率。不足之处是，这个优势随着问题的维度而降低（例如，对于3D球体积版本，差距会更小）。这被称为维度诅咒（=.=）</li><li>我们的工程将是非常高的维度（每个反射增加两个维度），所以我不会在本书中进行分层。</li><li>但是，如果你做的是单反射或阴影或某些严格的2D问题，分层是个很好的选择</li></ul><h1 id="chapter-2one-dimensional-mc-integration">Chapter 2：OneDimensional MC Integration</h1><h2 id="相关概念">2.1 相关概念</h2><ul><li>PDF：<spanclass="math inline">\(p(x)\)</span>，表示随机变量取值为<spanclass="math inline">\(x\)</span>的概率，值域为<spanclass="math inline">\((0,∞)\)</span></li><li>CPDF：<span class="math inline">\(P(x)=\int_{-∞}^xp(x)\)</span>，表示从负无穷到x的累积概率，值域为<spanclass="math inline">\((0,1)\)</span></li></ul><p>当我们使用<code>rand01()</code>获得满足<spanclass="math inline">\((0,1)\)</span>之间平均分布的变量<spanclass="math inline">\(Y\)</span>时，其对应的是<spanclass="math inline">\(P(x)\)</span></p><ul><li>因此我们需要使用CPDF的反函数<spanclass="math inline">\(P^{-1}(Y)\)</span>，获得满足我们需要的随机变量<spanclass="math inline">\(x\)</span></li><li><span class="math inline">\(x\)</span>满足<spanclass="math inline">\(p(x)\)</span>定义的分布</li></ul><blockquote><ul><li>假设我们希望随机变量<span class="math inline">\(x\)</span>满足<spanclass="math inline">\(p(x)=\frac{x}{2}\)</span></li><li>首先求出CPDF：<spanclass="math inline">\(P(x)=\frac{x^2}{4}\)</span></li><li>然后求反函数：<spanclass="math inline">\(P^{-1}(Y)=\sqrt{4Y}\)</span></li><li>从而得到生成随机变量<spanclass="math inline">\(x\)</span>的代码为：<code>x = sqrt(4 * rand01())</code></li></ul></blockquote><h2 id="重要性采样-蒙特卡洛积分">2.2 重要性采样 &amp; 蒙特卡洛积分</h2><p><span class="math display">\[S = \frac{1}{n} * \sum\frac{F(x_i)}{p(x_i)}\]</span></p><ul><li>PDF的最优函数：被积函数本身</li></ul><h2 id="示例int-cos2-θ-dθ">2.3 示例：<span class="math inline">\(\int\cos^2 θ\ dθ\)</span></h2><ul><li>PDF：均匀采样</li><li><span class="math inline">\(S = \frac{1}{n} * \sum\frac{\cos^2θ}{p(direction)} = \frac{1}{n} * \sum\frac{\cos^2θ}{1/4\pi}\)</span></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sphereMC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pdf = []() &#123; <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">4</span> * π); &#125;;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">10000000</span>;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dvec3 d = Random::<span class="built_in">random_unit_sphere</span>();</span><br><span class="line">        <span class="type">double</span> cosine = d.<span class="built_in">z</span>()*d.<span class="built_in">z</span>();</span><br><span class="line">        sum += cosine / <span class="built_in">pdf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I = &quot;</span> &lt;&lt; sum / n &lt;&lt; stds endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-3light-scaterring">Chapter 3：Light Scaterring</h1><ul><li><span class="math inline">\(albedo\)</span>：光线被反射的概率</li></ul><h2 id="光的散射">3.1 光的散射</h2><p>对于光的散射而言，可以基于立体角，设计一个PDF来描述光线散射的方向分布</p><ul><li>记为：<span class="math inline">\(s(direction)\)</span></li><li>这个散射PDF会随着入射方向的变化而变化</li></ul><p>对于表面色彩而言，有如下积分形式： <span class="math display">\[color=\int albedo * s(direciont) * color(direction)\ dθ\]</span></p><ul><li>其中，<span class="math inline">\(albedo\)</span>、<spanclass="math inline">\(s(direction)\)</span>都是依赖于观察方向的，因此<spanclass="math inline">\(color\)</span>也会随着观察方向的变化而变化</li><li><span class="math inline">\(albedo\)</span>、<spanclass="math inline">\(s(direction)\)</span>也可能随着表面或物体的位置而变化</li></ul><p>使用蒙特卡洛方法计算该积分： <span class="math display">\[color=\frac{1}{n} * \sum \frac{albedo * s(direciont) *color(direction)}{pdf(direction)}\]</span></p><h2 id="lambertian材质的表面散射pdf">3.2Lambertian材质的表面散射PDF</h2><ul><li>Lambertian材质的表面密度，呈余弦规律</li><li>因此，Lambertian表面的光散射PDF是正比于<spanclass="math inline">\(\cos θ\)</span><ul><li><spanclass="math inline">\(θ\)</span>：光线方向和表面法线的夹角</li></ul></li><li>此外，我们定义：<strong><span class="math inline">\(\cos θ &lt;0\)</span>时，<spanclass="math inline">\(s(direction)=0\)</span></strong><ul><li>因此有效区间为半球面</li></ul></li></ul><p>半球面积的计算如下： <span class="math display">\[\begin{aligned}S   &amp;= \iint_{A} \cosθ dA \\    &amp;= \int_{0}^{2\pi} \int_0^{\frac{\pi}{2}} \cosθ \sinθ \  dθdΦ\\    &amp;= \int_{0}^{2\pi} dΦ \int_0^{\frac{\pi}{2}} \cosθ \sinθ \  dθ\\    &amp;= \int_{0}^{2\pi} dΦ \int_0^{\frac{\pi}{2}} \frac{1}{2} \sin2θdθ\\    &amp;= \pi\end{aligned}\]</span> 因此，Lambertian材质的表面散射PDF为： <spanclass="math display">\[s(direction) = \frac{\cosθ}{\pi}\]</span></p><ul><li>为了保证采样的最优性，我们也使用同样的PDF函数：<spanclass="math inline">\(p(direction) = \frac{\cosθ}{\pi}\)</span></li><li>此时<span class="math inline">\(s\)</span>和<spanclass="math inline">\(p\)</span>可以约去，得到<spanclass="math inline">\(color=albedo *color(direction)\)</span>，这也是我们原始的color函数中的设定</li></ul><p>使用BRDF描述表面散射为： <span class="math display">\[BRDF=\frac{albedo*s(direction)}{\cosθ}\]</span></p><ul><li>对于Lambertian材质，<spanclass="math inline">\(BRDF=\frac{albedo}{\pi}\)</span></li></ul><h1 id="chapter-4important-sampling-materials">Chapter 4：ImportantSampling Materials</h1><h2 id="相关概念-1">4.1 相关概念</h2><ul><li><p>目标：向光源发送额外的光线，降低图片的噪声</p></li><li><p>设：</p><ul><li><spanclass="math inline">\(pLight(direction)\)</span>：发射的一束朝向光源的光线的PDF</li><li><spanclass="math inline">\(pSurface(diection)\)</span>：与s有关的PDF</li></ul></li><li><p>将两者线性组合，得到一个综合的PDF： <span class="math display">\[p(direction)=0.5*pLight(direction) + 0.5*pSurface(direction)\]</span></p><ul><li>注意：要求权重是正的，并且和为1</li></ul></li><li><p>设计PDF最重要的一点是，让其尽可能接近于<spanclass="math inline">\(s(direction)*color(direction)\)</span>的分布</p><ul><li>对于漫反射表面，我们猜测它更偏重<spanclass="math inline">\(color(direction)\)</span>因子</li><li>对于镜面材质表面，<spanclass="math inline">\(s(direction)\)</span>只在一个方向附近很大，因此它更重要</li></ul></li></ul><h2 id="对material基类的修改">4.2 对material基类的修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成散射光线</span></span><br><span class="line"><span class="comment">* @param r_in 入射光线</span></span><br><span class="line"><span class="comment">* @param info 碰撞信息</span></span><br><span class="line"><span class="comment">* @param attenuation 当发生散射时, 光强如何衰减, 分为rgb三个分量</span></span><br><span class="line"><span class="comment">* @param r_out 散射光线</span></span><br><span class="line"><span class="comment">* @return 是否得到了散射光线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成散射光线</span></span><br><span class="line"><span class="comment">* @param r_in 入射光线</span></span><br><span class="line"><span class="comment">* @param info 碰撞信息</span></span><br><span class="line"><span class="comment">* @param attenuation 当发生散射时, 光强如何衰减, 分为rgb三个分量</span></span><br><span class="line"><span class="comment">* @param r_out 散射光线</span></span><br><span class="line"><span class="comment">* @param pdf 重要性采样的pdf取值</span></span><br><span class="line"><span class="comment">* @return 是否得到了散射光线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out, <span class="type">double</span>&amp; pdf)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">scatter</span>(r_in, info, attenuation, r_out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 计算散射pdf的取值</span></span><br><span class="line"><span class="comment">* @param r_in 入射光线</span></span><br><span class="line"><span class="comment">* @param info 碰撞信息</span></span><br><span class="line"><span class="comment">* @param r_out 散射光线</span></span><br><span class="line"><span class="comment">* @return pdf取值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scatter_pdf</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, <span class="type">const</span> Ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 自发光</span></span><br><span class="line"><span class="comment">* @param u uv坐标</span></span><br><span class="line"><span class="comment">* @param v uv坐标</span></span><br><span class="line"><span class="comment">* @param p 碰撞点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="对lambertian的修改">4.3 对Lambertian的修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Lambertian::scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 漫反射: 在单位圆内随机取一点, 作为反射方向</span></span><br><span class="line">Vec3 target = info.position + info.normal + Random::<span class="built_in">rand_unit_sphere</span>();</span><br><span class="line">r_out = <span class="built_in">Ray</span>(info.position, target - info.position, r_in.<span class="built_in">Time</span>());</span><br><span class="line">attenuation = albedo-&gt;<span class="built_in">Value</span>(info.u, info.v, info.position);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Lambertian::scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out, <span class="type">double</span>&amp; pdf)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 漫反射: 在单位圆内随机取一点, 作为反射方向</span></span><br><span class="line">Vec3 target = info.position + info.normal + Random::<span class="built_in">rand_unit_sphere</span>();</span><br><span class="line">r_out = <span class="built_in">Ray</span>(info.position, target - info.position, r_in.<span class="built_in">Time</span>());</span><br><span class="line">attenuation = albedo-&gt;<span class="built_in">Value</span>(info.u, info.v, info.position);</span><br><span class="line">pdf = info.normal.<span class="built_in">dot</span>(r_out.<span class="built_in">Direction</span>()) / PI;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Lambertian::scatter_pdf</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, <span class="type">const</span> Ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> cosine = info.normal.<span class="built_in">dot</span>(r_out.<span class="built_in">Direction</span>());</span><br><span class="line"><span class="keyword">if</span> (cosine &lt; <span class="number">0</span>) cosine = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> cosine / PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-5generating-random-direction">Chapter 5：GeneratingRandom Direction</h1><h2 id="三维随机方向向量的生成">5.1 三维随机方向向量的生成</h2><p>假定：</p><ul><li><code>Z轴</code>：表面法线</li><li><code>θ</code>：与法线的夹角</li><li>仅处理<strong>关于z轴旋转对称</strong>的分布，其他相关的量，均设为均匀分布</li></ul><h2 id="pdfdirectionfθ">5.2 <spanclass="math inline">\(pdf(direction)=f(θ)\)</span></h2><p><span class="math display">\[\begin{aligned}g(Φ)&amp;=\frac{1}{2\pi}\\h(θ)&amp;=2\pi f(θ) \sin θ\end{aligned}\]</span></p><p>对于满足<spanclass="math inline">\([0,1]\)</span>之间均匀分布的随机变量<spanclass="math inline">\(r_1,r_2\)</span>而言： <spanclass="math display">\[\begin{aligned}r_1 &amp;= \int_{0}^{Φ} \frac{1}{2\pi} dθ = \frac{Φ}{2\pi} \\r_2 &amp;= \int_{0}^{θ} 2\pi f(t) \sin t \ dt\end{aligned}\]</span></p><h3 id="pdfdirectionfθfrac14pi">5.2.1 <spanclass="math inline">\(pdf(direction)=f(θ)=\frac{1}{4\pi}\)</span></h3><p><span class="math display">\[\begin{aligned}r_1 &amp;= \int_{0}^{Φ} \frac{1}{2\pi} dθ = \frac{Φ}{2\pi} \\r_2 &amp;= \int_{0}^{θ} 2\pi \frac{1}{4\pi} \sin t \ dt\\    &amp;= \int_{0}^{θ} \frac{1}{2} \sin t \ dt\\    &amp;= \frac{1-\cos θ}{2}\end{aligned}\]</span></p>从而： <span class="math display">\[\begin{aligned}Φ &amp;= 2\pi r_1 \\\cos θ &amp;= 1 - 2r_2\end{aligned}\]</span> 带入球坐标得： $$<span class="math display">\[\begin{aligned}x &amp;= \cosΦ\sinθ = 2\cos(2\pi r_1) * \sqrt{r_2(1-r_2)} \\y &amp;= \sinΦ\sinθ = 2\sin(2\pi r_1) * \sqrt{r_2(1-r_2)}&amp; \\z &amp;= \cosθ = 1-2r_2\end{aligned}\]</span><p>$$</p><h3 id="pdfdirectionfθfrac12pi">5.2.2 <spanclass="math inline">\(pdf(direction)=f(θ)=\frac{1}{2\pi}\)</span></h3><p><span class="math display">\[\begin{aligned}r_1 &amp;= \int_{0}^{Φ} \frac{1}{2\pi} dθ = \frac{Φ}{2\pi} \\r_2 &amp;= \int_{0}^{θ} 2\pi \frac{1}{2\pi} \sin t \ dt\\    &amp;= \int_{0}^{θ}  \sin t \ dt\\    &amp;= 1-\cos θ\end{aligned}\]</span></p>从而： <span class="math display">\[\begin{aligned}Φ &amp;= 2\pi r_1 \\\cos θ &amp;= 1 - r_2\end{aligned}\]</span> 带入球坐标得： $$<span class="math display">\[\begin{aligned}x &amp;= \cosΦ\sinθ = \cos(2\pi r_1) * \sqrt{r_2(2-r_2)} \\y &amp;= \sinΦ\sinθ = \sin(2\pi r_1) * \sqrt{r_2(2-r_2)}&amp; \\z &amp;= \cosθ = 1-r_2\end{aligned}\]</span><p>$$</p><h3 id="pdfdirectionfθfraccos-θ4pi">5.2.3 <spanclass="math inline">\(pdf(direction)=f(θ)=\frac{\cosθ}{4\pi}\)</span></h3><p><span class="math display">\[\begin{aligned}r_1 &amp;= \int_{0}^{Φ} \frac{1}{2\pi} dθ = \frac{Φ}{2\pi} \\r_2 &amp;= \int_{0}^{θ} 2\pi \frac{\cos t}{4\pi} \sin t \ dt\\    &amp;= \int_{0}^{θ} \frac{1}{2} \sin t \cos t \ dt\\    &amp;= 1-\cos^2 θ\end{aligned}\]</span></p>从而： <span class="math display">\[\begin{aligned}Φ &amp;= 2\pi r_1 \\\cos θ &amp;= \sqrt{1 - r_2}\end{aligned}\]</span> 带入球坐标得： $$<span class="math display">\[\begin{aligned}x &amp;= \cosΦ\sinθ = 2\cos(2\pi r_1) * \sqrt{r_2} \\y &amp;= \sinΦ\sinθ = 2\sin(2\pi r_1) * \sqrt{r_2}&amp; \\z &amp;= \cosθ = \sqrt{1 - r_2}\end{aligned}\]</span><p>$$</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Vec3 <span class="title">rand_cosine_direction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> r1 = <span class="built_in">rand01</span>();</span><br><span class="line"><span class="type">double</span> r2 = <span class="built_in">rand01</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> x = <span class="built_in">cos</span>(<span class="number">2</span> * PI * r1) * <span class="built_in">sqrt</span>(r2);</span><br><span class="line"><span class="type">double</span> y = <span class="built_in">sin</span>(<span class="number">2</span> * PI * r1) * <span class="built_in">sqrt</span>(r2);</span><br><span class="line"><span class="type">double</span> z = <span class="built_in">sqrt</span>(<span class="number">1</span> - r2);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-6ortho-normal-bases">Chapter 6：Ortho-normal Bases</h1><p>目标：将<code>Chapter 5</code>中基于z轴的随机方向，转化为基于表面法线的随机方向</p><h2 id="建立基于表面法线的坐标系">6.1 建立基于表面法线的坐标系</h2><ul><li><span class="math inline">\(\bold{n}\)</span>：表面法线</li><li><span class="math inline">\(\bold{t}\)</span>：<spanclass="math inline">\(\bold{t}=cross(\bold{vup},\bold{n})\)</span></li><li><span class="math inline">\(\bold{s}\)</span>：<spanclass="math inline">\(\bold{s}=cross(\bold{t},\bold{n})\)</span></li><li>坐标系中的任意一点<spanclass="math inline">\((x,y,z)\)</span>表示如下：<ul><li>随机向量 = <spanclass="math inline">\(x\bold{s}+y\bold{t}+z\bold{n}\)</span></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ONB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 根据法线构建局部坐标系</span></span><br><span class="line"><span class="comment">* @param normal 法线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">ONB</span>(Vec3 normal);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取局部坐标对应的世界坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Vec3 <span class="title">local</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> z)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取局部坐标对应的世界坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Vec3 <span class="title">local</span><span class="params">(<span class="type">const</span> Vec3&amp; v)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 根据法线构建局部坐标系</span></span><br><span class="line"><span class="comment">* @param normal 法线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_from_w</span><span class="params">(<span class="type">const</span> Vec3&amp; normal)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> Vec3&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> axis[index]; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Vec3&amp; <span class="title">u</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">0</span>]; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Vec3&amp; <span class="title">v</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Vec3&amp; <span class="title">w</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Vec3 axis[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ONB::<span class="built_in">ONB</span>(Vec3 normal) &#123;</span><br><span class="line">    <span class="built_in">build_from_w</span>(normal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3 <span class="title">ONB::local</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> z)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">u</span>() + y * <span class="built_in">v</span>() + z * <span class="built_in">w</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3 <span class="title">ONB::local</span><span class="params">(<span class="type">const</span> Vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">local</span>(v[<span class="number">0</span>], v[<span class="number">1</span>], v[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ONB::build_from_w</span><span class="params">(<span class="type">const</span> Vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    Vec3 n = normal.<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Vec3 <span class="title">vup</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(n.<span class="built_in">x</span>()) &gt; <span class="number">0.9</span>) vup = <span class="built_in">Vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    axis[<span class="number">2</span>] = n;</span><br><span class="line">    axis[<span class="number">1</span>] = n.<span class="built_in">cross</span>(vup).<span class="built_in">normalize</span>();</span><br><span class="line">    axis[<span class="number">0</span>] = n.<span class="built_in">cross</span>(axis[<span class="number">1</span>]).<span class="built_in">normalize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改-lambertian-材质的scatter函数">6.2 修改 Lambertian材质的scatter函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Lambertian::scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out, <span class="type">double</span>&amp; pdf)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="function">ONB <span class="title">uvw</span><span class="params">(info.normal)</span></span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 在单位球上随机采样方向, 作为出射方向, 然后将其转化为全局坐标</span></span><br><span class="line">Vec3 direction = uvw.<span class="built_in">local</span>(Random::<span class="built_in">rand_cosine_direction</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建出射光线</span></span><br><span class="line">r_out = <span class="built_in">Ray</span>(info.position, direction.<span class="built_in">normalize</span>(), r_in.<span class="built_in">Time</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要性采样 pdf = cosθ / π</span></span><br><span class="line">pdf = uvw.<span class="built_in">w</span>().<span class="built_in">dot</span>(r_out.<span class="built_in">Direction</span>()) / PI;</span><br><span class="line">&#125; <span class="keyword">while</span> (pdf == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">attenuation = albedo-&gt;<span class="built_in">Value</span>(info.u, info.v, info.position);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-7sample-lights-directly">Chapter 7：Sample LightsDirectly</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190314194434992-798000737.png" alt="img" style="zoom:80%;" /></p><ul><li>即直接朝光源方向发射光线</li><li>重点在于计算<span class="math inline">\(pdf(direction)\)</span></li></ul><h2 id="直接光源采样">7.1 直接光源采样</h2><ul><li><p>对于一个光源区域A，如果均匀采样该区域，则<spanclass="math inline">\(p\_q(q)=\frac{dA}{A}\)</span></p></li><li><p>但是由于积分区域是物体表面的单位球，因此我们需要将<spanclass="math inline">\(pdf\)</span>进行转换，即将光源处的微分<spanclass="math inline">\(dA\)</span>转化为方位角微分<spanclass="math inline">\(dΩ\)</span> <span class="math display">\[dΩ=\frac{\cos α}{distance^2}dA\]</span></p></li><li><p>由于<span class="math inline">\(dA\)</span>和<spanclass="math inline">\(dΩ\)</span>对应的区域的概率是相同的，因此有如下等式：<span class="math display">\[p(direction) * dΩ = p\_q(q) * dA \\\]</span></p></li><li><p>因此有 <span class="math display">\[p(direction) = \frac{distance^2}{\cos α *A}\]</span></p></li></ul><h2 id="修改getcolor的采样">7.2 修改<code>GetColor</code>的采样</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Color <span class="title">ObjectWorld::GetColor</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">int</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">HitInfo info;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果碰撞到了, 则根据材质计算反射光线</span></span><br><span class="line"><span class="comment">// 注意 t_min 需要设置一个很小的值, 否则会出现光线重复与同一个物体相交的情况</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(r, <span class="number">0.01</span>, INFINITY, info)) &#123;</span><br><span class="line">Ray r_out;</span><br><span class="line">Color emit = info.material-&gt;<span class="built_in">emitted</span>(r, info, info.u, info.v, info.position);</span><br><span class="line">Color attenuation;</span><br><span class="line"><span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (depth &lt; max_depth &amp;&amp; info.material-&gt;<span class="built_in">scatter</span>(r, info, attenuation, r_out, pdf)) &#123;</span><br><span class="line"><span class="comment">// 直接光源采样: 在光源上随机采样一个点</span></span><br><span class="line">Point3 on_light = <span class="built_in">Vec3</span>(<span class="number">213</span> + Random::<span class="built_in">rand01</span>() * (<span class="number">343</span> - <span class="number">213</span>), <span class="number">554</span>, <span class="number">227</span> + Random::<span class="built_in">rand01</span>() * (<span class="number">332</span> - <span class="number">227</span>));</span><br><span class="line"><span class="comment">// 计算方向及距离</span></span><br><span class="line">Vec3 direction = on_light - info.position;</span><br><span class="line"><span class="type">double</span> distance_squared = direction.<span class="built_in">length_squared</span>();</span><br><span class="line">direction = direction.<span class="built_in">normalize</span>();</span><br><span class="line"><span class="keyword">if</span>(direction.<span class="built_in">dot</span>(info.normal) &lt; <span class="number">0</span>) <span class="keyword">return</span> emit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 pdf</span></span><br><span class="line"><span class="type">double</span> A = (<span class="number">343</span> - <span class="number">213</span>) * (<span class="number">332</span> - <span class="number">227</span>);</span><br><span class="line"><span class="type">double</span> cos_alpha = <span class="built_in">fabs</span>(direction.<span class="built_in">y</span>());</span><br><span class="line"><span class="keyword">if</span> (cos_alpha &lt; <span class="number">1e-6</span>) <span class="keyword">return</span> emit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pdf = distance^2 / (cos_alpha * A)</span></span><br><span class="line">pdf = distance_squared / (cos_alpha * A);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向光源方向发射光线</span></span><br><span class="line">r_out = <span class="built_in">Ray</span>(info.position, direction, r.<span class="built_in">Time</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> emit + attenuation * info.material-&gt;<span class="built_in">scatter_pdf</span>(r, info, r_out) * <span class="built_in">GetColor</span>(r_out, ++depth) / pdf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> emit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不相交, 则返回黑色</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Color</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-8混合概率密度">Chapter 8：混合概率密度</h1><p>设计pdf的一个很重要的原则：使得累积概率密度达到且只达到1</p><h2 id="pdf基类">8.1 pdf基类</h2><p>主要的任务</p><ul><li>获取<span class="math inline">\(pdf(direction)\)</span></li><li>按照当前模型，生成<spanclass="math inline">\(direction\)</span></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PDF</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取 direction 对应的概率密度</span></span><br><span class="line"><span class="comment">* @param direction 随机方向</span></span><br><span class="line"><span class="comment">* @return 概率密度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> Vec3&amp; direction)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成随机方向</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="pdfdirectionfθfraccos-θ4pi-1">8.1.1 <spanclass="math inline">\(pdf(direction)=f(θ)=\frac{\cosθ}{4\pi}\)</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PDF_cos</span> : <span class="keyword">public</span> PDF &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 随机方向满足 cos 分布</span></span><br><span class="line"><span class="comment">* @param normal 法线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">PDF_cos</span>(<span class="type">const</span> Vec3&amp; normal) : <span class="built_in">uvw</span>(normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取 direction 对应的概率密度</span></span><br><span class="line"><span class="comment">* @param direction 随机方向</span></span><br><span class="line"><span class="comment">* @return 概率密度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> Vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成随机方向</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ONB uvw;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">PDF_cos::value</span><span class="params">(<span class="type">const</span> Vec3&amp; direction)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> cosine = direction.<span class="built_in">normalize</span>().<span class="built_in">dot</span>(uvw.<span class="built_in">w</span>());</span><br><span class="line"><span class="keyword">if</span>(cosine &gt; <span class="number">0</span>) <span class="keyword">return</span> cosine / PI;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3 <span class="title">PDF_cos::generate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> uvw.<span class="built_in">local</span>(Random::<span class="built_in">rand_cosine_direction</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接光源采样-1">8.1.2 直接光源采样</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PDF_hit</span> : <span class="keyword">public</span> PDF &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 直接光源采样</span></span><br><span class="line"><span class="comment">* @param light 光源</span></span><br><span class="line"><span class="comment">* @param origin 观察点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">PDF_hit</span>(Ref&lt;Object&gt; light, Point3 origin) : <span class="built_in">light</span>(light), <span class="built_in">origin</span>(origin) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取 direction 对应的概率密度</span></span><br><span class="line"><span class="comment">* @param direction 随机方向</span></span><br><span class="line"><span class="comment">* @return 概率密度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> Vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成随机方向</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Point3 origin;</span><br><span class="line">Ref&lt;Object&gt; light;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">PDF_hit::value</span><span class="params">(<span class="type">const</span> Vec3&amp; direction)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> light-&gt;<span class="built_in">pdf_value</span>(origin, direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3 <span class="title">PDF_hit::generate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> light-&gt;<span class="built_in">random</span>(origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对光源的修改：<code>RectXZ</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">RectXZ::pdf_value</span><span class="params">(<span class="type">const</span> Point3&amp; origin, <span class="type">const</span> Vec3 direction)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    HitInfo info;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">Ray</span>(origin, direction), <span class="number">1e-3</span>, INFINITY, info)) &#123;</span><br><span class="line">        <span class="type">double</span> area = (x2 - x1) * (z2 - z1);</span><br><span class="line">        <span class="type">double</span> distance_squared = info.t * info.t * direction.<span class="built_in">length_squared</span>();</span><br><span class="line">        <span class="type">double</span> cosine = <span class="built_in">fabs</span>(direction.<span class="built_in">dot</span>(info.normal) / direction.<span class="built_in">length</span>());</span><br><span class="line">        <span class="comment">// pdf = distance^2 / (cos_alpha * A)</span></span><br><span class="line">        <span class="keyword">return</span> distance_squared / (cosine * area);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3 <span class="title">RectXZ::random</span><span class="params">(<span class="type">const</span> Point3&amp; origin)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Point3 on_light = <span class="built_in">Vec3</span>(Random::<span class="built_in">rand_between</span>(x1, x2), k, Random::<span class="built_in">rand_between</span>(z1, z2));</span><br><span class="line">    <span class="keyword">return</span> on_light - origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合概率密度">8.2 混合概率密度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PDF_mixture</span> : <span class="keyword">public</span> PDF &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 等比例混合两个PDF</span></span><br><span class="line"><span class="comment">* @param pdf1 第一个PDF</span></span><br><span class="line"><span class="comment">* @param pdf2 第二个PDF</span></span><br><span class="line"><span class="comment">* @param weight0 pdf1的权重</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">PDF_mixture</span>(Ref&lt;PDF&gt; pdf1, Ref&lt;PDF&gt; pdf2, <span class="type">double</span> weight1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取 direction 对应的概率密度</span></span><br><span class="line"><span class="comment">* @param direction 随机方向</span></span><br><span class="line"><span class="comment">* @return 概率密度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> Vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成随机方向</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Ref&lt;PDF&gt; pdf[<span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> weight1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PDF_mixture::<span class="built_in">PDF_mixture</span>(Ref&lt;PDF&gt; pdf1, Ref&lt;PDF&gt; pdf2, <span class="type">double</span> weight1) &#123;</span><br><span class="line">pdf[<span class="number">0</span>] = pdf1;</span><br><span class="line">pdf[<span class="number">1</span>] = pdf2;</span><br><span class="line"><span class="keyword">this</span>-&gt;weight1 = weight1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PDF_mixture::value</span><span class="params">(<span class="type">const</span> Vec3&amp; direction)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> weight1 * pdf[<span class="number">0</span>]-&gt;<span class="built_in">value</span>(direction) + (<span class="number">1</span> - weight1) * pdf[<span class="number">1</span>]-&gt;<span class="built_in">value</span>(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3 <span class="title">PDF_mixture::generate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Random::<span class="built_in">rand01</span>() &lt; weight1) <span class="keyword">return</span> pdf[<span class="number">0</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> pdf[<span class="number">1</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对getcolor的修改">8.3 对GetColor的修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Color <span class="title">ObjectWorld::GetColor</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">int</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">HitInfo info;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果碰撞到了, 则根据材质计算反射光线</span></span><br><span class="line"><span class="comment">// 注意 t_min 需要设置一个很小的值, 否则会出现光线重复与同一个物体相交的情况</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(r, <span class="number">1e-3</span>, INFINITY, info)) &#123;</span><br><span class="line">Ray r_out;</span><br><span class="line">Color emit = info.material-&gt;<span class="built_in">emitted</span>(r, info, info.u, info.v, info.position);</span><br><span class="line">Color attenuation;</span><br><span class="line"><span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (depth &lt; max_depth &amp;&amp; info.material-&gt;<span class="built_in">scatter</span>(r, info, attenuation, r_out, pdf)) &#123;</span><br><span class="line">Ref&lt;RectXZ&gt; light = <span class="built_in">New</span>&lt;RectXZ&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="literal">nullptr</span>);</span><br><span class="line">Ref&lt;PDF_hit&gt; pdf_hit = <span class="built_in">New</span>&lt;PDF_hit&gt;(light, info.position);</span><br><span class="line">Ref&lt;PDF_cos&gt; pdf_cos = <span class="built_in">New</span>&lt;PDF_cos&gt;(info.normal);</span><br><span class="line"><span class="function">PDF_mixture <span class="title">pdf_mixture</span><span class="params">(pdf_hit, pdf_cos, <span class="number">0.8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">r_out = <span class="built_in">Ray</span>(info.position, pdf_mixture.<span class="built_in">generate</span>(), r.<span class="built_in">Time</span>());</span><br><span class="line">pdf = pdf_mixture.<span class="built_in">value</span>(r_out.<span class="built_in">Direction</span>());</span><br><span class="line"><span class="keyword">return</span> emit + attenuation * info.material-&gt;<span class="built_in">scatter_pdf</span>(r, info, r_out) * <span class="built_in">GetColor</span>(r_out, ++depth) / pdf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> emit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不相交, 则返回黑色</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Color</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Raytracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raytracing 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raytracing The Next Week</title>
      <link href="/2023/11/02/RayTracing/RayTracingTheNextWeek/"/>
      <url>/2023/11/02/RayTracing/RayTracingTheNextWeek/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p><a href="https://0xc0de.fr/webppm/">在线查看器</a></p><p><ahref="https://www.cnblogs.com/lv-anchoret/p/10269488.html">参考教程</a></p><p><ahref="https://github.com/unicorn2022/RayTracingLearning">项目代码</a></p><h1 id="chapter-1motion-blur">Chapter 1：Motion Blur</h1><h2 id="运动模糊">1.1 运动模糊</h2><ul><li><p>光线多了一个属性<code>time</code>，用于记录该光线射入相机的时间</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Ray</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Ray</span>(<span class="type">const</span> Point3&amp; orig, <span class="type">const</span> Vec3&amp; dir, <span class="type">const</span> <span class="type">double</span> time = <span class="number">0</span>) :<span class="built_in">origin</span>(orig), <span class="built_in">direction</span>(dir), <span class="built_in">time</span>(time) &#123;&#125;</span><br><span class="line"><span class="built_in">Ray</span>(<span class="type">const</span> Ray&amp; r) :<span class="built_in">origin</span>(r.origin), <span class="built_in">direction</span>(r.direction) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point3 <span class="title">Origin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> origin; &#125;</span><br><span class="line"><span class="function">Vec3 <span class="title">Direction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> direction; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Time</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> time; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P(t) = origin + t * direction</span></span><br><span class="line"><span class="function">Point3 <span class="title">At</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> origin + t * direction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Point3 origin;</span><br><span class="line">Vec3 direction;</span><br><span class="line"><span class="type">double</span> time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>time</code>的取值由<code>Camera</code>的曝光时间决定，为曝光时间内的一个随机值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Ray <span class="title">Camera::GetRay</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 光圈随机偏移</span></span><br><span class="line">Vec3 rd = lens_radius * Random::<span class="built_in">rand_unit_sphere</span>();</span><br><span class="line">Vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光线的起点为原点, 方向指向观察平面上的当前像素</span></span><br><span class="line"><span class="comment">// 当前时间为 [time1, time2] 之间的随机值</span></span><br><span class="line">Vec3 start = position + offset;</span><br><span class="line">Vec3 target = low_left_corner + u * horizontal + v * vertical;</span><br><span class="line"><span class="type">double</span> time = time1 + Random::<span class="built_in">rand01</span>() * (time2 - time1);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Ray</span>(start, target - start, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="moving-sphere">1.2 Moving Sphere</h2><ul><li>通过球心位置，确定球的位置</li><li>需要给定两个时间分别对应的球心位置，某个确定时间球心所在位置，即为两者插值</li><li>对于当前时刻，根据之前球的求根公式，计算交点</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SphereMoving::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据公式判断是否相交</span></span><br><span class="line"><span class="comment">// (1) 球: (P - center)^2 = radius^2</span></span><br><span class="line"><span class="comment">// (2) 光线: P = origin + t * direction</span></span><br><span class="line"><span class="comment">// 带入求t: t^2 * direction^2 + 2t * direction * (origin - center) + (origin - center)^2 - radius^2 = 0</span></span><br><span class="line">Point3 center = <span class="built_in">GetCenter</span>(r.<span class="built_in">Time</span>());</span><br><span class="line">Vec3 oc = r.<span class="built_in">Origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = r.<span class="built_in">Direction</span>().<span class="built_in">dot</span>(r.<span class="built_in">Direction</span>());</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span> * oc.<span class="built_in">dot</span>(r.<span class="built_in">Direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = oc.<span class="built_in">dot</span>(oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discrimination = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (discrimination &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discrimination);</span><br><span class="line"><span class="keyword">auto</span> t = (-b - sqrtd) / (<span class="number">2</span> * a);</span><br><span class="line"><span class="keyword">if</span> (t &lt; t_min || t &gt; t_max) &#123;</span><br><span class="line">t = (-b + sqrtd) / (<span class="number">2</span> * a);</span><br><span class="line"><span class="keyword">if</span> (t &lt; t_min || t &gt; t_max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.t = t;</span><br><span class="line">info.position = r.<span class="built_in">At</span>(t);</span><br><span class="line">info.material = material;</span><br><span class="line"></span><br><span class="line">Vec3 outward_normal = (info.position - center) / radius; <span class="comment">// 法线: 球心指向相交点</span></span><br><span class="line">info.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point3 <span class="title">SphereMoving::GetCenter</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> center1 + ((time - time1) / (time2 - time1)) * (center2 - center1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="场景中的物体相机配置">1.3 场景中的物体&amp;相机配置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="comment">/* 图片设置 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Image_Width = <span class="number">400</span>;<span class="comment">// 图片宽度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Image_Height = <span class="number">225</span>;<span class="comment">// 图片高度</span></span><br><span class="line">Color data[Image_Width][Image_Height];<span class="comment">// 图片数据</span></span><br><span class="line"><span class="type">int</span> total_completed = <span class="number">0</span>;<span class="comment">// 已完成的列数</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> aspect = <span class="number">1.0f</span> * Image_Width / Image_Height;<span class="comment">// 宽高比</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 世界设置 */</span></span><br><span class="line"><span class="function">Color <span class="title">background</span><span class="params">(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>)</span></span>;<span class="comment">// 背景颜色</span></span><br><span class="line"><span class="function">ObjectWorld <span class="title">world</span><span class="params">(background)</span></span>;<span class="comment">// 世界中的物体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 相机设置 */</span></span><br><span class="line"><span class="function">Vec3 <span class="title">from</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vec3 <span class="title">at</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> dist_to_focus = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> time_start = <span class="number">0</span>, time_end = <span class="number">1.0</span>;</span><br><span class="line"><span class="function">Camera <span class="title">main_camera</span><span class="params">(from, at, Vec3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">20</span>, aspect, aperture, <span class="number">0.7</span> * dist_to_focus, time_start, time_end)</span></span>;<span class="comment">// 主相机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 地面</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(</span><br><span class="line"><span class="built_in">Point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), </span><br><span class="line"><span class="number">1000</span>, </span><br><span class="line"><span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">Color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 小球</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">-2</span>; a &lt; <span class="number">2</span>; a++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-2</span>; b &lt; <span class="number">2</span>; b++) &#123;</span><br><span class="line"><span class="type">double</span> choose_material = Random::<span class="built_in">rand01</span>();</span><br><span class="line"><span class="function">Point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * Random::rand01(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * Random::rand01())</span></span>;</span><br><span class="line"><span class="keyword">if</span> ((center - <span class="built_in">Point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (choose_material &lt; <span class="number">0.55</span>) &#123;</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;SphereMoving&gt;(</span><br><span class="line">center, center + <span class="built_in">Vec3</span>(<span class="number">0</span>, <span class="number">0.5</span> * Random::<span class="built_in">rand01</span>(), <span class="number">0</span>),</span><br><span class="line"><span class="number">0.0</span>, <span class="number">1.0</span>,</span><br><span class="line"><span class="number">0.2</span>,</span><br><span class="line"><span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">Color</span>(Random::<span class="built_in">rand01</span>(), Random::<span class="built_in">rand01</span>(), Random::<span class="built_in">rand01</span>())))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (choose_material &lt; <span class="number">0.85</span>) &#123;</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(</span><br><span class="line">center,</span><br><span class="line"><span class="number">0.2</span>,</span><br><span class="line"><span class="built_in">New</span>&lt;Metal&gt;(<span class="built_in">Color</span>(<span class="number">0.5</span> * (<span class="number">1</span> + Random::<span class="built_in">rand01</span>()), <span class="number">0.5</span> * (<span class="number">1</span> + Random::<span class="built_in">rand01</span>()), <span class="number">0.5</span> * Random::<span class="built_in">rand01</span>())))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(</span><br><span class="line">center, </span><br><span class="line"><span class="number">0.2</span>, </span><br><span class="line"><span class="built_in">New</span>&lt;Dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 大球</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(</span><br><span class="line"><span class="built_in">Point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line"><span class="number">1.0</span>,</span><br><span class="line"><span class="built_in">New</span>&lt;Dielectric&gt;(<span class="number">1.5</span>))</span><br><span class="line">);</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(</span><br><span class="line"><span class="built_in">Point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line"><span class="number">1.0</span>,</span><br><span class="line"><span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">Color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>)))</span><br><span class="line">);</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(</span><br><span class="line"><span class="built_in">Point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line"><span class="number">1.0</span>,</span><br><span class="line"><span class="built_in">New</span>&lt;Metal&gt;(<span class="built_in">Color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-2bounding-volume-hierarchies">Chapter 2：Bounding VolumeHierarchies</h1><h2 id="aabb包围盒">2.1 AABB包围盒</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190117071558040-1330714029.png" alt="img" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190117071645284-802007402.png" alt="img" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190117071706719-2144093299.png" alt="img" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AABB::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//static int cnt = 0;</span></span><br><span class="line"><span class="comment">//std::cerr &lt;&lt; &quot;AABB hit: &quot; &lt;&lt; ++cnt &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算XYZ三个轴的 t 值</span></span><br><span class="line"><span class="comment">// t1 = (min.x - origin.x) / direction.x</span></span><br><span class="line"><span class="comment">// t2 = (max.x - origin.x) / direction.x</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="type">double</span> div = <span class="number">1.0</span> / r.<span class="built_in">Direction</span>()[i];</span><br><span class="line"><span class="type">double</span> t1 = (min[i] - r.<span class="built_in">Origin</span>()[i]) / r.<span class="built_in">Direction</span>()[i];</span><br><span class="line"><span class="type">double</span> t2 = (max[i] - r.<span class="built_in">Origin</span>()[i]) / r.<span class="built_in">Direction</span>()[i];</span><br><span class="line"><span class="keyword">if</span>(div &lt; <span class="number">0</span>) std::<span class="built_in">swap</span>(t1, t2);</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">min</span>(t2, t_max) &lt;= std::<span class="built_in">max</span>(t1, t_min)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AABB <span class="title">AABB::Merge</span><span class="params">(<span class="type">const</span> AABB&amp; box1, <span class="type">const</span> AABB&amp; box2)</span> </span>&#123;</span><br><span class="line">Vec3 Min&#123;</span><br><span class="line">std::<span class="built_in">min</span>(box1.<span class="built_in">Min</span>().<span class="built_in">x</span>(), box2.<span class="built_in">Min</span>().<span class="built_in">x</span>()),</span><br><span class="line">std::<span class="built_in">min</span>(box1.<span class="built_in">Min</span>().<span class="built_in">y</span>(), box2.<span class="built_in">Min</span>().<span class="built_in">y</span>()),</span><br><span class="line">std::<span class="built_in">min</span>(box1.<span class="built_in">Min</span>().<span class="built_in">z</span>(), box2.<span class="built_in">Min</span>().<span class="built_in">z</span>())</span><br><span class="line">&#125;;</span><br><span class="line">Vec3 Max&#123;</span><br><span class="line">std::<span class="built_in">max</span>(box1.<span class="built_in">Max</span>().<span class="built_in">x</span>(), box2.<span class="built_in">Max</span>().<span class="built_in">x</span>()),</span><br><span class="line">std::<span class="built_in">max</span>(box1.<span class="built_in">Max</span>().<span class="built_in">y</span>(), box2.<span class="built_in">Max</span>().<span class="built_in">y</span>()),</span><br><span class="line">std::<span class="built_in">max</span>(box1.<span class="built_in">Max</span>().<span class="built_in">z</span>(), box2.<span class="built_in">Max</span>().<span class="built_in">z</span>())</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">AABB</span>(Min, Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建bvh">2.2 构建BVH</h2><ul><li>将场景中的物体编号，<code>0~n-1</code></li><li>类似线段树，每个阶段管辖一个区间<code>[L,R]</code>，并根据区间内的物体建立AABB包围盒</li><li>递归构建每一个节点</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectWorld::build</span><span class="params">(Ref&lt;BVHnode&gt; u, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> deep)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*std::sort(objects.begin() + L, objects.begin() + R + 1, [&amp;](const Ref&lt;ObjectBase&gt;&amp; a, const Ref&lt;ObjectBase&gt;&amp; b) &#123;</span></span><br><span class="line"><span class="comment">return a-&gt;GetBox().Min()[deep % 3] &lt; b-&gt;GetBox().Min()[deep % 3];</span></span><br><span class="line"><span class="comment">&#125;);*/</span></span><br><span class="line">u-&gt;L = L; u-&gt;R = R;</span><br><span class="line"><span class="type">int</span> size = R - L + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">u-&gt;left = u-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">u-&gt;object = objects[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">u-&gt;left = <span class="built_in">New</span>&lt;BVHnode&gt;();</span><br><span class="line">u-&gt;right = <span class="built_in">New</span>&lt;BVHnode&gt;();</span><br><span class="line">u-&gt;object = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">build</span>(u-&gt;left, L, mid);</span><br><span class="line"><span class="built_in">build</span>(u-&gt;right, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line">u-&gt;<span class="built_in">Update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="碰撞检测">2.3 碰撞检测</h2><ul><li>如果到达叶节点，则与当前节点对应的物体进行碰撞检测</li><li>首先与当前节点的AABB包围盒进行碰撞检测，如果没有碰撞，则忽略该子树</li><li>然后递归判断左右子树，并返回两者中，<code>t</code>更小的那个</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BVHnode::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 叶节点, 则判断与当前物体是否碰撞</span></span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) </span><br><span class="line"><span class="keyword">return</span> object-&gt;<span class="built_in">hit</span>(r, t_min, t_max, info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部节点, 判断与当前包围盒是否碰撞, 进行剪枝</span></span><br><span class="line"><span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, t_min, t_max)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归判断左右儿子</span></span><br><span class="line">HitInfo left_info, right_info;</span><br><span class="line"><span class="type">bool</span> left_hit = (left != <span class="literal">nullptr</span>) &amp;&amp; left-&gt;<span class="built_in">hit</span>(r, t_min, t_max, left_info);</span><br><span class="line"><span class="type">bool</span> right_hit = (right != <span class="literal">nullptr</span>) &amp;&amp; right-&gt;<span class="built_in">hit</span>(r, t_min, t_max, right_info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left_hit &amp;&amp; right_hit) &#123;</span><br><span class="line"><span class="keyword">if</span> (left_info.t &lt; right_info.t) info = left_info;</span><br><span class="line"><span class="keyword">else</span> info = right_info;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left_hit) &#123;</span><br><span class="line">info = left_info;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (right_hit) &#123;</span><br><span class="line">info = right_info;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-3solid-textures">Chapter 3：Solid Textures</h1><h2 id="texture的功能">3.1 Texture的功能</h2><ul><li>给定：纹理坐标<code>(u,v)</code>，坐标<code>p</code></li><li>返回：颜色</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取纹理颜色</span></span><br><span class="line"><span class="comment">* @param u 纹理坐标u</span></span><br><span class="line"><span class="comment">* @param v 纹理坐标v</span></span><br><span class="line"><span class="comment">* @param p 坐标</span></span><br><span class="line"><span class="comment">* @return 纹理颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Color <span class="title">Value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常量纹理见texturetextureconstant.h">3.2常量纹理：见<code>Texture/TextureConstant.h</code></h2><ul><li><code>Value</code>函数返回定值</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextureConstant</span> : <span class="keyword">public</span> Texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param color 纹理颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">TextureConstant</span>(<span class="type">const</span> Color&amp; color) : <span class="built_in">color</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取纹理颜色</span></span><br><span class="line"><span class="comment">* @param u 纹理坐标u</span></span><br><span class="line"><span class="comment">* @param v 纹理坐标v</span></span><br><span class="line"><span class="comment">* @param p 坐标</span></span><br><span class="line"><span class="comment">* @return 纹理颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Color <span class="title">Value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Color color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">TextureConstant::Value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改材质类：<code>attenuation</code>的值由纹理返回</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lambertian</span> : <span class="keyword">public</span> Material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param albedo 反射率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Lambertian</span>(Ref&lt;Texture&gt; albedo) : <span class="built_in">albedo</span>(albedo) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成散射光线</span></span><br><span class="line"><span class="comment">* @param r_in 入射光线</span></span><br><span class="line"><span class="comment">* @param info 碰撞信息</span></span><br><span class="line"><span class="comment">* @param attenuation 当发生散射时, 光强如何衰减, 分为rgb三个分量</span></span><br><span class="line"><span class="comment">* @param r_out 散射光线</span></span><br><span class="line"><span class="comment">* @return 是否得到了散射光线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Ref&lt;Texture&gt; albedo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Lambertian::scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 漫反射: 在单位圆内随机取一点, 作为反射方向</span></span><br><span class="line">Vec3 target = info.position + info.normal + Random::<span class="built_in">rand_unit_sphere</span>();</span><br><span class="line">r_out = <span class="built_in">Ray</span>(info.position, target - info.position);</span><br><span class="line">attenuation = albedo-&gt;<span class="built_in">Value</span>(<span class="number">0</span>, <span class="number">0</span>, info.position);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="棋盘纹理见texturetexturechecker.h">3.3棋盘纹理，见：<code>Texture/TextureChecker.h</code></h2><ul><li>棋盘纹理就是交错的双色格子，呈现一定的规律性</li><li>使用正弦函数，将位置映射为<code>[0/1]</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Color <span class="title">TextureChecker::Value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sines = <span class="built_in">sin</span>(<span class="number">30</span> * p.<span class="built_in">x</span>()) * <span class="built_in">sin</span>(<span class="number">30</span> * p.<span class="built_in">y</span>()) * <span class="built_in">sin</span>(<span class="number">30</span> * p.<span class="built_in">z</span>());</span><br><span class="line">    <span class="keyword">if</span> (sines &lt; <span class="number">0</span>) <span class="keyword">return</span> odd-&gt;<span class="built_in">Value</span>(u, v, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> even-&gt;<span class="built_in">Value</span>(u, v, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-4perlin-noise">Chapter 4：Perlin Noise</h1><h2 id="柏林噪声">4.1 柏林噪声</h2><blockquote><p>柏林噪声是用来生成一些看似杂乱无章其实有些变换规律的图形（更加贴近自然），比如海水、地形、雾等</p><p>例如，2D柏林噪声可以生成</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown\1316111-20190118144910675-1086102315.png" alt="img" style="zoom:80%;" /></p></blockquote><p>柏林噪声有2个关键的特点：</p><ul><li>输入相同的3D点，总能返回相同的随机值</li><li>简单快捷，使用一些hack的方法，达到快速近似的效果</li></ul><h2 id="柏林噪声的类见mathperlin.h">4.2柏林噪声的类，见<code>Math/Perlin.h</code></h2><ul><li><p>噪声函数<code>noise(p)</code>：给定一个位置<code>p</code>，返回该位置对应的噪声函数值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Perlin::noise</span><span class="params">(<span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> u = p.<span class="built_in">x</span>() - i;</span><br><span class="line"><span class="type">double</span> v = p.<span class="built_in">y</span>() - j;</span><br><span class="line"><span class="type">double</span> w = p.<span class="built_in">z</span>() - k;</span><br><span class="line"></span><br><span class="line">Point3 list[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">2</span>; a++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">2</span>; b++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">2</span>; c++)</span><br><span class="line">list[a][b][c] = random_value[</span><br><span class="line">perm_x[(i + a) &amp; <span class="number">255</span>] ^</span><br><span class="line">perm_y[(j + b) &amp; <span class="number">255</span>] ^</span><br><span class="line">perm_z[(k + c) &amp; <span class="number">255</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(list, u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>噪声函数<code>turb(p, depth)</code>：给定一个位置<code>p</code>，返回该位置对应的复合噪声函数值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Perlin::turb</span><span class="params">(<span class="type">const</span> Point3&amp; p, <span class="type">int</span> depth)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> accumulate = <span class="number">0</span>;</span><br><span class="line">Point3 t = p;</span><br><span class="line"><span class="type">double</span> weight = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">accumulate += weight * <span class="built_in">noise</span>(t);</span><br><span class="line">weight *= <span class="number">0.5</span>;</span><br><span class="line">t *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(accumulate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三线性插值函数<code>trilinear_interp(list, u, v, w)</code>：根据<code>uvw</code>进行插值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Perlin::trilinear_interp</span><span class="params">(Point3 list[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> uu = u * u * (<span class="number">3</span> - <span class="number">2</span> * u);</span><br><span class="line"><span class="type">double</span> vv = v * v * (<span class="number">3</span> - <span class="number">2</span> * v);</span><br><span class="line"><span class="type">double</span> ww = w * w * (<span class="number">3</span> - <span class="number">2</span> * w);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> accumulate = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line"><span class="function">Point3 <span class="title">weight</span><span class="params">(u - i, v - j, w - k)</span></span>;</span><br><span class="line">accumulate +=</span><br><span class="line">(i * uu + (<span class="number">1</span> - i) * (<span class="number">1</span> - uu)) *</span><br><span class="line">(j * vv + (<span class="number">1</span> - j) * (<span class="number">1</span> - vv)) *</span><br><span class="line">(k * ww + (<span class="number">1</span> - k) * (<span class="number">1</span> - ww)) * list[i][j][k].<span class="built_in">dot</span>(weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> accumulate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="噪声纹理见texturetexturenoise.h">4.3噪声纹理，见<code>Texture/TextureNoise.h</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextureNoise</span> : <span class="keyword">public</span> Texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param scale 噪声缩放</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">TextureNoise</span>(<span class="type">double</span> scale = <span class="number">1.0</span>) : <span class="built_in">scale</span>(scale) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取纹理颜色</span></span><br><span class="line"><span class="comment">* @param u 纹理坐标u</span></span><br><span class="line"><span class="comment">* @param v 纹理坐标v</span></span><br><span class="line"><span class="comment">* @param p 坐标</span></span><br><span class="line"><span class="comment">* @return 纹理颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Color <span class="title">Value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Perlin noise;</span><br><span class="line"><span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">TextureNoise::Value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1</span> + <span class="built_in">sin</span>(scale * p.<span class="built_in">z</span>() + <span class="number">10</span> * noise.<span class="built_in">turb</span>(p)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-5image-texture-mapping">Chapter 5：Image TextureMapping</h1><h2 id="基础知识">5.1 基础知识</h2><p>利用2D纹理坐标<code>(u,v)</code>，确定当前点的<code>attenuation</code>，<code>(u,v)</code>需要保存到<code>HitInfo</code>中</p><ul><li><p><code>nx*ny</code>图像上的某个像素点<code>(i,j)</code>的纹理坐标：<span class="math display">\[u=\frac{i}{nx-1}, \ v=\frac{j}{ny-1}\]</span></p></li><li><p>球面上的某点<code>(x,y,z) / (r,θ,φ)</code>的纹理坐标： <spanclass="math display">\[\begin{aligned}x&amp;=\cos θ \cos Φ \\z&amp;=\cos θ \sin Φ \\y&amp;=\sin θ\end{aligned}\]</span></p><ul><li>将<code>θ,φ</code>规格化到<code>[0,1]</code>：</li></ul><p><span class="math display">\[u=\frac{Φ}{2\pi}, \ v=\frac{θ}{\pi}\\\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190120145539129-1250080533-16998545992352.jpg" alt="img" style="zoom:25%;" /></p></li></ul><h2 id="对sphere的碰撞的修改">5.2 对Sphere的碰撞的修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Sphere::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据公式判断是否相交</span></span><br><span class="line"><span class="comment">// (1) 球: (P - center)^2 = radius^2</span></span><br><span class="line"><span class="comment">// (2) 光线: P = origin + t * direction</span></span><br><span class="line"><span class="comment">// 带入求t: t^2 * direction^2 + 2t * direction * (origin - center) + (origin - center)^2 - radius^2 = 0</span></span><br><span class="line">Vec3 oc = r.<span class="built_in">Origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = r.<span class="built_in">Direction</span>().<span class="built_in">dot</span>(r.<span class="built_in">Direction</span>());</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span> * oc.<span class="built_in">dot</span>(r.<span class="built_in">Direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = oc.<span class="built_in">dot</span>(oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discrimination = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (discrimination &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discrimination);</span><br><span class="line"><span class="keyword">auto</span> t = (-b - sqrtd) / (<span class="number">2</span> * a);</span><br><span class="line"><span class="keyword">if</span> (t &lt; t_min || t &gt; t_max) &#123;</span><br><span class="line">t = (-b + sqrtd) / (<span class="number">2</span> * a);</span><br><span class="line"><span class="keyword">if</span> (t &lt; t_min || t &gt; t_max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.t = t;</span><br><span class="line">info.position = r.<span class="built_in">At</span>(t);</span><br><span class="line">info.material = material;</span><br><span class="line"><span class="built_in">GetUV</span>((info.position - center) / radius, info.u, info.v); <span class="comment">// 计算uv(球心为原点)</span></span><br><span class="line"></span><br><span class="line">Vec3 outward_normal = (info.position - center) / radius; <span class="comment">// 法线: 球心指向相交点</span></span><br><span class="line">info.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sphere::GetUV</span><span class="params">(<span class="type">const</span> Point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// x = cos(theta) * cos(phi)</span></span><br><span class="line"><span class="comment">// z = cos(theta) * sin(phi)</span></span><br><span class="line"><span class="comment">// y = sin(theta)</span></span><br><span class="line"><span class="type">double</span> phi = <span class="built_in">atan2</span>(p.<span class="built_in">z</span>(), p.<span class="built_in">x</span>()) + PI;</span><br><span class="line"><span class="type">double</span> theta = <span class="built_in">asin</span>(p.<span class="built_in">y</span>()) + PI / <span class="number">2</span>;</span><br><span class="line">u = phi / (<span class="number">2</span> * PI);</span><br><span class="line">v = theta / PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片纹理见texturetextureimage">5.3图片纹理，见<code>Texture/TextureImage</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextureImage</span> : <span class="keyword">public</span> Texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param path 图片路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">TextureImage</span>(std::string path);</span><br><span class="line"></span><br><span class="line">~<span class="built_in">TextureImage</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取纹理颜色</span></span><br><span class="line"><span class="comment">* @param u 纹理坐标u</span></span><br><span class="line"><span class="comment">* @param v 纹理坐标v</span></span><br><span class="line"><span class="comment">* @param p 坐标</span></span><br><span class="line"><span class="comment">* @return 纹理颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Color <span class="title">Value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Color* image_data;</span><br><span class="line"><span class="type">size_t</span> size_x, size_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TextureImage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../3rdpatry/stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TextureImage::<span class="built_in">TextureImage</span>(std::string path) &#123;</span><br><span class="line"><span class="type">int</span> nx, ny, nn;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* tex_data = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;nx, &amp;ny, &amp;nn, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(tex_data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;ERROR: 图片加载失败, 路径为: &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_x = nx;</span><br><span class="line">size_y = ny;</span><br><span class="line">image_data = <span class="keyword">new</span> Color[size_x * size_y];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_x; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size_y; j++) &#123;</span><br><span class="line"><span class="type">double</span> r = tex_data[nn * (i + j * size_x)] / <span class="number">255.0</span>;</span><br><span class="line"><span class="type">double</span> g = tex_data[nn * (i + j * size_x) + <span class="number">1</span>] / <span class="number">255.0</span>;</span><br><span class="line"><span class="type">double</span> b = tex_data[nn * (i + j * size_x) + <span class="number">2</span>] / <span class="number">255.0</span>;</span><br><span class="line">image_data[i + j * size_x] = <span class="built_in">Color</span>(r, g, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TextureImage::~<span class="built_in">TextureImage</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] image_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">TextureImage::Value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = std::<span class="built_in">clamp</span>&lt;<span class="type">int</span>&gt;(u * size_x, <span class="number">0</span>, size_x - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> j = std::<span class="built_in">clamp</span>&lt;<span class="type">int</span>&gt;(v * size_y, <span class="number">0</span>, size_y - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> image_data[i + j * size_x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-6rectangles-and-lights">Chapter 6：Rectangles andLights</h1><h2 id="发光材质见materialemit">6.1发光材质，见<code>Material/Emit</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Emit</span> : <span class="keyword">public</span> Material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param emit 自发光纹理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Emit</span>(Ref&lt;Texture&gt; emit) : <span class="built_in">emit</span>(emit) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成散射光线</span></span><br><span class="line"><span class="comment">* @param r_in 入射光线</span></span><br><span class="line"><span class="comment">* @param info 碰撞信息</span></span><br><span class="line"><span class="comment">* @param attenuation 当发生散射时, 光强如何衰减, 分为rgb三个分量</span></span><br><span class="line"><span class="comment">* @param r_out 散射光线</span></span><br><span class="line"><span class="comment">* @return 是否得到了散射光线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 自发光</span></span><br><span class="line"><span class="comment">* @param u uv坐标</span></span><br><span class="line"><span class="comment">* @param v uv坐标</span></span><br><span class="line"><span class="comment">* @param p 碰撞点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Ref&lt;Texture&gt; emit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Emit::scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 光线到达光源之后, 就不再散射了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">Emit::emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> Point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> emit-&gt;<span class="built_in">Value</span>(u, v, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的，修改<code>GetColor()</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Color <span class="title">ObjectWorld::GetColor</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">HitInfo record;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果碰撞到了, 则根据材质计算反射光线</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(r, <span class="number">0</span>, INFINITY, record)) &#123;</span><br><span class="line">Ray scattered;</span><br><span class="line">Color attenuation;</span><br><span class="line">Color emit = record.material-&gt;<span class="built_in">emitted</span>(record.u, record.v, record.position);</span><br><span class="line"><span class="keyword">if</span> (depth &lt; max_depth &amp;&amp; record.material-&gt;<span class="built_in">scatter</span>(r, record, attenuation, scattered))</span><br><span class="line"><span class="keyword">return</span> emit + attenuation * <span class="built_in">GetColor</span>(scattered, depth + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> emit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不相交, 则返回黑色</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Color</span>(<span class="number">0.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长方形物体平行于坐标轴轴">6.2 长方形物体（平行于坐标轴轴）</h2><blockquote><p>以平行于<code>z</code>轴为例，平行于<code>x、y</code>轴同理</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190122101308844-1609437275.png" alt="img" style="zoom:80%;" /><span class="math display">\[p(t)=position+t*direction\\p(t).z=position.z+t*direction.z=k\\t=\frac{k-position.z}{direction.z}\]</span></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RectXY</span> : <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param x1 x 轴最小值</span></span><br><span class="line"><span class="comment">* @param x2 x 轴最大值</span></span><br><span class="line"><span class="comment">* @param y1 y 轴最小值</span></span><br><span class="line"><span class="comment">* @param y2 y 轴最大值</span></span><br><span class="line"><span class="comment">* @param kz 轴值</span></span><br><span class="line"><span class="comment">* @param material 材质</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">RectXY</span>(<span class="type">double</span> x1, <span class="type">double</span> x2, <span class="type">double</span> y1, <span class="type">double</span> y2, <span class="type">double</span> k, Ref&lt;Material&gt; material)</span><br><span class="line">: <span class="built_in">x1</span>(x1), <span class="built_in">x2</span>(x2), <span class="built_in">y1</span>(y1), <span class="built_in">y2</span>(y2), <span class="built_in">k</span>(k), <span class="built_in">material</span>(material) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 判断光线是否与当前对象碰撞</span></span><br><span class="line"><span class="comment">* @param r 光线</span></span><br><span class="line"><span class="comment">* @param t_min 光线的最小 t 值</span></span><br><span class="line"><span class="comment">* @param t_max 光线的最大 t 值</span></span><br><span class="line"><span class="comment">* @param info 碰撞点信息</span></span><br><span class="line"><span class="comment">* @return 是否碰撞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取当前对象的包围盒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AABB <span class="title">GetBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Ref&lt;Material&gt; material;</span><br><span class="line"><span class="type">double</span> x1, x2, y1, y2, k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RectXY::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> t = (k - r.<span class="built_in">Origin</span>().<span class="built_in">z</span>()) / r.<span class="built_in">Direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Point3 p = r.<span class="built_in">At</span>(t);</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">x</span>() &lt; x1 || p.<span class="built_in">x</span>() &gt; x2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">y</span>() &lt; y1 || p.<span class="built_in">y</span>() &gt; y2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    info.t = t;</span><br><span class="line">    info.position = p;</span><br><span class="line">    info.<span class="built_in">set_face_normal</span>(r, <span class="built_in">Vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    info.material = material;</span><br><span class="line">    info.u = (p.<span class="built_in">x</span>() - x1) / (x2 - x1);</span><br><span class="line">    info.v = (p.<span class="built_in">y</span>() - y1) / (y2 - y1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AABB <span class="title">RectXY::GetBox</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AABB</span>(</span><br><span class="line">        <span class="built_in">Vec3</span>(x1, y1, k - <span class="number">0.0001</span>),</span><br><span class="line">        <span class="built_in">Vec3</span>(x2, y2, k + <span class="number">0.0001</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cornell-box">6.3 Cornell box</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Ref&lt;Material&gt; red = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.65</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)));</span><br><span class="line">Ref&lt;Material&gt; white = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.73</span>, <span class="number">0.73</span>, <span class="number">0.73</span>)));</span><br><span class="line">Ref&lt;Material&gt; green = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.12</span>, <span class="number">0.45</span>, <span class="number">0.15</span>)));</span><br><span class="line">Ref&lt;Material&gt; light = <span class="built_in">New</span>&lt;Emit&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXZ&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectYZ&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));<span class="comment">// 右红墙</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectYZ&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));<span class="comment">// 左绿墙</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXZ&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));<span class="comment">// 下白墙</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXZ&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));<span class="comment">// 上白墙</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXY&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));<span class="comment">// 后白墙</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 相机设置 */</span></span><br><span class="line"><span class="function">Vec3 <span class="title">from</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>)</span></span>;</span><br><span class="line"><span class="function">Vec3 <span class="title">at</span><span class="params">(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> dist_to_focus = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="type">double</span> time_start = <span class="number">0</span>, time_end = <span class="number">1.0</span>;</span><br><span class="line"><span class="function">Camera <span class="title">main_camera</span><span class="params">(from, at, Vec3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), vfov, aspect, aperture, <span class="number">0.7</span> * dist_to_focus, time_start, time_end)</span></span>;<span class="comment">// 主相机</span></span><br></pre></td></tr></table></figure><h1 id="chapter-7instance">Chapter 7：Instance</h1><h2 id="轴对齐-box">7.1 轴对齐 Box</h2><p>用六个长方形，拼成一个长方体，注意法线的朝向</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> : <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param point_min 左下顶点</span></span><br><span class="line"><span class="comment">* @param point_max 右上顶点</span></span><br><span class="line"><span class="comment">* @param material 材质</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Box</span>(<span class="type">const</span> Vec3&amp; point_min, <span class="type">const</span> Vec3&amp; point_max, Ref&lt;Material&gt; material);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 判断光线是否与当前对象碰撞</span></span><br><span class="line"><span class="comment">* @param r 光线</span></span><br><span class="line"><span class="comment">* @param t_min 光线的最小 t 值</span></span><br><span class="line"><span class="comment">* @param t_max 光线的最大 t 值</span></span><br><span class="line"><span class="comment">* @param info 碰撞点信息</span></span><br><span class="line"><span class="comment">* @return 是否碰撞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取当前对象的包围盒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AABB <span class="title">GetBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Vec3 point_min, point_max;</span><br><span class="line">Ref&lt;ObjectWorld&gt; sides;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box::<span class="built_in">Box</span>(<span class="type">const</span> Vec3&amp; point_min, <span class="type">const</span> Vec3&amp; point_max, Ref&lt;Material&gt; material) </span><br><span class="line">:<span class="built_in">point_min</span>(point_min), <span class="built_in">point_max</span>(point_max) &#123;</span><br><span class="line">sides = <span class="built_in">New</span>&lt;ObjectWorld&gt;();</span><br><span class="line">sides-&gt;<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXY&gt;(point_min.<span class="built_in">x</span>(), point_max.<span class="built_in">x</span>(), point_min.<span class="built_in">y</span>(), point_max.<span class="built_in">y</span>(), point_max.<span class="built_in">z</span>(), material));</span><br><span class="line">sides-&gt;<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;FlipNormal&gt;(<span class="built_in">New</span>&lt;RectXY&gt;(point_min.<span class="built_in">x</span>(), point_max.<span class="built_in">x</span>(), point_min.<span class="built_in">y</span>(), point_max.<span class="built_in">y</span>(), point_min.<span class="built_in">z</span>(), material)));</span><br><span class="line">sides-&gt;<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXZ&gt;(point_min.<span class="built_in">x</span>(), point_max.<span class="built_in">x</span>(), point_min.<span class="built_in">z</span>(), point_max.<span class="built_in">z</span>(), point_max.<span class="built_in">y</span>(), material));</span><br><span class="line">sides-&gt;<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;FlipNormal&gt;(<span class="built_in">New</span>&lt;RectXZ&gt;(point_min.<span class="built_in">x</span>(), point_max.<span class="built_in">x</span>(), point_min.<span class="built_in">z</span>(), point_max.<span class="built_in">z</span>(), point_min.<span class="built_in">y</span>(), material)));</span><br><span class="line">sides-&gt;<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectYZ&gt;(point_min.<span class="built_in">y</span>(), point_max.<span class="built_in">y</span>(), point_min.<span class="built_in">z</span>(), point_max.<span class="built_in">z</span>(), point_max.<span class="built_in">x</span>(), material));</span><br><span class="line">sides-&gt;<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;FlipNormal&gt;(<span class="built_in">New</span>&lt;RectYZ&gt;(point_min.<span class="built_in">y</span>(), point_max.<span class="built_in">y</span>(), point_min.<span class="built_in">z</span>(), point_max.<span class="built_in">z</span>(), point_min.<span class="built_in">x</span>(), material)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Box::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sides-&gt;<span class="built_in">hit</span>(r, t_min, t_max, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AABB <span class="title">Box::GetBox</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">AABB</span>(point_min, point_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平移">7.2 平移</h2><p>在计算碰撞点的时候把 <code>ray</code> 往反方向移动</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Translate</span> : <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Translate</span>(Ref&lt;Object&gt; object, <span class="type">const</span> Vec3&amp; offset) : <span class="built_in">object</span>(object), <span class="built_in">offset</span>(offset) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 判断光线是否与当前对象碰撞</span></span><br><span class="line"><span class="comment">* @param r 光线</span></span><br><span class="line"><span class="comment">* @param t_min 光线的最小 t 值</span></span><br><span class="line"><span class="comment">* @param t_max 光线的最大 t 值</span></span><br><span class="line"><span class="comment">* @param info 碰撞点信息</span></span><br><span class="line"><span class="comment">* @return 是否碰撞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取当前对象的包围盒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AABB <span class="title">GetBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Ref&lt;Object&gt; object;</span><br><span class="line">Vec3 offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Translate::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">Ray <span class="title">moved_r</span><span class="params">(r.Origin() - offset, r.Direction(), r.Time())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(moved_r, t_min, t_max, info)) &#123;</span><br><span class="line">        info.position += offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AABB <span class="title">Translate::GetBox</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> box = object-&gt;<span class="built_in">GetBox</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AABB</span>(box.<span class="built_in">Min</span>() + offset, box.<span class="built_in">Max</span>() + offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转">7.3 旋转</h2><p>绕Z轴转： <span class="math display">\[x&#39;=\cos θ * x - \sin θ * y\\y&#39;=\sin θ * x + \cos θ * y\]</span> 绕Y轴转： <span class="math display">\[x&#39;=\cos θ * x + \sin θ * z\\z&#39;=-\sin θ * x + \cos θ * z\]</span> 绕X轴转： <span class="math display">\[y&#39;=\cos θ * y - \sin θ * z\\z&#39;=\sin θ * y + \cos θ * z\]</span> 在计算碰撞点的时候把 <code>ray</code> 往反方向旋转</p><blockquote><p>以绕Y轴旋转为例</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RotateY</span> : <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RotateY</span>(<span class="type">double</span> angle, Ref&lt;Object&gt; object);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 判断光线是否与当前对象碰撞</span></span><br><span class="line"><span class="comment">* @param r 光线</span></span><br><span class="line"><span class="comment">* @param t_min 光线的最小 t 值</span></span><br><span class="line"><span class="comment">* @param t_max 光线的最大 t 值</span></span><br><span class="line"><span class="comment">* @param info 碰撞点信息</span></span><br><span class="line"><span class="comment">* @return 是否碰撞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取当前对象的包围盒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AABB <span class="title">GetBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">Ref&lt;Object&gt; object;</span><br><span class="line"><span class="type">double</span> sin_theta, cos_theta;</span><br><span class="line">AABB box;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RotateY::<span class="built_in">RotateY</span>(<span class="type">double</span> angle, Ref&lt;Object&gt; object) : <span class="built_in">object</span>(object) &#123;</span><br><span class="line"><span class="type">double</span> radians = angle * PI / <span class="number">180.0</span>;</span><br><span class="line">sin_theta = std::<span class="built_in">sin</span>(radians);</span><br><span class="line">cos_theta = std::<span class="built_in">cos</span>(radians);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算包围盒</span></span><br><span class="line">box = object-&gt;<span class="built_in">GetBox</span>();</span><br><span class="line"><span class="function">Vec3 <span class="title">min</span><span class="params">(INFINITY, INFINITY, INFINITY)</span></span>;</span><br><span class="line"><span class="function">Vec3 <span class="title">max</span><span class="params">(-INFINITY, -INFINITY, -INFINITY)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line"><span class="type">double</span> x = i * box.<span class="built_in">Max</span>().<span class="built_in">x</span>() + (<span class="number">1</span> - i) * box.<span class="built_in">Min</span>().<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> y = j * box.<span class="built_in">Max</span>().<span class="built_in">y</span>() + (<span class="number">1</span> - j) * box.<span class="built_in">Min</span>().<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> z = k * box.<span class="built_in">Max</span>().<span class="built_in">z</span>() + (<span class="number">1</span> - k) * box.<span class="built_in">Min</span>().<span class="built_in">z</span>();</span><br><span class="line"><span class="type">double</span> newx = cos_theta * x + sin_theta * z;</span><br><span class="line"><span class="type">double</span> newz = -sin_theta * x + cos_theta * z;</span><br><span class="line"><span class="function">Vec3 <span class="title">tester</span><span class="params">(newx, y, newz)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tester[c] &gt; max[c]) max[c] = tester[c];</span><br><span class="line"><span class="keyword">if</span> (tester[c] &lt; min[c]) min[c] = tester[c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">box = <span class="built_in">AABB</span>(min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RotateY::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将光线的原点和方向旋转 -theta 度</span></span><br><span class="line">Vec3 origin = r.<span class="built_in">Origin</span>().<span class="built_in">rotateY</span>(-sin_theta, cos_theta);</span><br><span class="line">Vec3 direction = r.<span class="built_in">Direction</span>().<span class="built_in">rotateY</span>(-sin_theta, cos_theta);</span><br><span class="line"><span class="function">Ray <span class="title">rotatedRay</span><span class="params">(origin, direction, r.Time())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(rotatedRay, t_min, t_max, info)) &#123;</span><br><span class="line">info.position = info.position.<span class="built_in">rotateY</span>(sin_theta, cos_theta);</span><br><span class="line">info.normal = info.normal.<span class="built_in">rotateY</span>(sin_theta, cos_theta);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AABB <span class="title">RotateY::GetBox</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-8volumes">Chapter 8：Volumes</h1><h2 id="次表面散射材质见materialisotropic.h">8.1次表面散射材质，见<code>Material/Isotropic.h</code></h2><ul><li>对于一个恒定密度体，一条光线通过其中的时候，在烟雾体中传播的时候也会发生散射</li><li>光线在烟雾体中能传播多远，是由烟雾体的密度决定的<ul><li>密度越高，光线穿透性越差，光线传播的距离也越短</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190125095708251-606536351.png" alt="img" style="zoom:80%;" /></p><ul><li><p>当光线通过体积时，它可能在任何点散射。 光线在单位距离<spanclass="math inline">\(dL\)</span>中散射的概率为： <spanclass="math display">\[P=C*dL\]</span></p><ul><li>其中<span class="math inline">\(C\)</span>与体积的光密度成比例</li></ul></li><li><p>对于恒定体积，我们只需要密度<spanclass="math inline">\(C\)</span>和边界</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Isotropic</span> : <span class="keyword">public</span> Material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 次表面散射材质</span></span><br><span class="line"><span class="comment">* @param albedo 散射系数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Isotropic</span>(Ref&lt;Texture&gt; albedo) : <span class="built_in">albedo</span>(albedo) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成散射光线</span></span><br><span class="line"><span class="comment">* @param r_in 入射光线</span></span><br><span class="line"><span class="comment">* @param info 碰撞信息</span></span><br><span class="line"><span class="comment">* @param attenuation 当发生散射时, 光强如何衰减, 分为rgb三个分量</span></span><br><span class="line"><span class="comment">* @param r_out 散射光线</span></span><br><span class="line"><span class="comment">* @return 是否得到了散射光线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Ref&lt;Texture&gt; albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Isotropic::scatter</span><span class="params">(<span class="type">const</span> Ray&amp; r_in, <span class="type">const</span> HitInfo&amp; info, Color&amp; attenuation, Ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    r_out = <span class="built_in">Ray</span>(info.position, Random::<span class="built_in">rand_unit_sphere</span>());</span><br><span class="line">    attenuation = albedo-&gt;<span class="built_in">Value</span>(info.u, info.v, info.position);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个材质的散射原理和漫反射材质的大同小异，均属于碰撞点转换为新视点，沿任意方向发射新的视线，区别就在于<ul><li>漫反射的散射光线不可能指到物体内部，它一定是散射到表面外部（视线方向指向外切球体表面）</li><li>isotropic材质的散射光线可以沿原来的方向一往前，以此视线透光性</li></ul></li><li>因为烟雾内部只是颗粒而不存在真正不可穿透的几何实体，所以漫反射实体不可穿透，只能散射到表面外部，而烟雾可穿透</li></ul><h2 id="烟雾体见objecttransformconstantmedium.h">8.2烟雾体，见<code>Object/Transform/ConstantMedium.h</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantMedium</span> : <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 恒定密度介质</span></span><br><span class="line"><span class="comment">* @param object 介质的形状</span></span><br><span class="line"><span class="comment">* @param density 介质的密度</span></span><br><span class="line"><span class="comment">* @param albedo 介质的反射率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">ConstantMedium</span>(Ref&lt;Object&gt; object, <span class="type">double</span> density, Ref&lt;Texture&gt; albedo) : <span class="built_in">object</span>(object), <span class="built_in">density</span>(density), <span class="built_in">isotropic_material</span>(<span class="built_in">New</span>&lt;Isotropic&gt;(albedo)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 判断光线是否与当前对象碰撞</span></span><br><span class="line"><span class="comment">* @param r 光线</span></span><br><span class="line"><span class="comment">* @param t_min 光线的最小 t 值</span></span><br><span class="line"><span class="comment">* @param t_max 光线的最大 t 值</span></span><br><span class="line"><span class="comment">* @param info 碰撞点信息</span></span><br><span class="line"><span class="comment">* @return 是否碰撞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取当前对象的包围盒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AABB <span class="title">GetBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Ref&lt;Object&gt; object;</span><br><span class="line"><span class="type">double</span> density;</span><br><span class="line">Ref&lt;Isotropic&gt; isotropic_material;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ConstantMedium::hit</span><span class="params">(<span class="type">const</span> Ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, HitInfo&amp; info)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    HitInfo info1, info2;</span><br><span class="line">    <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, -INFINITY, INFINITY, info1) &amp;&amp; object-&gt;<span class="built_in">hit</span>(r, info1.t + <span class="number">0.0001</span>, INFINITY, info2)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info1.t &lt; t_min) info1.t = t_min;</span><br><span class="line">        <span class="keyword">if</span> (info2.t &gt; t_max) info2.t = t_max;</span><br><span class="line">        <span class="keyword">if</span> (info1.t &gt;= info2.t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (info1.t &lt; <span class="number">0</span>) info1.t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> distance_inside_boundary = (info2.t - info1.t) * r.<span class="built_in">Direction</span>().<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">float</span> hit_distance = -(<span class="number">1</span> / density) * <span class="built_in">log</span>(Random::<span class="built_in">rand01</span>());</span><br><span class="line">        <span class="keyword">if</span> (hit_distance &lt; distance_inside_boundary) &#123;</span><br><span class="line">            info.t = info1.t + hit_distance / r.<span class="built_in">Direction</span>().<span class="built_in">length</span>();</span><br><span class="line">            info.position = r.<span class="built_in">At</span>(info.t);</span><br><span class="line">            info.normal = <span class="built_in">Vec3</span>(Random::<span class="built_in">rand01</span>(), Random::<span class="built_in">rand01</span>(), Random::<span class="built_in">rand01</span>());</span><br><span class="line">            info.material = isotropic_material;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AABB <span class="title">ConstantMedium::GetBox</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> object-&gt;<span class="built_in">GetBox</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景测试代码">8.3 场景测试代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cornell_smoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Ref&lt;Material&gt; red = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.65</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)));</span><br><span class="line">Ref&lt;Material&gt; blue = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.73</span>)));</span><br><span class="line">Ref&lt;Material&gt; green = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.12</span>, <span class="number">0.45</span>, <span class="number">0.15</span>)));</span><br><span class="line">Ref&lt;Material&gt; white = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.88</span>, <span class="number">0.88</span>, <span class="number">0.88</span>)));</span><br><span class="line">Ref&lt;Material&gt; light = <span class="built_in">New</span>&lt;Emit&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXZ&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));<span class="comment">// 顶部光源</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectYZ&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));<span class="comment">// 左绿墙</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;FlipNormal&gt;(<span class="built_in">New</span>&lt;RectYZ&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red)));<span class="comment">// 右红墙</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;FlipNormal&gt;(<span class="built_in">New</span>&lt;RectXZ&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white)));<span class="comment">// 上白墙</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXZ&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));<span class="comment">// 下白墙</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;FlipNormal&gt;(<span class="built_in">New</span>&lt;RectXY&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, blue)));<span class="comment">// 后蓝墙</span></span><br><span class="line"></span><br><span class="line">Ref&lt;Box&gt; box1 = <span class="built_in">New</span>&lt;Box&gt;(<span class="built_in">Vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">Vec3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">Ref&lt;Box&gt; box2 = <span class="built_in">New</span>&lt;Box&gt;(<span class="built_in">Vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">Vec3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">Ref&lt;Object&gt; box_1 = <span class="built_in">New</span>&lt;Translate&gt;(<span class="built_in">Vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>), <span class="built_in">New</span>&lt;RotateY&gt;(<span class="number">-18</span>, box1));</span><br><span class="line">Ref&lt;Object&gt; box_2 = <span class="built_in">New</span>&lt;Translate&gt;(<span class="built_in">Vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>), <span class="built_in">New</span>&lt;RotateY&gt;(<span class="number">15</span>, box2));</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;ConstantMedium&gt;(box_2, <span class="number">0.006</span>, <span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.8</span>, <span class="number">0.58</span>, <span class="number">0</span>))));<span class="comment">// 盒子1</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;ConstantMedium&gt;(box_1, <span class="number">0.008</span>, <span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.9</span>, <span class="number">0.2</span>, <span class="number">0.72</span>))));<span class="comment">// 盒子2</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-9a-scene-testing-all-new-features">Chapter 9：A SceneTesting All New Features</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Final_Scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Ref&lt;Material&gt; red = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.65</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)));</span><br><span class="line">Ref&lt;Material&gt; blue = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.73</span>)));</span><br><span class="line">Ref&lt;Material&gt; green = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.12</span>, <span class="number">0.45</span>, <span class="number">0.15</span>)));</span><br><span class="line">Ref&lt;Material&gt; white = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.88</span>, <span class="number">0.88</span>, <span class="number">0.88</span>)));</span><br><span class="line">Ref&lt;Material&gt; ground = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.48</span>, <span class="number">0.83</span>, <span class="number">0.53</span>)));</span><br><span class="line">Ref&lt;Material&gt; light = <span class="built_in">New</span>&lt;Emit&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20 * 20 个盒子</span></span><br><span class="line">Ref&lt;ObjectWorld&gt; boxes = <span class="built_in">New</span>&lt;ObjectWorld&gt;();</span><br><span class="line"><span class="type">int</span> nb = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nb; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nb; j++) &#123;</span><br><span class="line"><span class="type">double</span> w = <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> x0 = <span class="number">-1000</span> + i * w;</span><br><span class="line"><span class="type">double</span> z0 = <span class="number">-1000</span> + j * w;</span><br><span class="line"><span class="type">double</span> y0 = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> x1 = x0 + w;</span><br><span class="line"><span class="type">double</span> y1 = <span class="number">100</span> * (Random::<span class="built_in">rand01</span>() + <span class="number">0.01</span>);</span><br><span class="line"><span class="type">double</span> z1 = z0 + w;</span><br><span class="line">boxes-&gt;<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Box&gt;(<span class="built_in">Vec3</span>(x0, y0, z0), <span class="built_in">Vec3</span>(x1, y1, z1), ground));</span><br><span class="line">&#125;</span><br><span class="line">boxes-&gt;<span class="built_in">Build</span>();</span><br><span class="line">world.<span class="built_in">Add</span>(boxes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶部光源</span></span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;RectXZ&gt;(<span class="number">123</span>, <span class="number">423</span>, <span class="number">147</span>, <span class="number">412</span>, <span class="number">550</span>, light));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2个静止球 + 1个运动球</span></span><br><span class="line"><span class="function">Vec3 <span class="title">center</span><span class="params">(<span class="number">400</span>, <span class="number">400</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;SphereMoving&gt;(center, center + <span class="built_in">Vec3</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.1</span>)))));</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(<span class="built_in">Vec3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="number">50</span>, <span class="built_in">New</span>&lt;Dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(<span class="built_in">Vec3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">50</span>, <span class="built_in">New</span>&lt;Metal&gt;(<span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.9</span>)), <span class="number">10.0</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 体积雾</span></span><br><span class="line">Ref&lt;Object&gt; boundary = <span class="built_in">New</span>&lt;Sphere&gt;(<span class="built_in">Vec3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">70</span>, <span class="built_in">New</span>&lt;Dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">world.<span class="built_in">Add</span>(boundary);</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;ConstantMedium&gt;(boundary, <span class="number">0.2</span>, <span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.9</span>))));</span><br><span class="line">boundary = <span class="built_in">New</span>&lt;Sphere&gt;(<span class="built_in">Vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5000</span>, <span class="built_in">New</span>&lt;Dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;ConstantMedium&gt;(boundary, <span class="number">0.0001</span>, <span class="built_in">New</span>&lt;TextureConstant&gt;(<span class="built_in">Color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贴图球</span></span><br><span class="line">Ref&lt;Material&gt; earth = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureImage&gt;(<span class="string">&quot;resource/earthmap.jpg&quot;</span>));</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(<span class="built_in">Vec3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="number">100</span>, earth));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 噪声球</span></span><br><span class="line">Ref&lt;Material&gt; noise = <span class="built_in">New</span>&lt;Lambertian&gt;(<span class="built_in">New</span>&lt;TextureNoise&gt;(<span class="number">0.1</span>));</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(<span class="built_in">Vec3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="number">80</span>, noise));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1000 个球</span></span><br><span class="line"><span class="type">int</span> ns = <span class="number">1000</span>;</span><br><span class="line">Ref&lt;ObjectWorld&gt; spheres = <span class="built_in">New</span>&lt;ObjectWorld&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ns; j++)</span><br><span class="line">spheres-&gt;<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Sphere&gt;(<span class="built_in">Vec3</span>(<span class="number">165</span> * Random::<span class="built_in">rand01</span>(), <span class="number">165</span> * Random::<span class="built_in">rand01</span>(), <span class="number">165</span> * Random::<span class="built_in">rand01</span>()), <span class="number">10</span>, white));</span><br><span class="line">spheres-&gt;<span class="built_in">Build</span>();</span><br><span class="line">world.<span class="built_in">Add</span>(<span class="built_in">New</span>&lt;Translate&gt;(<span class="built_in">Vec3</span>(<span class="number">-100</span>, <span class="number">270</span>, <span class="number">395</span>), <span class="built_in">New</span>&lt;RotateY&gt;(<span class="number">15</span>, spheres)));</span><br><span class="line">world.<span class="built_in">Build</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Raytracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raytracing 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raytracing In One Weekend</title>
      <link href="/2023/11/01/RayTracing/RayTracingInOneWeekend/"/>
      <url>/2023/11/01/RayTracing/RayTracingInOneWeekend/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p><a href="https://0xc0de.fr/webppm/">在线查看器</a></p><p><ahref="https://www.cnblogs.com/lv-anchoret/p/10163205.html">参考教程</a></p><p><ahref="https://github.com/unicorn2022/RayTracingLearning">项目代码</a></p><h1 id="chapter-1output-an-image">Chapter 1：Output an image</h1><h2 id="ppm图像">1.1 PPM图像</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20181223021130139-1918320210.png" alt="img" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P3<span class="comment">// 文件的类型: Pixmap, ASCII</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span><span class="comment">// 图片的width、height</span></span><br><span class="line"><span class="number">255</span><span class="comment">// 像素的最大值</span></span><br><span class="line"><span class="comment">// 每个像素, 从左上角开始，一行一行扫描设置像素值</span></span><br><span class="line"><span class="number">255</span><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">255</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">255</span></span><br><span class="line"><span class="number">255</span> <span class="number">255</span> <span class="number">0</span></span><br><span class="line"><span class="number">255</span> <span class="number">255</span> <span class="number">255</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="chapter-2the-vec3-class">Chapter 2：The vec3 class</h1><h2 id="向量类见vec3.h">2.1 向量类，见<code>vec3.h</code></h2><h1 id="chapter-3raysa-simple-camera-and-background">Chapter 3：Rays，asimple camera, and background</h1><h2 id="光线见ray.h">3.1 光线，见<code>ray.h</code></h2><p><span class="math display">\[p(t) = origin + t * direction\]</span></p><h2 id="相机见camera.h">3.2 相机，见<code>camera.h</code></h2><p>主要任务是，给定一个<spanclass="math inline">\([0,1]^2\)</span>的屏幕坐标，生成一条光线</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ray <span class="title">camera::getRay</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 光线的起点为原点, 方向指向观察平面上的当前像素</span></span><br><span class="line"><span class="function">ray <span class="title">r</span><span class="params">(position, low_left_corner + u * horizontal + v * vertical - position)</span></span>;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在外层需要遍历图像中的每一个像素点，计算其对应的<spanclass="math inline">\((u,v)\)</span>坐标</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像素顺序: 从左到右, 从上到下, (0, h-1) =&gt; (w-1, 0)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = Image_Height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;\r&quot;</span> &lt;&lt; <span class="string">&quot;Scanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Image_Width; i++) &#123;</span><br><span class="line"><span class="comment">// 当前像素的[0,1]坐标</span></span><br><span class="line">        <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / Image_Width;</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / Image_Height;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前像素对应的光线</span></span><br><span class="line">        ray r = main_camera.<span class="built_in">getRay</span>(u, v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算光线得到的颜色</span></span><br><span class="line">        color pixel = world.<span class="built_in">ray_color</span>(r);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 输出颜色</span></span><br><span class="line">pixel.<span class="built_in">write_color</span>(std::cout);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="background">3.3 background</h2><p>使用基于方向的颜色插值方法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="type">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 direction_unit = r.<span class="built_in">getDirection</span>().<span class="built_in">normalize</span>();</span><br><span class="line">    <span class="type">double</span> t = <span class="number">0.5</span> * (direction_unit.<span class="built_in">y</span>() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - t) * <span class="built_in">color</span>(<span class="number">1.0f</span>) + t * background;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-4adding-a-sphere">Chapter 4：Adding a sphere</h1><h2 id="球见sphere.h">4.1 球，见<code>sphere.h</code></h2><p>向场景中添加了一个球，此时摄像机发出的光线就会与球产生碰撞 <spanclass="math display">\[(P-center)·(P-center) = radius^2 \\P=origin + t*direction\]</span> 联立求解<span class="math inline">\(t\)</span>，得： <spanclass="math display">\[direction^2*t^2 +2*direction*(origin-center)*t+(origin-center)^2-radius^2=0\]</span> 根据求根公式，即可求解碰撞点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; record)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据公式判断是否相交</span></span><br><span class="line">vec3 oc = r.<span class="built_in">getOrigin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">getDirection</span>(), r.<span class="built_in">getDirection</span>());</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">getDirection</span>());</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discrimination = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (discrimination &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discrimination);</span><br><span class="line"><span class="keyword">auto</span> t = (-b - sqrtd) / (<span class="number">2</span> * a);</span><br><span class="line"><span class="keyword">if</span> (t &lt; t_min || t &gt; t_max) &#123;</span><br><span class="line">t = (-b + sqrtd) / (<span class="number">2</span> * a);</span><br><span class="line"><span class="keyword">if</span> (t &lt; t_min || t &gt; t_max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record.t = t;</span><br><span class="line">record.position = r.<span class="built_in">at</span>(t);</span><br><span class="line">vec3 outward_normal = (record.position - center) / radius; <span class="comment">// 法线: 球心指向相交点</span></span><br><span class="line">record.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-5surface-normals-and-multiple-objects">Chapter5：Surface normals and multiple objects</h1><h2 id="表面法线">5.1 表面法线</h2><p>碰撞点为<span class="math inline">\(p\)</span>，球心为<spanclass="math inline">\(h\)</span>，那么表面法线即为：<spanclass="math inline">\(h→p\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20181227165521496-1306851858.png" alt="img" style="zoom:80%;" /></p><h2 id="与多物体碰撞见hittable_list.h">5.2与多物体碰撞，见<code>hittable_list.h</code></h2><p>就是遍历场景中的每个物体，将光线与物体求交</p><ul><li>过程中要注意更改<code>t_min, t_max</code></li><li>结果记录在<code>hit_record</code>中</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; record)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">hit_record temp_rec;</span><br><span class="line"><span class="type">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line"><span class="type">double</span> closest_so_far = t_max; <span class="comment">// 获取 ray 相交的最小的 t</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line"><span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">hit_anything = <span class="literal">true</span>;</span><br><span class="line">closest_so_far = temp_rec.t;</span><br><span class="line">record = temp_rec;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-6antialising">Chapter 6：Antialising</h1><p>此处是通过超采样，实现抗锯齿效果</p><ul><li>每个像素发射50根光线，将得到的结果平均，作为最后的颜色</li><li>最后加上一个<code>gamma 2</code>矫正，让场景更亮一点</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像素顺序: 从左到右, 从上到下, (0, h-1) =&gt; (w-1, 0)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = Image_Height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;\r&quot;</span> &lt;&lt; <span class="string">&quot;Scanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Image_Width; i++) &#123;</span><br><span class="line">color pixel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抗锯齿: 每个像素随机采样50次, 并取平均值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; samples_per_pixel; cnt++) &#123;</span><br><span class="line"><span class="comment">// 当前像素的[0,1]坐标</span></span><br><span class="line"><span class="keyword">auto</span> u = <span class="built_in">double</span>(i + Random::<span class="built_in">random_double_01</span>()) / Image_Width;</span><br><span class="line"><span class="keyword">auto</span> v = <span class="built_in">double</span>(j + Random::<span class="built_in">random_double_01</span>()) / Image_Height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前像素对应的光线</span></span><br><span class="line">ray r = main_camera.<span class="built_in">getRay</span>(u, v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算光线得到的颜色</span></span><br><span class="line">pixel += world.<span class="built_in">ray_color</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">pixel /= samples_per_pixel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gamma 2 矫正</span></span><br><span class="line">pixel.<span class="built_in">gamma2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出颜色</span></span><br><span class="line">pixel.<span class="built_in">write_color</span>(std::cout);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-7diffuse-materials">Chapter 7：Diffuse Materials</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20181229215109538-414984874.png" alt="img" style="zoom:80%;" /></p><p>光线与表面碰撞，相交于点p</p><p>在与p相切的单位圆内，随机找一点s，散射光的方向即为<code>p =&gt; s</code></p><p>每次散射，均会让光线强度减半</p><ul><li>注意递归的深度，此处用<code>weight</code>进行控制</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">color <span class="title">hittable_list::ray_color</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (depth &gt;= <span class="number">50</span>) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0.01f</span>);</span><br><span class="line"></span><br><span class="line">hit_record rec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果碰撞到了, 则进行漫反射</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(r, <span class="number">0</span>, INFINITY, rec)) &#123;</span><br><span class="line"><span class="comment">// 漫反射的随机反射方向</span></span><br><span class="line">vec3 target = rec.position + rec.normal + Random::<span class="built_in">random_unit_sphere</span>();</span><br><span class="line">ray new_r = <span class="built_in">ray</span>(rec.position, target - rec.position);</span><br><span class="line">        <span class="comment">// 此处省略了自发光项</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(new_r, weight / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不相交, 则根据方向插值背景颜色</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vec3 direction_unit = r.<span class="built_in">getDirection</span>().<span class="built_in">normalize</span>();</span><br><span class="line"><span class="type">double</span> t = <span class="number">0.5</span> * (direction_unit.<span class="built_in">y</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span> - t) * <span class="built_in">color</span>(<span class="number">1.0f</span>) + t * background;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-8metal">Chapter 8：Metal</h1><p>diffuse表面：</p><ol type="1"><li>视线与物体表面产生撞击点p，在p处相切单位圆内随机找一点s，散射光方向即p-&gt;s</li><li>采用的光线强度衰减机制是取半</li></ol><p>metal表面：</p><ol type="1"><li>根据物理反射定律确定入射光对应的反射光的方向</li><li>强度衰减改为三元组，分别对应rgb三分量的衰减度，且用参数自由确定</li></ol><h2 id="材质类见material.h">8.1 材质类，见<code>material.h</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 生成散射光线</span></span><br><span class="line"><span class="comment">* @param r_in 入射光线</span></span><br><span class="line"><span class="comment">* @param record 碰撞信息</span></span><br><span class="line"><span class="comment">* @param attenuation 当发生散射时, 光强如何衰减, 分为rgb三个分量</span></span><br><span class="line"><span class="comment">* @param r_out 散射光线</span></span><br><span class="line"><span class="comment">* @return 是否得到了散射光线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(<span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; record, color&amp; attenuation, ray&amp; r_out)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="金属材质的反射">8.2 金属材质的反射</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190102012515969-696514104.jpg" alt="img" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">material_metal::scatter</span><span class="params">(<span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; record, color&amp; attenuation, ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 镜面反射: 根据法线进行反射</span></span><br><span class="line">vec3 target = <span class="built_in">reflect</span>(r_in.<span class="built_in">getDirection</span>().<span class="built_in">normalize</span>(), record.normal);</span><br><span class="line">r_out = <span class="built_in">ray</span>(record.position, target);</span><br><span class="line">attenuation = albedo;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dot</span>(r_out.<span class="built_in">getDirection</span>(), record.normal) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">material_metal::reflect</span><span class="params">(<span class="type">const</span> vec3&amp; in, <span class="type">const</span> vec3&amp; normal)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> in - <span class="number">2</span> * <span class="built_in">dot</span>(in, normal) * normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模糊镜面反射">8.3 模糊镜面反射</h2><p>模糊镜面反射 = 镜面反射 + 模糊系数 * 单位球随机点漫反射</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190102025344492-230219258.png" alt="img" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">material_metal::scatter</span><span class="params">(<span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; record, color&amp; attenuation, ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 模糊镜面反射: 根据法线进行反射, 再加上一个随机扰动</span></span><br><span class="line">vec3 target = <span class="built_in">reflect</span>(r_in.<span class="built_in">getDirection</span>().<span class="built_in">normalize</span>(), record.normal);</span><br><span class="line">r_out = <span class="built_in">ray</span>(record.position, target + fuzz * Random::<span class="built_in">random_unit_sphere</span>());</span><br><span class="line">attenuation = albedo;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dot</span>(r_out.<span class="built_in">getDirection</span>(), record.normal) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-9dielectrics">Chapter 9：Dielectrics</h1><h2 id="光的折射">9.1 光的折射</h2><p><span class="math display">\[η=\frac{n_2}{n_1}\]</span></p><ul><li>当<span class="math inline">\(1-η^2(1-\cos^2θ_1)&lt;0\)</span>的时候，发生全反射现象，对应的<spanclass="math inline">\(\cos θ_2=0\)</span></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190103102459134-19753439.jpg" alt="img" style="zoom:80%;" /></p><h2 id="电介质材质-material_dielectric">9.2 电介质材质<code>material_dielectric</code></h2><ul><li>当没有发生全反射时：有一定概率反射，一定概率折射</li><li>当发生全反射时：只会反射</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">material_dielectric::scatter</span><span class="params">(<span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; record, color&amp; attenuation, ray&amp; r_out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> eta;<span class="comment">// 折射率</span></span><br><span class="line"><span class="type">double</span> reflect_prob;<span class="comment">// 反射概率</span></span><br><span class="line"><span class="type">double</span> cos_in;<span class="comment">// 入射角的余弦值</span></span><br><span class="line">vec3 outward_normal;<span class="comment">// 外部法线</span></span><br><span class="line">vec3 refracted;<span class="comment">// 折射光线</span></span><br><span class="line">vec3 reflected;<span class="comment">// 反射光线</span></span><br><span class="line">reflected = <span class="built_in">reflect</span>(r_in.<span class="built_in">getDirection</span>(), record.normal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 衰减永远是1, 因为玻璃不会吸收光线</span></span><br><span class="line">attenuation = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入射光线与法线同方向, 说明是从介质中出来的光线</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dot</span>(r_in.<span class="built_in">getDirection</span>(), record.normal) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">outward_normal = -record.normal;</span><br><span class="line">eta = refractive_index;</span><br><span class="line">cos_in = refractive_index * <span class="built_in">dot</span>(r_in.<span class="built_in">getDirection</span>(), record.normal) / r_in.<span class="built_in">getDirection</span>().<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">outward_normal = record.normal;</span><br><span class="line">eta = <span class="number">1.0</span> / refractive_index;</span><br><span class="line">cos_in = -<span class="built_in">dot</span>(r_in.<span class="built_in">getDirection</span>(), record.normal) / r_in.<span class="built_in">getDirection</span>().<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入射光线发生折射, 计算反射概率</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">refract</span>(r_in.<span class="built_in">getDirection</span>(), outward_normal, eta, refracted))</span><br><span class="line">reflect_prob = <span class="built_in">schlick</span>(cos_in, refractive_index);</span><br><span class="line"><span class="comment">// 入射光线发生全反射, 则反射概率为1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">reflect_prob = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据反射概率, 随机选择反射或折射</span></span><br><span class="line"><span class="keyword">if</span> (Random::<span class="built_in">random_double_01</span>() &lt; reflect_prob)</span><br><span class="line">r_out = <span class="built_in">ray</span>(record.position, reflected);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r_out = <span class="built_in">ray</span>(record.position, refracted);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反射系数的计算：Schlick 算法</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">material_dielectric::schlick</span><span class="params">(<span class="type">const</span> <span class="type">double</span> cosine, <span class="type">const</span> <span class="type">double</span> refractive_index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> r0 = (<span class="number">1</span> - refractive_index) / (<span class="number">1</span> + refractive_index);</span><br><span class="line">r0 *= r0;</span><br><span class="line"><span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-10positionalble-camera">Chapter 10：Positionalblecamera</h1><h2 id="相机的参数定义">10.1 相机的参数定义</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190104145736725-890706643.png" alt="img" style="zoom:80%;" /></p><ul><li><code>fov</code>：field of view<ul><li><code>vfov</code>：相机在垂直方向上从屏幕顶端扫描到底部所岔开的视角角度</li><li><code>hfov</code>：相机在水平方向上从屏幕左端扫描到右端所岔开的视角角度</li></ul></li><li><code>aspect</code>：屏幕宽高比</li></ul><p><span class="math display">\[\tan (\frac{vfoc}{2})=\frac{Height/2}{dis}\]</span></p><p>可得：</p><ul><li>屏幕左、右边界：<spanclass="math inline">\(x_{left}=-\frac{Width}{2},x_{right}=-x_{left}\)</span></li><li>屏幕上、下边界：<spanclass="math inline">\(y_{up}=dis*\tan(\frac{vfov}{2}),y_{bottom}=-y_{up}\)</span></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190104155246529-369799517.png" alt="img" style="zoom:80%;" /></p><ul><li><p><code>lookfrom</code>：相机所在位置</p></li><li><p><code>lookat</code>：相机视线指向的位置点</p></li><li><p><code>相机平面</code>：过<code>lookfrom</code>垂直于视线（<code>from→at</code>）的一个平面</p><ul><li><code>w = lookfrom - lookat</code></li><li><code>u = vup × w</code></li><li><code>v = w × u</code></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190104160906839-257480980.png" alt="img" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190104161223710-339714603.png" alt="img" style="zoom:80%;" /></p></li></ul><h2 id="相机类的实现见camera.h">10.2相机类的实现，见<code>camera.h</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 透视投影相机</span></span><br><span class="line"><span class="comment">* @param vfov垂直方向视角</span></span><br><span class="line"><span class="comment">* @param aspect宽高比</span></span><br><span class="line"><span class="comment">* @param lookfrom相机位置, 默认为原点(0, 0, 0)</span></span><br><span class="line"><span class="comment">* @param lookat相机看向的位置, 默认为屏幕中心(0, 0, -1)</span></span><br><span class="line"><span class="comment">* @param vup相机向上的方向, 默认为y轴正方向(0, 1, 0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">camera</span>(<span class="type">double</span> vfov, <span class="type">double</span> aspect, vec3 lookfrom = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), vec3 lookat = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), vec3 vup = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">: <span class="built_in">position</span>(lookfrom) &#123;</span><br><span class="line"><span class="type">double</span> theta = vfov * std::_Pi / <span class="number">180</span>;</span><br><span class="line"><span class="type">double</span> half_height = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line"><span class="type">double</span> half_width = aspect * half_height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机坐标系</span></span><br><span class="line">vec3 w = (lookfrom - lookat).<span class="built_in">normalize</span>();<span class="comment">// 指向相机</span></span><br><span class="line">vec3 u = <span class="built_in">cross</span>(vup, w).<span class="built_in">normalize</span>();<span class="comment">// 指向屏幕右侧</span></span><br><span class="line">vec3 v = <span class="built_in">cross</span>(w, u);<span class="comment">// 指向屏幕上方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机向量</span></span><br><span class="line">low_left_corner = position - half_width * u - half_height * v - w;</span><br><span class="line">horizontal = <span class="number">2</span> * half_width * u;</span><br><span class="line">vertical = <span class="number">2</span> * half_height * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 获取当前像素对应的光线</span></span><br><span class="line"><span class="comment">* @param u当前像素的[0,1]坐标</span></span><br><span class="line"><span class="comment">* @param v当前像素的[0,1]坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ray <span class="title">getRay</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// 光线的起点为原点, 方向指向观察平面上的当前像素</span></span><br><span class="line"><span class="function">ray <span class="title">r</span><span class="params">(position, low_left_corner + u * horizontal + v * vertical - position)</span></span>;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> vec3&amp; <span class="title">getPosition</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> position; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setPosition</span><span class="params">(<span class="type">const</span> vec3&amp; position)</span> </span>&#123; <span class="keyword">this</span>-&gt;position = position; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> point3&amp; <span class="title">getLowLeftCorner</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> low_left_corner; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> vec3&amp; <span class="title">getHorizontal</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> horizontal; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> vec3&amp; <span class="title">getVertical</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> vertical; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vec3 position;<span class="comment">// 相机位置</span></span><br><span class="line">point3 low_left_corner;<span class="comment">// 屏幕左下角坐标</span></span><br><span class="line">vec3 horizontal;<span class="comment">// 屏幕宽度向量: x轴</span></span><br><span class="line">vec3 vertical;<span class="comment">// 屏幕高度向量: y轴</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="chapter-11defocus-blur">Chapter 11：Defocus Blur</h1><h2 id="散焦模糊景深">11.1 散焦模糊（景深）</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190105005517891-2107468507.png" alt="img" style="zoom:80%;" /></p><ul><li>相机不再是一个点，而是眼睛所在的周围圆盘上的随机点</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/1316111-20190105005933824-1987535260.png" alt="img" style="zoom:80%;" /></p><ul><li>原来的<code>dis</code>也不再是常量，而是参数<code>focus</code></li><li>成像平面变为了：<code>z = -focus * w平面</code></li></ul><h2 id="对相机类的修改">11.2 对相机类的修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 透视投影相机</span></span><br><span class="line"><span class="comment">* @param lookfrom相机位置, 默认为原点(0, 0, 0)</span></span><br><span class="line"><span class="comment">* @param lookat相机看向的位置, 默认为屏幕中心(0, 0, -1)</span></span><br><span class="line"><span class="comment">* @param vup相机向上的方向, 默认为y轴正方向(0, 1, 0)</span></span><br><span class="line"><span class="comment">* @param vfov垂直方向视角</span></span><br><span class="line"><span class="comment">* @param aspect宽高比</span></span><br><span class="line"><span class="comment">* @param aperture光圈直径</span></span><br><span class="line"><span class="comment">* @param focus焦距</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">camera</span>(vec3 lookfrom, vec3 lookat, vec3 vup, <span class="type">double</span> vfov, <span class="type">double</span> aspect, <span class="type">double</span> aperture, <span class="type">double</span> focus)</span><br><span class="line">: <span class="built_in">position</span>(lookfrom), <span class="built_in">lens_radius</span>(aperture/<span class="number">2</span>) &#123;</span><br><span class="line"><span class="type">double</span> theta = vfov * std::_Pi / <span class="number">180</span>;</span><br><span class="line"><span class="type">double</span> half_height = <span class="built_in">tan</span>(theta / <span class="number">2</span>) * focus; <span class="comment">// tan(θ/2) = (h/2) / 焦距</span></span><br><span class="line"><span class="type">double</span> half_width = aspect * half_height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机坐标系</span></span><br><span class="line">w = (lookfrom - lookat).<span class="built_in">normalize</span>();<span class="comment">// 指向相机</span></span><br><span class="line">u = <span class="built_in">cross</span>(vup, w).<span class="built_in">normalize</span>();<span class="comment">// 指向屏幕右侧</span></span><br><span class="line">v = <span class="built_in">cross</span>(w, u).<span class="built_in">normalize</span>();<span class="comment">// 指向屏幕上方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机向量</span></span><br><span class="line">low_left_corner = position - half_width * u - half_height * v - focus * w; <span class="comment">// 高和宽都乘了焦距，w也要乘，不然公式是错的</span></span><br><span class="line">horizontal = <span class="number">2</span> * half_width * u;</span><br><span class="line">vertical = <span class="number">2</span> * half_height * v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总代码"><ahref="https://github.com/unicorn2022/RayTracingLearning/tree/main/RayTracingInOneWeekend">总代码</a></h1>]]></content>
      
      
      <categories>
          
          <category> Raytracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raytracing 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOPLab4：Person Diary</title>
      <link href="/2023/10/14/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/Lab4%20PersonDiary/"/>
      <url>/2023/10/14/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/Lab4%20PersonDiary/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一问题描述">一、问题描述</h1><p><strong>Personal Diary</strong>是一个命令行程序，包含以下四个程序</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pdadd</span><br><span class="line">pdlist []</span><br><span class="line">pdshow</span><br><span class="line">pdremove</span><br></pre></td></tr></table></figure><h2 id="pdadd程序">1.1 pdadd程序</h2><p>向日记文件<strong>dairy.txt</strong>中添加一个实体,包含日记的时间、内容</p><ul><li><p>时间：如果日记的时间与<strong>dairy.txt</strong>中的已有日记重复,则会将原来的日记替换掉</p></li><li><p>内容：从<strong>stdin</strong>中逐行读取日记内容，直到单独的一个<strong>'.'/EOF</strong>截止</p></li></ul><h2 id="pdlist程序">1.2 pdlist程序</h2><p>按照日期的顺序，列出<strong>diary.txt</strong>中的日记实体</p><ul><li>输入：如果通过命令行参数，输入了开始日期和结束日期，则只输出在这两个日期之间的日记</li><li>输出：<strong>stdout</strong></li></ul><h2 id="pdshow程序">1.3 pdshow程序</h2><p>按照输入的日期，列出<strong>diary.txt</strong>中的对应日记实体的内容</p><ul><li>输入：<strong>stdin</strong></li><li>输出：<strong>stdout</strong></li></ul><h2 id="pdremove程序">1.4 pdremove程序</h2><p>按照输入的日期，删除<strong>diary.txt</strong>中的对应日记</p><ul><li>输入：<strong>stdin</strong></li><li>输出：<strong>stdout</strong></li><li>返回值：<strong>0</strong>表示删除成功，<strong>1</strong>表示删除失败</li></ul><h1 id="二实现思路">二、实现思路</h1><h2 id="定义的类">2.1 定义的类</h2><h3 id="date类">2.1.1 Date类</h3><h4 id="成员变量">成员变量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> year;  <span class="comment">//日记的年份</span></span><br><span class="line"><span class="type">int</span> month; <span class="comment">//日记的月份</span></span><br><span class="line"><span class="type">int</span> day;   <span class="comment">//日记的日子</span></span><br></pre></td></tr></table></figure><h4 id="成员函数">成员函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//从键盘中输入日期,并且给出输入提示</span></span><br><span class="line"><span class="comment">//当输入的日期为-1/-1/-1时,返回false</span></span><br><span class="line"><span class="comment">//否则返回true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">(ifstream&amp; fin)</span></span>; </span><br><span class="line"><span class="comment">//从文件流中输入日期</span></span><br><span class="line"><span class="comment">//当输入的日期为-1/-1/-1时,表示整个文件的日记读取完成,返回false</span></span><br><span class="line"><span class="comment">//否则返回true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//向屏幕中输出日期</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(ofstream&amp; fout)</span></span>;</span><br><span class="line"><span class="comment">//向文件流中输出日期</span></span><br></pre></td></tr></table></figure><h4 id="重载符号">重载符号</h4><ol type="1"><li>以年、月、日为第一、二、三关键字进行比较</li><li>注意，<strong>-1/-1/-1</strong>默认为最大值</li></ol><h3 id="diary类">2.1.2 Diary类</h3><h4 id="成员变量-1">成员变量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Date date;<span class="comment">//记录日记的日期</span></span><br><span class="line">vector&lt;string&gt;content;  <span class="comment">//记录日记的内容</span></span><br></pre></td></tr></table></figure><h4 id="成员函数-1">成员函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//从键盘中输入日记的日期及内容,并且给出输入提示</span></span><br><span class="line"><span class="comment">//当输入的日期为-1/-1/-1时,返回false</span></span><br><span class="line"><span class="comment">//否则返回true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">(ifstream&amp; fin)</span></span>; </span><br><span class="line"><span class="comment">//从文件中输入日记的日期及内容</span></span><br><span class="line"><span class="comment">//当输入的日期为-1/-1/-1时,表示整个文件的日记读取完成,返回false</span></span><br><span class="line"><span class="comment">//否则返回true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//向屏幕中输出日记的日期及内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(ofstream&amp; fout)</span></span>;</span><br><span class="line"><span class="comment">//向文件流中输出日记的日期及内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outputDate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//向屏幕中输出日记的日期</span></span><br><span class="line"><span class="function">Date <span class="title">GetDate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取当前日记的日期</span></span><br></pre></td></tr></table></figure><h4 id="重载符号-1">重载符号</h4><ol type="1"><li>以<strong>date</strong>为唯一关键字进行比较</li></ol><h2 id="存储">2.2 存储</h2><ol type="1"><li>日记文件为<strong>./code/diary.txt</strong></li><li>按照日期，升序排列所有日记文件</li><li>以<strong>-1/-1/-1</strong>为文件结尾</li></ol><h2 id="pdadd">2.3 pdadd</h2><p>用一个<strong>vector&lt; Diary&gt;diary</strong>保存已有的所有日记</p><ol type="1"><li>首先，从键盘中输入新增日记的信息，放到<strong>vector</strong>数组里面，记为<strong>diary[0]</strong></li><li>然后，从<strong>diary.txt</strong>文件读取所有日记，放到<strong>vector</strong>数组里面</li><li>从<strong>diary[1]</strong>开始输出存下的所有日记，分为三种情况<ol type="1"><li><strong>diary[i] =diary[0]</strong>：根据题意，舍弃<strong>diary[i]</strong>，将<strong>diary[0]</strong>输入到文件中</li><li><strong>diary[i] &gt; diary[0] &amp;&amp; diary[i] &lt;diary[0]</strong>：由于根据日期升序排列，此时要先输出<strong>diary[0]</strong>，后输出<strong>diary[i]</strong></li><li>其它情况：直接输出<strong>diary[i]</strong></li></ol></li></ol><h2 id="pdlist">2.4 pdlist</h2><ol type="1"><li>与<strong>pdadd</strong>类似，从<strong>diary.txt</strong>中读取所有日记，保存到<strong>diary</strong>数组中</li><li>从<strong>diary[0]</strong>开始输出存下的所有日记，由于只需要表示日记实体，因此我们只输出日记的日期</li><li>至于输出一定范围内的日记，我们只需要在输出的时候，判断一下<strong>diary[i]</strong>的日期是否在指定的范围内即可</li><li>当没有日记输出时，会输出提示信息</li></ol><h2 id="pdshow">2.5 pdshow</h2><ol type="1"><li>与<strong>pdlist</strong>类似，从<strong>diary.txt</strong>中读取所有日记，保存到<strong>diary</strong>数组中</li><li>从<strong>diary[0]</strong>开始遍历存下的所有日记，如果日期与输入的相同，则输出当前日记的所有内容</li><li>当没有日记输出时，会输出提示信息</li></ol><h2 id="pdremove">2.6 pdremove</h2><ol type="1"><li>与<strong>pdadd</strong>类似，从<strong>diary.txt</strong>中读取所有日记，保存到<strong>diary</strong>数组中</li><li>从<strong>diary[0]</strong>开始输出存下的所有日记，分为两种情况<ol type="1"><li><strong>diary[i]</strong>的日期与给定的日期相同：跳过该条日记</li><li>否则将<strong>diary[i]</strong>输入到文件中</li></ol></li><li>当待删除的日期不存在时，会输出提示信息</li></ol><h1 id="三源码">三、源码</h1><h2 id="公共类">3.0 公共类</h2><h3 id="date">3.0.1 Date</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>() : <span class="built_in">year</span>(<span class="number">0</span>), <span class="built_in">month</span>(<span class="number">0</span>), <span class="built_in">day</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day) : <span class="built_in">year</span>(year), <span class="built_in">month</span>(month), <span class="built_in">day</span>(day) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 从控制台读取日期</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 从文件读取日期</span></span><br><span class="line"><span class="comment">* @param fin 文件输入流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">(std::ifstream&amp; fin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 输出日期到控制台</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 输出日期到文件</span></span><br><span class="line"><span class="comment">* @param fout 文件输出流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(std::ostream&amp; fout)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; A) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> Date&amp; A) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Date&amp; A) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> Date DATE_MAX = <span class="built_in">Date</span>(<span class="number">9999</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> Date DATE_MIN = <span class="built_in">Date</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Date::input</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入日记的日期：年 月 日\n&quot;</span>);</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Red);</span><br><span class="line">std::cin &gt;&gt; year &gt;&gt; month &gt;&gt; day;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Blue);</span><br><span class="line"><span class="keyword">if</span> (year == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Date::input</span><span class="params">(std::ifstream&amp; fin)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fin.<span class="built_in">eof</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">fin &gt;&gt; year &gt;&gt; month &gt;&gt; day;</span><br><span class="line"><span class="keyword">if</span> (year == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::output</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Red);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%04d/%02d/%02d\n&quot;</span>, year, month, day);</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::output</span><span class="params">(std::ostream&amp; fout)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">fout &lt;&lt; year &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; day &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; A) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> year == A.year &amp;&amp; month == A.month &amp;&amp; day == A.day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>&lt;(<span class="type">const</span> Date&amp; A) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (year == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (A.year == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year != A.year)<span class="keyword">return</span> year &lt; A.year;</span><br><span class="line"><span class="keyword">if</span> (month != A.month)<span class="keyword">return</span> month &lt; A.month;</span><br><span class="line"><span class="keyword">return</span> day &lt; A.day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>&gt;(<span class="type">const</span> Date&amp; A) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; A) &amp;&amp; !(*<span class="keyword">this</span> == A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="diary">3.0.2 Diary</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Diary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Diary</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">Diary</span>(<span class="type">const</span> Date&amp; date) : <span class="built_in">date</span>(date) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 从控制台读取日期</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 从文件读取日期</span></span><br><span class="line"><span class="comment">* @param fin 文件输入流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">(std::ifstream&amp; fin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 输出日期到控制台</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 输出日期到文件</span></span><br><span class="line"><span class="comment">* @param fout 文件输出流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(std::ostream&amp; fout)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 输出日期到控制台</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outputDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Date <span class="title">GetDate</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> date; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Diary&amp; A) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> Diary&amp; A) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Diary&amp; A) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Date date;</span><br><span class="line">std::vector&lt;std::string&gt; content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Diary.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Diary::input</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="built_in">input</span>() == <span class="literal">false</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请逐行输入日记的内容,以.或EOF结束\n&quot;</span>);</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Yellow);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d:&quot;</span>, (<span class="type">int</span>)content.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Red);</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">empty</span>())<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">content.<span class="built_in">push_back</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">content.<span class="built_in">push_back</span>(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetColor</span>(Color::Yellow);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;日记输入成功\n&quot;</span>);</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Clear);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Diary::input</span><span class="params">(std::ifstream&amp; fin)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (date.<span class="built_in">input</span>(fin) == <span class="literal">false</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(fin, s);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">getline</span>(fin, s);</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">empty</span>())<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">content.<span class="built_in">push_back</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">content.<span class="built_in">push_back</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Diary::output</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">date.<span class="built_in">output</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; content.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">cout &lt;&lt; content[i] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Diary::output</span><span class="params">(std::ostream&amp; fout)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">date.<span class="built_in">output</span>(fout);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; content.<span class="built_in">size</span>(); i++)</span><br><span class="line">fout &lt;&lt; content[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Diary::outputDate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">date.<span class="built_in">output</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Diary::<span class="keyword">operator</span>==(<span class="type">const</span> Diary&amp; A) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> date == A.date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Diary::<span class="keyword">operator</span>&lt;(<span class="type">const</span> Diary&amp; A) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> date &lt; A.date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Diary::<span class="keyword">operator</span>&gt;(<span class="type">const</span> Diary&amp; A) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> date &gt; A.date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="diarymanager">3.0.3 DiaryManager</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Diary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiaryManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> DiaryManager&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> DiaryManager instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputNewDiary</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputAllDiary</span><span class="params">(Date L = DATE_MIN, Date R = DATE_MAX)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveDiary</span><span class="params">(Date now)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputAllDiary</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoreDiary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">DiaryManager</span>();</span><br><span class="line">~<span class="built_in">DiaryManager</span>();</span><br><span class="line"></span><br><span class="line">std::set&lt;Diary&gt; diary;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DiaryManager.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DiaryManager::InputNewDiary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Diary tmp;</span><br><span class="line">tmp.<span class="built_in">input</span>();</span><br><span class="line">diary.<span class="built_in">insert</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DiaryManager::OutputAllDiary</span><span class="params">(Date L, Date R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it1 = diary.<span class="built_in">lower_bound</span>(<span class="built_in">Diary</span>(L));</span><br><span class="line"><span class="keyword">auto</span> it2 = diary.<span class="built_in">upper_bound</span>(<span class="built_in">Diary</span>(R));</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Yellow);</span><br><span class="line"><span class="keyword">if</span> (it1 == it2) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No diary in this period!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Diary is as following:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = it1; it != it2; it++) &#123;</span><br><span class="line">it-&gt;<span class="built_in">output</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Clear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DiaryManager::RemoveDiary</span><span class="params">(Date now)</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Yellow);</span><br><span class="line"><span class="keyword">if</span>(diary.<span class="built_in">find</span>(<span class="built_in">Diary</span>(now)) != diary.<span class="built_in">end</span>()) &#123;</span><br><span class="line">diary.<span class="built_in">erase</span>(<span class="built_in">Diary</span>(now));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Remove success&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No diary on this day!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Clear);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DiaryManager::InputAllDiary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;diary.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">Diary tmp;</span><br><span class="line"><span class="keyword">if</span> (!tmp.<span class="built_in">input</span>(fin)) <span class="keyword">break</span>;</span><br><span class="line">diary.<span class="built_in">insert</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DiaryManager::StoreDiary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;diary.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = diary.<span class="built_in">begin</span>(); it != diary.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">it-&gt;<span class="built_in">output</span>(fout);</span><br><span class="line">&#125;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiaryManager::<span class="built_in">DiaryManager</span>() &#123;</span><br><span class="line"><span class="built_in">InputAllDiary</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiaryManager::~<span class="built_in">DiaryManager</span>() &#123;</span><br><span class="line"><span class="built_in">StoreDiary</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="utils">3.0.4 Utils</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">Red,</span><br><span class="line">Blue,</span><br><span class="line">Green,</span><br><span class="line">Yellow,</span><br><span class="line">Clear</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">HANDLE hdl = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line"><span class="keyword">if</span> (color == Color::Red)<span class="built_in">SetConsoleTextAttribute</span>(hdl, FOREGROUND_RED | FOREGROUND_INTENSITY);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (color == Color::Blue)<span class="built_in">SetConsoleTextAttribute</span>(hdl, FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (color == Color::Green)<span class="built_in">SetConsoleTextAttribute</span>(hdl, FOREGROUND_GREEN | FOREGROUND_INTENSITY);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (color == Color::Yellow)<span class="built_in">SetConsoleTextAttribute</span>(hdl, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (color == Color::Clear)<span class="built_in">SetConsoleTextAttribute</span>(hdl, FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pdadd-1">3.1 pdadd</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Diary/DiaryManager.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Blue);</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">freopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiaryManager::<span class="built_in">GetInstance</span>().<span class="built_in">InputNewDiary</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pdlist-1">3.2 pdlist</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Diary/DiaryManager.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckFormat</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span>* s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">3</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(s[<span class="number">1</span>]);</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">1</span>][i] == <span class="string">&#x27;/&#x27;</span>)cnt++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>][i] &gt; <span class="string">&#x27;9&#x27;</span> || s[<span class="number">1</span>][i] &lt; <span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt != <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">len = <span class="built_in">strlen</span>(s[<span class="number">2</span>]);</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">2</span>][i] == <span class="string">&#x27;/&#x27;</span>)cnt++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">2</span>][i] &gt; <span class="string">&#x27;9&#x27;</span> || s[<span class="number">2</span>][i] &lt; <span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt != <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Blue);</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">DiaryManager::<span class="built_in">GetInstance</span>().<span class="built_in">OutputAllDiary</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CheckFormat</span>(argc, argv)) &#123;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Red);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入正确的参数格式:xxxx/xx/xx xxxx/xx/xx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> LYear = <span class="number">0</span>, LMonth = <span class="number">0</span>, LDay = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> RYear = <span class="number">0</span>, RMonth = <span class="number">0</span>, RDay = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d/%d/%d&quot;</span>, &amp;LYear, &amp;LMonth, &amp;LDay);</span><br><span class="line"><span class="built_in">sscanf</span>(argv[<span class="number">2</span>], <span class="string">&quot;%d/%d/%d&quot;</span>, &amp;RYear, &amp;RMonth, &amp;RDay);</span><br><span class="line">DiaryManager::<span class="built_in">GetInstance</span>().<span class="built_in">OutputAllDiary</span>(<span class="built_in">Date</span>(LYear, LMonth, LDay), <span class="built_in">Date</span>(RYear, RMonth, RDay));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pdremove-1">3.3 pdremove</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Diary/DiaryManager.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Blue);</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">freopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">&#125;</span><br><span class="line">Date now;</span><br><span class="line">now.<span class="built_in">input</span>();</span><br><span class="line">DiaryManager::<span class="built_in">GetInstance</span>().<span class="built_in">RemoveDiary</span>(now);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pdshow-1">3.4 pdshow</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Diary/DiaryManager.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetColor</span>(Color::Blue);</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">freopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">&#125;</span><br><span class="line">Date now;</span><br><span class="line">now.<span class="built_in">input</span>();</span><br><span class="line">DiaryManager::<span class="built_in">GetInstance</span>().<span class="built_in">OutputAllDiary</span>(now, now);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sample.bat">3.5 sample.bat</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pdadd sampleAdd.txt</span><br><span class="line">pdshow sampleShow.txt</span><br><span class="line">pdremove sampleRemove.txt</span><br><span class="line">pdlist</span><br><span class="line">pdlist 2022/4/10 2022/4/11</span><br><span class="line">pdlist 2025/4/10 2025/4/11</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">call pdadd.exe &lt; sampleAdd.txt</span><br><span class="line">call pdshow.exe &lt; sampleShow.txt</span><br><span class="line">call pdremove.exe &lt; sampleRemove.txt</span><br><span class="line">pdlist</span><br><span class="line">pdlist 2022/4/10 2022/4/11</span><br><span class="line">pdlist 2025/4/10 2025/4/11</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="diary.txt">3.6 diary.txt</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">2022 4 10</span><br><span class="line">asd123www</span><br><span class="line">asdqw</span><br><span class="line">.</span><br><span class="line">2022 4 11</span><br><span class="line">asd1asdqweyuitbladf</span><br><span class="line">.</span><br><span class="line">2022 4 13</span><br><span class="line">asd123www</span><br><span class="line">asdqweyuitbladf</span><br><span class="line">.</span><br><span class="line">2022 4 14</span><br><span class="line">123456789</span><br><span class="line">00000000</span><br><span class="line">14568+423</span><br><span class="line">.</span><br><span class="line">2022 4 15</span><br><span class="line">123456789</span><br><span class="line">00000000</span><br><span class="line">14568+423</span><br><span class="line">.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP13：SmartPointer</title>
      <link href="/2023/10/13/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC13%E7%AB%A0-SmartPointer/"/>
      <url>/2023/10/13/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC13%E7%AB%A0-SmartPointer/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第13章-smartpointer">第13章 SmartPointer</h1><h2 id="设计目标">13.1 设计目标</h2><ol type="1"><li>记录当前对象被引用了多少次 <strong>reference count</strong></li><li>类<strong>UCObject</strong>用来记录次数，use-counted object</li><li>类<strong>UCPointer</strong>用来指向<strong>UCObject</strong><ol type="1"><li>智能指针是通过一个类定义的</li><li>使用模板实现</li><li>重载操作符<strong>-&gt;</strong>和*****</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120411976.png" alt="image-20231022120411976" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120419356.png" alt="image-20231022120419356" style="zoom:80%;" /></p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120425393.png"alt="image-20231022120425393" /><figcaption aria-hidden="true">image-20231022120425393</figcaption></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120506563.png" alt="image-20231022120506563" style="zoom:80%;" /></p><h2 id="设计类和接口">13.2 设计类和接口</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120515388.png" alt="image-20231022120515388" style="zoom:80%;" /></p><ol type="1"><li><strong>UCObject</strong>：实现<strong>reference count</strong></li><li><strong>UCPointer</strong>：是一个类模板，支持指向任意一个类型的<strong>UCObject</strong></li><li><strong>String Rep</strong>：字符串表示的细节，是可共享的</li><li><strong>String</strong>：再封装一层，提供给用户</li></ol><h2 id="实现细节">13.3 实现细节</h2><ol type="1"><li><p><strong>UCObject</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCObject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_refCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UCObject</span>() : <span class="built_in">m_refCount</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">UCObject</span>(<span class="type">const</span> UCObject&amp;) : <span class="built_in">m_refCount</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数需要是virtual的,因为使用的时候,我们通常会使用父类指针指向子类,但是析构的时候要正确调用子类的析构函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">UCObject</span>() &#123; </span><br><span class="line">        <span class="built_in">assert</span>(m_refCount == <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口不需要virtual, 因为所有子类的这些操作都是一样的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        m_refCount++; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_refCount -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_refCount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">references</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m_refCount; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>UCPointer</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCPointer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_pObj;</span><br><span class="line">    <span class="comment">// 下列两个函数表明: T继承自UCObject, 否则调用incr(),decr()时编译器会报错</span></span><br><span class="line">    <span class="comment">// 因为UCPointer要像指针一样使用, 因此将这两个函数放入private中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (m_pObj) m_pObj-&gt;<span class="built_in">incr</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (m_pObj) m_pObj-&gt;<span class="built_in">decr</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UCPointer</span>(T* r = <span class="number">0</span>): <span class="built_in">m_pObj</span>(r) &#123; </span><br><span class="line">        <span class="built_in">increment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">~<span class="built_in">UCPointer</span>() &#123; </span><br><span class="line">        <span class="built_in">decrement</span>(); </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">UCPointer</span>(<span class="type">const</span> UCPointer&lt;T&gt; &amp; p)&#123;</span><br><span class="line">        m_pObj = p.m_pObj;</span><br><span class="line">  <span class="built_in">increment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">UCPointer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UCPointer&lt;T&gt; &amp;)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pObj != p.m_Obj)&#123;</span><br><span class="line">            <span class="built_in">decrement</span>();</span><br><span class="line">            m_pObj = p.m_pObj;</span><br><span class="line">            <span class="built_in">increment</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pObj;</span><br><span class="line">    &#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> *m_pObj; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用实例：假设Shape继承自UCObject</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Ellipse <span class="title">elly</span><span class="params">(<span class="number">200F</span>, <span class="number">300F</span>)</span></span>;</span><br><span class="line"><span class="function">UCPointer&lt;Shape&gt; <span class="title">p</span><span class="params">(&amp;elly)</span></span>;</span><br><span class="line">p-&gt;<span class="built_in">render</span>(); <span class="comment">// calls Ellipse::render() on  elly!</span></span><br></pre></td></tr></table></figure></li><li><p><strong>String</strong></p><ol type="1"><li><strong>StringReq</strong>继承自<strong>UCObject</strong></li><li><strong>String</strong>提供用户使用的</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">~<span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp;);</span><br><span class="line">String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp;);</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>==(<span class="type">const</span> String&amp;) <span class="type">const</span>;</span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp;) <span class="type">const</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">operator</span> <span class="type">const</span> <span class="type">char</span>*() <span class="type">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">UCPointer&lt;StringRep&gt; m_rep;</span><br><span class="line">&#125;;</span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *s) : <span class="built_in">m_rep</span>(<span class="number">0</span>) &#123;</span><br><span class="line">m_rep = <span class="keyword">new</span> <span class="built_in">StringRep</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~<span class="built_in">String</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Again, note constructor for rep in list.</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String&amp; s) : <span class="built_in">m_rep</span>(s.m_rep) &#123;&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; s) &#123;</span><br><span class="line">m_rep = s.m_rep; <span class="comment">// let smart pointer do work!</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> String::<span class="keyword">operator</span>==(<span class="type">const</span> String&amp; s) <span class="type">const</span> &#123;</span><br><span class="line"><span class="comment">// overloaded -&gt; forwards to StringRep</span></span><br><span class="line"><span class="keyword">return</span> m_rep-&gt;<span class="built_in">equal</span>(*s.m_rep); <span class="comment">// smart ptr *</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">String::length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_rep-&gt;<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StringRep</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span> : <span class="keyword">public</span> UCObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">StringRep</span>(<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">~<span class="built_in">StringRep</span>();</span><br><span class="line"><span class="built_in">StringRep</span>(<span class="type">const</span> StringRep&amp;);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> <span class="built_in">strlen</span>(m_pChars); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> StringRep&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *m_pChars;</span><br><span class="line"><span class="comment">// reference semantics -- no assignment op!</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> StringRep&amp;) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">StringRep::<span class="built_in">StringRep</span>(<span class="type">const</span> <span class="type">char</span> *s) &#123;</span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(s) + <span class="number">1</span>;</span><br><span class="line">m_pChars = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line"><span class="built_in">strcpy</span>(m_pChars , s);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m_pChars = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">*m_pChars = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">StringRep::~<span class="built_in">StringRep</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span> [] m_pChars ;</span><br><span class="line">&#125;</span><br><span class="line">StringRep::<span class="built_in">StringRep</span>(<span class="type">const</span> StringRep&amp; sr) &#123;</span><br><span class="line"><span class="type">int</span> len = sr.<span class="built_in">length</span>();</span><br><span class="line">m_pChars = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(m_pChars , sr.m_pChars );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StringRep::equal</span><span class="params">(<span class="type">const</span> StringRep&amp; sp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">strcmp</span>(m_pChars, sp.m_pChars) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120526039.png" alt="image-20231022120526039" style="zoom:80%;" /></p><h2 id="细节">13.4 细节</h2><ol type="1"><li><strong>UCPointer</strong>维护了<strong>referencecounts</strong></li><li><strong>UCObject</strong>隐藏了<strong>count</strong>的细节，使得<strong>String</strong>非常干净</li><li><strong>StringReq</strong>只处理字符串的存储和操作</li><li><strong>UCObject</strong>和<strong>UCPointer</strong>是可重用的</li><li>当<strong>UCPointer</strong>的对象有环时，对象不会被<strong>delete</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP12：Policy-based Design</title>
      <link href="/2023/10/12/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC12%E7%AB%A0-Policy-based%20Design/"/>
      <url>/2023/10/12/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC12%E7%AB%A0-Policy-based%20Design/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第12章-policy-based-design基于策略的设计">第12章 Policy-basedDesign基于策略的设计</h1><h2 id="the-multiplicity-of-software-design">12.1 The Multiplicity ofSoftware Design</h2><ol type="1"><li>一个问题有很多中正确的解法，不同的解法在不同情况下具有不同的优势</li><li>软件需要支持用户的定制，因此需要提供多种情况对应的实现形式</li></ol><h3 id="例创建一个对象的策略">12.1.1 例:创建一个对象的策略</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接new一个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OpNewCreator</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 先分配内存，再调用构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MallocCreator</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">void</span>* buf = std::<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line">        <span class="keyword">if</span> (!buf) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(buf) T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从已有对象中复制一个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrototypeCreator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* pPrototype_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">PrototypeCreator</span>(T* pObj = <span class="number">0</span>):<span class="built_in">pPrototype_</span>(pObj)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">T* <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pPrototype_ ? pPrototype_-&gt;<span class="built_in">Clone</span>() : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">T* <span class="title">GetPrototype</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> pPrototype_; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPrototype</span><span class="params">(T* pObj)</span> </span>&#123; </span><br><span class="line">        pPrototype_ = pObj;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="通过policy控制内存分配的策略">12.1.2通过policy控制内存分配的策略</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Library code: 用户控制实现哪个类型的分配</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">CreationPolicy</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetManager</span> : <span class="keyword">public</span> CreationPolicy&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">WidgetManager&lt; OpNewCreator&lt;Widget&gt; &gt; wgtManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Library code: 程序控制实现哪个类型的分配, 用户不需要声明widget的类型信息</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Created</span>&gt; <span class="keyword">class</span> <span class="title class_">CreationPolicy</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetManager</span> : <span class="keyword">public</span> CreationPolicy&lt;Widget&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">WidgetManager&lt; OpNewCreator&gt; wgtManager;</span><br></pre></td></tr></table></figure><h3 id="使用模板类作为模板参数">12.1.3 使用模板类作为模板参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Library code</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">CreationPolicy</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetManager</span> : <span class="keyword">public</span> CreationPolicy&lt;Widget&gt;&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Gadget* pW = <span class="built_in">CreationPolicy</span>&lt;Gadget&gt;().<span class="built_in">Create</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="policy-based-design的优点">12.1.4 Policy-based Design的优点</h3><ol type="1"><li>使用策略给<strong>WidgetManager</strong>带来了很大的灵活性<ol type="1"><li>我们可以从外部改变策略</li><li>我们可以提供我们自己的特定于我们具体应用的策略</li><li><strong>WidgetManager</strong>现在是一个小的代码生成引擎，用户可以配置它生成代码的方式。</li></ol></li><li>策略的特性也使它们不适合动态绑定和二进制接口，所以在本质上策略和经典接口不存在竞争。</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120359504.png" alt="image-20231022120359504" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP11：Iterators</title>
      <link href="/2023/10/11/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC11%E7%AB%A0-Iterators/"/>
      <url>/2023/10/11/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC11%E7%AB%A0-Iterators/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第11章-iterators">第11章 Iterators</h1><h2 id="iterator的作用">11.1 Iterator的作用</h2><ol type="1"><li>在算法中使用的统一接口</li><li>像指向容器中元素的指针一样工作</li><li>通过++操作符顺序访问容器的元素</li><li>通过*操作符访问元素的内容</li></ol><h3 id="auto_ptr">11.1.1 auto_ptr</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line">    T *pointee;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(T *p)</span> </span>&#123; pointee = p;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="built_in">auto_ptr</span>(<span class="type">const</span> auto_ptr&lt;U&gt; &amp;rhs): <span class="built_in">pointee</span>(rhs.release) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数模板</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    Auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> auto_ptr&lt;U&gt;  &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) <span class="built_in">reset</span>(rhs.<span class="built_in">release</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() &#123; <span class="keyword">return</span> *pointee; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt;() &#123; <span class="keyword">return</span> pointee; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iter的基础实现listiter">11.1.2 iter的基础实现：listIter</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List的内部实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListItem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">    ListItem *next &#123; <span class="keyword">return</span> _next&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _value;</span><br><span class="line">    ListItem&lt;T&gt; *_next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// List对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListItem&lt;T&gt; *front;</span><br><span class="line">    ListItem&lt;T&gt; *end;</span><br><span class="line">    <span class="type">long</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// List迭代器对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListIter</span> &#123;</span><br><span class="line">Item *ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ListIter</span>(Item *p=<span class="number">0</span>) :<span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    <span class="comment">// 要实现基础的这三个操作符</span></span><br><span class="line">    ListIter&lt;Item&gt; &amp;<span class="keyword">operator</span>++() &#123; ptr = ptr-&gt;next; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    Item&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    Item* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> ptr;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用List迭代器对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">begin</span>(myList.<span class="built_in">begin</span>());</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">end</span>(myList.<span class="built_in">end</span>());</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; iter;</span><br><span class="line"></span><br><span class="line">    iter = <span class="built_in">find</span>(begin, end, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter == end)</span><br><span class="line">        cout&lt;&lt;“<span class="keyword">not</span> found”&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-迭代器-及-迭代器指向的类型-进行编程">11.1.3 对 迭代器 及迭代器指向的类型 进行编程</h3><p>直接实现：</p><ol type="1"><li><strong>func</strong>需要使用<strong>iterator</strong>指向的元素的类型</li><li>由于<strong>iterator</strong>是一个模板，因此我们不知道其指向的类型是什么</li><li>将与指向元素类型有关的代码封装为另一个函数<strong>func_impl</strong></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 我们不知道iter指向的对象类型是什么</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_impl</span><span class="params">(I iter, T v)</span></span>&#123;   <span class="comment">// 所以需要一个额外的变量T v来表示iter指向的对象及其类型</span></span><br><span class="line">T tmp;</span><br><span class="line">tmp = *iter;</span><br><span class="line"><span class="comment">//processing code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span> &gt;    <span class="comment">// a wrapper to extract the associated data type T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span> <span class="params">(I iter)</span></span>&#123;</span><br><span class="line"><span class="built_in">func_impl</span>(iter, *iter);</span><br><span class="line"><span class="comment">//processing code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<strong>iterator</strong>特征提取器</p><ol type="1"><li><strong>typename</strong>表示后面的类型，是可以推导出来的</li><li>这样就可以直接获得迭代器指向的对象的类型<strong>I::value_type</strong></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myIter</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span>  T value_type;</span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="built_in">myIter</span>(T *p = <span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> *iter; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="partial-specialization偏特化">11.2 partialspecialization偏特化</h2><p>对同一个模板类C</p><ol type="1"><li>当传入的类型是指针时，使用下面的模板进行实例化</li><li>当传入的类型不是指针时，使用上面的模板进行实例化</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入的类型不是指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">C</span>() &#123;cout&lt;&lt;“<span class="keyword">template</span> T”&lt;&lt;endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入的类型是指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T*&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">C</span>() &#123;cout&lt;&lt;“<span class="keyword">template</span> T*”&lt;&lt;endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iterator中的偏特化">11.2.2 Iterator中的偏特化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer_type pointer_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator_traits</span>&lt;T *&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> T* pointer_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stl中的标准特征提取技术">11.2.3 STL中的标准特征提取技术</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type differece_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer_type pointer_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP11：Class Design</title>
      <link href="/2023/10/10/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC11%E7%AB%A0-Class%20Design/"/>
      <url>/2023/10/10/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC11%E7%AB%A0-Class%20Design/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第11章-class-design">第11章 Class Design</h1><h2 id="类的设计要求">11.1 类的设计要求</h2><ol type="1"><li>要易于理解，易于维护，易于重用</li><li>要做些什么<ol type="1"><li>我们需要多少种类？</li><li>何时定义成一个类？</li><li>类中有什么接口和数据？</li><li>我们需要构造继承来促进接口和代码重用吗?</li><li>哪个函数应该是<strong>virtual</strong>的，以支持运行时的动态绑定?</li></ol></li><li>考量内容 1. <strong>Responsibility-drivendesign</strong>：职责驱动的设计 2. <strong>Coupling</strong>：耦合 3.<strong>Cohesion</strong>：内聚 4.<strong>Refactoring</strong>：重构</li></ol><h2 id="代码质量">11.2 代码质量</h2><h3 id="coupling-耦合">11.2.1 Coupling 耦合</h3><p><strong>Coupling</strong>耦合：指的是一个程序中，不同单元之间的联系</p><ol type="1"><li>如果两个类紧密地依赖于彼此的许多细节，我们就说它们是紧密耦合<strong>tightlycoupled</strong>的</li><li>我们的目标是：尽可能松耦合<strong>Loose coupling</strong></li><li>直观表述：如果X改变了，在Y中我们需要修改多少代码</li></ol><p><strong>Loose coupling</strong>松耦合：</p><ol type="1"><li>理解类X，我们不需要理解类Y</li><li>改变类X，我们不需要改变类Y</li><li>因此会提高可维护性<strong>maintainability</strong></li></ol><p>实现松耦合的方法：</p><ol type="1"><li>回调函数<strong>call-back</strong>：通过接口实现调用</li><li>消息机制<strong>message mech</strong></li></ol><h3 id="cohesion-内聚">11.2.2 Cohesion 内聚</h3><p><strong>Cohesion</strong>内聚：指的是一个单元，需要负责的任务的数量和多样性</p><ol type="1"><li>如果<strong>每个单元负责一项逻辑任务</strong>，我们就说它具有高内聚</li><li>内聚适用于类和方法</li><li>我们的目标是高内聚<strong>hign cohension</strong></li></ol><p><strong>hign cohension</strong>高内聚的优点：</p><ol type="1"><li>更容易理解类或方法的作用</li><li>更容易使用描述性的名字</li><li>更容易重用类或方法</li></ol><p>方法的内聚性：</p><ol type="1"><li>一个<strong>方法</strong>应该负责且仅负责<strong>一个定义良好的任务</strong></li></ol><p>类的内聚性：</p><ol type="1"><li><strong>类</strong>应该表示一个定义良好的<strong>单一实体</strong></li></ol><h3 id="code-duplication-代码重复">11.2.3 Code duplication 代码重复</h3><ol type="1"><li>是糟糕设计的标志</li><li>使得维护困难</li><li>可能导致维修过程中出现错误</li></ol><h3 id="responsibility-driven-design-职责驱动的设计">11.2.4Responsibility-driven design 职责驱动的设计</h3><ol type="1"><li>问题：我们应该在哪里添加一个新方法(哪个类)</li><li>每个类都应该负责操作自己的数据</li><li>拥有数据的类应该负责处理数据</li><li>RDD可以实现低耦合</li></ol><h3 id="localizing-change-局部化修改">11.2.5 Localizing change局部化修改</h3><ol type="1"><li>减少耦合和责任驱动设计的一个目标是将更改本地化</li><li>当需要<strong>更改时，受影响的类越少越好</strong></li></ol><h3 id="thinking-ahead-提前思考">11.2.6 Thinking ahead 提前思考</h3><ol type="1"><li>在设计类时，我们试图<strong>思考将来可能会做出哪些更改</strong></li><li>我们的目标是让这些更改变得容易</li></ol><h3 id="refactoring-重构">11.2.7 Refactoring 重构</h3><p><strong>Refactoring</strong>重构：</p><ol type="1"><li>维护类时，通常会添加代码</li><li>类和方法变得越来越长</li><li>应该不时地重构类和方法，以保持内聚和低耦合</li></ol><p><strong>Refactoring and testing</strong>重构和测试：</p><ol type="1"><li>在重构代码时，要将重构与其他更改分开</li><li>首先只进行重构，不改变功能</li><li>在重构之前和之后进行测试，以确保没有任何问题</li></ol><h2 id="设计的问题">11.3 设计的问题</h2><p>通性问题：</p><ol type="1"><li>一个类需要多长</li><li>一个方法需要多长</li></ol><p>设计的准则</p><ol type="1"><li>如果一个方法执行多个逻辑任务，那么它就太长了</li><li>如果一个类表示多个逻辑实体，那么它就太复杂了</li><li>注意：这些是指导原则—它们仍然给设计师留下了很大的空间。</li></ol>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP10：Exceptions</title>
      <link href="/2023/10/09/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC10%E7%AB%A0-Exceptions/"/>
      <url>/2023/10/09/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC10%E7%AB%A0-Exceptions/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第10章-exceptions">第10章 Exceptions</h1><h2 id="introduction">10.1 Introduction</h2><p>C++的原则</p><ol type="1"><li>尽量在编译时，找出可能的错误</li><li>代码重用</li></ol><p>但是在运行过程中，仍有错误发生，我们需要能够处理未来运行时，可能出现的错误</p><ol type="1"><li>当出现错误的时候，程序不知道应该如何处理</li><li>但是程序知道必须要停止当前进程</li><li>让调用者<strong>caller</strong>处理异常</li></ol><p>exception的优点</p><ol type="1"><li>将代码简化</li><li>将描述想要执行的代码与执行的代码分开</li></ol><h2 id="语法">10.2 语法</h2><h3 id="callee扔出异常">10.2.1 callee扔出异常</h3><ol type="1"><li><strong>throw</strong>出的是一个<strong>异常对象(class)</strong></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VectorIndexError</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">VectorIndexError</span>(<span class="type">int</span> v) : <span class="built_in">m_badValue</span>(v) &#123; &#125;</span><br><span class="line">~<span class="built_in">VectorIndexError</span>() &#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">diagnostic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;index &quot;</span> &lt;&lt; m_ badValue &lt;&lt; <span class="string">&quot;out of range!&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_badValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> indx)&#123;  </span><br><span class="line">  <span class="keyword">if</span> (indx &lt; <span class="number">0</span> || indx &gt;= m_size) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">VectorIndexError</span>(indx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m_elements[indx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="caller处理异常">10.2.2 caller处理异常</h3><h4 id="不管异常">10.2.2.1 不管异常</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">v[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> i = v[<span class="number">42</span>]; <span class="comment">// out of range</span></span><br><span class="line"><span class="comment">// 下面的代码不会被执行</span></span><br><span class="line"><span class="keyword">return</span> i * <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理异常-try-catch">10.2.2.2 处理异常 try… catch…</h4><ol type="1"><li><strong>catch</strong>处理哪一类异常，是根据<strong>catch</strong>后面的<strong>异常对象</strong>决定的</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span> (VectorIndexError&amp; e) &#123;</span><br><span class="line">e.<span class="built_in">diagnostic</span>();</span><br><span class="line"><span class="comment">// 对异常的处理到这里截止,代码正常向后执行</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Control is here after exception&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将异常传递下去">10.2.2.3 将异常传递下去</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outer2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">err</span><span class="params">(<span class="string">&quot;exception caught&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (VectorIndexError) &#123;</span><br><span class="line">        cout &lt;&lt; err;</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 将异常传递下去</span></span><br><span class="line">        <span class="comment">//之后的代码依旧不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理任意类型的异常">10.2.2.4 处理任意类型的异常</h4><ol type="1"><li><strong>...</strong>代表任意类型的异常</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outer3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="built_in">outer2</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// ...代表任意类型的异常</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The exception stops here!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120255377.png" alt="image-20231022120255377" style="zoom:80%;" /></p><h3 id="总结">10.2.3 总结</h3><p><strong>throw</strong>扔出异常</p><ol type="1"><li>处理器会沿着调用链，找到第一个能够处理异常的程序</li><li>在<strong>stack</strong>上的对象，会被正确的析构</li></ol><p><strong>throw exp;</strong></p><ol type="1"><li>扔出异常对象，便于<strong>caller</strong>处理</li></ol><p><strong>throw;</strong></p><ol type="1"><li>将捕获到的异常再扔出去</li><li>只能在<strong>catch</strong>块里面写</li></ol><p><strong>try block</strong></p><ol type="1"><li>一个<strong>try</strong>后面可以有任意多个<strong>catch</strong></li><li>每个<strong>catch block</strong>处理不同的异常</li><li>如果没有对异常处理的代码，则可以不写<strong>try</strong></li></ol><p><strong>catch</strong></p><ol type="1"><li>一个<strong>try</strong>后面可以有任意多个<strong>catch</strong></li><li>会根据出现的顺序，判断使用哪一个<strong>handler</strong></li><li>对于每一个<strong>handler</strong><ol type="1"><li>会先进行精准匹配</li><li>如果精准匹配不成功，会尝试类型转换：如果当前<strong>handler</strong>可以处理当前异常的父类，则会调用这个<strong>handler</strong></li><li>最后判断当前<strong>handler</strong>是否处理<strong>…</strong></li></ol></li><li>因此，要<strong>将精确匹配的类型放在前面</strong></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">B</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (A &amp;a)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handler A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (B &amp;b)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handler B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handler ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 会调用catch(A)</span></span><br><span class="line">    <span class="comment">// 因为处理器是按照顺序进行的,当寻找到catch(A)时,会将B类型转换为A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常类型的继承">10.2.4 异常类型的继承</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathErr</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">diagnostic</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OverflowErr</span> : <span class="keyword">public</span> MathErr &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnderflowErr</span> : <span class="keyword">public</span> MathErr &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroDivideErr</span> : <span class="keyword">public</span> MathErr &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> func&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code to exercise math options</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">UnderFlowErr</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (ZeroDivideErr&amp; e) &#123;</span><br><span class="line">        <span class="comment">// handle zero divide case</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (MathErr&amp; e) &#123;</span><br><span class="line">        <span class="comment">// handle other math errors</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// any other exceptions</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统自带的异常">10.3 系统自带的异常</h2><h3 id="bad_allocnew不成功">10.3.1 bad_alloc()：new不成功</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">char</span> *p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10000</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="built_in">catch</span> (bad_alloc&amp; e) &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120306064.png" alt="image-20231022120306064" style="zoom:80%;" /></p><h2 id="定义函数应该扔出的异常">10.4 定义函数应该扔出的异常</h2><ol type="1"><li><strong>abc</strong>扔出的异常应该是<strong>MathErr</strong>，相当于要求<strong>abc</strong>函数应该只处理数学问题</li><li>在编译时，不会检查</li><li>在运行时，如果扔出的异常不是<strong>MathErr</strong>，会扔出<strong>unexpected</strong>异常</li><li>规定的异常类型可以是多个</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">(<span class="type">int</span> a)</span> <span class="title">throw</span><span class="params">(MathErr)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Printer::<span class="built_in">print</span>(Document&amp;) <span class="keyword">throw</span>(PrinterOffLine, BadDocument)&#123; </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintManager::<span class="built_in">print</span>(Document&amp;) <span class="built_in">throw</span> (BadDocument) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// raises or doesn’t handle BadDocument</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">goodguy</span>() <span class="built_in">throw</span> () &#123;</span><br><span class="line"><span class="comment">// 不可以扔出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">average</span>() &#123;</span><br><span class="line">    <span class="comment">//没有规定,也不会判断扔出的异常类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常与构造函数析构函数">10.5 异常与构造函数、析构函数</h2><p>判断构造是否成功</p><ol type="1"><li>使用一个<strong>uninitialized flag</strong></li><li>将申请内存的操作延后到<strong>Init()</strong>函数</li><li>扔出一个异常</li></ol><p>异常与构造函数</p><ol type="1"><li>初始化所有成员对象</li><li>将所有的指针初始化为<strong>NULL</strong></li><li>不进行申请资源的操作，如打开文件、申请内存、连接网络</li><li>在<strong>Init()</strong>函数中申请资源</li></ol><p>异常与析构函数</p><ol type="1"><li>由于析构函数本来就是退栈过程，因此不能在析构函数中扔出异常</li><li>如果扔出异常，会触发<strong>std::terminate()</strong>异常</li><li>通过异常退出析构函数，是不合法的</li></ol><h2 id="使用异常编程">10.6 使用异常编程</h2><ol type="1"><li><p><strong>throw</strong>的如果是<strong>new</strong>出的对象，要记着在<strong>catch</strong>中<strong>delete</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Y</span>();</span><br><span class="line">&#125;<span class="built_in">catch</span>(Y* p) &#123;</span><br><span class="line">  <span class="comment">// whoops, forgot to delete..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>建议<strong>catch</strong>引用/指针，而不是对象</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> : <span class="keyword">public</span> X &#123;&#125;;</span><br><span class="line"><span class="comment">// 不要写成这样</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">Y</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span>(X x) &#123;</span><br><span class="line"><span class="comment">// was it X or Y?</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要使用引用or指针</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">Y</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span>(X &amp;x) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果一个异常没有被捕获，则会产生<strong>std::terminate()</strong>异常，<strong>terminate()</strong>也可以被拦截</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_terminate</span><span class="params">()</span></span>&#123; <span class="comment">/* ... */</span>&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">set_terminate</span>(my_terminate);</span><br></pre></td></tr></table></figure></li></ol><h2 id="exception的处理机制">10.7 Exception的处理机制</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120315983.png" alt="image-20231022120315983" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120323052.png" alt="image-20231022120323052" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120333201.png" alt="image-20231022120333201" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120338768.png" alt="image-20231022120338768" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP09：Template</title>
      <link href="/2023/10/08/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC9%E7%AB%A0-Template/"/>
      <url>/2023/10/08/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC9%E7%AB%A0-Template/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第9章-template">第9章 Template</h1><p>相当于定义了一个 函数/类 的集合</p><h2 id="函数模板">9.1 函数模板</h2><h3 id="函数模板的声明">9.1.1 函数模板的声明</h3><p>对不同的类型，执行相同的操作时，使用函数模板，比如swap、sort</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 或者是&lt;typename T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; x, T&amp; y)</span></span>&#123;</span><br><span class="line">    T temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><strong>template</strong>：声明模板</li><li><strong>classT</strong>：声明了参数化类型的名字，在模板函数中，用<strong>T</strong>作为一个类型名<ul><li>作为函数的参数</li><li>作为函数的返回值</li><li>作为函数的中间变量</li></ul></li></ol><h3 id="函数模板的实例化-template-instantiation">9.1.2 函数模板的实例化template instantiation</h3><ol type="1"><li>将一个真实的类型，带入template中</li><li>编译器会生成一个新的 函数/类 的定义<ul><li>在生成的过程中，会检查 语法错误/不安全的调用</li></ul></li><li>模板特化<strong>specialization</strong><ul><li>对特定的类型，执行新的模板函数</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>; <span class="type">int</span> j = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">swap</span>(i, j);  <span class="comment">// 实例化 int swap</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> k = <span class="number">4.5</span>; <span class="type">float</span> m = <span class="number">3.7</span>;</span><br><span class="line"><span class="built_in">swap</span>(k, m);  <span class="comment">// 实例化 float swap</span></span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(“Hello”)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">t</span><span class="params">(“World”)</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(s, t);  <span class="comment">// 实例化 std::string swap</span></span><br></pre></td></tr></table></figure><h3 id="函数模板的使用要求">9.1.3 函数模板的使用要求</h3><ol type="1"><li><p>只有精确匹配，才能调用，不能执行类型转换</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">swap</span>(<span class="type">double</span>, <span class="type">double</span>); <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">swap</span>(<span class="type">int</span>, <span class="type">double</span>);  <span class="comment">// error!</span></span><br></pre></td></tr></table></figure></li><li><p>函数模板、正常函数的命名可以是相同的，编译器会决定调用哪一个函数</p><ul><li>首先，检查与正常函数的参数类型是否完全匹配</li><li>然后，检查是否与模板的参数相同</li><li>最后，进行类型转换</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">float</span> i, <span class="type">float</span> k)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f(float, float);\n&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T t, T u)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f(T, T);\n&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);<span class="comment">//编译器默认浮点数为double, 此处编译器先判断为f(double, double), 符合模板的定义, 输出f(T,T);</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//此处编译器先判断为f(int, int), 符合模板的定义, 输出f(T,T)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2.0</span>);<span class="comment">//此处编译器先判断为f(int, double), 不符合模板的定义, 进行类型转换, 1=&gt;1.0f,2.0=&gt;2.0f, 然后输出f(float, float);</span></span><br></pre></td></tr></table></figure></li><li><p>编译器会推导<strong>T</strong>的实际类型，也可以自己手动定义</p><ul><li>如果函数模板没有参数，则需要手动填写参数类型</li><li>参数可以有无限多个</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="built_in">foo</span>&lt;<span class="type">int</span>&gt;();   <span class="comment">// type T is int</span></span><br><span class="line"><span class="built_in">foo</span>&lt;<span class="type">float</span>&gt;(); <span class="comment">// type T is float</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="类模板">9.2 类模板</h2><p>由类型参数化<strong>parameterized</strong>的类</p><h3 id="声明">9.2.1 声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">int</span>);</span><br><span class="line">~<span class="built_in">Vector</span>();</span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp;);</span><br><span class="line">Vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Vector&amp;);</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_elements;</span><br><span class="line"><span class="type">int</span> m_size;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="使用">9.2.2 使用</h3><p>必须手动填写类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Vector&lt;Complex&gt; <span class="title">v2</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v1[<span class="number">20</span>] = <span class="number">10</span>;</span><br><span class="line">v2[<span class="number">20</span>] = v1[<span class="number">20</span>];  <span class="comment">// ok if int-&gt;Complex defined</span></span><br></pre></td></tr></table></figure><h3 id="定义成员函数">9.2.3 定义成员函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Vector&lt;T&gt;::<span class="built_in">Vector</span>(<span class="type">int</span> size): <span class="built_in">m_size</span>(size)&#123;</span><br><span class="line">m_elements = <span class="keyword">new</span> T[m_size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line"><span class="keyword">if</span>(index &lt; m_size &amp;&amp; index &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_elements[index];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型参数的传递">9.2.4 类型参数的传递</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;T&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> last = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;last; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = last; i&lt;j; j--)</span><br><span class="line"><span class="keyword">if</span>(arr[j] &lt; arr[j<span class="number">-1</span>])</span><br><span class="line"><span class="built_in">swap</span>(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vi</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">vi[<span class="number">0</span>] = <span class="number">4</span>; vi[<span class="number">1</span>] = <span class="number">3</span>; vi[<span class="number">2</span>] = <span class="number">7</span>; vi[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(vi);  <span class="comment">// sort(vector&lt;int&gt;&amp;)</span></span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vs;</span><br><span class="line">vs.<span class="built_in">push_back</span>(“Fred”);</span><br><span class="line">vs.<span class="built_in">push_back</span>(“Wilma”);</span><br><span class="line">vs.<span class="built_in">push_back</span>(“Barney”);</span><br><span class="line">vs.<span class="built_in">push_back</span>(“Dino”);</span><br><span class="line">vs.<span class="built_in">push_back</span>(“Prince”);</span><br><span class="line"><span class="built_in">sort</span>(vs);<span class="comment">// sort(vector&lt;string&gt;&amp;);</span></span><br><span class="line"><span class="comment">//注意:sort需要有&lt;的定义</span></span><br></pre></td></tr></table></figure><h2 id="templates">9.3 templates</h2><ol type="1"><li><p>templates可以有多个参数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> Value&amp; <span class="title">lookup</span> <span class="params">(<span class="type">const</span> Key&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">install</span> <span class="params">(<span class="type">const</span> Key&amp;, <span class="type">const</span> Value&amp;)</span></span>;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数的嵌套</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vector&lt; vector&lt;<span class="type">double</span>*&gt; &gt;<span class="comment">//note space &gt; &gt;</span></span><br></pre></td></tr></table></figure></li><li><p>参数可以很复杂</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vector&lt; <span class="built_in">int</span> (*) (Vector&lt;<span class="type">double</span>&gt;&amp;, <span class="type">int</span>)&gt;</span><br></pre></td></tr></table></figure></li><li><p>参数可以是具体的类型--非类型参数 <strong>non-typeparameters</strong></p><ul><li>每给一个bounds的值，编译器就会生成对应的代码，可能会导致编译出的代码过长</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> bounds = <span class="number">100</span>&gt;</span><br><span class="line"><span class="keyword">class</span> FixedVector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FixedVector</span>();</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T elements[bounds];<span class="comment">// fixed size array!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> bounds&gt;</span><br><span class="line">T&amp; FixedVector&lt;T, bounds&gt;::<span class="keyword">operator</span>[] (<span class="type">int</span> i)&#123;</span><br><span class="line"><span class="keyword">return</span> elements[i];<span class="comment">//no error checking</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">FixedVector&lt;<span class="type">int</span>, <span class="number">50</span>&gt; v1;</span><br><span class="line">FixedVector&lt;<span class="type">int</span>, <span class="number">10</span>*<span class="number">5</span>&gt; v2;</span><br><span class="line">FixedVector&lt;<span class="type">int</span>&gt; v2;  <span class="comment">// 使用缺省值</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="模板与继承">9.4 模板与继承</h2><ol type="1"><li><p>模板类 可以继承于 非模板类</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;…&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板类 可以继承于 模板类</p><ul><li>基类的模板参数，从 派生类 中获得</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> List&lt;A&gt;&#123;…&#125;</span><br></pre></td></tr></table></figure></li><li><p>非模板类 可以继承于 模板类</p><ul><li>基类的模板参数，需要用户显式指定</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SupervisorGroup</span>:<span class="keyword">public</span> List&lt;Employee*&gt;&#123;…&#125;</span><br></pre></td></tr></table></figure></li></ol><p>例：模拟virtual函数的调用(不借用虚函数表)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">implementation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">implementation</span>(); <span class="comment">// ... </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    T::<span class="built_in">static_sub_func</span>(); <span class="comment">// ... </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;Derived&gt; &#123; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">implementation</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_sub_func</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="注意">9.5 注意</h2><ol type="1"><li>要把<strong>模板的定义和实现</strong>都放到<strong>头文件</strong>中</li><li>编译器会自动去除模板的重复定义</li></ol>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP08：Container</title>
      <link href="/2023/10/07/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC8%E7%AB%A0-Container&amp;Overload/"/>
      <url>/2023/10/07/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC8%E7%AB%A0-Container&amp;Overload/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第8-1章-container">第8-1章 Container</h1><h2 id="stl">8.1 STL</h2><h3 id="stl定义">8.1.1 STL定义</h3><p>(1)STL = Standard Template Library</p><p>(2)是ISO Standard C++ Library的一部分</p><p>(3)包含C++实现的数据结构、算法</p><h3 id="stl的三个部分">8.1.2 STL的三个部分</h3><p>(1)<strong>Containsers</strong>：容器</p><p>(2)<strong>Algorithms</strong>：算法</p><p>(3)<strong>Iterators</strong>：迭代器</p><h2 id="顺序访问的容器">8.2 顺序访问的容器</h2><p>(1)<strong>vecotor</strong>：可变长数组</p><p>(2)<strong>deque</strong>：双向队列</p><p>(3)<strong>list</strong>：双向链表</p><p>(4)<strong>forward_list</strong></p><p>(5)<strong>array</strong></p><p>(6)<strong>string</strong>：字符数组</p><h3 id="vector">8.2.1 vector</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义及初始化</span></span><br><span class="line">vector&lt;Elem&gt; c;</span><br><span class="line"><span class="function">vector&lt;Elem&gt; <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//预分配100个元素的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line">v.<span class="built_in">size</span>();</span><br><span class="line">v.<span class="built_in">empty</span>();</span><br><span class="line">==,!=,&gt;,&lt;,&lt;=,&gt;-;</span><br><span class="line">v.<span class="built_in">swap</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">v.<span class="built_in">begin</span>();</span><br><span class="line">v.<span class="built_in">end</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="keyword">for</span>(p=v.<span class="built_in">begin</span>();p&lt;x.<span class="built_in">end</span>();p++)</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">v.<span class="built_in">at</span>(index);</span><br><span class="line">v[index];</span><br><span class="line">v.<span class="built_in">front</span>();</span><br><span class="line">v.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加，删除，查找</span></span><br><span class="line">v.<span class="built_in">push_back</span>(e);</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">v.<span class="built_in">insert</span>(pos,e);</span><br><span class="line">v.<span class="built_in">erase</span>(pos);</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line">v.<span class="built_in">find</span>(first,last,item);</span><br></pre></td></tr></table></figure><h3 id="list">8.2.2 list</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义及初始化</span></span><br><span class="line">list&lt;string&gt; s;</span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">s1</span><span class="params">(s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">s.<span class="built_in">begin</span>();</span><br><span class="line">s.<span class="built_in">end</span>();</span><br><span class="line">list&lt;string&gt;::iterator p;</span><br><span class="line"><span class="keyword">for</span>(p=s.<span class="built_in">begin</span>();p!=s.<span class="built_in">end</span>();p++)</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">s.<span class="built_in">front</span>();</span><br><span class="line">s.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加，删除，查找</span></span><br><span class="line">s.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s.<span class="built_in">push_front</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">s.<span class="built_in">pop_back</span>();</span><br><span class="line">s.<span class="built_in">pop_front</span>();</span><br><span class="line">s.<span class="built_in">insert</span>(pos,item);</span><br><span class="line">s.<span class="built_in">remove</span>(item);</span><br><span class="line">s.<span class="built_in">erase</span>(pos);</span><br></pre></td></tr></table></figure><h2 id="map">8.3 Map</h2><p><strong>Map</strong>是一个<strong>pair</strong>的集合，包含<strong>key</strong>和<strong>value</strong></p><p>查找：需要一个<strong>key</strong>，返回一个<strong>value</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">map&lt;string,<span class="type">double</span>&gt; price;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">price[<span class="string">&quot;snapple&quot;</span>] = <span class="number">0.75</span>;</span><br><span class="line">price[<span class="string">&quot;coke&quot;</span>] = <span class="number">0.50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">string item;</span><br><span class="line"><span class="type">double</span> item_price;</span><br><span class="line">item_price = price[item];</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算item在map中出现的次数</span></span><br><span class="line">price.<span class="built_in">count</span>(item);</span><br></pre></td></tr></table></figure><h2 id="iterator-迭代器">8.4 Iterator 迭代器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iteator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器的开头</span></span><br><span class="line">L.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器的结尾</span></span><br><span class="line">L.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器的迭代</span></span><br><span class="line">++it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dereferenced</span></span><br><span class="line">*it = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="标准方法">8.5 标准方法</h2><h3 id="copy">8.5.1 copy</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将L中的每个元素,送到cout输出流中</span></span><br><span class="line"><span class="built_in">copy</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将L中的值放到V里面</span></span><br><span class="line"><span class="built_in">copy</span>(L.<span class="built_in">begin</span>(),L.<span class="built_in">end</span>(),V.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><h2 id="typedef">8.6 typedef</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不使用typedef的声明</span></span><br><span class="line">map&lt;Name, list&lt;PhoneNum&gt; &gt; phonebook;</span><br><span class="line">map&lt;Name, list&lt;PhoneNum&gt; &gt;::iterator finger;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef</span></span><br><span class="line"><span class="keyword">typedef</span> PB map&lt;Name,list&lt;PhoneNum&gt; &gt;;</span><br><span class="line">PB phonebook;</span><br><span class="line">PB::iterator finger;</span><br></pre></td></tr></table></figure><h2 id="将自己的class放入stl容器">8.7 将自己的class放入STL容器</h2><p>(1)需要：赋值操作<strong>operator = ()</strong>，缺省构造函数</p><p>(2)对于排序类型：需要<strong>operator &lt; ()</strong></p><h1 id="第8-2章-overload-operator">第8-2章 Overload Operator</h1><h2 id="操作符重载">8.1 操作符重载</h2><h3 id="可以重载">8.1.1 可以重载</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120216411.png" alt="image-20231022120216411" style="zoom:80%;" /></p><h3 id="不能重载">8.1.2 不能重载</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120221953.png" alt="image-20231022120221953" style="zoom:80%;" /></p><h3 id="注意">8.1.3 注意</h3><p>(1)不能重载不存在的操作符</p><p>(2)操作符的顺序不能改变</p><h2 id="重载的语法">8.2 重载的语法</h2><h3 id="作为成员函数">8.2.1 作为成员函数</h3><p>可以作为类的成员函数，隐藏调用的对象</p><ol type="1"><li>返回值必须是该类的类型</li><li>必须能够得到类的定义</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Integer</span>(<span class="type">int</span> n=<span class="number">0</span>):<span class="built_in">i</span>(n)&#123;&#125;;</span><br><span class="line">    <span class="type">const</span> Integer <span class="keyword">operator</span>+(<span class="type">const</span> Integer&amp; n)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Integer</span>(i + n.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Integer <span class="keyword">operator</span>-()<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Integer</span>(-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Integer <span class="title">x</span><span class="params">(<span class="number">1</span>)</span>,<span class="title">y</span><span class="params">(<span class="number">5</span>)</span>,z</span>;</span><br><span class="line">z = x + y; <span class="comment">//√</span></span><br><span class="line">z = x + <span class="number">3</span>; <span class="comment">//√,3作为参数传入,会被转化为Integer</span></span><br><span class="line">z = <span class="number">3</span> + y; <span class="comment">//×</span></span><br></pre></td></tr></table></figure><h3 id="作为global函数">8.2.2 作为global函数</h3><p>也可以是一个<strong>global</strong>函数，此时必须写出两个对象</p><ol type="1"><li>不需要特殊的访问<strong>class</strong></li><li>可能需要定义为<strong>friend</strong>函数，使其能够访问<strong>private</strong>变量</li><li>两个参数都可以进行类型转换</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Integer <span class="keyword">operator</span>+(<span class="type">const</span> Integer&amp; rhs,<span class="type">const</span> Integer&amp; lhs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> Integer <span class="keyword">operator</span>+(<span class="type">const</span> Integer&amp; rhs,<span class="type">const</span> Integer&amp; lhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Integer</span>(lhs.i + rhs.i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Integer <span class="title">x</span><span class="params">(<span class="number">1</span>)</span>,<span class="title">y</span><span class="params">(<span class="number">5</span>)</span>,z</span>;</span><br><span class="line">z = x + y; <span class="comment">//等价于z = operator+(x,y)</span></span><br><span class="line">z = <span class="number">3</span> + y; <span class="comment">//√</span></span><br></pre></td></tr></table></figure><h3 id="必须是成员函数的重载">8.2.3 必须是成员函数的重载</h3><ol type="1"><li>单目运算符</li><li><strong>=、()、[]、-&gt;、</strong>*</li></ol><h2 id="作为global函数的operator">8.3 作为global函数的operator</h2><ol type="1"><li>如果是一个<strong>read-only</strong>的传递，必须声明为<strong>const&amp;</strong></li><li>如果成员函数定义为<strong>const</strong>，则不能修改成员变量的值</li><li>对于<strong>global</strong>函数左边的参数需要会作为引用传递</li><li>返回值，要根据操作符本身的意思来定，并且要定义为<strong>const</strong><ol type="1"><li>如果不定义成<strong>const</strong>，可能会出现：<strong>x+y=z</strong>的情况</li><li>逻辑运算的返回值要定义成<strong>bool</strong></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+ - * / % ^ &amp; | ~</span></span><br><span class="line"><span class="function"><span class="type">const</span> T <span class="keyword">operator</span> <span class="title">X</span> <span class="params">(<span class="type">const</span> T &amp;l, <span class="type">const</span> T &amp;r)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//! &amp;&amp; || &lt; &lt;= == &gt;= &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="keyword">operator</span> <span class="title">X</span> <span class="params">(<span class="type">const</span> T &amp;l, <span class="type">const</span> T &amp;r)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作为成员函数的operator">8.4 作为成员函数的operator</h2><h3 id="下标">8.4.1 下标</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[]</span></span><br><span class="line">E&amp; T::<span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和--操作">8.4.2 ++和--操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> Integer&amp; <span class="keyword">operator</span>++()&#123; <span class="comment">//++i,返回的是对自己的引用</span></span><br><span class="line">        *<span class="keyword">this</span> += <span class="number">1</span>;   <span class="comment">//先自增</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//再返回新的自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Integer <span class="keyword">operator</span>++(<span class="type">int</span>)&#123; <span class="comment">//i++,返回的是临时对象</span></span><br><span class="line">        <span class="function">Integer <span class="title">old</span><span class="params">( *<span class="keyword">this</span> )</span></span>; <span class="comment">//先保存旧的自己</span></span><br><span class="line">        ++(*<span class="keyword">this</span>);  <span class="comment">//再自增</span></span><br><span class="line">        <span class="keyword">return</span> old;  <span class="comment">//最后返回旧的自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Integer&amp; <span class="keyword">operator</span>--(); <span class="comment">//--i</span></span><br><span class="line">    <span class="type">const</span> Integer <span class="keyword">operator</span>--(<span class="type">int</span>); <span class="comment">//i--</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">x</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">++x; <span class="comment">//调用x.operator++();</span></span><br><span class="line">x++; <span class="comment">//调用x.operator++(0);</span></span><br><span class="line">--x; <span class="comment">//调用x.operator--();</span></span><br><span class="line">x--; <span class="comment">//调用x.operator--(0);</span></span><br></pre></td></tr></table></figure><h3 id="bool操作">8.4.3 bool操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span>; </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span>; </span><br><span class="line">    <span class="type">bool</span> <span class="built_in">operator</span>&lt; (<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span>; </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span>; </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span>; </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>使用 <strong>==</strong> 实现 <strong>!=</strong></li><li>使用 <strong>&lt;</strong> 实现<strong>&gt;,&gt;=,&lt;=</strong></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>==( <span class="type">const</span> Integer&amp; rhs ) <span class="type">const</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> i == rhs.i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 使用 !(*this == rhs) 实现 *this != rhs</span></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>!=( <span class="type">const</span> Integer&amp; rhs ) <span class="type">const</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>&lt;( <span class="type">const</span> Integer&amp; rhs ) <span class="type">const</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> i &lt; rhs.i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 rhs &lt; *this 实现 *this &gt; rhs</span></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>&gt;( <span class="type">const</span> Integer&amp; rhs ) <span class="type">const</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> rhs &lt; *<span class="keyword">this</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 使用 !(rhs &lt; *this) 实现 *this &lt;= rhs</span></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>&lt;=( <span class="type">const</span> Integer&amp; rhs ) <span class="type">const</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> !(rhs &lt; *<span class="keyword">this</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 使用 !(*this &lt; rhs) 实现 *this &gt;= rhs</span></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>&gt;=( <span class="type">const</span> Integer&amp; rhs ) <span class="type">const</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值">8.4.5 赋值</h3><ol type="1"><li>要返回引用类型，因为可能会存在<strong>A=B=C=D</strong></li><li>当<strong>A</strong>与<strong>this</strong>的地址相同时，说明是<strong>A=A</strong>，可以不用执行赋值操作</li><li>对于具有动态分配内存的类，系统的默认赋值只能进行浅拷贝，也就是说，会出现后面的实例中指针指向了前面的示例的指针指向的地址。因此要写赋值操作</li><li>如果不想出现赋值操作，可以将<strong>operator=</strong>声明为<strong>private</strong></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;A != <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//执行赋值操作</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy-vs-initialization">8.5 copy vs initialization</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyType b;</span><br><span class="line">MyType a = b; <span class="comment">//initialization,调用了MyType()构造函数</span></span><br><span class="line">a = b; <span class="comment">//copy,调用了operator=</span></span><br></pre></td></tr></table></figure><p><strong>initialization</strong>：</p><ol type="1"><li>会调用<strong>MyType</strong>的构造函数</li><li>如果没有对应类型的构造函数，则会进行类型转换</li></ol><p><strong>copy</strong>：</p><ol type="1"><li>会调用<strong>MyType</strong>的<strong>operator=</strong></li><li>如果没有写<strong>operator=</strong>，系统会有一个缺省构造函数，默认调用所有成员变量的<strong>operator=</strong></li></ol><h2 id="流操作-stream-extractor">8.6 流操作 stream extractor</h2><ol type="1"><li>返回<strong>&amp;</strong>，因为输入/输出<strong>obj</strong>后，输入/输出流会变化</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, T&amp; obj)&#123;</span><br><span class="line">    <span class="comment">// 从输入流is中,读取obj的值</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">((cin &gt;&gt; a) &gt;&gt; b) &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> T&amp; obj) &#123;</span><br><span class="line"><span class="comment">// 将obj的值,写入输出流os</span></span><br><span class="line"><span class="keyword">return</span> os; </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line">((cout &lt;&lt; a) &lt;&lt; b) &lt;&lt; c;</span><br></pre></td></tr></table></figure><h3 id="定义-manipulators">8.6.1 定义 manipulators</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// output stream manipulator的框架</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">manip</span><span class="params">(ostream&amp; out)</span> </span>&#123;  </span><br><span class="line">   ... </span><br><span class="line">   <span class="keyword">return</span> out; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function">ostream&amp; <span class="title">tab</span> <span class="params">(ostream&amp; out)</span> </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> out &lt;&lt; <span class="string">&#x27;\t&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; tab &lt;&lt; <span class="string">&quot;World!&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="类型转换">8.7 类型转换</h2><ol type="1"><li>类型转换操作符，可以将一个类的对象转化为<ol type="1"><li>另一个类的对象</li><li>内置类型<strong>built-in type</strong></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> numerator_/(<span class="type">double</span>)denominator_; </span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>; </span><br><span class="line"><span class="type">double</span> d = <span class="number">1.3</span> * r; <span class="comment">// r=&gt;double</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>编译器可以自动执行的类型转换<ol type="1"><li>单参数的类型转换<strong>single argument</strong></li><li>隐式类型转换<strong>implicittype</strong>：如子类→父类，在构造函数中定义的类型转换</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PathName</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PathName</span>(<span class="type">const</span> string&amp;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">abc</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">PathName <span class="title">xyz</span><span class="params">(abc)</span></span>;</span><br><span class="line">xyz = abc;  <span class="comment">//OK,编译器会调用构造函数PathName(const string&amp;)，将abc类型转换为PathName</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>防止<strong>implicit conversion</strong><ol type="1"><li>添加关键字<strong>explicit</strong>，显式调用</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PathName</span> &#123; </span><br><span class="line">   string name; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PathName</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">... </span><br><span class="line"><span class="function">string <span class="title">abc</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>; </span><br><span class="line"><span class="function">PathName <span class="title">xyz</span><span class="params">(abc)</span></span>; <span class="comment">// OK! </span></span><br><span class="line">xyz = abc;    <span class="comment">// error! </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内置类型转换：</p><ol type="1"><li><p>原始类型</p><p>char → short → int → float → double</p><p>​ → int → long</p></li><li><p>隐式类型转换</p><ol type="1"><li>T → T&amp;</li><li>T&amp; → T</li><li>T* → void*</li><li>T[] → T*</li><li>T* → T[]</li><li>T → const T[]</li></ol></li></ol><p>用户定义的类型转换：<strong>T→C</strong></p><ol type="1"><li>判断<strong>C</strong>的构造函数中是否存在<strong>C(T)</strong></li><li>判断<strong>T</strong>的重载中是否存在<strong>operatorC()</strong></li></ol><h2 id="casting-operator">8.8 casting operator</h2><p>出错信息：bad cast</p><h3 id="static_cast">8.8.1 static_cast</h3><p>显式类型转换，为了保证操作符转换的安全性</p><p>不允许const 指针/引用 → 非const</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(a);<span class="comment">//correct</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> *c = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">void</span> *d = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(c);<span class="comment">//correct</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;(e);<span class="comment">//correct</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *h = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;g);<span class="comment">//error: static_cast can not remove the const property</span></span><br></pre></td></tr></table></figure><p>但是当用来转化class指针的时候，static_cast不是安全的，因为它不会检查两个class的继承关系</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class A &#123;<span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="title">test</span><span class="params">()</span> </span>&#123;…&#125;&#125;</span><br><span class="line"></span><br><span class="line">Class B: <span class="keyword">public</span> A &#123;<span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="title">test</span><span class="params">()</span> </span>&#123;…&#125;&#125;</span><br><span class="line"></span><br><span class="line">A *pA1 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">B *pB = <span class="built_in">static_cast</span>&lt;B*&gt;(pA1);  <span class="comment">//downcast not safe</span></span><br></pre></td></tr></table></figure><h3 id="dynamic_cast">8.8.2 dynamic_cast</h3><p>会检查向下转换 downcast 是否为安全的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class A &#123;<span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="title">test</span><span class="params">()</span> </span>&#123;…&#125;&#125;</span><br><span class="line"></span><br><span class="line">Class B: <span class="keyword">public</span> A &#123;<span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="title">test</span><span class="params">()</span> </span>&#123;…&#125;&#125;</span><br><span class="line"></span><br><span class="line">Class C: &#123;<span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="title">test</span><span class="params">()</span> </span>&#123;…&#125;&#125;</span><br><span class="line"></span><br><span class="line">A *pA1 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">B *pB = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pA1);  <span class="comment">//safe downcast</span></span><br><span class="line"></span><br><span class="line">C *pC = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pA1);  <span class="comment">//not safe, will return a NULL pointer</span></span><br></pre></td></tr></table></figure><h3 id="const_cast">8.8.3 const_cast</h3><p>const 指针/引用 → 为非const</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *h = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;g); <span class="comment">//correct</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;h = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(g); <span class="comment">//correct</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *g = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *h = <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(g); <span class="comment">//correct</span></span><br></pre></td></tr></table></figure><h3 id="reinterperet_cast">8.8.4 reinterperet_cast</h3><p>指针 → int，int → 指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> *pA = &amp;b;</span><br><span class="line">a = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&gt;(pA); <span class="comment">//correct</span></span><br><span class="line">pA = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(a);  <span class="comment">//correct</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&gt;(a);  <span class="comment">//Error, can not be used to convert int to int</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP07：Polymorphism 多态</title>
      <link href="/2023/10/06/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC7%E7%AB%A0-Polymorphism/"/>
      <url>/2023/10/06/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC7%E7%AB%A0-Polymorphism/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第7章-polymorphism-多态">第7章 Polymorphism 多态</h1><h2 id="类型转换-conversions">7.1 类型转换 Conversions</h2><p>(1)<strong>public</strong>继承，应该包含替换：即将子类转成父类(子类是父类的超集)</p><p>​ (a)如果B是A的子类，那么能使用A的地方，一定能使用B</p><p>​ (b)如果B是A的子类，那么对A成立的，对B也成立</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;m_a = <span class="number">0</span>; <span class="keyword">return</span> m_a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;m_a = <span class="number">10</span>; <span class="keyword">return</span> m_a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getA</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b_ins;</span><br><span class="line">    <span class="built_in">func</span>(b_ins);</span><br><span class="line">    <span class="comment">//此时,会将b_ins转换为A类型,因此其输出为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120055217.png" alt="image-20231022120055217" style="zoom:80%;" /></p><h3 id="向上转换-upcast">7.1.1 向上转换 Upcast</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Manager <span class="title">pete</span><span class="params">(<span class="string">&quot;Pete&quot;</span>, <span class="string">&quot;444-55-6666&quot;</span>, <span class="string">&quot;Bakey&quot;</span>)</span></span>;  </span><br><span class="line">Employee* ep = &amp;pete;<span class="comment">// Upcast</span></span><br><span class="line">Employee&amp; er = pete;<span class="comment">// Upcast</span></span><br><span class="line"><span class="comment">//会丢失子类额外定义的信息</span></span><br><span class="line"></span><br><span class="line">ep-&gt;<span class="built_in">print</span>( cout );<span class="comment">//调用的是父类的print函数</span></span><br></pre></td></tr></table></figure><h2 id="例drawing">例：drawing</h2><h3 id="具体对象共有数据接口">1 具体对象、共有数据、接口</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120101317.png" alt="image-20231022120101317" style="zoom:80%;" /></p><h3 id="继承结构">2 继承结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120106675.png" alt="image-20231022120106675" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120114027.png" alt="image-20231022120114027" style="zoom:80%;" /></p><ol type="1"><li><p>在父类<strong>Shape</strong>中，定义了接口<strong>render()</strong></p></li><li><p>在子类中，通过多态的机制，重定义接口<strong>render()</strong></p></li></ol><h3 id="类的声明">3 类的声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XYPos</span>&#123; ... &#125;; <span class="comment">// x,y point</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    XYPos center;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">const</span> XYPos&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">resize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="多态-polymorphism">7.2 多态 Polymorphism</h2><p>向上转换<strong>upcast</strong>：将子类的对象作为父类的一个对象</p><p>多态使用的时间：<strong>upcast</strong></p><p>多态的目的：在<strong>upcast</strong>的时候，使用子类的对象</p><p>动态绑定<strong>binding</strong>：</p><ol type="1"><li><p>绑定<strong>binding</strong>：调用哪个函数</p></li><li><p>静态绑定<strong>staticbinding</strong>：调用函数作为代码</p></li><li><p>动态绑定<strong>dynamic binding</strong>：调用对象的函数</p></li></ol><h3 id="non-virtual-function">7.2.1 non-virtual function</h3><p>(1)视为静态绑定，编译时就确定好使用哪个函数</p><p>(2)调用较快</p><h3 id="virtual-function">7.2.2 virtual function</h3><ol type="1"><li>子类一定要重定义该函数</li><li>对象存储了虚函数的信息</li><li>编译器会检查、并动态调用正确的函数</li><li>编译器优化：如果编译器在编译的时候知道应该调用哪个函数，则会生成一个静态调用</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> major_axis, minor_axis;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ellipse</span>(<span class="type">float</span> maj, <span class="type">float</span> minr);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span></span>; <span class="comment">// will define own</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Ellipse &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> radius):<span class="built_in">Ellipse</span>(radius, radius)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(Shape* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//借助多态机制virtual,函数只需要跟父类打交道,upcast的时候会保证调用子类的对应接口</span></span><br><span class="line">    p-&gt;<span class="built_in">render</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Ellipse <span class="title">ell</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    ell.<span class="built_in">render</span>(); <span class="comment">//静态绑定,没有upcast,调用了 Ellipse::render();</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Circle <span class="title">circ</span><span class="params">(<span class="number">40</span>)</span></span>;</span><br><span class="line">    circ.<span class="built_in">render</span>(); <span class="comment">//静态绑定,没有upcast,调用了Circle::render();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(&amp;ell); <span class="comment">//动态绑定,出现upcast:Ellips-&gt;Shape,会调用Ellipse::render();</span></span><br><span class="line">    <span class="built_in">render</span>(&amp;circ); <span class="comment">//动态绑定,出现upcast:Circle-&gt;Shape,会调用Circle::render();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象基础类-abstract-base-classes">7.3 抽象基础类 Abstract baseclasses</h2><h3 id="定义">7.3.1 定义</h3><ol type="1"><li>一个抽象的基础类有纯虚函数<strong>pure virtualfunctions</strong></li></ol><ol type="1"><li>只定义返回值、参数</li><li>不需要给函数体</li></ol><ol start="2" type="1"><li>抽象基础类不能直接实例化≠不能用指针</li></ol><ol type="1"><li><p>必须由一个子类继承</p></li><li><p>子类必须要实现抽象类的所有纯虚函数</p></li></ol><h3 id="例定义纯虚函数">7.3.2 例：定义纯虚函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XYPos</span>&#123; ... &#125;; <span class="comment">// x,y point</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    XYPos center;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//告诉编译器, 该函数为纯虚函数, 子类必须重载该函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">const</span> XYPos&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">resize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="作用">7.3.3 作用</h3><p>(1)便于建模 ==&gt; 抽象定义</p><p>(2)强制要求正确的行为 ==&gt; 所有子类都必须有该行为</p><p>(3)定义接口，而不是定义实现</p><h3 id="例定义抽象类">7.3.4 例：定义抽象类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CDevice</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CDevice</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">read</span><span class="params">(...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">write</span><span class="params">(...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">open</span><span class="params">(...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">close</span><span class="params">(...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">ioctl</span><span class="params">(...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(1)所有非静态的成员函数都是纯虚函数，除了析构函数</p><p>(2)虚拟析构函数，没有函数体</p><p>(3)没有非静态的成员变量，可以有<strong>静态成员变量</strong></p><h2 id="virtual的实现机制">7.4 Virtual的实现机制</h2><p>(1)在内存中，会存储一个指针，指向当前类的虚函数表</p><p>(2)一个class会有一个虚函数表</p><p>(3)父类的变量会在子类的变量之前</p><p>(4)子类的虚函数表中，不会有父类的虚函数表，因为子类已经将所有虚函数重新定义了</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120129912.png" alt="image-20231022120129912" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120137474.png" alt="image-20231022120137474" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120143345.png" alt="image-20231022120143345" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120148755.png" alt="image-20231022120148755" style="zoom:80%;" /></p><h2 id="赋值与upcast">7.5 赋值与upcast</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Ellipse <span class="title">elly</span><span class="params">(<span class="number">20f</span>,<span class="number">40f</span>)</span></span>;</span><br><span class="line"><span class="function">Circle  <span class="title">circ</span><span class="params">(<span class="number">60f</span>)</span></span>;</span><br><span class="line">elly = circ;</span><br><span class="line">elly.<span class="built_in">render</span>(); <span class="comment">//Ellipse::render()</span></span><br><span class="line"><span class="comment">//赋值的时候,将circ与elly共有的属性赋给elly</span></span><br><span class="line"><span class="comment">//但是elly的虚函数表不会变</span></span><br><span class="line"><span class="comment">//elly.render()时,调用的依旧是父类的render()</span></span><br><span class="line"></span><br><span class="line">Ellipse *elly = <span class="keyword">new</span> <span class="built_in">Ellipse</span>(<span class="number">20f</span>,<span class="number">40f</span>);</span><br><span class="line">Circle  *circ = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">60f</span>);</span><br><span class="line">elly = circ;</span><br><span class="line">elly-&gt;<span class="built_in">render</span>(); <span class="comment">//Circle::render()</span></span><br><span class="line"><span class="comment">//指针赋值,对应的内存并不会变,但是出现了upcast</span></span><br><span class="line"><span class="comment">//elly-&gt;render()时,会找到子类的虚函数表,然后执行子类的render()函数</span></span><br></pre></td></tr></table></figure><h2 id="relaxation">7.6 Relaxation</h2><p>虚函数的返回类型为指针、引用的时候，子类可以修改返回类型</p><p>虚函数的返回类型为class的时候，子类不能修改返回类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Expr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Expr* <span class="title">newExpr</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Expr&amp; <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Expr  <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryExpr</span>: <span class="keyword">public</span> Expr&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BinaryExpr* <span class="title">newExpr</span><span class="params">()</span></span>;<span class="comment">//OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BinaryExpr&amp; <span class="title">clone</span><span class="params">()</span></span>;  <span class="comment">//OK</span></span><br><span class="line">    <span class="comment">//virtual BinaryExpr  self(); //Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="overloading-and-virtuals">7.7 Overloading and virtuals</h2><p>重载的几个函数，都需要被子类重定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base::<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意">7.8 注意</h2><p>(1)不要重新定义<strong>non-virtual</strong>的函数</p><p>(2)不要重定义继承函数的缺省值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">A</span>() &#123; <span class="built_in">f</span>();&#125; <span class="comment">//A::f()</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span>; &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">B</span>() &#123; <span class="built_in">f</span>();&#125;<span class="comment">//B::f() </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f()&quot;</span>; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造B的时候，会先调用A的构造函数，输出A::f()，然后调用B的构造函数，输出B::f()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP06：Inline and Inheritance</title>
      <link href="/2023/10/05/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC6%E7%AB%A0-Inline%20and%20Inheritance/"/>
      <url>/2023/10/05/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC6%E7%AB%A0-Inline%20and%20Inheritance/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第6章-inline-and-inheritance">第6章 Inline and Inheritance</h1><h2 id="inline">6.1 Inline</h2><h3 id="函数调用的基本流程">6.1.1 函数调用的基本流程</h3><p>(1)将参数、返回地址压栈</p><p>(2)计算返回值</p><p>(3)将栈中的所有内容出栈</p><h3 id="inline的原理">6.1.2 inline的原理</h3><p>将短函数转化为类似宏定义，在调用处将函数展开，如下图</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022115907924.png" alt="image-20231022115907924" style="zoom:80%;" /></p><h3 id="inline的使用注意">6.1.3 inline的使用注意</h3><p>(1)<strong>inline</strong>函数的<strong>函数体</strong>需要定义在<strong>头文件</strong>内</p><p>(2)<strong>inline</strong>的函数调用的<strong>代码</strong>，可能**不会在*.obj中**存在（直接被编译器在调用inline函数的地方展开了）</p><p>(3)<strong>inline</strong>函数是<strong>声明</strong>，而不是定义</p><p>(4)<strong>inline</strong>函数由于是直接展开，其会增加代码的长度</p><p>(5)<strong>inline</strong>函数是否展开，由编译器决定，当函数太大/递归，就不会展开</p><p>(6)有的编译器不实现<strong>inline</strong></p><h2 id="对象的组合-composition">6.2 对象的组合 Composition</h2><p>(1)直接在一个<strong>class</strong>中，实例化另一个<strong>class</strong>，作为自己的成员变量</p><p>(2)调用的<strong>class</strong>必须有<strong>缺省构造函数</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Currency</span> &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SavingsAccount</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SavingsAccount</span>( <span class="type">const</span> <span class="type">char</span>* name,</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* address, <span class="type">int</span> cents);</span><br><span class="line">    ~<span class="built_in">SavingsAccount</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person m_saver;</span><br><span class="line">    Currency m_balance;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>(3)注意，如果在<strong>class</strong>中实例化的<strong>class</strong>为<strong>public</strong>类型，子对象的接口也会暴露出去</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SavingsAccount</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person m_saver;</span><br><span class="line">...</span><br><span class="line">&#125;;<span class="comment">// assume Person class has set_name()</span></span><br><span class="line">SavingsAccount account;</span><br><span class="line">account.m_saver.<span class="built_in">set_name</span>(<span class="string">&quot;Fred&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="继承-inheritance">6.3 继承 Inheritance</h2><p>子类具有父类的：</p><p>​ (1)成员变量</p><p>​ (2)成员函数</p><p>​ (3)接口 <strong>Interfaces</strong></p><p><strong>Circle</strong>继承于<strong>Shape</strong>：</p><p>​ (1)先将<strong>Shape</strong>中的所有内容复制</p><p>​ (2)在父类的基础上，进行拓展</p><p>​ (3)父类中的成员函数可以为空</p><p>​ (4)子类和父类的<strong>接口一致，但行为可以不一样</strong></p><p>​ (5)子类只能在父类的基础上加东西，不能删除父类中的东西</p><h3 id="优点">6.3.1 优点</h3><p>​ (1)避免代码冗余 <strong>Avoiding code duplication</strong></p><p>​ (2)代码重用 <strong>Code reuse</strong></p><p>​ (3)便于维护 <strong>Easier maintenance</strong></p><p>​ (4)可扩展 <strong>Extendibility</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022115921026.png" alt="image-20231022115921026" style="zoom:80%;" /></p><h3 id="继承的表示方法">6.3.2 继承的表示方法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022115927729.png" alt="image-20231022115927729" style="zoom:80%;" /></p><h3 id="c中的作用域和访问">6.3.2 c++中的作用域和访问</h3><p>​ (1)子类不能访问父类的<strong>priviate</strong>内容</p><p>​ (2)子类可见，用户不可见：<strong>protected</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022115936242.png" alt="image-20231022115936242" style="zoom:80%;" /></p><h2 id="例dome">例：DoME</h2><p><strong>Database of Multimedia Entertainment</strong></p><h3 id="程序框图">1 程序框图</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120001153.png" alt="image-20231022120001153" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120006810.png" alt="image-20231022120006810" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120012611.png" alt="image-20231022120012611" style="zoom:80%;" /></p><p><strong>:public</strong>：公有继承，父类的<strong>public</strong>，在子类中也是<strong>public</strong></p><h3 id="源代码">2 源代码</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120030793.png" alt="image-20231022120030793" style="zoom:80%;" /></p><h3 id="添加新的类型-videogame">3 添加新的类型 VideoGame</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231022120038981.png" alt="image-20231022120038981" style="zoom:80%;" /></p><h2 id="例employee">例：Employee</h2><h3 id="employee父类">1 Employee父类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string m_name;</span><br><span class="line">std::string m_ssn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Employee</span>( <span class="type">const</span> std::string&amp; name,<span class="type">const</span> std::string&amp; ssn )</span><br><span class="line">    : <span class="built_in">m_name</span>(name), <span class="built_in">m_ssn</span>( ssn)&#123;</span><br><span class="line">        <span class="comment">// initializer list sets up the values!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">get_name</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        out &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">        out &lt;&lt; m_ssn &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out, <span class="type">const</span> std::string&amp; msg)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        out &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">print</span>(out); </span><br><span class="line">        <span class="comment">//在子类中使用时,只会调用父类的print,而不会调用子类重定义的print</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="manager子类">2 Manager子类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> : <span class="keyword">public</span> Employee &#123;<span class="comment">//public继承</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_title;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Manager</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; ssn, <span class="type">const</span> std::string&amp; title = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    :<span class="built_in">Employee</span>(name, ssn), <span class="built_in">m_title</span>( title )&#123;<span class="comment">//注意要调用父类的构造函数:Employee(name, ssn)</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string <span class="title">title_name</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>( m_title + <span class="string">&quot;: &quot;</span> + m_name ); </span><br><span class="line"><span class="comment">// access base m_name</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">get_title</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_title;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        Employee::<span class="built_in">print</span>( out ); <span class="comment">//调用父类的函数</span></span><br><span class="line">out &lt;&lt; m_title &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(1)父类在子类之前构造</p><p>(2)如果没有参数传递给父类，则会调用父类的缺省构造函数</p><p>(3)析构时，子类先析构，父类后析构</p><p>(4)当子类的成员函数与父类的成员函数完全一致时（函数名、参数一致），会重定义父类的成员函数</p><p>​ 也就是说，当实例化一个子类时，调用该函数，只会调用子类的该函数</p><h3 id="使用">3 使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Employee <span class="title">bob</span><span class="params">( <span class="string">&quot;Bob Jones&quot;</span>, <span class="string">&quot;555-44-0000&quot;</span> )</span></span>;</span><br><span class="line"><span class="function">Manager <span class="title">bill</span><span class="params">( <span class="string">&quot;Bill Smith&quot;</span>, <span class="string">&quot;666-55-1234&quot;</span>, <span class="string">&quot;ImportantPerson&quot;</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">string name = bill.<span class="built_in">get_name</span>(); </span><br><span class="line">    <span class="comment">//子类继承父类的get_name()接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string title = bob.get_title(); </span></span><br><span class="line">    <span class="comment">//父类中没有get_title()接口</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bill.<span class="built_in">title_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    bob.<span class="built_in">print</span>(cout);</span><br><span class="line">    bill.<span class="built_in">print</span>(cout);</span><br><span class="line"></span><br><span class="line">    bob.<span class="built_in">print</span>(cout, <span class="string">&quot;Employee:&quot;</span>);</span><br><span class="line"><span class="comment">//bill.print(cout, &quot;Employee:&quot;); </span></span><br><span class="line">    <span class="comment">//这里调用的是父类的print,父类的print中并没有打印title</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重定义-name-hiding">6.4 重定义 Name Hiding</h2><p>(1)当子类的成员函数与父类的成员函数完全一致时（函数名、参数一致），会重定义父类的成员函数</p><p>(2)如果重定义子类中的成员函数，则父类中的所有其他重定义函数都不可访问</p><p>(3)可以通过<strong>virtual</strong>关键字，来影响函数的重定义</p><h2 id="子类没有继承的东西">6.5 子类没有继承的东西</h2><p>(1)构造函数：构造子类时，需要调用父类的构造函数，如果没有调用，系统会默认调用父类的缺省函数</p><p>(2)析构函数</p><p>(3)赋值操作：重定义<strong>=</strong>时，需要调用父类的赋值操作。如果没有重定义<strong>=</strong>，系统会默认调用每个成员变量的赋值操作</p><h2 id="访问权限">6.6 访问权限</h2><h3 id="成员变量">6.6.1 成员变量</h3><p>(1)<strong>public</strong>：子类、用户、friends可见</p><p>(2)<strong>protected</strong>：子类、friends可见</p><p>(3)<strong>private</strong>：friends可见</p><h3 id="继承">6.6.2 继承</h3><p>(1)<strong>public</strong>：父类中的限制是什么，子类就是什么</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base ...</span><br></pre></td></tr></table></figure><p>(2)<strong>protected</strong>：父类的<strong>public</strong>，到子类会变成<strong>protected</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">protected</span> Base ...</span><br></pre></td></tr></table></figure><p>(3)<strong>private</strong>、<strong>default</strong>：父类的<strong>public</strong>、<strong>protected</strong>，到子类会变成<strong>private</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base ...</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align: center;">Inheritance Type</th><th style="text-align: center;">public</th><th style="text-align: center;">protected</th><th style="text-align: center;">private</th></tr></thead><tbody><tr><td style="text-align: center;">public A</td><td style="text-align: center;">public in B</td><td style="text-align: center;">protected in B</td><td style="text-align: center;">private in B</td></tr><tr><td style="text-align: center;">protected A</td><td style="text-align: center;">protected in B</td><td style="text-align: center;">protected in B</td><td style="text-align: center;">private in B</td></tr><tr><td style="text-align: center;">private A</td><td style="text-align: center;">private in B</td><td style="text-align: center;">private in B</td><td style="text-align: center;">private in B</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP04：Object Interactive</title>
      <link href="/2023/10/04/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC4%E7%AB%A0-Object%20Interactive/"/>
      <url>/2023/10/04/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC4%E7%AB%A0-Object%20Interactive/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第4章-object-interactive">第4章 Object Interactive</h1><p>构造函数的调用顺序：<strong>基类 → 成员变量 → 派生类</strong></p><p>析构函数的调用顺序：<strong>派生类 → 成员变量 → 基类</strong></p><h2 id="构造函数">4.1 构造函数</h2><h3 id="构造函数的作用">4.1.1 构造函数的作用</h3><p>(1)函数名与类名相同</p><p>(2)通过编译器调用，进行初始化，保证实例化的类一定会初始化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X a;<span class="comment">//此时，等同于调用a.X()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数的参数">4.1.2 构造函数的参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tree</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Tree</span>(<span class="type">int</span> i)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1)构造函数可以有很多个</p><p>(2)如果仅定义了一个带参数的构造函数，那么缺省构造函数会丢失，在实例化时，必须添加参数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span>&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">Y</span>(<span class="type">int</span> a);</span><br><span class="line">&#125;;</span><br><span class="line">Y y2[<span class="number">2</span>]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>)&#125;;<span class="comment">//会报错，因为只声明了一个数</span></span><br></pre></td></tr></table></figure><p>(3)如果没有定义构造函数，系统会默认添加一个缺省构造函数<strong>autodefault constructor</strong></p><h2 id="析构函数">4.2 析构函数</h2><h3 id="析构函数的定义">4.2.1 析构函数的定义</h3><p>(1)函数名为<strong>~类名()</strong></p><p>(2)用于返回内存</p><p>(3)当对象超出作用域后，编译器自动调用析构函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Y</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(4)析构函数调用的唯一标志是<strong>右大括号</strong></p><p>​ 对象变量的作用域是一对大括号，出了作用域便会被销毁</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">V</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    MyClass c1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">V</span>()&#123;&#125;;</span><br><span class="line">    <span class="comment">//成员变量的析构是在本对象变量析构之后调用的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        V v1;</span><br><span class="line">    &#125;<span class="comment">//在这里时，会调用~V()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存分配">4.3 内存分配</h2><p>(1)在大括号的左括号处，编译器会分配所有的内存</p><p>(2)在定义对象的语句处，才会调用对象的构造函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="comment">//!goto jump1; //Error:goto语句可能跳过x1的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">X x1;  <span class="comment">//在这里调用x1的构造函数</span></span><br><span class="line">jump1:</span><br><span class="line"><span class="keyword">switch</span>(i) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">X x2;  <span class="comment">//在这里调用x2的构造函数</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//! case 2 : // Error: case bypasses init</span></span><br><span class="line">X x3;  <span class="comment">//在这里调用x3的构造函数</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="抽象">4.4 抽象</h2><p>(1)抽象：忽略部分细节，以将注意力集中在更高级别问题上</p><p>(2)模块化：将整体划分为明确定义的部分的过程，这些部分可以单独构建和检查，并且以明确定义的方式相互作用</p><h2 id="局部变量">4.5 局部变量</h2><p>(1)局部变量是在函数内部定义的，其作用域仅限于它们所属的函数</p><p>(2)如果局部变量的名字与类的成员变量相同，则会使用局部变量而非成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span><span class="title">TicketMachine::refundBalance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="type">int</span>amountToRefund;  </span><br><span class="line">    amountToRefund = balance;  </span><br><span class="line">    balance = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> amountToRefund;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段fields参数局部变量">4.5.1 字段(Fields)，参数，局部变量</h3><ol type="1"><li>这三种类型的变量都能够存储适合于其定义类型的值。</li><li>字段(Fields)<ol type="1"><li>字段在构造函数和方法之外定义。</li><li>字段用于存储贯穿一个工程生命周期的数据。因此，它们维护对象的当前状态。它们的生命周期和工程的生命周期一样长。</li><li>字段具有类作用域：它们的可访问性扩展到整个类，因此可以在定义它们的类的任何构造函数或方法中使用它们</li><li>一旦字段被定义为私有，它们就不能从定义类之外的任何地方访问。</li></ol></li><li>形式参数和局部变量仅在构造函数或方法执行期间持续存在。它们的生存期仅相当于一次调用，因此在调用之间会丢失它们的值。因此，它们是临时的而不是永久的存储位置。</li><li>形参<ol type="1"><li>形参定义在构造函数或方法的头文件中。它们从外部接收值，由构成构造函数或方法调用一部分的实际参数值初始化。</li><li>形式参数的作用域仅限于其定义的构造函数或方法。</li></ol></li><li>局部变量<ol type="1"><li>局部变量在构造函数或方法的函数体中定义。它们只能在其定义的构造函数或方法体中进行初始化和使用</li><li>局部变量在表达式中使用之前必须先初始化——它们没有默认值。</li><li>局部变量的作用域仅限于定义它们的块。从那个块以外的任何地方都无法进入。</li></ol></li></ol><h2 id="初始化">4.6 初始化</h2><h3 id="initializer-list">4.6.1 Initializer list</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xa=<span class="number">0.0</span>, <span class="type">float</span> ya=<span class="number">0.0</span>)</span><br><span class="line">        :<span class="built_in">y</span>(ya),<span class="built_in">x</span>(xa)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(1)可以初始化任意类型的数据</p><p>​ (a)相当于调用了析构函数</p><p>​ (b)避免了赋值操作</p><p>(2)初始化的顺序是写的顺序</p><p>​ (a)例如在例子中，先初始化y，后初始化x</p><p>​ (b)析构时，按照初始化的倒序</p><h3 id="initializer-list-与-assignment的区别">4.6.1 Initializer list 与Assignment的区别</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student::<span class="built_in">Student</span>(string s):<span class="built_in">name</span>(s)&#123;&#125;</span><br><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="comment">//直接构造了一个内容为s的string</span></span><br><span class="line">Student::<span class="built_in">Student</span>(string s)&#123;name=s;&#125;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="comment">//先构造了一个string,然后再将这个string赋值为s</span></span><br></pre></td></tr></table></figure><h2 id="函数的重载">4.7 函数的重载</h2><h3 id="overload">4.7.1 Overload</h3><p>相同的函数，可以有不同的参数列表</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> width)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d, <span class="type">int</span> width)</span></span>; <span class="comment">// #2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">long</span> l, <span class="type">int</span> width)</span></span>; <span class="comment">// #3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> width)</span></span>; <span class="comment">// #4</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *str)</span></span>; <span class="comment">// #5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Pancakes&quot;</span>, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Syrup&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1999.0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1999</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1999L</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure><h3 id="overload-和-auto-cast">4.7.2 Overload 和 auto-cast</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">short</span> i)</span></span>; <span class="comment">//#1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span> d)</span></span>;<span class="comment">//#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据c++类型转换的优先级来决定调用哪一种函数</span></span><br><span class="line"><span class="built_in">f</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//自动转换为short,调用#1</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2</span>);<span class="comment">//自动转换为short,调用#1</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2L</span>);<span class="comment">//自动转换为double,调用#2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">3.2</span>);<span class="comment">//自动转换为double,调用#2</span></span><br></pre></td></tr></table></figure><h2 id="缺省参数">4.8 缺省参数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stash</span>(<span class="type">int</span> size, <span class="type">int</span> initQuantity = <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>规定：缺省参数必须从右往左写</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">harpo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m = <span class="number">4</span>, <span class="type">int</span> j = <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chico</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m = <span class="number">6</span>, <span class="type">int</span> j)</span></span>;<span class="comment">//不合法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">groucho</span><span class="params">(<span class="type">int</span> k = <span class="number">1</span>, <span class="type">int</span> m = <span class="number">2</span>, <span class="type">int</span> n = <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="常量对象变量-const-objects">4.9 常量对象变量 const objects</h2><h3 id="定义">4.9.1 定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Currency <span class="title">the_raise</span><span class="params">(<span class="number">42</span>, <span class="number">38</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="常量成员函数-const-member-functions">4.9.2 常量成员函数 constmember functions</h3><p>(1)不能改变对象内部的内容</p><p>(2)在函数内只能调用常量成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Date::get_day</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Date::set_day</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">day = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Date::get_day</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line"><span class="comment">//!day++;//ERROR:更改了对象的内容</span></span><br><span class="line">    <span class="comment">//!set_day(12);//ERROR:调用了non-const成员函数</span></span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量成员变量">4.9.3 常量成员变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//必须在初始化列表中,初始化i的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasArray</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> array[size];<span class="comment">//ERROR:编译器无法预先分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasArray</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> size = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> array[size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HassArray</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span>&#123;size = <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> array[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数变量中的class">4.10 函数变量中的class</h2><h3 id="传入参数">4.10.1 传入参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Student i)</span></span>;</span><br><span class="line"><span class="comment">//创建新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Student* i)</span></span>;</span><br><span class="line"><span class="comment">//只传递指针,不会传递变量</span></span><br><span class="line"><span class="comment">//在前方加const保证不会修改该对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Student &amp;i)</span></span>;</span><br><span class="line"><span class="comment">//只传递引用,不传递变量</span></span><br><span class="line"><span class="comment">//不使用指针,防止堆内存的任意访问</span></span><br></pre></td></tr></table></figure><h3 id="返回值">4.10.2 返回值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//要创建一个临时对象</span></span><br><span class="line"><span class="function">Student* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//要保证指针的有效性,不能返回野指针(指向临时变量)</span></span><br><span class="line"><span class="function">Student&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//与指针类似返回的引用不能是临时变量</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码耦合性较强,需要在bar()中释放掉在foo()中分配的内存</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];  </span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;something&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span>p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> *p= <span class="built_in">foo</span>();  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);  </span><br><span class="line">    <span class="keyword">delete</span>p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改：<strong>谁分配，谁销毁</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;something&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span>p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> *p= <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];  </span><br><span class="line">    <span class="built_in">foo</span>(p);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);  </span><br><span class="line">    <span class="keyword">delete</span>p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP03：class</title>
      <link href="/2023/10/03/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC3%E7%AB%A0-class/"/>
      <url>/2023/10/03/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC3%E7%AB%A0-class/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第3章-class">第3章 class</h1><h2 id="c语言面向过程">3.1 C语言–面向过程</h2><ol type="1"><li>定义：定义结构体、对结构体的操作函数</li><li>使用：传入结构体指针、对应的参数</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span>  </span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line"><span class="type">float</span> y;</span><br><span class="line">&#125;Point;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> Point *p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f %f\n&quot;</span>,p-&gt;x,p-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(Point* p,<span class="type">int</span> dx,<span class="type">int</span> dy)</span>&#123;</span><br><span class="line">    p-&gt;x += dx; p-&gt;y += dy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Point a;</span><br><span class="line">a.x = <span class="number">1</span>;a.y = <span class="number">2</span>;</span><br><span class="line">move(&amp;a,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">print(&amp;a);</span><br></pre></td></tr></table></figure><h2 id="c语言面向对象">3.2 C++语言–面向对象</h2><ol type="1"><li>定义：将<strong>对象</strong>和<strong>操作</strong>绑定到一起</li><li>使用：操作Point对象</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> dx,<span class="type">int</span> dy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::init</span><span class="params">(<span class="type">int</span> ix,<span class="type">int</span> iy)</span></span>&#123;</span><br><span class="line">x = ix; y = iy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::move</span><span class="params">(<span class="type">int</span> dx,<span class="type">int</span> dy)</span></span>&#123;</span><br><span class="line">    x += dx; y += dy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Point a;</span><br><span class="line">a.<span class="built_in">init</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">move</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure><h2 id="resolver">3.3 :: resolver</h2><p><strong>&lt; Class Name &gt;::&lt; function name &gt;</strong></p><p><strong>::&lt; function name &gt;</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">S::f</span><span class="params">()</span></span>&#123;</span><br><span class="line">::<span class="built_in">f</span>();<span class="comment">//这里调用的f()是全局的函数f(),而非自己</span></span><br><span class="line">    ::a++;<span class="comment">//全局的a++</span></span><br><span class="line">    a--;<span class="comment">//S里的a++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="container容器">3.4 Container容器</h2><p><strong>container</strong>：是一个能够保存其它对象的<strong>object</strong></p><p><strong>stash</strong>：是一个可以存储变量、运行时可以扩展的<strong>container</strong></p><p>要求：</p><ol type="1"><li>无类型限制</li><li>存储的对象类型相同</li><li>操作：<strong>add()</strong>、<strong>fetch()</strong></li><li>可以自动扩展内存</li></ol><h3 id="声明">3.4.1 声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STASH2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STASH2_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stash</span>&#123;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 每个空间的大小</span></span><br><span class="line">    <span class="type">int</span> quantity;<span class="comment">// 空间的个数</span></span><br><span class="line">    <span class="type">int</span> next; <span class="comment">// 下一个为空的空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行动态内存访问</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* storage; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inflatte</span><span class="params">(<span class="type">int</span> increase)</span></span>;<span class="comment">// 增长内存</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stash</span>(<span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">Stash</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">void</span> * element)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">fetch</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="定义">3.4.2 定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stash2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../require.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> increment = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数,函数名和类名相同</span></span><br><span class="line">Stash::<span class="built_in">Stash</span>(<span class="type">int</span> sz) &#123; </span><br><span class="line">size = sz;</span><br><span class="line">quantity = <span class="number">0</span>;</span><br><span class="line">storage = <span class="number">0</span>;</span><br><span class="line">next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stash::add</span><span class="params">(<span class="type">void</span>* element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 剩余内存不够,增加内存</span></span><br><span class="line"><span class="keyword">if</span>(next &gt;= quantity) </span><br><span class="line"><span class="built_in">inflate</span>(increment);</span><br><span class="line"><span class="comment">// 将元素复制到storage[]中,开始另一个新内存</span></span><br><span class="line"><span class="type">int</span> startBytes = next * size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* e = (<span class="type">unsigned</span> <span class="type">char</span>*)element;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">storage[startBytes + i] = e[i];</span><br><span class="line">next++;</span><br><span class="line"><span class="keyword">return</span> (next - <span class="number">1</span>); <span class="comment">//当前元素存储的空间编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Stash::fetch</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="number">0</span> &lt;= index, <span class="string">&quot;Stash::fetch (-)index&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(index &gt;= next) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 访问为空</span></span><br><span class="line"><span class="comment">// 返回访问的内存地址</span></span><br><span class="line"><span class="keyword">return</span> &amp;(storage[index * size]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stash::count</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> next; <span class="comment">// Stash中的元素个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stash::inflate</span><span class="params">(<span class="type">int</span> increase)</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(increase &gt; <span class="number">0</span>, <span class="string">&quot;Stash::inflate zero or negative increase&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> newQuantity = quantity + increase;</span><br><span class="line"><span class="type">int</span> newBytes = newQuantity * size;</span><br><span class="line"><span class="type">int</span> oldBytes = quantity * size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* b = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[newBytes];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; oldBytes; i++)</span><br><span class="line">b[i] = storage[i]; <span class="comment">// 将旧内存中的元素复制到新内存中</span></span><br><span class="line"><span class="keyword">delete</span>[] (storage); <span class="comment">// 删除旧内存</span></span><br><span class="line">storage = b; <span class="comment">// storage指向新内存</span></span><br><span class="line">quantity = newQuantity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Stash::~<span class="built_in">Stash</span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(storage != <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;freeing storage&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] storage;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this">3.5 this</h2><p><strong>this</strong>：指向对象本身的指针，是类的每个成员函数的隐藏参数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stash::initialize</span><span class="params">(<span class="type">int</span> sz)</span></span>;</span><br><span class="line"><span class="comment">// 可以被视为: </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stash::initialize</span><span class="params">(Stash* <span class="keyword">this</span>, <span class="type">int</span> sz)</span></span>;</span><br><span class="line"></span><br><span class="line">Stash a;</span><br><span class="line">a.<span class="built_in">initialize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 可以被视为: </span></span><br><span class="line">Stash::<span class="built_in">initialize</span>(&amp;a, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()&#123;x = <span class="number">0</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y; <span class="comment">// 在运行时,this会被看为指向该对象的一个指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="object-class">3.6 Object &amp; class</h2><p><strong>Objects = Attributes + Services</strong></p><ol type="1"><li>data：对象的特性or状态；operations：对对象的操作</li><li>通过接口修改数据，而非直接修改数据</li><li>直接访问变量，变量的声明者对变量没有控制权，无法控制操作者的行为</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231013192216365.png" alt="image-20231013192216365" style="zoom:80%;" /></p><p><strong>class</strong>定义<strong>object</strong>，<strong>object</strong>是<strong>class</strong>的一个实例</p><ol type="1"><li>class表述对象可能具有哪些特性</li><li>object表示当前对象的每个特性的具体取值</li></ol><p>OOP的特性：</p><ol type="1"><li>所有事物均可以看作一个对象object</li><li>程序是对象的集合，他们通过互相发送消息，告知应该做些什么</li><li>每个对象都有自己独有的内存空间，由其他更加通用的对象组成</li><li>每个对象都有一个类型type</li><li>一个特定类型的所有对象，可以收到相同的信息</li></ol><h2 id="definition-of-a-class">3.7 Definition of a class</h2><ol type="1"><li><strong>class</strong>的声明放入<strong>.h</strong>文件</li><li><strong>class</strong>的函数体、静态成员变量放入*<strong>.cpp</strong>文件</li></ol><h2 id="compile-unit">3.8 compile unit</h2><ol type="1"><li><strong>compiler</strong>只会看到当前的<strong>cpp</strong>文件，生成当前文件对应的<strong>obj</strong>文件</li><li><strong>linker</strong>会链接所有的<strong>obj</strong>文件，生成一个<strong>exe</strong>文件</li><li>如果要使用其它<strong>cpp</strong>文件中定义的函数/类，需要使用<strong>.h</strong>头文件进行声明</li></ol><h2 id="the-header-files">3.9 The header files</h2><ol type="1"><li>如果函数定义在头文件，那么必须在任何使用该函数和定义该函数的地方<strong>include</strong>该头文件</li><li>如果<strong>class</strong>定义在头文件，那么必须在任何使用<strong>class</strong>和定义<strong>class</strong>的地方<strong>include</strong>该头文件</li><li>当使用<code>#include</code>引用头文件时，编译器会将头文件的内容展开到当前文件，相当于将函数/类的声明写入了当前<strong>cpp</strong>文件中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231013193814111.png" alt="image-20231013193814111" style="zoom:80%;" /></p><h2 id="makefile">3.10 Makefile</h2><ul><li>当程序的代码量过大时，如果仅使用单个文件，会导致诸如难以管理、单次修改需要编译整个项目等问题</li><li>因此我们需要将代码拆分为多个文件进行管理与修改</li><li>多个代码文件之间的关系，通过Makefile文件声明</li></ul><h3 id="project的结构">3.10.1 Project的结构</h3><p>可以看作是一个有向无环图<strong>DAG</strong></p><p>以一个工程为例</p><ul><li>包含main.c、sum.c、sum.h</li><li>sum.h在所有.c文件中都包含</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231013194226096.png" alt="image-20231013194226096" style="zoom:80%;" /></p><p>此时的<strong>makefile</strong>为：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">sum: main.osum.o</span></span><br><span class="line">gcc –o sum main.o sum.o</span><br><span class="line"><span class="section">main.o: main.c sum.h  </span></span><br><span class="line">    gcc –c main.c</span><br><span class="line"><span class="section">sum.o: sum.c sum.h  </span></span><br><span class="line">    gcc –c sum.c</span><br></pre></td></tr></table></figure><h3 id="makefile的语法规则">3.10.2 makefile的语法规则：</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231013194235783.png" alt="image-20231013194235783" style="zoom:80%;" /></p><p>简化语法：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">sum: main.osum.o</span></span><br><span class="line">gcc –o <span class="variable">$@</span> main.o sum.o <span class="comment"># $@ ==&gt; sum</span></span><br><span class="line">main.osum.o: sum.h  </span><br><span class="line">    gcc –c <span class="variable">$*</span>.c <span class="comment"># $* ==&gt; main、sum</span></span><br></pre></td></tr></table></figure><h3 id="makefile的过程">3.10.3 makefile的过程</h3><ol type="1"><li>构建项目依赖树</li><li>创建第一条指令的目标，当且仅当一下两种情况成立之时：<ol type="1"><li>目标文件不存在</li><li>目标文件比它的一个依赖项更早生成</li></ol></li><li><strong>makefile</strong>的作用是保证最小的编译数量，因此需要正确写明<ol type="1"><li>不要写成下面这样(这样写会直接重新编译所有文件)</li></ol></li></ol><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">prog: main.c sum1.csum2.c</span></span><br><span class="line">gcc –o prog main.c sum1.c sum2.c</span><br></pre></td></tr></table></figure><h2 id="cmake">3.11 CMake</h2><ol type="1"><li>是一个跨平台的，开源编译系统</li><li>可以看作是Makefile的升级版</li></ol><p><ahref="https://hzoi-unicorn.top/2023/06/02/指令合集/cmake学习笔记/">cmake学习笔记| 华风夏韵 (hzoi-unicorn.top)</a></p>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP02：Using Object</title>
      <link href="/2023/10/02/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC2%E7%AB%A0-using%20objects/"/>
      <url>/2023/10/02/OOP%E6%9C%8B%E8%BE%88%E8%BE%85%E5%AD%A6/%E7%AC%AC2%E7%AB%A0-using%20objects/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="第2章-using-object">第2章 Using Object</h1><h2 id="string">2.1 string</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line">string str1 = <span class="string">&quot;Hello&quot;</span>, str2, str3;</span><br><span class="line"><span class="comment">// 输入、输出</span></span><br><span class="line">cin &gt;&gt; str1;</span><br><span class="line">cout &lt;&lt; str1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str1.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="comment">// 运算</span></span><br><span class="line">str2 = str1;</span><br><span class="line">str3 = str1 + str2;</span><br><span class="line">str1 += str2;</span><br><span class="line">str1 += <span class="string">&quot;lalala&quot;</span>;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *cp, <span class="type">int</span> len);</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s2, <span class="type">int</span> pos);</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s2, <span class="type">int</span> pos, <span class="type">int</span> len);</span><br><span class="line"><span class="comment">// 子串</span></span><br><span class="line"><span class="built_in">substr</span>(<span class="type">int</span> pos, <span class="type">int</span> len);</span><br><span class="line"><span class="comment">// 修改串</span></span><br><span class="line"><span class="built_in">assign</span>();</span><br><span class="line"><span class="built_in">insert</span>(<span class="type">const</span> string &amp;s, <span class="type">int</span> len);</span><br><span class="line"><span class="built_in">insert</span>(<span class="type">int</span> pos, <span class="type">const</span> string &amp;s);</span><br><span class="line"><span class="built_in">erase</span>();</span><br><span class="line"><span class="built_in">append</span>();</span><br><span class="line"><span class="built_in">replace</span>();</span><br><span class="line"><span class="comment">// 寻找串</span></span><br><span class="line"><span class="built_in">find</span>();</span><br></pre></td></tr></table></figure><h2 id="file-io">2.2 File I/O</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function">ofstream <span class="title">File1</span><span class="params">(<span class="string">&quot;C:\\test.txt&quot;</span>)</span></span>;</span><br><span class="line">File1 &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">File2</span><span class="params">(<span class="string">&quot;C:\\test.txt&quot;</span>)</span></span>;</span><br><span class="line">string str;</span><br><span class="line">File2 &gt;&gt; str;</span><br></pre></td></tr></table></figure><h2 id="内存结构">2.3 内存结构</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20231013174250011.png" alt="image-20231013174250011" style="zoom:80%;" /></p><p>全局变量<strong>Global Vars</strong>：</p><ol type="1"><li>在函数外定义</li><li>可以通过<strong>extern</strong>，分享给不同的*<strong>.cpp</strong>文件</li></ol><p><strong>extern</strong>：</p><ol type="1"><li>声明，在整个工程中会有这样一个变量</li><li>声明了变量的类型、名称</li></ol><p><strong>static global var</strong>：</p><ol type="1"><li>禁止被其他*<strong>.cpp</strong>文件访问</li><li>包括<strong>static</strong>变量、<strong>static</strong>函数</li></ol><p><strong>static local var</strong>：</p><ol type="1"><li>保存了在不同次访问函数时，需要被保存的变量</li><li>在第一次访问函数时，变量被初始化</li></ol><h2 id="pointers-to-objects">2.4 Pointers to Objects</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string *ps = &amp;s;</span><br></pre></td></tr></table></figure><p><strong>&amp;</strong>：取地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps = &amp;s;</span><br></pre></td></tr></table></figure><p>*****：得到对象</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*ps).<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure><p><strong>-&gt;</strong>：调用函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps-&gt;<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure><p>两种访问对象的方法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s; <span class="comment">// s是对象本身, 会将对象s进行初始化</span></span><br><span class="line">string *ps; <span class="comment">// ps是指向对象的指针, ps指向的对象不一定存在</span></span><br></pre></td></tr></table></figure><p>赋值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">s1 = s2;<span class="comment">// 对象本身发生了变化</span></span><br><span class="line"></span><br><span class="line">string *ps1, *ps2;</span><br><span class="line">ps1 = ps2;<span class="comment">// 只是指针的指向发生了变化, 但是对象本身并没有变化</span></span><br></pre></td></tr></table></figure><h2 id="动态分配内存">2.5 动态分配内存</h2><p>动态分配内存：保存在堆空间</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配内存: new--申请内存, 然后调用对象的构造函数</span></span><br><span class="line"><span class="comment">// 分配内存时, 系统会默认在内存的前面加上一些描述信息, 以便于系统后期回收</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">new</span> Stash;</span><br><span class="line"><span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除内存: delete--调用对象的析构函数, 然后释放内存</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// 删除数组</span></span><br></pre></td></tr></table></figure><p>动态数组：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *psome = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] psome;</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pArr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">pArr++;</span><br><span class="line"><span class="keyword">delete</span>[] pArr; <span class="comment">// 这句话是不对的, pArr指向的不仅仅是自身, 还有堆分配的内存的相关信息</span></span><br></pre></td></tr></table></figure><p>要求：</p><ol type="1"><li>不要<strong>delete</strong>不是被<strong>new</strong>分配的内存</li><li>不要<strong>delete</strong>同一个内存两次</li><li>如果<strong>new []</strong>，要用<strong>delete []</strong></li><li>可以<strong>delete</strong>一个空指针</li></ol><h2 id="引用-reference">2.6 引用 Reference</h2><p>用法：对一个已经存在的对象，生成一个新的名字</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义,定义后,访问r &lt;==&gt; 访问c</span></span><br><span class="line"><span class="comment">// 如: r=&#x27;t&#x27; &lt;==&gt; c=&#x27;t&#x27;</span></span><br><span class="line"><span class="type">char</span>&amp; r = c;</span><br><span class="line"><span class="comment">// 应用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>; <span class="comment">// 在func函数中, 对x的修改会返回</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">string&amp; rs1 = s1;</span><br><span class="line">rs1 = s2;<span class="comment">// 这句话表示将rs1赋值为&quot;World&quot;,而非将rs1重新绑定到s2上</span></span><br></pre></td></tr></table></figure><p><strong>Pointers vs References</strong>：</p><ol type="1"><li><p><strong>Pointers</strong></p><ol type="1"><li>可以是<strong>null</strong></li><li>不依赖于已经存在的对象</li><li>可以修改指向不同地址</li></ol></li><li><p><strong>References</strong>：</p><ol type="1"><li><p>不能是<strong>null</strong>，定义时必须初始化</p></li><li><p>依赖于已经存在的对象</p></li><li><p>定义后，不能指向其他对象</p></li><li><p>指向的对象必须有地址，不能是表达式等临时变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="built_in">func</span>(i * <span class="number">3</span>); <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>Reference</strong>的限制：</p><ol type="1"><li><p>引用本身不是对象，因此无法定义引用的引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> &amp;rx = x;</span><br><span class="line"><span class="type">int</span> &amp;(&amp;rrx) = rx; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure></li><li><p>不能用指针指向引用对象：<code>int&amp; *p</code>是非法的，但是可以<code>int* px = &amp;x;</code></p></li><li><p>可以对指针生成一个引用：<code>int* &amp;p</code>是合法的</p></li><li><p>不能定义引用的数组：<code>int&amp; x[100]</code>是非法的</p></li></ol><h2 id="常量-const">2.7 常量 const</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义, 定义后x不能修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于将x的值拷贝给了y</span></span><br><span class="line"><span class="type">int</span> y = x;</span><br></pre></td></tr></table></figure><p>使用<strong>const</strong>代替宏定义常量，优点：</p><ol type="1"><li>有作用域</li><li>宏是强替换，而<strong>const</strong>是一个变量</li></ol><p>编译器对<strong>const</strong>的处理：</p><ol type="1"><li>编译器会尽量避免为<strong>const</strong>变量分配内存，而是放入符号表中</li><li><strong>extern</strong>的<strong>const</strong>变量，会被分配内存</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufsize;</span><br></pre></td></tr></table></figure><ul><li>编译时常量：在编译期间可以决定取值的常量</li><li>运行时常量：在运行期间才可以确定取值的常量</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line"><span class="type">char</span> s[bufsize]; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = x;</span><br><span class="line"><span class="type">char</span> s[size]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h2 id="聚合-aggregates">2.8 聚合 Aggregates</h2><h3 id="常量数组">2.8.1 常量数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="type">float</span> f[i[<span class="number">3</span>]]; <span class="comment">// Illegal, 此处i的内存是被分配出来的, 取值必须经过内存读取, 无法在编译时确定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> S s[] = &#123; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span> &#125; &#125;;</span><br><span class="line"><span class="type">double</span> d[s[<span class="number">1</span>].j]; <span class="comment">// Illegal</span></span><br></pre></td></tr></table></figure><h3 id="pointers-and-const">2.8.2 Pointers and const</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针本身不被更改: q is const</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> q = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">*q = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// OK</span></span><br><span class="line">q++; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针指向的内容不被更改: (*p) is const</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = <span class="string">&quot;ABCD&quot;</span>; </span><br><span class="line">*p = <span class="string">&#x27;b&#x27;</span>; <span class="comment">// Error;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="function">string <span class="title">p1</span><span class="params">(<span class="string">&quot;Fred&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> string *p= &amp;p1; <span class="comment">// (*p)不能更改</span></span><br><span class="line">string <span class="type">const</span> *p= &amp;p1; <span class="comment">// (*p)不能更改</span></span><br><span class="line">string *<span class="type">const</span> p= &amp;p1; <span class="comment">// p不能更改</span></span><br></pre></td></tr></table></figure><p><strong>Pointers and constants</strong>：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">int i</th><th style="text-align: center;">const int ci = 3;</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>int </strong>* ip;</td><td style="text-align: center;">ip = &amp;i;</td><td style="text-align: center;">ip = &amp;ci; //不合法</td></tr><tr><td style="text-align: center;"><strong>const int </strong>* cip;</td><td style="text-align: center;">cip = &amp;i;</td><td style="text-align: center;">cip = &amp;ci;</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*ip = <span class="number">54</span>; <span class="comment">// 永远是合法的,因为ip指向的是int</span></span><br><span class="line">*cip = <span class="number">54</span>; <span class="comment">// 不可能是合法的,因为ip指向的是const int</span></span><br></pre></td></tr></table></figure><h3 id="string-literals">2.8.3 String Literals</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里s指向了一个字符串常量, 但现在的编译器通常会对这种写法报编译错误</span></span><br><span class="line"><span class="type">char</span> *s = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要修改字符串,需要保存到数组之中</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="常量与非常量的转化">2.8.4 常量与非常量的转化</h3><p>非常量 ==&gt; 常量：可以直接转化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *x)</span></span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">f</span>(&amp;a);</span><br></pre></td></tr></table></figure><p>常量 ==&gt; 非常量：使用<strong>const_cast</strong>关键字</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* y = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x);</span><br><span class="line">    <span class="comment">// 此处只能修改*y的值, 无法修改x的值, 因为在C++中修改一个const变量，如x，通过解引用const_cast得到的指针是未定义行为</span></span><br><span class="line">    *y = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x  %d\n&quot;</span>, &amp;x, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x  %d\n&quot;</span>, y, *y);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递并返回参数的地址">2.7.5 传递并返回参数的地址</h3><ol type="1"><li>传递一整个对象，代价会非常大。我们应该传递对象的地址，而非对象</li><li>但是此时，会导致函数可以修改原始对象</li><li>事实上，如果需要给函数传递一个地址，我们需要将其设置为<strong>const</strong></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *x)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OOP朋辈辅学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP朋辈辅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-18：网络游戏的架构基础</title>
      <link href="/2023/07/18/GAMES104/18--%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/18/GAMES104/18--%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十八网络游戏的架构基础">十八、网络游戏的架构基础</h1><h2 id="同步算法">18.1 同步算法</h2><h3 id="快照同步snapshot">18.1.1 快照同步Snapshot</h3><blockquote><p>如Quake</p></blockquote><ol type="1"><li>步骤：<ol type="1"><li>客户端：把<strong>输入</strong>发送给服务器</li><li>服务器：将所有客户的输入集合起来，在服务器中进行<strong>游戏世界的模拟</strong>，然后将<strong>游戏世界的状态</strong>生成<strong>快照</strong>返回给客户端</li><li>客户端：拿到服务器给的快照后，将所有对象设置为对应的状态，然后进行<strong>渲染</strong></li></ol></li><li>优点：<ol type="1"><li>结构清晰，保证了绝<strong>对的一致性</strong>，无法作弊</li><li>不用担心同步的问题</li><li>客户端只负责输入和最后的渲染</li><li>当客户端非常多时，服务器的计算量是最低的，因为只需要对世界模拟一次即可</li></ol></li><li>针对实际情况的改进：<ol type="1"><li>服务器端的帧率通常会很低，需要客户端进行插值</li><li>快照可能包含非常多的信息，但是相邻两帧通常差距不大，因此可以只传delta，从而降低信息量</li></ol></li><li>缺点：<ol type="1"><li>浪费了客户端的算力</li><li>服务器生成快照传递给每一个客户端，会占用非常大的服务器处的上行带宽</li></ol></li></ol><h3 id="帧同步lockstep">18.1.2 帧同步Lockstep</h3><blockquote><p>如DOOM、王者荣耀</p></blockquote><ol type="1"><li>步骤：<ol type="1"><li>每一帧：客户端把输入统一交给服务器</li><li>服务器等待所有服务器提交输入，然后把所有输入分发给客户端</li><li>客户端得到服务器的指令，做一致的游戏逻辑模拟，得到的结果一定相同</li><li>要求所有客户端进行初始化，初始条件必须相同</li></ol></li><li>针对实际情况的改进：<ol type="1"><li>如果有一个客户端发送输入总是很慢，就需要其他客户端等待它<ol type="1"><li><strong>BucketSynchronization</strong>：每隔固定的时间收集一次信息，服务器没收到的就当没发生</li></ol></li></ol></li><li>缺点：<ol type="1"><li>一样的输入，得到的结果<strong>不一定</strong>相同，因为会有随机数、浮点数等<strong>不确定</strong>的因素<ol type="1"><li>浮点数：要求满足IEE754标准</li><li>随机数：要求随机数种子、随机数算法严格相同</li></ol></li></ol></li></ol><h3 id="状态同步state-synchornization">18.1.3 状态同步StateSynchornization</h3><blockquote><p>如CS</p></blockquote><ol type="1"><li>步骤：<ol type="1"><li>客户端：Authorized将命令发送给服务器(如向某个方向发射一个炮弹)</li><li>服务器：接收客户端的命令，模拟操作(如打中某个对象)，然后将改变的状态广播给所有客户端</li><li>客户端：接收服务器的对场景状态的改变，模拟出整个世界</li></ol></li><li>针对实际情况的改进：<ol type="1"><li>客户端发送指令，服务器接受指令并确返回结果，会存在延迟<ol type="1"><li><strong>Client-sideprediction</strong>：客户端要进行预测操作，即先将客户的指令执行，然后再和服务器对齐<ol type="1"><li>守望先锋：预测半个RTT+一个命令帧时间</li></ol></li><li><strong>ServerReconciliation</strong>：预测与服务器的返回不一致时，客户端要与服务器对齐<ol type="1"><li>平滑的差值对齐</li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-14：工具链：高级概念及应用</title>
      <link href="/2023/07/14/GAMES104/14--%E5%B7%A5%E5%85%B7%E9%93%BE%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2023/07/14/GAMES104/14--%E5%B7%A5%E5%85%B7%E9%93%BE%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十四工具链高级概念及应用">十四、工具链：高级概念及应用</h1><h2 id="world-editor">14.1 World Editor</h2><blockquote><p><strong>A hub for everything to build the world</strong></p></blockquote><h3 id="world-editor中的编辑工具">14.1.1 World Editor中的编辑工具</h3><h4 id="editor-viewport">14.1.1.1 Editor Viewport</h4><p>用户和游戏世界交互的窗口</p><ul><li><p>底层跑的实际上就是引擎的runtime，但是是以editor mode</p></li><li><p>引擎有一些代码会是editor-only</p></li><li><p>Viewport有时是不止一个的，需要改造引擎支持多个viewport</p></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802161611838.png" alt="image-20230802161611838" style="zoom:80%;" /></p><h4 id="可编辑游戏对象">14.1.1.2 可编辑游戏对象</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802161933727.png" alt="image-20230802161933727" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802162112343.png" alt="image-20230802162112343" style="zoom:80%;" /></p><ul><li>由对象的属性，反射出的一个schema，可以直接修改对象的属性</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802162321862.png" alt="image-20230802162321862" style="zoom:80%;" /></p><h4 id="内容浏览器">14.1.1.3 内容浏览器</h4><ul><li>资产不一定是在本地，也可能是在数据库</li><li>内容浏览器负责将所有的资产显示到引擎中，从而不需要专门去某个静态文件夹中找</li></ul><blockquote><p>将静态文件夹转化为内容的ocean</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802162456550.png" alt="image-20230802162456550" style="zoom:80%;" /></p><h4 id="总结">14.1.1.4 总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802162953875.png" alt="image-20230802162953875" style="zoom:80%;" /></p><h3 id="鼠标选取">14.1.2 鼠标选取</h3><p>Ray Casting：通过射线检测，与物体的包围盒碰撞，表示选取哪个物体</p><ul><li>透明物是不写入depthbuffer的，需要特殊处理：如在particle的发生器处添加一个虚拟物体</li></ul><p>RTT(run time type)：专门绘制一个选取帧，表示每一个像素对应的物体</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802163052990.png" alt="image-20230802163052990" style="zoom:80%;" /></p><h3 id="编辑物体的-transform">14.1.3 编辑物体的 Transform</h3><p>需要支持很多特性，而不是仅仅的一个transform</p><ul><li>如旋转角度的对齐</li></ul><h3 id="地形">14.1.4 地形</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802163900330.png" alt="image-20230802163900330" style="zoom:80%;" /></p><p>高度刷：</p><ul><li><p>重点是平滑过渡</p></li><li><p>自定义笔刷：支持导入高度图，要有可扩展性</p></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802163943757.png" alt="image-20230802163943757" style="zoom:80%;" /></p><p>实例刷：</p><ul><li>大面积刷树、草等物体时常用</li><li>需要能够一个一个修改</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802164142885.png" alt="image-20230802164142885" style="zoom:80%;" /></p><h3 id="环境">14.1.5 环境</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802164329502.png" alt="image-20230802164329502" style="zoom:80%;" /></p><h3 id="环境编辑中的规则系统">14.1.6 环境编辑中的规则系统</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230802164429700.png" alt="image-20230802164429700" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803101518507.png" alt="image-20230803101518507" style="zoom:80%;" /></p><h2 id="编辑器插件架构">14.2 编辑器插件架构</h2><h3 id="系统对象矩阵结构">14.2.1 系统&amp;对象矩阵结构</h3><ul><li>plugin即需要能够修改系统，也需要能够修改单个对象</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803101944704.png" alt="image-20230803101944704" style="zoom:80%;" /></p><h3 id="多个plugin之间的组合">14.2.2 多个plugin之间的组合</h3><ul><li>Covered：新的plugin覆盖旧的plugin</li><li>Distributed：不同plugin之间互不影响，最后将结果合成，产生最终输出</li><li>Pipeline：不同plugin依次进行加工</li><li>Onion rings：不同plugin之间会进行数据传输</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803102307980.png" alt="image-20230803102307980" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803102436703.png" alt="image-20230803102436703" style="zoom:80%;" /></p><h3 id="plugin-engine-的版本控制">14.2.3 Plugin &amp; engine的版本控制</h3><ul><li>对引擎的接口进行版本编号，只有当接口的版本相同时，Plugin才有效</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803102744948.png" alt="image-20230803102744948" style="zoom:80%;" /></p><h2 id="设计叙事工具-narrative-tools">14.3 设计叙事工具 NarrativeTools</h2><h3 id="游戏引擎中的叙事">14.3.1 游戏引擎中的叙事</h3><ul><li>在时间轴上，让游戏对象动起来</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803105711305.png" alt="image-20230803105711305" style="zoom:80%;" /></p><ul><li>示例：UE中的Sequencer</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803105738398.png" alt="image-20230803105738398" style="zoom:80%;" /></p><h2 id="反射和游戏逻辑">14.4 反射和游戏逻辑</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803110424118.png" alt="image-20230803110424118" style="zoom:80%;" /></p><ul><li>反射的任务：将代码中的接口，显示到可视化编程脚本中</li></ul><h3 id="反射">14.4.1 反射</h3><ul><li>反射：当写完一行代码后，系统会告诉我到底有哪些新的功能被暴露出来，从而让其他编写者在不需要重新编译这个文件的同时，使用这些新的功能的接口</li><li>反射构建了代码和工具之间的桥梁</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803110826742.png" alt="image-20230803110826742" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803111124025.png" alt="image-20230803111124025" style="zoom:80%;" /></p><h3 id="在c中的反射实现">14.4.2 在C++中的反射实现</h3><h4 id="从代码中获取类型信息">14.4.2.1 从代码中获取类型信息</h4><ul><li>语言经过编译器生成AST后，可以在AST中很容易的得到类型信息</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803111434201.png" alt="image-20230803111434201" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803111511388.png" alt="image-20230803111511388" style="zoom:80%;" /></p><h4 id="picolo使用的是clang">14.4.2.2 Picolo使用的是Clang</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803111638570.png" alt="image-20230803111638570" style="zoom:80%;" /></p><h4 id="从ast中生成schema">14.4.2.3 从AST中生成Schema</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803111702820.png" alt="image-20230803111702820" style="zoom:80%;" /></p><h4 id="反射中的精确控制">14.4.2.4 反射中的精确控制</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803111731150.png" alt="image-20230803111731150" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803111835118.png" alt="image-20230803111835118" style="zoom:80%;" /></p><h4 id="反射accessor">14.4.2.5 反射Accessor</h4><ul><li>对每个收集到的字段，生成三类方法：<code>get, set, invoke</code></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803112047326.png" alt="image-20230803112047326" style="zoom:80%;" /></p><h4 id="代码渲染">14.4.2.6 代码渲染</h4><ul><li>大量减少冗余代码的开发</li><li>经过一次debug后，基本不会出错</li><li>将数据和逻辑进行分离</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803112128910.png" alt="image-20230803112128910" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803112207954.png" alt="image-20230803112207954" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803112325199.png" alt="image-20230803112325199" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803112348460.png" alt="image-20230803112348460" style="zoom:80%;" /></p><h2 id="协同编辑">14.5 协同编辑</h2><h3 id="解决合并时的冲突">14.5.1 解决合并时的冲突</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803112656855.png" alt="image-20230803112656855" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803112716987.png" alt="image-20230803112716987" style="zoom:80%;" /></p><p>将物体进行划分</p><ul><li>将世界进行分层：<ul><li>优点：正确的分层可以降低编辑冲突，分层有逻辑上的可行性</li><li>缺点：分层难以分好，且不同层之间会有依赖</li></ul></li><li>对世界进行划分，分为不同地块<ul><li>优点：便于动态扩展世界</li><li>缺点：难以处理跨界的物体</li></ul></li><li>OFPA：每个Actor一个文件，每个人只修改自己的文件<ul><li>缺点：会生成很多小文件，cooking的时候需要将这些小文件打包到同一个关卡中</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803112738102.png" alt="image-20230803112738102" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113002421.png" alt="image-20230803113002421" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113135835.png" alt="image-20230803113135835" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113155734.png" alt="image-20230803113155734" style="zoom:80%;" /></p><h3 id="同时编辑同一个对象">14.5.2 同时编辑同一个对象</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113356599.png" alt="image-20230803113356599" style="zoom:80%;" /></p><ul><li>基础：对编辑操作进行原子化操作，同步command</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113412177.png" alt="image-20230803113412177" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113555546.png" alt="image-20230803113555546" style="zoom:80%;" /></p><ul><li>实例锁</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113609346.png" alt="image-20230803113609346" style="zoom:80%;" /></p><ul><li>资源锁</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113622754.png" alt="image-20230803113622754" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113715453.png" alt="image-20230803113715453" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113723244.png" alt="image-20230803113723244" style="zoom:80%;" /></p><h3 id="现代编辑工作流">14.5.3 现代编辑工作流</h3><ul><li>将所有的操作先同步到一个server上，然后再由server更新数据</li><li>server要求很高的鲁棒性</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113830069.png" alt="image-20230803113830069" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230803113948347.png" alt="image-20230803113948347" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-13：工具链：基础</title>
      <link href="/2023/07/13/GAMES104/13--%E5%B7%A5%E5%85%B7%E9%93%BE%EF%BC%9A%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/13/GAMES104/13--%E5%B7%A5%E5%85%B7%E9%93%BE%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十三工具链基础">十三、工具链：基础</h1><h2 id="工具链">13.1 工具链</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801110208184.png" alt="image-20230801110208184" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801111200754.png" alt="image-20230801111200754" style="zoom:80%;" /></p><p>工具链的任务：</p><ul><li>让不同思维方式的人，能够共同工作</li><li>对于不同的人，打开同一个游戏，关注的侧重点、看到的形式都是不同的</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801112950233.png" alt="image-20230801112950233" style="zoom:80%;" /></p><h2 id="复杂的工具">13.2 复杂的工具</h2><h3 id="gui">13.2.1 GUI</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801113437985.png" alt="image-20230801113437985" style="zoom:80%;" /></p><h4 id="直接模式-immediate-mode">13.2.1.1 直接模式 Immediate Mode</h4><p>直接由游戏逻辑绘制GUI</p><p>优点：简单易实现</p><p>缺点：难以扩展</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801113541640.png" alt="image-20230801113541640" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801113551192.png" alt="image-20230801113551192" style="zoom:80%;" /></p><h4 id="retained-mode">13.2.1.2 Retained Mode</h4><p>将要画的东西存储到一个buffer中，绘制时根据这些指令自动绘制</p><p>优点：将UI的逻辑和渲染划分开，扩展性好，性能高（绘制指令集中在一起）</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801113756034.png" alt="image-20230801113756034" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801113829936.png" alt="image-20230801113829936" style="zoom:80%;" /></p><h3 id="设计模式">13.2.2 设计模式</h3><h4 id="mvc">13.2.2.1 MVC</h4><p>Model：数据</p><p>View：根据model进行渲染</p><p>Controller：修改model</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801114027100.png" alt="image-20230801114027100" style="zoom:80%;" /></p><h4 id="mvp">13.2.2.2 MVP</h4><p>Model：数据</p><p>View：根据presenter的指令更新界面，并反馈给presenter用户事件</p><p>Presenter：从model中取数据，并更新model</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801114237328.png" alt="image-20230801114237328" style="zoom:80%;" /></p><h4 id="mvvm">13.2.2.3 MVVM</h4><p>Model：数据</p><p>ViewModel：由程序员编写，将view与对应的model绑定</p><p>View：由designer编写，表示交互逻辑</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801114630997.png" alt="image-20230801114630997" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801114700612.png" alt="image-20230801114700612" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801141830204.png" alt="image-20230801141830204" style="zoom:80%;" /></p><h3 id="load-save">13.2.3 Load &amp; Save</h3><h4 id="序列化与反序列化">13.2.3.1 序列化与反序列化</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801142121940.png" alt="image-20230801142121940" style="zoom:80%;" /></p><h4 id="text文件">13.2.3.2 Text文件</h4><p>可以先支持将所有asset均存放为text文件，便于debug</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801142612287.png" alt="image-20230801142612287" style="zoom:80%;" /></p><h4 id="binary文件">13.2.3.3 Binary文件</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801142935327.png" alt="image-20230801142935327" style="zoom:80%;" /></p><h3 id="asset-reference">13.2.4 Asset Reference</h3><p>将重复的东西提取出来</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801143205286.png" alt="image-20230801143205286" style="zoom:80%;" /></p><h3 id="场景中的对象实例">13.2.5 场景中的对象实例</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801143336464.png" alt="image-20230801143336464" style="zoom:80%;" /></p><h4 id="对象实例的变化">13.2.5.1 对象实例的变化</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801143423688.png" alt="image-20230801143423688" style="zoom:80%;" /></p><h4 id="数据继承">13.2.5.2 数据继承</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801143554748.png" alt="image-20230801143554748" style="zoom:80%;" /></p><h2 id="资产加载反序列化">13.3 资产加载–反序列化</h2><h3 id="解析-asset-文件">13.3.1 解析 Asset 文件</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801143918747.png" alt="image-20230801143918747" style="zoom:80%;" /></p><h3 id="创建-key-type-value-的树状结构">13.3.2 创建 Key-Type-Value的树状结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801144101782.png" alt="image-20230801144101782" style="zoom:80%;" /></p><h3 id="binary-vs-text">13.3.3 Binary vs Text</h3><p>Binary：将描述存储在文件头部</p><p>Text：由json库解析生成树，然后进行查找</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801144311730.png" alt="image-20230801144311730" style="zoom:80%;" /></p><h3 id="endianness-大小端">13.3.4 Endianness 大小端</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801144500583.png" alt="image-20230801144500583" style="zoom: 80%;" /></p><h3 id="资产的版本兼容">13.3.5 资产的版本兼容</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801144734659.png" alt="image-20230801144734659" style="zoom:80%;" /></p><h4 id="添加删除字段">13.3.5.1 添加/删除字段</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801145104800.png" alt="image-20230801145104800" style="zoom:80%;" /></p><ul><li>硬编码：通过检查版本号，多的数据不处理，少的数据写为默认值</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801145136066.png" alt="image-20230801145136066" style="zoom:80%;" /></p><ul><li>protocol buffer：定义每个数据时，生成一个uniqueID，数据更新时比较ID是否有变化</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801145306634.png" alt="image-20230801145306634" style="zoom:80%;" /></p><h2 id="如何制作高鲁棒性的工具command">13.4如何制作高鲁棒性的工具：Command</h2><ol type="1"><li>将用户的操作分解为很多个小的command，command要尽量原子化</li><li>将command定时存到磁盘上，系统崩溃时从磁盘上找这些command</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801150124281.png" alt="image-20230801150124281" style="zoom:80%;" /></p><h3 id="command的定义">13.4.1 Command的定义</h3><ul><li>UID：唯一的、累加的<ul><li>隐含了时序信息</li></ul></li><li>Data</li><li>Invoke()：执行command</li><li>Revoke()：回退command</li><li>Serialize()：序列化，将command存到磁盘上</li><li>Deserialize()：反序列化，从磁盘中读取command<ul><li>通常由TData自身提供标准的序列化和反序列化方法</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801150323211.png" alt="image-20230801150323211" style="zoom:80%;" /></p><h3 id="三种标准command增删改">13.4.2 三种标准Command：增删改</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801150810357.png" alt="image-20230801150810357" style="zoom:80%;" /></p><h2 id="如何制作工具链">13.5 如何制作工具链</h2><h3 id="找到共同的building-block">13.5.1 找到共同的building block</h3><ul><li>任何复杂的事物，均可以描述成简单事物的集合</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801151103241.png" alt="image-20230801151103241" style="zoom:80%;" /></p><h3 id="schema一种描述结构">13.5.2 Schema：一种描述结构</h3><ul><li>定义不同building block的描述结构</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801151206840.png" alt="image-20230801151206840" style="zoom:80%;" /></p><h4 id="基础元素">13.5.2.1 基础元素</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801153152433.png" alt="image-20230801153152433" style="zoom:80%;" /></p><h4 id="继承">13.5.2.2 继承</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801153225484.png" alt="image-20230801153225484" style="zoom:80%;" /></p><h4 id="data-reference">13.5.2.3 data reference</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801153324595.png" alt="image-20230801153324595" style="zoom:80%;" /></p><h4 id="种定义方式">13.5.2.4 2种定义方式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801153551935.png" alt="image-20230801153551935" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801153615812.png" alt="image-20230801153615812" style="zoom:80%;" /></p><h3 id="引擎数据的三种表现形式">13.5.3 引擎数据的三种表现形式</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154026068.png" alt="image-20230801154026068" style="zoom:80%;" /></p><ul><li>内存中：数据要尽可能高效处理</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154036871.png" alt="image-20230801154036871" style="zoom:80%;" /></p><ul><li>存储中：尽可能节约存储空间、加快读写速率</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154123422.png" alt="image-20230801154123422" style="zoom:80%;" /></p><ul><li>工具中：要尽可能直观，容易理解</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154217195.png" alt="image-20230801154217195" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154239595.png" alt="image-20230801154239595" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154313786.png" alt="image-20230801154313786" style="zoom:80%;" /></p><h2 id="wysiwyg所见即所得">13.6 WYSIWYG：所见即所得</h2><blockquote><p><strong>What You See Is What You Get</strong></p></blockquote><h3 id="stand-alone-tools">13.6.1 Stand-alone Tools</h3><p>将工具层隔离出来，防止工具链的复杂代码污染引擎</p><ul><li>难以实现”所见即所得“</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154605268.png" alt="image-20230801154605268" style="zoom:80%;" /></p><h3 id="in-game-tools">13.6.2 In Game Tools</h3><p>将工具层构建在整个引擎之上，工具层直接调用引擎代码</p><ul><li>在编辑器中的东西和实际游戏中的东西是相同的</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154756403.png" alt="image-20230801154756403" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801154930491.png" alt="image-20230801154930491" style="zoom:80%;" /></p><h3 id="pieplayer-in-editor">13.6.3 PIE：Player in Editor</h3><ul><li>player in editor world：直接在编辑器中运行游戏</li><li>player in PIE world：拷贝一份editor world，创建一个PIEworld，然后在PIE world中运行游戏</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801155013747.png" alt="image-20230801155013747" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801155152737.png" alt="image-20230801155152737" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801155311998.png" alt="image-20230801155311998" style="zoom:80%;" /></p><h2 id="可扩展性插件">13.7 可扩展性：插件</h2><h3 id="plug-in框架">13.7.1 Plug-in框架</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801155619712.png" alt="image-20230801155619712" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801155633462.png" alt="image-20230801155633462" style="zoom:80%;" /></p><h3 id="添加toolbar-button">13.7.2 添加Toolbar Button</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801155655033.png" alt="image-20230801155655033" style="zoom: 80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-12：特效：粒子和声效系统</title>
      <link href="/2023/07/12/GAMES104/12--%E7%89%B9%E6%95%88%EF%BC%9A%E7%B2%92%E5%AD%90%E5%92%8C%E5%A3%B0%E6%95%88%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/12/GAMES104/12--%E7%89%B9%E6%95%88%EF%BC%9A%E7%B2%92%E5%AD%90%E5%92%8C%E5%A3%B0%E6%95%88%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十二特效粒子和声效系统">十二、特效：粒子和声效系统</h1><h2 id="粒子基础">12.1 粒子基础</h2><h3 id="粒子">12.1.1 粒子</h3><p>空间中的一个面片/3D模型，包含如下属性：</p><ul><li>位置、速度、大小、颜色、生命周期</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731111013026.png" alt="image-20230731111013026" style="zoom:80%;" /></p><h3 id="粒子的生命周期">12.1.2 粒子的生命周期</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731111137829.png" alt="image-20230731111137829" style="zoom:80%;" /></p><h3 id="粒子发射器">12.1.3 粒子发射器</h3><p>发射器设置粒子的随即初始值：</p><ul><li>随机速度、随机方向</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731112909187.png" alt="image-20230731112909187" style="zoom:80%;" /></p><h3 id="粒子生成">12.1.4 粒子生成</h3><p>生成位置：</p><ul><li>单点、区域、mesh</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731113202843.png" alt="image-20230731113202843" style="zoom:80%;" /></p><p>生成模式：</p><ul><li>连续型、爆发型</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731113344685.png" alt="image-20230731113344685" style="zoom:80%;" /></p><h3 id="粒子模拟">12.1.5 粒子模拟</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731113450835.png" alt="image-20230731113450835" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731113528467.png" alt="image-20230731113528467" style="zoom:80%;" /></p><p>可以改变粒子的</p><ul><li>位置、旋转、颜色、大小</li><li>与环境产生碰撞</li></ul><h3 id="粒子的类型">12.1.6 粒子的类型</h3><h4 id="billboard-particle">12.1.6.1 Billboard Particle</h4><p>一个面片，始终朝向摄像机</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731113840940.png" alt="image-20230731113840940" style="zoom:80%;" /></p><h4 id="mesh-particle">12.1.6.2 Mesh Particle</h4><p>每个粒子都是一个3D模型</p><ul><li>每个particle都不一样，可以通过XYZ方向的随机放缩&amp;旋转实现</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731114050915.png" alt="image-20230731114050915" style="zoom:80%;" /></p><h4 id="ribbon-particle">12.1.6.3 Ribbon Particle</h4><p>每个粒子拖出的是一条光带</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731114215219.png" alt="image-20230731114215219" style="zoom:80%;" /></p><ul><li>粒子在飞行的过程中，会拉出一个个额外的控制点</li><li>每个粒子有一定的宽度，把一个个控制点连接在一起</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731114238604.png" alt="image-20230731114238604" style="zoom:80%;" /></p><ul><li>一般会使用样条曲线插值，使用Catmull曲线</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731114609891.png" alt="image-20230731114609891" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731114509858.png" alt="image-20230731114509858" style="zoom:80%;" /></p><h2 id="粒子渲染">12.2 粒子渲染</h2><h3 id="透明物排序">12.2.1 透明物排序</h3><p>从最远的透明物，逐步画到最近的透明物</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731114732175.png" alt="image-20230731114732175" style="zoom:80%;" /></p><h3 id="粒子排序">12.2.2 粒子排序</h3><p>全局排序：将所有emitter生成的粒子放在一起排序</p><ul><li>优点：真实</li><li>缺点：绘制成本高</li></ul><p>按照emitter分类排序</p><ul><li>缺点：不同emitter生成的粒子相互的重叠关系不对，如右下图</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731114819367.png" alt="image-20230731114819367" style="zoom:80%;" /></p><h3 id="full-resolution-particles">12.2.3 Full-Resolution Particles</h3><p>粒子由于是透明物，因此无法像其他物体一样，只需要shading最后一个像素，因此会十分吃性能</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731115755930.png" alt="image-20230731115755930" style="zoom:80%;" /></p><h3 id="low-resolution-particles">12.2.4 Low-Resolution Particles</h3><p>将屏幕的分辨率降低，然后绘制所有透明物体，最后再将其进行上采样，与原有图像混合</p><ol type="1"><li>下采样后的绘制不需要绘制Z-Buffer，因为每一个透明物体都需要绘制</li><li>需要对整个图像计算一个alpha值，用于后续的混合</li><li>当粒子离相机特别近的时候，会删除一些粒子，以降低在同一个像素点上需要绘制的粒子的数量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731115741692.png" alt="image-20230731115741692" style="zoom:80%;" /></p><h2 id="gpu粒子">12.3 GPU粒子</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731153534879.png" alt="image-20230731153534879" style="zoom:80%;" /></p><h3 id="生成-模拟-排序">12.3.1 生成 =&gt; 模拟 =&gt; 排序</h3><h4 id="initial-state">12.3.1.1 Initial State</h4><ul><li>定义Particle Pool，用于保存所有粒子的描述数据<ul><li>如位置、速度、颜色、尺寸</li></ul></li><li>定义Dead List，用于表示当前Particle Pool中可用的粒子数据</li><li>定义Alive List，用于表示活着的粒子的数据</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731153611222.png" alt="image-20230731153611222" style="zoom:80%;" /></p><h4 id="spawn-particles">12.3.1.2 Spawn Particles</h4><p>假设一个emitter产生了5个粒子：</p><ol type="1"><li>从Dead List的尾部取5个位置，放到Alive List中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731153823555.png" alt="image-20230731153823555" style="zoom:80%;" /></p><h4 id="simulate">12.3.1.3 Simulate</h4><p>计算Alive List中所有粒子的属性，并写入Particle Pool</p><ol type="1"><li>如果该粒子活着，则将其添加到Alive List 1中</li><li>如果该粒子死亡，则将其添加进Dead List中</li></ol><ul><li>每个tick时，在computershader中，计算出每个粒子生命周期的变化，将其反向更新到Alive List &amp;Dead List，再通过buffer swapping，就得到了下一帧要绘制的粒子</li><li>使用frustumculling，得到所有可见的粒子的列表，进一步减少要绘制的粒子数量</li></ul><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731153952906.png" alt="image-20230731153952906" style="zoom:80%;" /></p><h4 id="sortrender-and-swap-alive-lists">12.3.1.4 Sort，Render and SwapAlive Lists</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731154715120.png" alt="image-20230731154715120" style="zoom:80%;" /></p><h3 id="并行的归并排序">12.3.2 并行的归并排序</h3><p>在两个数列中选取一个元素，判断其在合并数列之后的位置：</p><ol type="1"><li>当前数列中在自己前面的，在合并数列中依旧在自己前面</li><li>在另一个数列中，二分查找有哪些数在自己的前边</li><li>两者加和，即可得到自己在合并数列中的位置</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731154923121.png" alt="image-20230731154923121" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731155040057.png" alt="image-20230731155040057" style="zoom:80%;" /></p><h3 id="depth-buffer-collision">12.3.3 Depth Buffer Collision</h3><p>用View Space的深度缓冲，模拟出空间的几何形状，粒子在这里进行碰撞</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731163336612.png" alt="image-20230731163336612" style="zoom:80%;" /></p><h2 id="粒子应用">12.4 粒子应用</h2><h3 id="animated-particle-mesh">12.4.1 Animated Particle Mesh</h3><ol type="1"><li>每个粒子存储一个影响自己的Bone</li><li>把每个粒子所有可能的动画，和在某个状态对粒子速度的影响，全部转换为一个texture</li><li>每个粒子在simulation的时候，不仅仅计算速度位移，还需要在状态机之间来回切换</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731163643143.png" alt="image-20230731163643143" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731163736750.png" alt="image-20230731163736750" style="zoom:80%;" /></p><h3 id="navigation-texture">12.4.2 Navigation Texture</h3><p>让粒子在世界中流动起来：</p><ol type="1"><li>根据当前场景形成一个SDF场，表示当前角色在建筑的里面还是外面</li><li>由SDF，可以得到场景中任何一个位置的导向图</li><li>对于每个粒子，可以由导向图生成一个指引性的力，让人物动起来</li><li>在计算过程中，可以添加一些随机量，让粒子随机切换状态</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731164133003.png" alt="image-20230731164133003" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731164615197.png" alt="image-20230731164615197" style="zoom:80%;" /></p><h2 id="design-philosophy">12.4.3 Design Philosophy</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731164837811.png" alt="image-20230731164837811" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731164848741.png" alt="image-20230731164848741" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731164957470.png" alt="image-20230731164957470" style="zoom:80%;" /></p><h2 id="声音基础">12.5 声音基础</h2><h3 id="相关术语">12.5.1 相关术语</h3><h4 id="音量">12.5.1.1 音量</h4><p>音量本质上是空气的压强</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731171227694.png" alt="image-20230731171227694" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731171239196.png" alt="image-20230731171239196" style="zoom:80%;" /></p><h4 id="pitch-频率">12.5.1.2 Pitch 频率</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731171619641.png" alt="image-20230731171619641" style="zoom:80%;" /></p><h4 id="timbre-音色">12.5.1.3 Timbre 音色</h4><p>音色是由不同基波叠加产生的差异</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731171721378.png" alt="image-20230731171721378" style="zoom:80%;" /></p><h4 id="相位-降噪">12.5.1.4 相位 &amp; 降噪</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731171838212.png" alt="image-20230731171838212" style="zoom:80%;" /></p><h4 id="人的听力范围">12.5.1.5 人的听力范围</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731171924901.png" alt="image-20230731171924901" style="zoom:80%;" /></p><h3 id="数字声音">12.5.2 数字声音</h3><h4 id="pcm脉冲代码调制器">12.5.2.1 PCM：脉冲代码调制器</h4><p>对信号依次进行：</p><ol type="1"><li>采样</li><li>量化</li><li>编码</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731172034772.png" alt="image-20230731172034772" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731172709056.png" alt="image-20230731172709056" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731172731618.png" alt="image-20230731172731618" style="zoom:80%;" /></p><h4 id="audio-format">12.5.2.2 Audio Format</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731173016753.png" alt="image-20230731173016753" style="zoom:80%;" /></p><h2 id="三维音频渲染">12.6 三维音频渲染</h2><h3 id="listener">12.6.1 Listener</h3><p>是一个虚拟的麦克风</p><ol type="1"><li>位置（第三人称游戏通常会在角色和相机之间的某个点）</li><li>速度</li><li>朝向</li></ol><h3 id="spatialization-空间感">12.6.2 Spatialization 空间感</h3><ol type="1"><li>声音的大小</li><li>到达左右耳之间声音的差距（10ms即可感知差距）</li><li>到达左右耳时，音色会发生变化</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731173830145.png" alt="image-20230731173830145" style="zoom:80%;" /></p><h3 id="panning">12.6.3 Panning</h3><p>Panning算法：通过调整在通道中不同声音的大小、音色、latency，产生虚拟的空间感觉</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731174147523.png" alt="image-20230731174147523" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731174203793.png" alt="image-20230731174203793" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731174212714.png" alt="image-20230731174212714" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731174310977.png" alt="image-20230731174310977" style="zoom:80%;" /></p><h3 id="attenuation-衰弱">12.6.4 Attenuation 衰弱</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731174657167.png" alt="image-20230731174657167" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731174856935.png" alt="image-20230731174856935" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731174906408.png" alt="image-20230731174906408" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731174941647.png" alt="image-20230731174941647" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731175008879.png" alt="image-20230731175008879" style="zoom:80%;" /></p><h3 id="环境的影响">12.6.5 环境的影响</h3><p>通过ray casting计算相应的效果</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731175410804.png" alt="image-20230731175410804" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731175500470.png" alt="image-20230731175500470" style="zoom:80%;" /></p><h3 id="混响">12.6.6 混响</h3><ol type="1"><li>干音dry：直接进入耳朵的声音</li><li>回音echo：声音打到墙上反射的声音</li><li>尾音tail：声音产生回音之后，还会有没有打到耳朵的声音继续反弹，产生尾音</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230731175629658.png" alt="image-20230731175629658" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801103059842.png" alt="image-20230801103059842" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801103121084.png" alt="image-20230801103121084" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801103430858.png" alt="image-20230801103430858" style="zoom:80%;" /></p><h3 id="运动中的声音多普勒效应">12.6.7 运动中的声音：多普勒效应</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801103508891.png" alt="image-20230801103508891" style="zoom:80%;" /></p><h3 id="对声场的采样">12.6.8 对声场的采样</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801103644875.png" alt="image-20230801103644875" style="zoom:80%;" /></p><h3 id="常用声音中间件">12.6.9 常用声音中间件</h3><p>通过中间件，连接audio designer和游戏引擎，让audiodesigner在自己习惯的环境下工作</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801103822294.png" alt="image-20230801103822294" style="zoom:80%;" /></p><h3 id="对声音世界进行建模">12.6.10 对声音世界进行建模</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230801104022411.png" alt="image-20230801104022411" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-11：物理：高级应用</title>
      <link href="/2023/07/11/GAMES104/11--%E7%89%A9%E7%90%86%EF%BC%9A%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
      <url>/2023/07/11/GAMES104/11--%E7%89%A9%E7%90%86%EF%BC%9A%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十一物理高级应用">十一、物理：高级应用</h1><h2 id="角色控制器">11.1 角色控制器</h2><p>角色控制器是 Kinematic Actor，是反物理的</p><h3 id="在物理系统中创建一个controller">11.1.1在物理系统中创建一个Controller</h3><p>两个胶囊体：</p><ol type="1"><li>内部的胶囊体：用于与其他物体进行碰撞</li><li>外部的胶囊体：防止高速移动时卡到其他物体里面、防止角色离墙太近导致相机出现bug</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728144547779.png" alt="image-20230728144547779" style="zoom:80%;" /></p><h3 id="与环境的碰撞">11.1.2 与环境的碰撞</h3><ol type="1"><li>撞墙时不是直接停住，而是会沿墙滑动</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728144822521.png" alt="image-20230728144822521" style="zoom:80%;" /></p><h3 id="自动的stepping">11.1.3 自动的stepping</h3><p>有小台阶时，角色要能够迈上去</p><ol type="1"><li>每一帧会尝试将controller往高抬一点，往前走</li><li>问题：如果屋顶不是很高，这样做会导致角色卡到屋顶里面</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728144939164.png" alt="image-20230728144939164" style="zoom:80%;" /></p><h3 id="最大斜坡角度">11.1.4 最大斜坡角度</h3><p>当斜坡的角度过大时，角色虽然能上去，但是会滑下来</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728145229999.png" alt="image-20230728145229999" style="zoom:80%;" /></p><h3 id="体积更新">11.1.5 体积更新</h3><p>当角色的姿态变换时，controller的形状要发生变化</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728145432971.png" alt="image-20230728145432971" style="zoom:80%;" /></p><h3 id="controller推动物体">11.1.6 Controller推动物体</h3><p>当controller撞击到物体上时，会触发物理引擎的回调函数，根据controller的质量&amp;速度，输出一个冲量</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728145621939.png" alt="image-20230728145621939" style="zoom:80%;" /></p><h3 id="站在平台上">11.1.7 站在平台上</h3><p>会通过raycast，判断controller是站在哪个物体上的。在没有新的输入之前，会将controller与物体绑死</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728145901094.png" alt="image-20230728145901094" style="zoom:80%;" /></p><h2 id="布娃娃系统">11.2 布娃娃系统</h2><h3 id="将骨骼与刚体绑定">11.2.1 将骨骼与刚体绑定</h3><p>用几个刚体包裹住角色的大骨骼，所有刚体加起来将整个骨骼包裹住</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728150433669.png" alt="image-20230728150433669" style="zoom:80%;" /></p><h3 id="骨骼的约束">11.2.2 骨骼的约束</h3><p>通常在引擎中，会开放每个刚体之间的六个自由度的约束</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728150835128.png" alt="image-20230728150835128" style="zoom:80%;" /></p><h3 id="用ragdoll驱动骨骼运动">11.2.3 用Ragdoll驱动骨骼运动</h3><p>类似于动画重定向</p><ol type="1"><li>Active joint：Ragdoll绑定的骨骼，直接由Ragdoll控制</li><li>Leaf joint：在Ragdoll之外的骨骼，通常不会改变姿态</li><li>Intermediatejoint：在Ragdoll绑定的骨骼之间的骨骼，会通过相邻两个Activejoint进行插值计算</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728151119627.png" alt="image-20230728151119627" style="zoom:80%;" /></p><h3 id="将动画与ragdoll混合">11.2.4 将动画与Ragdoll混合</h3><ol type="1"><li>前一部分由动画驱动，后一部分逐步交给Ragdoll驱动</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728151418052.png" alt="image-20230728151418052" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728151408758.png" alt="image-20230728151408758" style="zoom:80%;" /></p><h3 id="powered-ragdoll">11.2.5 Powered Ragdoll</h3><p>将动画作为输入，动画中会包含速度与旋转，然后由物理系统产生新的动量&amp;角动量，混合起来</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728151630922.png" alt="image-20230728151630922" style="zoom: 80%;" /></p><h2 id="衣料模拟">11.3 衣料模拟</h2><h3 id="基于动画的衣料模拟">11.3.1 基于动画的衣料模拟</h3><p>用骨骼驱动衣物</p><p>优点：性能高、可控</p><p>缺点：不真实、不能与环境交互、衣物的设计很受限</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728160942706.png" alt="image-20230728160942706" style="zoom:80%;" /></p><h3 id="基于刚体的衣料模拟">11.3.2 基于刚体的衣料模拟</h3><p>用ragdoll技术驱动衣物</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728161116126.png" alt="image-20230728161116126" style="zoom:80%;" /></p><h3 id="基于mesh的衣料模拟">11.3.3 基于Mesh的衣料模拟</h3><h4 id="前期工作">11.3.3.1 前期工作</h4><p>将render mesh转化为physical mesh，大幅减少面数</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728161306494.png" alt="image-20230728161306494" style="zoom:80%;" /></p><p>设置每个顶点的约束，越靠近固定点的顶点，约束越大，可变性越小，骨骼权重越小</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728161842890.png" alt="image-20230728161842890" style="zoom:80%;" /></p><h4 id="衣料结算质点弹簧系统">11.3.3.2 衣料结算–质点弹簧系统</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728162458501.png" alt="image-20230728162458501" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728162523506.png" alt="image-20230728162523506" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728163035195.png" alt="image-20230728163035195" style="zoom:80%;" /></p><h4 id="verlet积分">11.3.3.3 Verlet积分</h4><p>通过相邻两帧的计算公式的合并，下一帧的位置只与当前帧位置、上一帧位置、当前帧加速度有关</p><ol type="1"><li>模拟中，位移是最真实的</li><li>这样计算可以减小误差</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728163235979.png" alt="image-20230728163235979" style="zoom:80%;" /></p><h3 id="基于位置的动力学模拟-pbd">11.3.5 基于位置的动力学模拟 PBD</h3><p>用拉格朗日约束求解位置，不需要通过力&amp;速度</p><ol type="1"><li>更加快、更加稳定、精度敏感时表现更好</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728163548025.png" alt="image-20230728163548025" style="zoom:80%;" /></p><h3 id="自穿插">11.3.6 自穿插</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728163830417.png" alt="image-20230728163830417" style="zoom:80%;" /></p><ol type="1"><li>加厚布料</li><li>增加布料的物理仿真步伐</li><li>设置最大的速度，保证每一步不会穿得过深，还可以弹回来</li><li>在布料的里面添加一个负向力场，将顶点弹回来</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728164003716.png" alt="image-20230728164003716" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728164019251.png" alt="image-20230728164019251" style="zoom:80%;" /></p><h2 id="破坏模拟">11.4 破坏模拟</h2><h3 id="层级碎片">11.4.1 层级碎片</h3><ol type="1"><li><p>将整个表面按照层级分为多个碎片，形成一个树状结构</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728164503118.png" alt="image-20230728164503118" style="zoom:80%;" /></p></li><li><p>连接相邻碎片，得到连接图</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728164616789.png" alt="image-20230728164616789" style="zoom:80%;" /></p></li><li><p>设置连接权重，表示该连接的硬度</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728164713239.png" alt="image-20230728164713239" style="zoom:80%;" /></p></li><li><p>当施加的冲量大于硬度时，该连接就会断裂，造成实际的伤害</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728164915647.png" alt="image-20230728164915647" style="zoom:80%;" /></p></li><li><p>当打中一个点时，会将damage以同心圆的方式传播出去</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728165027145.png" alt="image-20230728165027145" style="zoom:80%;" /></p></li></ol><h3 id="与游戏世界连接">11.4.2 与游戏世界连接</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728165236281.png" alt="image-20230728165236281" style="zoom:80%;" /></p><h3 id="自动生成碎片voronoi算法">11.4.3 自动生成碎片：Voronoi算法</h3><p>在空间中洒下一些种子，从种子开始，自动划分该空间</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728165445311.png" alt="image-20230728165445311" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728165511861.png" alt="image-20230728165511861" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728165526214.png" alt="image-20230728165526214" style="zoom:80%;" /></p><p>生成断裂处的纹理：</p><ol type="1"><li>使用3D Texture表示物体的纹理，碎裂时直接在3D Texture中采样即可</li><li>提前离线渲染好断裂处的纹理，碎裂时切换到断裂处的纹理</li></ol><p>通常不会让碎裂后的物体参与游戏逻辑的计算</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728165614394.png" alt="image-20230728165614394" style="zoom:80%;" /></p><h3 id="物理系统中的destruction">11.4.4 物理系统中的Destruction</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728170049396.png" alt="image-20230728170049396" style="zoom:80%;" /></p><h3 id="破坏后的回调函数">11.4.5 破坏后的回调函数</h3><p>在破坏后，要提供一些回调函数，供上层开发者选择是否播放特效、音效或者其他效果</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728170236962.png" alt="image-20230728170236962" style="zoom:80%;" /></p><h3 id="destruction产生的问题">11.4.6 Destruction产生的问题</h3><p>一个物体碎成很多个碎片后，会产生大量的独立物体，它们之间会产生大量碰撞</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728170458842.png" alt="image-20230728170458842" style="zoom:80%;" /></p><h2 id="载具模拟">11.5 载具模拟</h2><h3 id="载具结构建模">11.5.1 载具结构建模</h3><ol type="1"><li>通过rigid body模拟车身</li><li>轮子是弹簧，但是也会与地面产生碰撞</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728170843037.png" alt="image-20230728170843037" style="zoom:80%;" /></p><h3 id="驱动力">11.5.2 驱动力</h3><ol type="1"><li>由引擎<code>engine</code>产生扭矩<code>torque</code></li><li>经过变速箱<code>gear</code>和差分器<code>differential</code>，将扭矩差分到各个轮子上，转化为轮子真实的扭矩<code>drive torque</code></li><li>轮子的扭矩与地面作用，产生向前的驱动力（静摩擦力）</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728171110327.png" alt="image-20230728171110327" style="zoom:80%;" /></p><h3 id="悬挂力">11.5.3 悬挂力</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728171942668.png" alt="image-20230728171942668" style="zoom:80%;" /></p><h3 id="轮胎力">11.5.4 轮胎力</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728172101716.png" alt="image-20230728172101716" style="zoom:80%;" /></p><h3 id="重心">11.5.5 重心</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728172246993.png" alt="image-20230728172246993" style="zoom:80%;" /></p><p>重心会对汽车在空中的稳定性产生影响：</p><ol type="1"><li>重心靠前，容易翻滚</li><li>重心靠后，更加稳定</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728172332009.png" alt="image-20230728172332009" style="zoom:80%;" /></p><p>重心会对转向的驱动力产生影响</p><ol type="1"><li>重心靠前：转向力更低</li><li>重心靠后：更容易转向</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728172342905.png" alt="image-20230728172342905" style="zoom:80%;" /></p><h3 id="重心的变化">11.5.6 重心的变化</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728172602276.png" alt="image-20230728172602276" style="zoom:80%;" /></p><h3 id="转向角">11.5.7 转向角</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728172721719.png" alt="image-20230728172721719" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728172820162.png" alt="image-20230728172820162" style="zoom:80%;" /></p><h3 id="advanced-wheel-contact">11.5.8 Advanced Wheel Contact</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728172913874.png" alt="image-20230728172913874" style="zoom:80%;" /></p><h2 id="pbdxpbd">11.6 PBD/XPBD</h2><p>拉格朗日力学：用约束反向推导运动</p><h3 id="约束示例">11.6.1 约束示例</h3><p>圆周运动约束：始终绕着原点，半径一定的运动</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728173629506.png" alt="image-20230728173629506" style="zoom:80%;" /></p><p>弹簧约束</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728173738433.png" alt="image-20230728173738433" style="zoom:80%;" /></p><h3 id="pbd">11.6.2 PBD</h3><p>雅可比矩阵的作用：计算从某个状态转移到另一个状态时，每个变量的变化趋势</p><p>PBD：将任务表达为一系列关于位置的约束，通过雅可比矩阵，计算在当前位置应该向哪个方向扰动，每次只扰动一点点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728174607551.png" alt="image-20230728174607551" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728174701030.png" alt="image-20230728174701030" style="zoom:80%;" /></p><p>每一步里面：</p><ol type="1"><li>首先把所有v放进去，计算半隐式积分</li><li>判断是否由碰撞，如果有碰撞，相当于添加了一个约束</li><li>用刚才的方法，每一次按照λ步长进行迭代，直到误差较小</li><li>从而得到当前帧每个顶点的位置、速度</li><li>为速度添加一个damping，让PBD的计算更加稳定</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728174754116.png" alt="image-20230728174754116" style="zoom:80%;" /></p><p>优点：稳定、收敛快</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728175255932.png" alt="image-20230728175255932" style="zoom:80%;" /></p><h3 id="xpbd">11.6.3 XPBD</h3><ol type="1"><li>给约束添加stiffness，表示约束的权重</li><li>将约束矩阵<spanclass="math inline">\(C(X)\)</span>变为了服从度矩阵<spanclass="math inline">\(U(X)\)</span><ol type="1"><li>类似于弹簧的势能，要求总体的势能最小</li><li>可以对不同约束设计不同的stiffness，在一个方程中求解</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728175316018.png" alt="image-20230728175316018" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-10：物理：基础理论和算法</title>
      <link href="/2023/07/10/GAMES104/10--%E7%89%A9%E7%90%86%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/10/GAMES104/10--%E7%89%A9%E7%90%86%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十物理基础理论和算法">十、物理：基础理论和算法</h1><h2 id="物理对象与形状">10.1 物理对象与形状</h2><h3 id="actor">10.1.1 Actor</h3><ol type="1"><li>static actor：静态物体，不移动，不用解算</li><li>dynamic actor：动态物体，每一帧都需要计算其状态</li><li>trigger：触发器，和物理世界没有关系</li><li>kinematic actor：运动学物体，无视物理规则，直接由游戏逻辑控制</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727110520872.png" alt="image-20230727110520872" style="zoom:80%;" /></p><h3 id="actor-shapes">10.1.2 Actor Shapes</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727110718269.png" alt="image-20230727110718269" style="zoom:80%;" /></p><h3 id="shape属性">10.1.3 Shape属性</h3><p>质量 Mass &amp; 密度 Density</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727111612952.png" alt="image-20230727111612952" style="zoom:80%;" /></p><p>质心 Center of Mass</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727111727898.png" alt="image-20230727111727898" style="zoom:80%;" /></p><p>物理材质：摩擦系数 Friction、弹性系数 Restitution</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727111749362.png" alt="image-20230727111749362" style="zoom:80%;" /></p><h2 id="力与运动">10.2 力与运动</h2><h3 id="力的种类">10.2.1 力的种类</h3><p>Force：有一定持续时间的力，如重力、拉力、摩擦力</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727114748641.png" alt="image-20230727114748641" style="zoom:80%;" /></p><p>Impulse：冲量</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727114857546.png" alt="image-20230727114857546" style="zoom:80%;" /></p><h3 id="移动">10.2.2 移动</h3><p>显式欧拉法：用当前的力&amp;速度计算位移</p><ol type="1"><li>优点：容易计算</li><li>缺点：能量不守恒</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727143630198.png" alt="image-20230727143630198" style="zoom:80%;" /></p><p>隐式欧拉法：用未来的力&amp;速度计算位移</p><ol type="1"><li>优点：能量会衰减，从而保证计算是稳定的，衰减很小时可以被视为转化为热能</li><li>缺点：如果力是取决于位置的，那么在位置不确定的情况下，无法知道未来的力</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727143510570.png" alt="image-20230727143510570" style="zoom:80%;" /></p><p>半隐式欧拉法：用当前的力、未来的速度计算位移</p><ol type="1"><li>优点：更加稳定，并且容易计算</li><li>缺点：积分出来的周期会比实际的周期长一点，导致有一定的相位差</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727144235099.png" alt="image-20230727144235099" style="zoom:80%;" /></p><h2 id="刚体动力学">10.3 刚体动力学</h2><h3 id="质点动力学">10.3.1 质点动力学</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727144551982.png" alt="image-20230727144551982" style="zoom:80%;" /></p><h3 id="基础概念">10.3.2 基础概念</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727144854761.png" alt="image-20230727144854761" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727145512765.png" alt="image-20230727145512765" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727145535306.png" alt="image-20230727145535306" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727145737642.png" alt="image-20230727145737642" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727145758977.png" alt="image-20230727145758977" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727150006906.png" alt="image-20230727150006906" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727150041602.png" alt="image-20230727150041602" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727150231290.png" alt="image-20230727150231290" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727150318355.png" alt="image-20230727150318355" style="zoom:80%;" /></p><h2 id="碰撞检测">10.4 碰撞检测</h2><h3 id="两个阶段">10.4.1 两个阶段</h3><ol type="1"><li>Broad Phase：使用AABB包围盒，快速筛除一些不会碰撞的物体</li><li>Narrow Phase：精确判断是否能够碰撞，生成碰撞信息</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151246689.png" alt="image-20230727151246689" style="zoom:80%;" /></p><h3 id="broad-phase">10.4.2 Broad Phase</h3><h4 id="bvh树">10.4.2.1 BVH树</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151333377.png" alt="image-20230727151333377" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151359255.png" alt="image-20230727151359255" style="zoom:80%;" /></p><h4 id="sort-and-sweep">10.4.2.2 Sort and Sweep</h4><p>对于AABB包围盒来说：</p><ol type="1"><li>将每个包围盒按照x轴上的两个边界排序</li><li>如果在轴上分离，则一定无法碰撞</li><li>如果在轴上交错，则可能碰撞，此时计算y轴是否交错</li><li>只有两个轴上都交错，才会碰撞</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151415157.png" alt="image-20230727151415157" style="zoom:80%;" /></p><p>更新时：</p><ol type="1"><li>相当于在一个已经排好序的数组中，更新某个数的位置，效率很高</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151708077.png" alt="image-20230727151708077" style="zoom:80%;" /></p><h3 id="narrow-phase">10.4.3 Narrow Phase</h3><ol type="1"><li>准确检测碰撞</li><li>生成碰撞信息<ol type="1"><li>碰撞采样：生成碰撞点的集合</li><li>碰撞法线</li><li>穿透深度</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727171236961.png" alt="image-20230727171236961" style="zoom:80%;" /></p><h4 id="基础图形碰撞检测">10.4.3.1 基础图形碰撞检测</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727172955545.png" alt="image-20230727172955545" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727173031040.png" alt="image-20230727173031040" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727175222136.png" alt="image-20230727175222136" style="zoom:80%;" /></p><h4 id="minkowski算法">10.4.3.2 Minkowski算法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727175329180.png" alt="image-20230727175329180" style="zoom:80%;" /></p><h5 id="minkowski和">10.4.3.2.1 Minkowski和</h5><ol type="1"><li>A为一个点：相当于B加上了A的位移</li><li>A为线段：相当于B加上A的位移后，沿A的方向和长度整体移动</li><li>A为三角形：相当于B加上A的位移后，沿A的轮廓整体移动</li><li>两个凸包的闵可夫和 = 对应顶点的闵可夫和</li></ol><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728104958801.png" alt="image-20230728104958801" style="zoom:50%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728105035389.png" alt="image-20230728105035389" style="zoom:50%;" /></th><th><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728105050063.png" alt="image-20230728105050063" style="zoom:50%;" /></th><th><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728105104420.png" alt="image-20230728105104420" style="zoom:50%;" /></th></tr></thead><tbody></tbody></table><h5 id="minkowski差">10.4.3.2.2 Minkowski差</h5><ol type="1"><li>将被减数变为它的负数，转化为Minkowski和</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728102422657.png" alt="image-20230728102422657" style="zoom:80%;" /></p><h5 id="minkowski差-原点">10.4.3.2.3 Minkowski差 &amp; 原点</h5><ol type="1"><li>如果两个凸包有交点，那么Minkowski差一定包含原点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728102534497.png" alt="image-20230728102534497" style="zoom:80%;" /></p><h5 id="gjk算法">10.4.3.2.4 GJK算法</h5><ol type="1"><li>随机选取一个方向，在该方向的两端找到沿该方向最远的两个点AB，这两个点相减一定是结果的一个顶点C</li><li>以OC为新的方向，再选择两个点相减，得到顶点D</li><li>以CD的垂线方向，选择两个点相减，得到顶点E</li><li>判断原点是否在三角形CDE中<ol type="1"><li>如果在，则说明凸包包含原点</li><li>如果不在，则以离原点最远的那条边的垂线方向，选择两个点相减，得到顶点F，判断原点是否在三角形DEF中</li><li>以此类推，直到无法找到新的凸包中的顶点</li></ol></li></ol><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728104002566.png" alt="image-20230728104002566" style="zoom:50%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728103858070.png" alt="image-20230728103858070" style="zoom: 50%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728104026849.png" alt="image-20230728104026849" style="zoom:50%;" /></th></tr></thead><tbody></tbody></table><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728104350214.png" alt="image-20230728104350214" style="zoom:50%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728104507055.png" alt="image-20230728104507055" style="zoom:50%;" /></th></tr></thead><tbody></tbody></table><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728104616148.png" alt="image-20230728104616148" style="zoom:50%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728104640817.png" alt="image-20230728104640817" style="zoom:50%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728104701180.png" alt="image-20230728104701180" style="zoom: 50%;" /></th></tr></thead><tbody></tbody></table><h4 id="分离轴定理-satseparating-axis-theorem">10.4.3.3 分离轴定理SAT：Separating Axis Theorem</h4><ol type="1"><li>空间中的任意两个不相交的凸多面体，一定能找到一根轴，使得：两个凸多面体在该轴上的投影不会有交集</li><li>空间中的任意两个不相交的凸多面体，以其中一个多面体的一条边为轴，能够将这两个凸多面体分离</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728105434748.png" alt="image-20230728105434748" style="zoom:80%;" /></p><p>检测算法：</p><ol type="1"><li>以A的每一条边的垂线为轴，检测B的每个顶点是否在A的另一侧</li><li>以B的每一条边的垂线为轴，检测A的每个顶点是否在A的另一侧</li><li>只要有一条边满足要求，那么两者就是分离的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728110008864.png" alt="image-20230728110008864" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728110034047.png" alt="image-20230728110034047" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728111432807.png" alt="image-20230728111432807" style="zoom:80%;" /></p><p>3D中的延申：</p><ol type="1"><li>要检测A中的每一个面、B中的每一个面</li><li>还需要检测A中的每一条边与B中的每一条边的叉积形成的平面</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728111731191.png" alt="image-20230728111731191" style="zoom:80%;" /></p><p>对于运动中的物体：</p><ol type="1"><li>上一次得到的分离轴，是下一次检测的第一个轴</li></ol><h2 id="碰撞解决">10.5 碰撞解决</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728111957590.png" alt="image-20230728111957590" style="zoom:80%;" /></p><h3 id="添加一个penalty-force">10.5.1 添加一个Penalty Force</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728112049397.png" alt="image-20230728112049397" style="zoom:80%;" /></p><h3 id="将力学问题转化为约束问题">10.5.2 将力学问题转化为约束问题</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728112126815.png" alt="image-20230728112126815" style="zoom:80%;" /></p><ol type="1"><li>碰撞时，给物体一个小冲量，然后求解拉格朗日约束</li><li>如果不满足约束，则调整冲量，不断迭代，直到满足约束</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728112234729.png" alt="image-20230728112234729" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728112321997.png" alt="image-20230728112321997" style="zoom:80%;" /></p><h2 id="场景请求">10.6 场景请求</h2><h3 id="ray-cast">10.6.1 Ray Cast</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728112543030.png" alt="image-20230728112543030" style="zoom:80%;" /></p><ol type="1"><li>Mutiple hits：返回所有碰撞结果</li><li>Closest hit：返回最近的碰撞结果</li><li>Any hit：随机返回一个碰撞结果</li></ol><h3 id="sweep">10.6.2 Sweep</h3><p>整个物体的横扫</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728112728897.png" alt="image-20230728112728897" style="zoom:80%;" /></p><h3 id="overlap">10.6.3 Overlap</h3><p>判断一个形体是否与其他Actor碰撞</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728112752743.png" alt="image-20230728112752743" style="zoom:80%;" /></p><h3 id="碰撞分组">10.6.4 碰撞分组</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728112850790.png" alt="image-20230728112850790" style="zoom:80%;" /></p><h2 id="效率准确性确定性">10.7 效率、准确性、确定性</h2><h3 id="island">10.7.1 Island</h3><p>将整个物理世界分为不同island</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728113001390.png" alt="image-20230728113001390" style="zoom:80%;" /></p><p>如果某个island稳定下来了，那么就会进入sleeping状态</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728113016423.png" alt="image-20230728113016423" style="zoom:80%;" /></p><h3 id="ccdcontinuous-collision-detection-持续碰撞检测">10.7.2CCD：Continuous Collision Detection 持续碰撞检测</h3><p>当物体移动过快时，可能会出现上一帧没碰撞，下一帧直接穿过的问题</p><ol type="1"><li>可以将地面做厚</li><li>进行CCD：保守估计一个安全步长，当距离过近时，需要减小步长</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728113157251.png" alt="image-20230728113157251" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728113223229.png" alt="image-20230728113223229" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728113337301.png" alt="image-20230728113337301" style="zoom:80%;" /></p><h3 id="确定性模拟">10.7.3 确定性模拟</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728113505626.png" alt="image-20230728113505626" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230728113713014.png" alt="image-20230728113713014" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-09：动画：动画树、IK、表情动画</title>
      <link href="/2023/07/09/GAMES104/09--%E5%8A%A8%E7%94%BB%EF%BC%9A%E5%8A%A8%E7%94%BB%E6%A0%91%E3%80%81IK%E3%80%81%E8%A1%A8%E6%83%85%E5%8A%A8%E7%94%BB/"/>
      <url>/2023/07/09/GAMES104/09--%E5%8A%A8%E7%94%BB%EF%BC%9A%E5%8A%A8%E7%94%BB%E6%A0%91%E3%80%81IK%E3%80%81%E8%A1%A8%E6%83%85%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="九动画动画树ik表情动画">九、动画：动画树、IK、表情动画</h1><h2 id="动画混合lerp">9.1 动画混合：LERP</h2><p>在不同动画内，各取一帧，进行插值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726161349832.png" alt="image-20230726161349832" style="zoom:80%;" /></p><h3 id="计算混合权重">9.1.1 计算混合权重</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726161520179.png" alt="image-20230726161520179" style="zoom:80%;" /></p><h3 id="对齐混合时间线">9.1.2 对齐混合时间线</h3><ol type="1"><li>将动画的时间归一化<ol type="1"><li>对于走和跑的两个动画，保证：0-没有动，0.25-抬左脚，0.5-放左脚，0.75-抬右脚，1.0-放右脚</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726161637220.png" alt="image-20230726161637220" style="zoom:80%;" /></p><h2 id="混合空间">9.2 混合空间</h2><h3 id="d混合空间">9.2.1 1D混合空间</h3><ol type="1"><li>可以有多个动画，通过一个变量进行混合</li><li>并且动画切换的密度也不一定是均匀的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726162032131.png" alt="image-20230726162032131" style="zoom:80%;" /></p><h3 id="d混合空间-1">9.2.2 2D混合空间</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726162328115.png" alt="image-20230726162328115" style="zoom:80%;" /></p><ol type="1"><li>Delaunay三角化：根据给定的多个顶点，生成空间的三角形划分</li><li>根据速度&amp;方向两个值，确定二维空间上的唯一点，选择临近的三个动画，通过重心坐标的方法进行插值</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726162413212.png" alt="image-20230726162413212" style="zoom:80%;" /></p><h3 id="skeleton-masked-blending">9.2.3 Skeleton Masked Blending</h3><p>通过mask，控制动画影响的关节</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726162907137.png" alt="image-20230726162907137" style="zoom:80%;" /></p><h3 id="additive-blending">9.2.4 Additive Blending</h3><p>动画只影响局部关节，且只保留变化量，在原有骨骼之上添加额外的transform</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726163020077.png" alt="image-20230726163020077" style="zoom:80%;" /></p><p>叠加动画可能回调导致非正常的骨骼结果</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726163239755.png" alt="image-20230726163239755" style="zoom:80%;" /></p><h2 id="动画状态机-asm-animation-state-machine">9.3 动画状态机 ASMAnimation State Machine</h2><h3 id="asm的定义">9.3.1 ASM的定义</h3><p>ASM的节点：</p><ol type="1"><li>可以是一个动画，也可以是混合空间，还可以是动画树</li><li>要求节点的产出必须是一个pose</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726163706843.png" alt="image-20230726163706843" style="zoom:80%;" /></p><p>状态过渡：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726163926818.png" alt="image-20230726163926818" style="zoom:80%;" /></p><p>状态过渡时的Fade：</p><ol type="1"><li>Smooth Transition：两个动画进行插值</li><li>Frozen Transition：上一个动画停止，下一个动画逐步进入</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164019587.png" alt="image-20230726164019587" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164219218.png" alt="image-20230726164219218" style="zoom:80%;" /></p><h3 id="layered-asm">9.3.2 Layered ASM</h3><p>分为不同层，控制角色的不同部分</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164525801.png" alt="image-20230726164525801" style="zoom:80%;" /></p><h2 id="动画混合树">9.4 动画混合树</h2><h3 id="混合树">9.4.1 混合树</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164757665.png" alt="image-20230726164757665" style="zoom:80%;" /></p><h3 id="混合节点">9.4.2 混合节点</h3><h4 id="lerp混合节点">9.4.2.1 LERP混合节点</h4><p>二通道插值：一个权重，控制两者比例</p><p>多通道插值：通常需要自己定义动画各自的比例</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164820353.png" alt="image-20230726164820353" style="zoom:80%;" /></p><h4 id="additive混合节点">9.4.2.2 Additive混合节点</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164944591.png" alt="image-20230726164944591" style="zoom:80%;" /></p><h4 id="混合树节点">9.4.2.3 混合树节点</h4><p>叶节点：动画、混合空间、动画状态机</p><p>中间节点：LERP混合节点、Additive混合节点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726165138287.png" alt="image-20230726165138287" style="zoom:80%;" /></p><h3 id="混合树控制参数">9.4.3 混合树控制参数</h3><ol type="1"><li>混合树上要暴露大量的控制参数，由GamePlay控制不同节点的混合、状态机</li><li>可以通过事件控制参数的改变</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726165450780.png" alt="image-20230726165450780" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726165816283.png" alt="image-20230726165816283" style="zoom:80%;" /></p><h2 id="ik技术">9.5 IK技术</h2><h3 id="基本概念">9.5.1 基本概念</h3><p>End-Effector：希望被移动到目标位置的末端关节</p><p>IK：给定end-effecto的期望位置，反向求解骨骼的变换</p><p>FK：给定骨骼的变化，计算end-effector的位置</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726170138434.png" alt="image-20230726170138434" style="zoom:80%;" /></p><h3 id="two-bones-ik">9.5.2 Two Bones IK</h3><ol type="1"><li>大腿和小腿两根骨头 =&gt; 三角形的两条边</li><li>脚的位置/地面的位置 =&gt; 目标点</li><li>大腿根部到目标点的距离 =&gt; 三角形的第三条边</li></ol><p>根据三角形的三条边边长，可以唯一确定一个三角形，从而求解出大腿、小腿各自的旋转</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726170422401.png" alt="image-20230726170422401" style="zoom:80%;" /></p><p>上述算法解出的实际上是一个圆环</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726170647922.png" alt="image-20230726170647922" style="zoom:80%;" /></p><p>通过额外给定一个reference vector，确定是圆环上的哪个点</p><ol type="1"><li>通过reference vector、大腿和目标点的连线，确定一个平面</li><li>平面与圆环求交，得到两个交点</li><li>通过向量点乘，确定哪个点是正向的，哪个点是反向的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726170731090.png" alt="image-20230726170731090" style="zoom:80%;" /></p><h3 id="多关节ik计算">9.5.3 多关节IK计算</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726171113977.png" alt="image-20230726171113977" style="zoom:80%;" /></p><h4 id="可达性判断">9.5.3.1 可达性判断</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726171154553.png" alt="image-20230726171154553" style="zoom:80%;" /></p><h4 id="关节约束">9.5.3.2 关节约束</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726171245185.png" alt="image-20230726171245185" style="zoom:80%;" /></p><h4 id="ccdcyclic-coordinate-decent">9.5.3.3 CCD：Cyclic CoordinateDecent</h4><ol type="1"><li>将最末端的关节，向上一个关节与目标点的连线方向旋转，逐步旋转所有关节</li><li>重复上述步骤，直到每一次旋转几乎不变</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726171715760.png" alt="image-20230726171715760" style="zoom:80%;" /></p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172025542.png" alt="image-20230726172025542" style="zoom: 50%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172049462.png" alt="image-20230726172049462" style="zoom:50%;" /></th></tr></thead><tbody></tbody></table><h4 id="优化ccd">9.5.3.4 优化CCD</h4><ol type="1"><li>旋转时不需要要求骨骼一定要到达目标位置，只需要到达一个范围即可 or设置旋转角度上限</li><li>每次迭代逐渐缩小范围</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172307179.png" alt="image-20230726172307179" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172453544.png" alt="image-20230726172453544" style="zoom:80%;" /></p><h4 id="fabrikforward-and-backward-reaching-ik">9.5.3.5 FABRIK：ForwardAnd Backward Reaching IK</h4><p>Forward：</p><ol type="1"><li>从End-Effector开始，把第一个关节强行拉到目标点</li><li>根据上一个关节点的原有位置，与当前关节点连一条线，将骨骼旋转到连线上</li><li>骨骼的另一端即为下一个关键点的目标位置</li><li>重复上述步骤，直到根节点为止</li><li>此时会由于凑关键点位置，导致根节点移动，需要通过Backward解决</li></ol><p>Backward：</p><ol type="1"><li>从根节点开始，将根节点拉回到原点</li><li>依次移动对应骨骼和另一端的关节点，直到拉到End-Effector</li></ol><p>重复Forward和Backward，直到End-Effector非常接近目标点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172950697.png" alt="image-20230726172950697" style="zoom:80%;" /></p><p>骨骼约束：将目标点投影到约束的平面，得到新的目标点，然后再移动骨骼</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726173401688.png" alt="image-20230726173401688" style="zoom:80%;" /></p><h3 id="多end-effectors">9.5.4 多End-Effectors</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726173555467.png" alt="image-20230726173555467" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726173636640.png" alt="image-20230726173636640" style="zoom:80%;" /></p><h4 id="jacobian-matrix">9.5.4.1 Jacobian Matrix</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726173727183.png" alt="image-20230726173727183" style="zoom:80%;" /></p><p>通过雅可比矩阵，逐步逼近目标点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726174159735.png" alt="image-20230726174159735" style="zoom:80%;" /></p><h3 id="其他ik解法">9.5.5 其他IK解法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726174332161.png" alt="image-20230726174332161" style="zoom:80%;" /></p><h3 id="ik的问题">9.5.6 IK的问题</h3><ol type="1"><li>IK会认为骨骼是没有体积的，从而导致解出的骨骼由穿插</li><li>IK无法预测环境</li><li>IK解出的解不考虑平衡重心等问题</li></ol><h3 id="添加ik之后的动画pipeline">9.5.7 添加IK之后的动画Pipeline</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726174830356.png" alt="image-20230726174830356" style="zoom:80%;" /></p><h2 id="面部动画">9.6 面部动画</h2><h3 id="表情由复杂的肌肉系统驱动">9.6.1 表情由复杂的肌肉系统驱动</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175017486.png" alt="image-20230726175017486" style="zoom:80%;" /></p><h3 id="面部动作编码系统-facs">9.6.2 面部动作编码系统 FACS</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175211494.png" alt="image-20230726175211494" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175311165.png" alt="image-20230726175311165" style="zoom:80%;" /></p><h3 id="个核心au">9.6.3 28个核心AU</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175719857.png" alt="image-20230726175719857" style="zoom:80%;" /></p><h3 id="关键姿势混合">9.6.4 关键姿势混合</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175742143.png" alt="image-20230726175742143" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175818590.png" alt="image-20230726175818590" style="zoom:80%;" /></p><p>实际存储的是某一个表情对应中性表情的offset</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175907342.png" alt="image-20230726175907342" style="zoom:80%;" /></p><h3 id="uv-texture-facial-animation">9.6.5 UV Texture FacialAnimation</h3><p>用纹理表达面部表情</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727100531316.png" alt="image-20230727100531316" style="zoom:80%;" /></p><h3 id="muscle-model-animation">9.6.6 Muscle Model Animation</h3><p>通过46个实际肌肉控制面部运动</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727100640384.png" alt="image-20230727100640384" style="zoom:80%;" /></p><h2 id="动画重定向">9.7 动画重定向</h2><h3 id="相关术语-terminology">9.7.1 相关术语 Terminology</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101019327.png" alt="image-20230727101019327" style="zoom:80%;" /></p><h3 id="重定向的方法">9.7.2 重定向的方法</h3><ol type="1"><li><p>骨骼一根对一根，忽略位移项</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101219102.png" alt="image-20230727101219102" style="zoom:80%;" /></p></li><li><p>应用每一帧相对binding pose的位移，而不是绝对值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101307534.png" alt="image-20230727101307534" style="zoom:80%;" /></p></li><li><p>把source character的</p><ol type="1"><li>旋转动画：直接应用到target character上</li><li>平移动画：考虑骨骼的相对长度，等比例放缩</li><li>缩放动画：直接应用到target character上</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101506030.png" alt="image-20230727101506030" style="zoom:80%;" /></p></li><li><p>通过Pelvis高度对齐运动</p><ol type="1"><li>通过最初的腰眼离地的距离，等比例缩放运动速度</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101720649.png" alt="image-20230727101720649" style="zoom:80%;" /></p></li><li><p>重定向之后，通过IK将脚锁死在地上</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101938145.png" alt="image-20230727101938145" style="zoom:80%;" /></p></li><li><p>通常是使用离线算法，进行重定向的计算</p></li></ol><h3 id="不同骨骼结构之间的重定向">9.7.3 不同骨骼结构之间的重定向</h3><ol type="1"><li>找到不同骨骼结构之间，对应的骨骼</li><li>将骨骼归一化到[0, 1]之间，然后进行插值</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727102206721.png" alt="image-20230727102206721" style="zoom:80%;" /></p><h3 id="未解决的问题">9.7.4 未解决的问题</h3><ol type="1"><li>骨骼穿插问题</li><li>由于骨骼大小不一样，导致的效果不佳，如鼓掌等语义动作</li><li>目标角色的平衡</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727102448557.png" alt="image-20230727102448557" style="zoom:80%;" /></p><h3 id="morph-animation重定向">9.7.5 Morph Animation重定向</h3><ol type="1"><li>不同face使用相同的拓扑结构</li><li>存储顶点的相对位移</li><li>应用重定向后，强制将某些顶点移动到目标位置，然后用拉普拉斯算子计算剩下的顶点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727102755696.png" alt="image-20230727102755696" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727102852037.png" alt="image-20230727102852037" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-08：动画：动画技术基础</title>
      <link href="/2023/07/08/GAMES104/08--%E5%8A%A8%E7%94%BB%EF%BC%9A%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/08/GAMES104/08--%E5%8A%A8%E7%94%BB%EF%BC%9A%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="八动画动画技术基础">八、动画：动画技术基础</h1><h2 id="d游戏动画技术">8.1 2D游戏动画技术</h2><h3 id="sprite-animation">8.1.1 Sprite Animation</h3><p>记录每一帧的动作，循环播放</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725172639259.png" alt="image-20230725172639259" style="zoom:80%;" /></p><p>在不同视角采样一系列的动作，根据当前视角播放不同动画</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173034724.png" alt="image-20230725173034724" style="zoom:80%;" /></p><p>现代游戏引擎中，粒子效果就是Sprite Animation</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173149954.png" alt="image-20230725173149954" style="zoom:80%;" /></p><h3 id="live2d">8.1.2 Live2D</h3><p>将一个角色的所有元素，变成一个个小图元，通过变换图元，组成人物的不同姿态</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173218195.png" alt="image-20230725173218195" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173430996.png" alt="image-20230725173430996" style="zoom:80%;" /></p><ol type="1"><li><p>首先，定义不同图元的深度，以控制图元是否出现，不同图元之间的层次关系</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173813825.png" alt="image-20230725173813825" style="zoom:80%;" /></p></li><li><p>然后，生成ArtMesh，通过拖动ArtMesh上的控制点，控制图元的变化</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173852827.png" alt="image-20230725173852827" style="zoom:80%;" /></p></li><li><p>设置动画关键帧，从而进行动画插值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173944369.png" alt="image-20230725173944369" style="zoom:80%;" /></p></li></ol><h2 id="d游戏动画技术-1">8.2 3D游戏动画技术</h2><h3 id="dofdegress-of-freedom-自由度">8.2.1 DoF：Degress of Freedom自由度</h3><p>一个物体可以在多少个维度进行变化</p><ol type="1"><li>刚体：6个自由度，平移3个，旋转3个</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725174149918.png" alt="image-20230725174149918" style="zoom:80%;" /></p><h3 id="rigid-hierarchical-animation">8.2.2 Rigid HierarchicalAnimation</h3><ol type="1"><li>将mesh分为层次化的多个可以变化的刚体，动画即是改变这些刚体的平移/旋转</li><li>缺点：不同关节之间可能会穿插</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725174416495.png" alt="image-20230725174416495" style="zoom:80%;" /></p><h3 id="per-vertex-animation-顶点动画">8.2.3 Per-vertex Animation顶点动画</h3><p>顶点动画：</p><ol type="1"><li>记录每个顶点的位置随时间的变化</li><li>一般存两个texture，一个texture记录顶点的位置，另一个记录顶点的法向</li><li>通常是用物理引擎离线计算好，然后存到texture中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725174558034.png" alt="image-20230725174558034" style="zoom:80%;" /></p><h3 id="morph-target-animation">8.2.4 Morph Target Animation</h3><ol type="1"><li>也是一种顶点动画，但是记录的是顶点影响权重</li><li>存储多个Key Poses，然后在Key Poses之间进行插值</li><li>在捏脸系统中更好用</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725174900318.png" alt="image-20230725174900318" style="zoom:80%;" /></p><h3 id="skinned-animation-蒙皮动画">8.2.5 Skinned Animation蒙皮动画</h3><p>刚体骨骼驱动外表的蒙皮进行动画，每个顶点由多个骨骼同时影响</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725175213453.png" alt="image-20230725175213453" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725175347643.png" alt="image-20230725175347643" style="zoom:80%;" /></p><h3 id="physics-based-animation">8.2.6 Physics-based Animation</h3><ol type="1"><li>布娃娃系统</li><li>衣料、流体模拟</li><li>IK反向动力学</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725175428162.png" alt="image-20230725175428162" style="zoom:80%;" /></p><h3 id="animation-content-creation">8.2.7 Animation ContentCreation</h3><ol type="1"><li>动画师设置关键帧</li><li>动捕</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725175649795.png" alt="image-20230725175649795" style="zoom:80%;" /></p><h2 id="蒙皮动画的实现">8.3 蒙皮动画的实现</h2><h3 id="如何让mesh播放动画">8.3.1 如何让Mesh播放动画</h3><ol type="1"><li>创建mesh的binding pose</li><li>创建binding skeleton</li><li>刷上蒙皮，告诉每个顶点应该受到哪些骨骼的影响</li><li>移动skeleton</li><li>蒙皮上的顶点会跟着运动</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726102514399.png" alt="image-20230726102514399" style="zoom:80%;" /></p><h3 id="不同的空间">8.3.2 不同的空间</h3><ol type="1"><li>世界空间：全局坐标系</li><li>模型空间：以角色为中心，相对世界空间有平移&amp;旋转</li><li>局部空间：每根骨骼的坐标系，每根骨骼都不相同，需要逐步累加进来</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726102748726.png" alt="image-20230726102748726" style="zoom:80%;" /></p><h3 id="两种骨骼">8.3.3 两种骨骼</h3><p>Humanoid Skeleton：两足动物的骨骼</p><ol type="1"><li>起点在人的胯部：Pelvis</li><li>有时会在Pelvis之上添加一个root</li></ol><p>Non-humanoid Skeleton：四足动物的骨骼</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726103147477.png" alt="image-20230726103147477" style="zoom:80%;" /></p><h3 id="骨骼-bone-关节-joint">8.3.4 骨骼 Bone &amp; 关节 Joint</h3><ol type="1"><li>在引擎中，存储的是关节的信息</li><li>相邻两个关节定义一个骨骼</li><li>joint是严格的刚体，无法被扭曲；而bone是可以扭曲的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726103450456.png" alt="image-20230726103450456" style="zoom:80%;" /></p><h3 id="游戏中的关节">8.3.5 游戏中的关节</h3><ol type="1"><li>通常会添加一些额外的骨骼，用于控制角色的面部表情、衣物等附加物</li><li>武器、骑乘等都会有对应的关节，用于绑定外部物品</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726103902491.png" alt="image-20230726103902491" style="zoom:80%;" /></p><h3 id="根骨骼">8.3.6 根骨骼</h3><ol type="1"><li>通常会放置于两脚之间，便于表示离地高度、移速等属性</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104007356.png" alt="image-20230726104007356" style="zoom:80%;" /></p><ol type="1"><li>四足动物的Pelvis在尾椎处，而root在肚子下四足中心</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104125333.png" alt="image-20230726104125333" style="zoom:80%;" /></p><h3 id="绑定动画">8.3.7 绑定动画</h3><ol type="1"><li>当人物骑乘在马身上时，两者的bind point就会绑定到一起<ol type="1"><li>不仅仅是位置的绑定，还有旋转的绑定</li></ol></li><li>两者分别播放自己的动画</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104219332.png" alt="image-20230726104219332" style="zoom:80%;" /></p><h3 id="绑定姿势t-pose-vs-a-pose">8.3.8 绑定姿势：T-pose vs A-pose</h3><p>T-pose：肩胛处的骨骼是压缩的，精度不够</p><p>A-pose：人相对自然的站在那里，肩胛处的精度会更高</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104519860.png" alt="image-20230726104519860" style="zoom:80%;" /></p><h3 id="骨骼姿势">8.3.9 骨骼姿势</h3><p>关节姿势有9个自由度：平移、旋转、缩放</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104647937.png" alt="image-20230726104647937" style="zoom:80%;" /></p><h2 id="d旋转的数学原理">8.4 3D旋转的数学原理</h2><h3 id="d空间的旋转">8.4.1 2D空间的旋转</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104902602.png" alt="image-20230726104902602" style="zoom:80%;" /></p><h3 id="d空间的旋转欧拉角">8.4.2 3D空间的旋转：欧拉角</h3><h4 id="旋转矩阵">8.4.2.1 旋转矩阵</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105052981.png" alt="image-20230726105052981" style="zoom:80%;" /></p><h4 id="yaw-pitch-roll">8.4.2.2 Yaw &amp; Pitch &amp; Roll</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105207538.png" alt="image-20230726105207538" style="zoom:80%;" /></p><h4 id="问题欧拉角的运算是严格依赖顺序的">8.4.2.3问题：欧拉角的运算是严格依赖顺序的</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105341930.png" alt="image-20230726105341930" style="zoom:80%;" /></p><h4 id="万向锁gimbal-lock">8.4.2.4 万向锁：Gimbal lock</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105432867.png" alt="image-20230726105432867" style="zoom:80%;" /></p><h4 id="欧拉角的退化现象β90">8.4.2.5 欧拉角的退化现象：β=90°</h4><p>当β=90°时，α和γ各自都没有意义，只有α-γ有意义，此时最终的DoF变为了1</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105811316.png" alt="image-20230726105811316" style="zoom:80%;" /></p><h4 id="欧拉角的问题">8.4.2.6 欧拉角的问题</h4><ol type="1"><li>万向锁</li><li>难以插值</li><li>难以进行旋转的叠加，必须通过旋转矩阵相乘</li><li>难以进行任意轴旋转，必须将其分解为XYZ轴的旋转</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105951500.png" alt="image-20230726105951500" style="zoom:80%;" /></p><h3 id="四元数-quaternion">8.4.3 四元数 Quaternion</h3><h4 id="用复数表示2d旋转">8.4.3.1 用复数表示2D旋转</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726110321992.png" alt="image-20230726110321992" style="zoom:80%;" /></p><h4 id="四元数的定义">8.4.3.2 四元数的定义</h4><p>定义：<span class="math inline">\(q=a+bi+cj+dk \ (a,b,c,d\inR)\)</span>，其中 <spanclass="math inline">\(i^2=j^2=k^2=ijk=-1\)</span></p><p>性质：单位四元数的共轭，就是它的逆</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726115007887.png" alt="image-20230726115007887" style="zoom:80%;" /></p><h4 id="欧拉角-四元数">8.4.3.3 欧拉角 =&gt; 四元数</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726111111068.png" alt="image-20230726111111068" style="zoom:80%;" /></p><h4 id="用四元数表示旋转">8.4.3.4 用四元数表示旋转</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726114919429.png" alt="image-20230726114919429" style="zoom: 67%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726115156359.png" alt="image-20230726115156359" style="zoom: 60%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726115332722.png" alt="image-20230726115332722" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726140131693.png" alt="image-20230726140131693" style="zoom:80%;" /></p><h2 id="关节与蒙皮">8.5 关节与蒙皮</h2><h3 id="三种数据旋转平移缩放">8.5.1 三种数据：旋转、平移、缩放</h3><ol type="1"><li><p>Orientation 空间上的朝向</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726140531917.png" alt="image-20230726140531917" style="zoom:80%;" /></p></li><li><p>Position</p><ol type="1"><li>通常是不变的</li><li>但是当角色蹲下时，是通过pelvis相对于root的位置变换表示的</li><li>表情动画也会用到位置变换</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726140846380.png" alt="image-20230726140846380" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141023444.png" alt="image-20230726141023444" style="zoom:80%;" /></p></li><li><p>Scale：缩放变换</p><ol type="1"><li>通常也不会变</li><li>但是在更改角色面部关节时，可能会改变</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141049396.png" alt="image-20230726141049396" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141102714.png" alt="image-20230726141102714" style="zoom:80%;" /></p></li></ol><h2 id="affine-matrix-仿射矩阵">8.5.2 Affine Matrix 仿射矩阵</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141216420.png" alt="image-20230726141216420" style="zoom:80%;" /></p><h2 id="局部空间-模型空间">8.5.3 局部空间 =&gt; 模型空间</h2><p>对于每一个关节<span class="math inline">\(j\)</span>：</p><ol type="1"><li><span class="math inline">\(p(j)\)</span>：父关节</li><li><spanclass="math inline">\(M_{p(j)}^l\)</span>：父关节在局部空间的关节姿势</li><li><spanclass="math inline">\(M_j^m\)</span>：关节在模型空间的关节姿势</li></ol><p><span class="math display">\[M_j^m=\prod_{j=J}^0 M_{p(j)}^l\]</span></p><p>即从当前节点开始，逐步乘父节点的关节姿势，直到到达根节点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141439188.png" alt="image-20230726141439188" style="zoom:80%;" /></p><h3 id="关节姿势的插值局部空间-vs-模型空间">8.5.4关节姿势的插值：局部空间 vs 模型空间</h3><p>将动画存储在局部坐标系</p><ol type="1"><li>transform中的数据更少</li><li>更容易进行插值/混合</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141729580.png" alt="image-20230726141729580" style="zoom:80%;" /></p><h3 id="single-joint-skin">8.5.5 Single Joint Skin</h3><h4 id="顶点相对于关节的局部坐标永远不变">8.5.5.1顶点相对于关节的局部坐标永远不变</h4><p>将mesh上的一个顶点，绑定到一个骨骼上</p><ol type="1"><li>每个顶点可以绑定一个或多个关节，每个关节有不同的权重</li><li>顶点在每个绑定关节的局部空间的位置是固定的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726142238716.png" alt="image-20230726142238716" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726143414912.png" alt="image-20230726143414912" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726143513171.png" alt="image-20230726143513171" style="zoom:80%;" /></p><h4 id="skinning-matrix-palette">8.5.5.2 Skinning Matrix Palette</h4><ol type="1"><li>先计算每一个关节的Skinning Matrix，保存起来</li><li>在渲染顶点的时候，可以直接查表，不用重新计算蒙皮矩阵</li></ol><p>优化：通常会再乘上<spanclass="math inline">\(M^w\)</span>，将模型空间转化为世界空间</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726143715728.png" alt="image-20230726143715728" style="zoom:80%;" /></p><h4 id="在内存中表示一个骨骼">8.5.5.3 在内存中表示一个骨骼</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726144203453.png" alt="image-20230726144203453" style="zoom:80%;" /></p><h3 id="weighted-skinning-with-multi-joints">8.5.6 Weighted Skinningwith Multi-joints</h3><ol type="1"><li>每个mesh上的顶点会由多个关节同时作用</li><li>每个关节有不同的权重，但是要求权重和为1</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726144503596.png" alt="image-20230726144503596" style="zoom:80%;" /></p><ol type="1"><li>计算每个关节对应的顶点的模型空间坐标，在模型空间中进行混合</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726144939033.png" alt="image-20230726144939033" style="zoom:80%;" /></p><h3 id="clip">8.5.7 Clip</h3><p>将每一帧的骨骼姿势放在一个序列里面，称为一个clip</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726145536660.png" alt="image-20230726145536660" style="zoom:80%;" /></p><h3 id="在不同pose之间进行插值">8.5.8 在不同Pose之间进行插值</h3><p><strong>位移&amp;缩放 lerp</strong>：线性插值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726145711201.png" alt="image-20230726145711201" style="zoom:80%;" /></p><p><strong>旋转 Nlerp</strong>：q1和q2的线性插值，然后进行归一化</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726145736080.png" alt="image-20230726145736080" style="zoom:80%;" /></p><p><strong>最短路径插值</strong>：判断一下q1·q2，如果是&lt;0，则需要反向插值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726150409999.png" alt="image-20230726150409999" style="zoom:80%;" /></p><p><strong>Nlerp的问题</strong>：插值的角速度不恒定</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726150653720.png" alt="image-20230726150653720" style="zoom:80%;" /></p><p><strong>Slerp</strong>：通过arccos，计算两个方向的夹角，通过θ插值</p><ol type="1"><li>但是计算比较费资源</li><li>并且当角度很小时，结果不精确</li><li>通常会指定一个角度，小于它用NLERP，大于它用SLERP</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726150718402.png" alt="image-20230726150718402" style="zoom:80%;" /></p><h3 id="简单动画的runtime-pipeline">8.5.9 简单动画的RuntimePipeline</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726151230438.png" alt="image-20230726151230438" style="zoom:80%;" /></p><h2 id="动画压缩技术">8.6 动画压缩技术</h2><h3 id="减少dof">8.6.1 减少DoF</h3><ol type="1"><li><p>Scale：直接忽略</p></li><li><p>Translation：只存储最初的值</p></li><li><p>Rotation：通过关键帧进行插值</p><ol type="1"><li>以第0帧作为第一个关键帧，通过插值计算下一帧</li><li>如果误差高于某个值，则将其作为下一个关键帧</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726151745711.png" alt="image-20230726151745711" style="zoom:80%;" /></p></li><li><p>Catmull-Rom曲线：</p><ol type="1"><li>由四个控制点生成一个曲线，拟合原有的旋转曲线</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726151936487.png" alt="image-20230726151936487" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152053696.png" alt="image-20230726152053696" style="zoom:80%;" /></p></li></ol><h3 id="用定点数代替float">8.6.2 用定点数代替float</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152215646.png" alt="image-20230726152215646" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152341008.png" alt="image-20230726152341008" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152358663.png" alt="image-20230726152358663" style="zoom:80%;" /></p><h3 id="误差传播">8.6.3 误差传播</h3><p>由于关节的模型坐标是从根节点累乘得到的，因此会导致误差的累积</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152529422.png" alt="image-20230726152529422" style="zoom:80%;" /></p><p>衡量精确度：Visual Error</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152700328.png" alt="image-20230726152700328" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152726472.png" alt="image-20230726152726472" style="zoom:80%;" /></p><p>误差补偿：子骨骼对父骨骼产生的误差进行补偿</p><ol type="1"><li>缺点：父骨骼的误差叠加后，可能在子骨骼上产生高频数据，导致末端骨骼产生高频抖动</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153005119.png" alt="image-20230726153005119" style="zoom:80%;" /></p><h2 id="动画制作流程">8.7 动画制作流程</h2><ol type="1"><li><p>构建mesh，用低精度的mesh做动画</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153201327.png" alt="image-20230726153201327" style="zoom:80%;" /></p></li><li><p>在关节处添加网格，防止关节处变形</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153255760.png" alt="image-20230726153255760" style="zoom:80%;" /></p></li><li><p>骨架绑定，并添加Game Play关节（如武器关节、Pelvis、root）</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153358233.png" alt="image-20230726153358233" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153421687.png" alt="image-20230726153421687" style="zoom:80%;" /></p></li><li><p>自动计算skinning</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153522586.png" alt="image-20230726153522586" style="zoom:80%;" /></p></li><li><p>手动调整skinning</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153553479.png" alt="image-20230726153553479" style="zoom:80%;" /></p></li><li><p>制作动画：设置关键帧及时间间隔</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153629247.png" alt="image-20230726153629247" style="zoom:80%;" /></p></li><li><p>导出动画</p><ol type="1"><li>如果在动画中root产生位移，会将root的移动单独导出为一个位移曲线给引擎用</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153644960.png" alt="image-20230726153644960" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153828377.png" alt="image-20230726153828377" style="zoom:80%;" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-07：渲染：渲染管线、后处理和其他的一切</title>
      <link href="/2023/07/07/GAMES104/07--%E6%B8%B2%E6%9F%93%EF%BC%9A%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E3%80%81%E5%90%8E%E5%A4%84%E7%90%86%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E5%88%87/"/>
      <url>/2023/07/07/GAMES104/07--%E6%B8%B2%E6%9F%93%EF%BC%9A%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E3%80%81%E5%90%8E%E5%A4%84%E7%90%86%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E5%88%87/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1id="七渲染渲染管线后处理和其他的一切">七、渲染：渲染管线、后处理和其他的一切</h1><h2 id="环境光遮罩-ambient-occlusionao">7.1 环境光遮罩 AmbientOcclusion：AO</h2><p>原理：在物体中，只有一部分能看到天光，其他部分会被遮挡住 <spanclass="math display">\[AO(\bold{p,n})=\frac{1}{\pi}\int_{\Omega}V(\bold{p},\omega)\bold{n}·\omega\ d\omega\]</span><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724102810366.png" alt="image-20230724102810366" style="zoom:80%;" /></p><h3 id="预计算ao">7.1.1 预计算AO</h3><p>使用光线追踪的算法，离线计算AO并将其保存到纹理中</p><ol type="1"><li>需要额外的存储</li><li>只能应用于静态物体</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724103150057.png" alt="image-20230724103150057" style="zoom:80%;" /></p><h3 id="ssaoscreen-space-ambient-occlusion">7.1.2 SSAO：Screen SpaceAmbient Occlusion</h3><p>思想：</p><ol type="1"><li>在渲染的每一帧中，可以得到每个像素的颜色&amp;深度</li><li>将每个像素的深度信息连接到一起，就可以得到height field</li><li>根据height field可以得到几何关系，从而估算自遮挡</li></ol><p>估算自遮挡：</p><ol type="1"><li>在观察点p的给定半径的球形空间内，随机采样N个点</li><li>对这N个采样点，通过相机去投射，可以得到这些点的深度，与Z-Buffer中的深度进行对比<ol type="1"><li>深度比Z-Buffer中的近，则证明其可以看见光</li><li>深度比Z-Buffer中的远，则证明其被当前绘制中的某个几何挡住了</li></ol></li><li>则最后的自遮挡为：<spanclass="math inline">\(A(p)=1-\frac{Occlusion}{N}\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724103340183.png" alt="image-20230724103340183" style="zoom:80%;" /></p><h3 id="ssao">7.1.3 SSAO+</h3><ol type="1"><li>沿着p点的法线方向，采样半球面</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724104812491.png" alt="image-20230724104812491" style="zoom:80%;" /></p><h3 id="hbaohorizon-based-ambient-occlusion">7.1.4 HBAO：Horizon BasedAmbient Occlusion</h3><p>思想：</p><ol type="1"><li>要求的实际上是球面空间上的可见性</li><li>从p点出发，沿着各个方向去转，找到光线能够越过最高邻居的仰角，称为pitchangle</li><li>如果在每个方向都找到了，则会得到Occluded Area</li><li>根据Occluded Area，可以估算出有多大面积的天顶是可见的</li><li>attenuation function：如果某个山离p点过远，则认为其对我没有影响</li></ol><p><span class="math display">\[A=1-\frac{1}{2\pi}\int_{\theta=-\pi}^{\pi}\int_{\alpha=t(\theta)}^{h(\theta)}W(\vec{\omega})\cos(\alpha)\d\alpha d\theta\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724105031680.png" alt="image-20230724105031680" style="zoom:80%;" /></p><p>具体实现：ray marching</p><ol type="1"><li>将Z-Buffer视为height field</li><li>以P点为圆心，以几个像素为固定步长进行采样，采样一圈，得到最大horizonangle</li><li>注意：对于每个像素，要随机抖动步长、旋转方向</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724105717883.png" alt="image-20230724105717883" style="zoom:80%;" /></p><h3 id="gtaoground-truth-based-ambient-occlusion">7.1.5 GTAO：GroundTruth-based Ambient Occlusion</h3><p>问题：不同方向的光，对于P点的反射贡献是不同的，有一个 <spanclass="math inline">\(\cos\theta\)</span> 的修正 <spanclass="math display">\[\hat{A}(x)=\frac{1}{\pi}\int_{0}^{\pi}\int_{\theta_1(\phi)}^{\theta_2(\phi)}\cos(\theta-\gamma)^+|\sin(\theta)|\d\theta d\phi\\\gamma=angle(\vec{n},\vec{v})\]</span><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724110713853.png" alt="image-20230724110713853" style="zoom:80%;" /></p><ol type="1"><li>根据计算出的AO值，可以猜测光射进山谷后，多次Bounce后形成的亮度<ol type="1"><li>例如山谷虽然被周围的山遮挡住了，但是底部仍旧有光，并且底部的光与周围的山的面的颜色有关系</li></ol></li><li>根据不同的AO值，与对应的MultiScattering值进行分析，得到一个多项式的关联</li><li>从而根据一个多项式，将Single Bounce转换为Multi Bounce的效果<ol type="1"><li>AO的值类似于BRDF中的roughness值，表示周围区域对当前点的遮挡性</li><li>GTAO的发现类似于用多项式方程拟合了积分的效果</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724111134323.png" alt="image-20230724111134323" style="zoom:80%;" /></p><h3 id="ray-tracing-ambient-occlusion">7.1.6 Ray-Tracing AmbientOcclusion</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724112133504.png" alt="image-20230724112133504" style="zoom:80%;" /></p><h2 id="雾效">7.2 雾效</h2><h3 id="depth-fog">7.2.1 Depth Fog</h3><p>思想：从眼睛看过去，随着距离，能见度逐渐下降</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724112307755.png" alt="image-20230724112307755" style="zoom:80%;" /></p><h3 id="height-fog">7.2.2 Height Fog</h3><p>思想：不同高度，雾的浓度不同</p><ol type="1"><li>Fog有一个最大值：当低于某个高度时，都是最大的Fog；当高于该高度时，Fog是以指数递减的</li><li>当人的位置<spanclass="math inline">\(O_z\)</span>高于目标位置时，Fog要通过RayMarching算法，从目标位置到当前位置进行积分</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724112613301.png" alt="image-20230724112613301" style="zoom:80%;" /></p><h3 id="voxel-based-volumetric-fog">7.2.3 Voxel-Based VolumetricFog</h3><p>将相机空间非均匀体素化：根据视锥进行切分(如左上图所示)</p><ol type="1"><li>原因：如果进行均匀体素化，那么近处的颗粒太大，远处的颗粒太细</li><li>一般会用一个3D纹理存储运算结构</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724113400597.png" alt="image-20230724113400597" style="zoom:80%;" /></p><h2 id="抗锯齿">7.3 抗锯齿</h2><h3 id="锯齿产生的原因">7.3.1 锯齿产生的原因</h3><p>产生锯齿的原因：屏幕的分辨率是有限的，而几何世界的分辨率是无限的</p><ol type="1"><li>边界的采样</li><li>纹理的采样</li><li>高光的采样</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724114416137.png" alt="image-20230724114416137" style="zoom:80%;" /></p><h3 id="anti-aliasing">7.3.2 Anti-aliasing</h3><p>多采样几次，进行平均，从而产生过渡区域</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724114726723.png" alt="image-20230724114726723" style="zoom:80%;" /></p><h3 id="ssaasuper-sample-aa-msaamulti-sample-aa">7.3.3 SSAA(Super-sampleAA) &amp; MSAA(Multi-sample AA)</h3><p>SSAA：</p><ol type="1"><li>在屏幕分辨率的基础上，绘制更高分辨率的图片，然后对高分辨率的图片进行下采样，得到屏幕上的图片</li><li>缺点：所有buffer、shading均变成原来的4倍</li></ol><p>MSAA：</p><ol type="1"><li>对空间仍是4倍采样，但是在渲染时，如果这4个sub-pixel对三角形的贡献相同的话，只进行一次shading；如果不止一个贡献的话，则对四个采样点均进行一次shading，然后计算平均值</li><li>只有在最后的shading时，会省略一些不需要的渲染</li><li>缺点：当三角形数量高于像素数量时，MSAA会彻底失效</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724114910115.png" alt="image-20230724114910115" style="zoom:80%;" /></p><h3 id="fxaafast-approximate-anti-aliasing">7.3.4 FXAA：Fast ApproximateAnti-Aliasing</h3><p>在采样率不变的情况下，进行抗锯齿</p><p>思想：产生锯齿的地方，一般都是边界，此时会产生颜色的跳变，只需要对边界进行抗锯齿即可</p><ol type="1"><li><p>对每个像素点，进行十字滤波：</p><ol type="1"><li>计算上下左右四个邻居以及自己的差异值，当差异值大于某个阈值时，就是边界</li><li>将颜色转化为亮度，只计算亮度的差异值：<spanclass="math inline">\(L=0.299*R+0.587*G+0.114*B\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724115838038.png" alt="image-20230724115838038" style="zoom:80%;" /></p></li><li><p>计算差异的方向：</p><ol type="1"><li>使用两个卷积矩阵，分别计算横向与纵向的差异权重，判断差异方向</li><li>确定方向后，比较两个邻居，判断谁的差异更大</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724120357356.png" alt="image-20230724120357356" style="zoom:80%;" /></p></li><li><p>边界搜索算法：</p><ol type="1"><li>从当前点出发，与应该与其进行混合的点形成一对，求亮度平均值<spanclass="math inline">\(L_{avg}\)</span>、亮度差异值<spanclass="math inline">\(L_{offset}\)</span></li><li>朝着垂直于这一对的方向的两边进行搜索，找到像素对的颜色变化与当前点像素对不同为止</li><li>此时就找到了边界的两个端点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724144851026.png" alt="image-20230724144851026" style="zoom:80%;" /></p></li><li><p>计算混合系数</p><ol type="1"><li>比较当前点距离左端和右端的距离，找到更近的端点<spanclass="math inline">\(targetP\)</span></li><li>根据平均亮度、当前点亮度、端点亮度，计算混合系数</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724145257417.png" alt="image-20230724145257417" style="zoom:80%;" /></p></li><li><p>与相邻的像素进行混合</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724145657591.png" alt="image-20230724145657591" style="zoom:80%;" /></p></li></ol><h3 id="taateamporal-anti-aliasing">7.3.5 TAA：TeamporalAnti-Aliasing</h3><ol type="1"><li>利用前一帧的数据进行混合</li><li>每个点都需要计算上一帧的对应位置，生成motion vector</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724145900584.png" alt="image-20230724145900584" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724150017897.png" alt="image-20230724150017897" style="zoom:80%;" /></p><h2 id="后处理">7.4 后处理</h2><h3 id="blooming-光晕效果">7.4.1 Blooming 光晕效果</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724152124723.png" alt="image-20230724152124723" style="zoom:80%;" /></p><ol type="1"><li><p>首先，取出当前帧中高亮的部分</p><ol type="1"><li>计算每一个像素的亮度，与平均光场亮度做对比，超过阈值的像素取出其RGB值</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724154401888.png" alt="image-20230724154401888" style="zoom:80%;" /></p></li><li><p>然后，对取出的像素进行高斯模糊</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724154659877.png" alt="image-20230724154659877" style="zoom:80%;" /></p></li><li><p>先进行几次下采样，对下采样之后的结果进行Blur，然后再进行上采样，与原有的图像进行混合，此时模糊的区域就会很大</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724155120135.png" alt="image-20230724155120135" style="zoom:80%;" /></p></li></ol><h3 id="tone-mapping">7.4.2 Tone Mapping</h3><p>将HDR颜色转化为SDR颜色，从而显示HDR图像</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724162530557.png" alt="image-20230724162530557" style="zoom:80%;" /></p><p>关键在于定义一条Tone Mapping曲线，用于转换颜色</p><ol type="1"><li><p>filmic曲线</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724163300239.png" alt="image-20230724163300239" style="zoom:80%;" /></p></li><li><p>ACES：Academy Color Encoding System</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724163550628.png" alt="image-20230724163550628" style="zoom:80%;" /></p></li></ol><h3 id="color-grading">7.4.3 Color Grading</h3><p>通过一个LookupTable，整体改变图像的色彩空间，从而快速修改游戏画面的颜色</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724163949045.png" alt="image-20230724163949045" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724164015141.png" alt="image-20230724164015141" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724164344381.png" alt="image-20230724164344381" style="zoom:80%;" /></p><h2 id="渲染管线">7.5 渲染管线</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724164827551.png" alt="image-20230724164827551" style="zoom:80%;" /></p><h3 id="forward-rendering">7.5.1 Forward Rendering</h3><p>对每一个mesh、每一个light，渲染一遍</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165010279.png" alt="image-20230724165010279" style="zoom:67%;" /></p><ol type="1"><li>透明物体必须在不透明物体之后绘制</li><li>多个透明物体按照由远及近的顺序绘制</li><li>天空最后绘制</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165037797.png" alt="image-20230724165037797" style="zoom:80%;" /></p><h3 id="deffered-rendering-延迟渲染">7.5.2 Deffered Rendering延迟渲染</h3><ol type="1"><li>先计算所有物体的材质信息，将其保存到一个巨大的G-Buffer中</li><li>然后再计算所有的光，将其应用到G-Buffer中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165433022.png" alt="image-20230724165433022" style="zoom:80%;" /></p><p>优点：</p><ol type="1"><li>对光的处理非常方便</li><li>渲染很容易debug</li></ol><p>缺点：</p><ol type="1"><li>需要更多的内存、读写开销</li><li>不支持透明物体</li><li>对MSAA不友好</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165643986.png" alt="image-20230724165643986" style="zoom:80%;" /></p><h3 id="tile-based-rendering">7.5.3 Tile-based Rendering</h3><p>将画面拆成一小块一小块，降低对读写的压力</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165933701.png" alt="image-20230724165933701" style="zoom:80%;" /></p><p>从而可以判断每个光会对哪些tile产生影响，进行光的裁剪</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170117258.png" alt="image-20230724170117258" style="zoom:80%;" /></p><p>对于每一个tile，可以在计算Z-Buffer的时候，得到该tile的深度范围，从而计算出光源可能影响到的tile</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170247601.png" alt="image-20230724170247601" style="zoom:80%;" /></p><h3 id="forward-rendering-1">7.5.4 Forward+ Rendering</h3><p>分块进行Forward Rendering</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170500085.png" alt="image-20230724170500085" style="zoom:80%;" /></p><h3 id="cluster-based-rendering">7.5.5 Cluster-based Rendering</h3><p>直接对Z空间进行切分，划分为一个个的四棱锥</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170548584.png" alt="image-20230724170548584" style="zoom:80%;" /></p><h3 id="visibility-buffer">7.5.6 Visibility Buffer</h3><p>将几何信息与材质信息分开，存储几何信息，反向找到材质</p><ol type="1"><li>在VisibilityBuffer中，记录每个像素属于哪个几何体的哪个三角形，从而可以反向查该三角形应用哪种材质</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170734043.png" alt="image-20230724170734043" style="zoom:80%;" /></p><h2 id="frame-graph">7.6 Frame Graph</h2><p>用一个有向无环图表示资源之间的依赖关系，由系统自动管理实际资源的使用和释放</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724173121032.png" alt="image-20230724173121032" style="zoom:80%;" /></p><h2 id="v-sync-g-sync">7.7 V-Sync &amp; G-Sync</h2><h3 id="screen-tearing-屏幕撕裂">7.7.1 Screen Tearing 屏幕撕裂</h3><p>引擎渲染的刷新率是不一定的，而屏幕的刷新率是固定的，从而会导致画面的撕裂</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724173615680.png" alt="image-20230724173615680" style="zoom:80%;" /></p><h3 id="v-sync-垂直同步">7.7.2 V-Sync 垂直同步</h3><blockquote><p><strong>垂直同步(VSync)</strong>：将游戏或应用程序的图像帧速率与显示监视器的刷新速率进行同步，有助于建立稳定性。如果不同步，则可能会导致画面撕裂，即图像看起来在整个屏幕上呈现水平方向毛刺或重影的效果。启用VSync 后，便会获得完美对齐的画面而不会出现毛刺</p></blockquote><p>将整个Frame渲染完成后，等到下一个屏幕刷新时间，统一写进去</p><ol type="1"><li>可能会导致画面一会快一会慢</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724173646994.png" alt="image-20230724173646994" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-06：渲染：地形、大气、云的渲染</title>
      <link href="/2023/07/06/GAMES104/06--%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%9C%B0%E5%BD%A2%E3%80%81%E5%A4%A7%E6%B0%94%E3%80%81%E4%BA%91%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
      <url>/2023/07/06/GAMES104/06--%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%9C%B0%E5%BD%A2%E3%80%81%E5%A4%A7%E6%B0%94%E3%80%81%E4%BA%91%E7%9A%84%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="六渲染地形大气云的渲染">六、渲染：地形、大气、云的渲染</h1><h2 id="地形的几何">6.1 地形的几何</h2><h3 id="heightfield">6.1.1 Heightfield</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710164528555.png" alt="image-20230710164528555" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710164711163.png" alt="image-20230710164711163" style="zoom:80%;" /></p><h3 id="两个优化的准则">6.1.3 两个优化的准则</h3><ol type="1"><li>FOV越窄，三角形划分越密集</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710165356323.png" alt="image-20230710165356323" style="zoom:80%;" /></p><ol start="2" type="1"><li>和ground truth在屏幕上的误差不要超过一个像素</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710171620877.png" alt="image-20230710171620877" style="zoom:80%;" /></p><h3 id="基于三角形的剖分">6.1.4 基于三角形的剖分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710171859276.png" alt="image-20230710171859276" style="zoom:80%;" /></p><p><strong>T-Junctions</strong></p><ol type="1"><li>问题：当两个相邻的三角形在同一个边上，这个三角形没有切分这条边，而相邻三角形切分了(高度会随之变化)，会导致地形上有个裂缝</li><li>解决方法：如果发现边上有邻居对相邻边的切分更密集，则当前三角形也需要将该边切分，直到与邻居的切分数相同</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710172014900.png" alt="image-20230710172014900" style="zoom:80%;" /></p><h3 id="基于四叉树的切分">6.1.5 基于四叉树的切分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710172614256.png" alt="image-20230710172614256" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710172803559.png" alt="image-20230710172803559" style="zoom:80%;" /></p><p>解决T-Junctions的问题：<strong>Stitching吸附</strong></p><ol type="1"><li>将划分更密集的那个三角形的中心，对齐到更稀疏的三角形上</li><li>即划分出了一个面积为0的三角形</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713102702521.png" alt="image-20230713102702521" style="zoom:80%;" /></p><h3 id="基于不规则三角形的绘制-tin">6.1.6 基于不规则三角形的绘制TIN</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713103514295.png" alt="image-20230713103514295" style="zoom:80%;" /></p><p>通过顶点简化，减少三角形的数目</p><p>优点：</p><ol type="1"><li>通常情况下，三角形的数目更少</li></ol><p>缺点：</p><ol type="1"><li>地形的三角形难以在渲染的时候调整</li></ol><h3 id="基于gpu的曲面细分tessellation">6.1.7基于GPU的曲面细分(Tessellation)</h3><p>DirectX12开始支持Mesh Shader</p><ol type="1"><li>在给定Mesh Shader之后，MeshShader会生成一小块meshlit(一小片顶点&amp;三角形)，顶点&amp;三角形如何插值、如何凸包由shader控制</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713104436099.png" alt="image-20230713104436099" style="zoom:80%;" /></p><h3 id="real-time-deformable-terrain">6.1.8 Real-Time DeformableTerrain</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713105028872.png" alt="image-20230713105028872" style="zoom:80%;" /></p><p>如果所有顶点的位置都可以在runtime动态调整，则可以让地形产生动态效果</p><ol type="1"><li>在人物的周边生成一个terraindeformable的texture，将这上面的脚印记录在texture上</li><li>当移动的时候，texture跟着角色走，但是要保持数据一致性</li><li>由于地形数据是实时细分出来的，就可以根据texture添加一些offset</li><li>还要注意更新地形的碰撞</li></ol><h3 id="non-heightfield-terrain">6.1.9 Non-Heightfield Terrain</h3><p>地形不止有起伏，还有悬崖山洞之类的物体</p><h4 id="在terrain中开一个洞">6.1.9.1 在Terrain中开一个洞</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713105844108.png" alt="image-20230713105844108" style="zoom:80%;" /></p><ol type="1"><li>可以在设置顶点位置的时候，判断一下这个顶点是否在洞中</li><li>如果在洞中，则将其位置设为NaN</li><li>GPU在看到位置为NaN的顶点后，不会绘制用到这个顶点的所有物体</li><li>然后再通过加一个山洞的模型，避免地形上的zigzag条纹显示出来</li></ol><h4 id="地形体素化表达">6.1.9.2 地形体素化表达</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713110208576.png" alt="image-20230713110208576" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713110303928.png" alt="image-20230713110303928" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713110648064.png" alt="image-20230713110648064" style="zoom:80%;" /></p><ol type="1"><li>将地形表示为三维空间，三维空间中的每个点存一个权重值，表示这个位置是否有物质、物质的密度</li><li>通过MarchingCubes方法，找到等值面，切分立方体，形成一个水密的三角面片集，把形状表达出来</li></ol><h2 id="地形的材质">6.2 地形的材质</h2><h3 id="texture-splatting">6.2.1 Texture Splatting</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713110922421.png" alt="image-20230713110922421" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713111446052.png" alt="image-20230713111446052" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713111410233.png" alt="image-20230713111410233" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713111837774.png" alt="image-20230713111837774" style="zoom:80%;" /></p><ol type="1"><li>每个材质存储Base Color、Normal、Roughness、Height四种贴图</li><li>再存储一张混合贴图，每个channel表示一种贴图的权重，通过笔刷设置不同材质的权重</li><li>在过渡的时候，如果需要混合两种材质，则根据height对权重进行调整，height高的权重下降慢<ol type="1"><li>缺点：由于是01切换，当相机移动的时候，会有很多抖动，导致分界线过硬</li><li>解决方法：添加一个bias，当两者高度差&lt;bias的时候，用权重进行插值</li></ol></li></ol><h3 id="在texture-array中采样">6.2.2 在Texture Array中采样</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713112037261.png" alt="image-20230713112037261" style="zoom:80%;" /></p><ol type="1"><li>将地表的多种材质存储为一个数组，每次采样仅会采样其中一个材质</li><li>混合的时候，根据位置、权重、index，判断采样哪种材质，采样的权重是但多少</li></ol><h3 id="displacement-mapping">6.2.3 Displacement Mapping</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713112551490.png" alt="image-20230713112551490" style="zoom:80%;" /></p><h3 id="expensive-material-blending">6.2.4 Expensive MaterialBlending</h3><ol type="1"><li>每一次进行纹理采样，都需要采样8个点，进行7次插值</li><li>一个点有几种材质进行混合，就需要在上述基础上乘几</li><li>而这些采样的数据在内存中的不同地方，address的不停跳跃会非常浪费时间</li><li>事实上，我们看到的地形仅有地形的一部分，其他部分都会被裁剪掉</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713113001442.png" alt="image-20230713113001442" style="zoom:80%;" /></p><h3 id="virtual-texture">6.2.5 Virtual Texture</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713113417200.png" alt="image-20230713113417200" style="zoom:80%;" /></p><p>核心思想：将用到的东西装载到内存中</p><ol type="1"><li>将纹理分为不同块，分块数满足2的幂次</li><li>然后根据分块对纹理建立Mipmap</li><li>绘制时，只将看到的纹理LOD层加载到内存</li></ol><h3 id="浮点数精度溢出">6.2.6 浮点数精度溢出</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713114800746.png" alt="image-20230713114800746" style="zoom:80%;" /></p><ol type="1"><li>当摄像机&amp;地形的全局坐标很大(如1km)，而地形上的物体与地形距离很近(如0.5m)的时候，远处的地形与物体就会由于精度问题产生抖动</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713115131010.png" alt="image-20230713115131010" style="zoom:80%;" /></p><ol start="2" type="1"><li>解决方法：<ol type="1"><li>将相机的位置强行设置为0，地形的位置坐标根据相机的位置设置，此时两者使用到的坐标都不会很大，就可以保证小数点后的精度了<ol type="1"><li>修改前：地形位置1000010m、物体位置1000010.5m、相机位置1000000m</li><li>修改后：地形位置10m、物体位置10.5m、相机位置0m</li></ol></li><li>也可以将整个大型关卡切分为不同的小关卡，每个小关卡拥有自己的全局坐标系</li></ol></li></ol><h2 id="植被道路贴花等">6.3 植被道路贴花等</h2><h3 id="树木渲染">6.3.1 树木渲染</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713123021648.png" alt="image-20230713123021648" style="zoom:80%;" /></p><h3 id="装饰物渲染-decorator">6.3.2 装饰物渲染 Decorator</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713123446738.png" alt="image-20230713123446738" style="zoom:80%;" /></p><h3 id="道路和贴画渲染">6.3.3 道路和贴画渲染</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713123544838.png" alt="image-20230713123544838" style="zoom:80%;" /></p><ol type="1"><li>将地形的纹理、道路的纹理、贴画的纹理全部放到VirtualTexture中，runtime的时候直接调用virtual texture即可</li><li>计算的复杂度集中在bake中，runtime的时候只需要将纹理贴上去即可，开销很低</li></ol><h2 id="大气散射理论">6.4 大气散射理论</h2><h3 id="analytic-atmosphere-apperance-modeling">6.4.1 AnalyticAtmosphere Apperance Modeling</h3><p><span class="math display">\[F(\theta,\gamma)=(1+Ae^{\frac{B}{\cos\theta+0.01}})·(C+De^{E\gamma}+F\cos^2\gamma+G·\chi(H,\gamma)+I\cos^{\frac{1}{2}}\theta)\\L_\lambda=F(\theta,\gamma)·L_{M\lambda}\]</span></p><p>优点：</p><ol type="1"><li>便于计算</li></ol><p>缺点：</p><ol type="1"><li>只能在地表</li><li>参数是写死的，无法自由的更改</li></ol><h3 id="participating-media">6.4.2 Participating Media</h3><p>空气是由两种粒子构成的：</p><ol type="1"><li>各种气体分子：如N2、O2、CO2</li><li>气溶胶：空气中的灰尘形成的小的气溶胶分子</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717170023348.png" alt="image-20230717170023348" style="zoom:80%;" /></p><h3id="光与participating-media的交互radiative-transfer-function-rtf">6.4.3光与Participating Media的交互：Radiative Transfer Function (RTF)</h3><ol type="1"><li>吸收：<span class="math inline">\(-\sigma_\alphaL(x,\omega)\)</span></li><li>散射：<span class="math inline">\(-\sigma_sL(x,\omega)\)</span></li><li>自发光：<span class="math inline">\(\sigma_\alphaL_e(x,\omega)\)</span></li><li>其他气体分子的影响：<spanclass="math inline">\(\sigma_s\int_{S^2}f_p(x,\omega,\omega&#39;)L(x,\omega&#39;)d\omega&#39;\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717170238128.png" alt="image-20230717170238128" style="zoom:80%;" /></p><h3 id="volume-rendering-equation-vre">6.4.4 Volume Rendering Equation(VRE)</h3><ol type="1"><li><strong>Transmittance通透度</strong>：在M点看到的东西，由多少会保留到在P点看到的东西，是路径积分的结果</li><li><strong>scattering function散射方程</strong>：从M点到P点，叠加的其他粒子的效果</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717170857327.png" alt="image-20230717170857327" style="zoom:80%;" /></p><h3 id="大气的实际物理">6.4.5 大气的实际物理</h3><ol type="1"><li>太阳光由不同波长的光组成</li><li>大气由两种粒子构成：<ol type="1"><li>气体分子：直径小于光的波长</li><li>气溶胶分子：直径接近于光的波长</li></ol></li></ol><h4 id="散射">6.4.5.1 散射</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717171902619.png" alt="image-20230717171902619" style="zoom:80%;" /></p><p>两种散射类型</p><ol type="1"><li><p>瑞利散射：当粒子的直径远小于光的波长的时候，光会均匀散射，波长越短散射越明显</p><ol type="1"><li><span class="math inline">\(\lambda\)</span>：光的波长</li><li><spanclass="math inline">\(\theta\)</span>：观察方向与光方向的夹角</li><li><span class="math inline">\(h\)</span>：海拔高度</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172209324.png" alt="image-20230717172209324" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172535846.png" alt="image-20230717172535846" style="zoom:80%;" /></p></li><li><p>幂散射：当粒子的直径接近或大于光的波长的时候，光的散射会有方向性，且对波长不敏感</p><ol type="1"><li><span class="math inline">\(\lambda\)</span>：光的波长</li><li><spanclass="math inline">\(\theta\)</span>：观察方向与光方向的夹角</li><li><span class="math inline">\(h\)</span>：海拔高度</li><li><span class="math inline">\(g\)</span>：几何参数，由艺术家调整</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172604878.png" alt="image-20230717172604878" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172731013.png" alt="image-20230717172731013" style="zoom:80%;" /></p></li></ol><h4 id="吸收">6.4.5.2 吸收</h4><ol type="1"><li>O3：吸收红光、橙光、黄光</li><li>CH4：吸收红光</li><li>假设大气中的O3、CH4均匀分布</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172849011.png" alt="image-20230717172849011" style="zoom:80%;" /></p><h3 id="单次散射-多次散射">6.4.6 单次散射 &amp; 多次散射</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717173525948.png" alt="image-20230717173525948" style="zoom:80%;" /></p><h3 id="ray-marching">6.4.7 Ray Marching</h3><ol type="1"><li>沿着一条视线，均匀地采很多点，把沿途的效果一步一步地积分起来</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717174657314.png" alt="image-20230717174657314" style="zoom:80%;" /></p><h2 id="实时大气渲染">6.5 实时大气渲染</h2><h3 id="transmittance-lut-mur">6.5.1 Transmittance LUT <spanclass="math inline">\((\mu,r)\)</span></h3><ol type="1"><li>选择一个海拔高度为<spanclass="math inline">\(h\)</span>的点，在当前海拔高度存储两个值<ol type="1"><li>视线和天顶之间的夹角为<spanclass="math inline">\(\theta\)</span>，用<spanclass="math inline">\(\cos\theta\)</span>进行参数化表达</li><li>从当前点<spanclass="math inline">\(X_v\)</span>出发，沿视线方向走到大气层的边界，与边界的交点为<spanclass="math inline">\(B\)</span></li></ol></li><li>此时，我们可以计算出整个大气层的通透度，即：<spanclass="math inline">\(T(X_v → B)\)</span></li><li>假设在远处有一个物体在点<spanclass="math inline">\(X_m\)</span>处发出光，则该处的光到达当前点<spanclass="math inline">\(X_v\)</span>的通透度为：<spanclass="math inline">\(T(X_v→X_m)=\frac{T(X_v→B)}{T(X_m→B)}\)</span></li><li>此时，我们可以通过一个简单的二维方程，通过除法，即可表达原先的四维方程</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717174857029.png" alt="image-20230717174857029" style="zoom:80%;" /></p><h3 id="single-scattering-lut-vmu_smur">6.5.2 Single Scattering LUT<span class="math inline">\((v,\mu_s,\mu,r)\)</span></h3><ol type="1"><li>视线方向：<span class="math inline">\(\theta\)</span><ol type="1"><li>选择一个海拔高度为<span class="math inline">\(h\)</span>的点<spanclass="math inline">\(X_v\)</span>，朝着一个方向去看，此时可以得到天顶角<spanclass="math inline">\(\theta\)</span></li><li>由于大气层是个球，因此有了起点和方向，即可得知<spanclass="math inline">\(B\)</span>与<spanclass="math inline">\(X_v\)</span>的距离</li></ol></li><li>太阳到天顶的角度为：<span class="math inline">\(\eta\)</span></li><li>视线与太阳之间的夹角：<span class="math inline">\(\phi\)</span></li><li>如果大气层各项同性，则只需要存储<spanclass="math inline">\((\theta,\eta,\phi)\)</span>对应的散射，即可得到某个点看向太空中的点的SingleScattering</li><li>再沿着高度<spanclass="math inline">\(h\)</span>进行采样，即可得到一个四维表，可以将其存储到3DTexture Array中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230719151741381.png" alt="image-20230719151741381" style="zoom:80%;" /></p><h3 id="计算multi-scattering">6.5.3 计算Multi Scattering</h3><ol type="1"><li>将SingleScattering照亮的点，通过Transmittance进行多次积分，即可得到MultiScattering<ol type="1"><li>通常只做3~4次</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230719153923385.png" alt="image-20230719153923385" style="zoom:80%;" /></p><h3 id="缺点">6.5.4 缺点</h3><ol type="1"><li>预计算的计算量很大</li><li>场景变化后，需要重新计算：如天空忽然开始下雨，设计场景时更改参数的值</li><li>实时计算时，需要做很多次高维表查值，导致时间开销较大</li></ol><h3 id="production-friendly-quick-sky-and-atmosphere-rendering">6.5.5Production Friendly Quick Sky and Atmosphere Rendering</h3><p>假设：在空气中的散射是低频的，对空气中的一个分子，来自于不同方向的散射在各向分布都是同样的</p><p>从而会导致每个分子的多次散射，实际上是一个等比衰减，比例可以通过计算两次&amp;三次散射得到</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721171740498.png" alt="image-20230721171740498" style="zoom:80%;" /></p><p>由于每一帧都要计算LUT，因此可以假设太阳位置不变、角色位置不变，从而可以删除两维</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721171756792.png" alt="image-20230721171756792" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721171919821.png" alt="image-20230721171919821" style="zoom:80%;" /></p><h2 id="云的渲染">6.6 云的渲染</h2><h3 id="云的类型">6.6.1 云的类型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172318834.png" alt="image-20230721172318834" style="zoom:80%;" /></p><h3 id="billboard-cloud">6.6.2 Billboard Cloud</h3><p>通过大量2D图片的混合，实现云的效果</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172435886.png" alt="image-20230721172435886" style="zoom:80%;" /></p><h3 id="volumetric-cloud-modeling">6.6.3 Volumetric Cloud Modeling</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172511551.png" alt="image-20230721172511551" style="zoom:80%;" /></p><h4 id="weather-texture">6.6.3.1 Weather Texture</h4><ol type="1"><li>云的随机分布</li><li>云的厚度：0~1的值</li></ol><p>让云飘起来：对Weather Texture进行平移</p><p>让云产生变化：对Weather Texture进行扰动</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172636329.png" alt="image-20230721172636329" style="zoom:80%;" /></p><h4 id="noise-function">6.6.3.2 Noise Function</h4><p>Perlin噪声：在多项式时间内产生棉花絮之类的效果</p><p>Worley噪声：形成泡泡絮的效果</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172956467.png" alt="image-20230721172956467" style="zoom:80%;" /></p><h4 id="cloud-density-model">6.6.3.3 Cloud Density Model</h4><ol type="1"><li>基础的云是柱状的，需要添加噪声优化效果</li><li>先用低频噪声，删除一部分</li><li>在添加高频的细节</li><li>从而可以模拟数学上的分形效果</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721173021690.png" alt="image-20230721173021690" style="zoom:80%;" /></p><h4 id="rendering-cloud-by-ray-marching">6.6.3.4 Rendering Cloud by RayMarching</h4><ol type="1"><li>从相机发送射线，判断是否能打到云上<ol type="1"><li>开始时步长较大</li></ol></li><li>一旦与云相交，就缩小步长，在每一个点计算大气的通透和散射<ol type="1"><li>由于云的通透度很低，因此可以做大量假设，简化渲染方程</li></ol></li><li>天空中的云实际上是GPU中的一个3D纹理，通过RayMarching的方法解析该纹理的结果</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721173206921.png" alt="image-20230721173206921" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-05：渲染：光和材质的数学魔法</title>
      <link href="/2023/07/05/GAMES104/05--%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%85%89%E5%92%8C%E6%9D%90%E8%B4%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E9%AD%94%E6%B3%95/"/>
      <url>/2023/07/05/GAMES104/05--%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%85%89%E5%92%8C%E6%9D%90%E8%B4%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E9%AD%94%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="五渲染光和材质的数学魔法">五、渲染：光和材质的数学魔法</h1><h2 id="渲染方程及挑战">5.1 渲染方程及挑战</h2><h3 id="渲染方程">5.1.1 渲染方程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710111512770.png" alt="image-20230710111512770" style="zoom:80%;" /><span class="math display">\[L_o(x,\omega_o)=L_e(x,\omega_o)+\int_{H^2}f_r(x,\omega_o,\omega_i)L_i(x,\omega_i)\cos\theta_id\omega_i\]</span><strong>radiance</strong>：辐射度；光照到物体上，物体反射出去的能量</p><p><strong>irradiance</strong>：入射的能量</p><p><span class="math inline">\(L_o(x,\omega_o)\)</span>：观察点为<spanclass="math inline">\(x\)</span>，观察方向为<spanclass="math inline">\(\omega_o\)</span>，观察到的radiance即为<spanclass="math inline">\(L_o(x,\omega_o)\)</span></p><ol type="1"><li><span class="math inline">\(L_e(x,\omega_o)\)</span>：观察点<spanclass="math inline">\(x\)</span>，在<spanclass="math inline">\(\omega_o\)</span>方向的自发光</li><li><spanclass="math inline">\(\int_{H^2}f_r(x,\omega_o,\omega_i)L_i(x,\omega_i)\cos\theta_id\omega_i\)</span>：观察点<spanclass="math inline">\(x\)</span>接受所有方向射来的光，反射到<spanclass="math inline">\(\omega_o\)</span>方向的光<ol type="1"><li><spanclass="math inline">\(f_r(x,\omega_o,\omega_i)\)</span>：观察点<spanclass="math inline">\(x\)</span>，入射方向为<spanclass="math inline">\(\omega_i\)</span>，反射方向为<spanclass="math inline">\(\omega_o\)</span>，反射光能量占入射光能量的比例</li><li><span class="math inline">\(L_i(x,\omega_i)\)</span>：观察点<spanclass="math inline">\(x\)</span>，接受到的入射方向为<spanclass="math inline">\(\omega_i\)</span>的光的能量</li><li><spanclass="math inline">\(\cos\theta_i\)</span>：光线与平面的夹角</li></ol></li></ol><h3 id="挑战1如何得到irradiance">5.1.2 挑战1：如何得到irradiance</h3><p>对光源的可见性（阴影）</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710113016584.png" alt="image-20230710113016584" style="zoom:80%;" /></p><p>光源本身的复杂性</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710113045374.png" alt="image-20230710113045374" style="zoom:80%;" /></p><h3 id="挑战2如何快速地在球面上进行积分">5.1.4挑战2：如何快速地在球面上进行积分</h3><p>如何计算光与表面的作用，即材质的影响</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710113110253.png" alt="image-20230710113110253" style="zoom:80%;" /></p><h3 id="挑战3所有的物体都可能是光源">5.1.5挑战3：所有的物体都可能是光源</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710113218876.png" alt="image-20230710113218876" style="zoom:80%;" /></p><h2 id="基础光照解决方案">5.2 基础光照解决方案</h2><h3 id="简化光源main-light-ambient-light-environment-map">5.2.1简化光源：Main Light + Ambient Light + Environment Map</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710114440708.png" alt="image-20230710114440708" style="zoom:80%;" /></p><ol type="1"><li><p>简化光源的种类：主光<strong>dominant light</strong></p><ol type="1"><li>要么是点光源，要么是方向光源，要么是锥形光源</li></ol></li><li><p>简化光场的表示：环境光<strong>ambient light</strong></p><ol type="1"><li>将四面八方的光，用平均值代替</li></ol></li><li><p>环境光贴图：<strong>Environment Map</strong></p><ol type="1"><li>贴图是一个立方体</li><li>根据顶点的法线方向，计算观察到的颜色</li></ol><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec3</span> N = <span class="built_in">normalize</span>(normal);</span><br><span class="line">    <span class="type">vec3</span> V = <span class="built_in">normalize</span>(camera_position - world_position);</span><br><span class="line">    <span class="type">vec3</span> R = <span class="built_in">reflect</span>(V,N);</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(cube_texture, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="简化积分blinn-phong-材质">5.2.2 简化积分：Blinn-Phong 材质</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710115348670.png" alt="image-20230710115348670" style="zoom:80%;" /></p><p>将材质分为三类：<spanclass="math inline">\(L=L_a+L_d+L_s\)</span></p><ol type="1"><li>环境光项<strong>Ambient</strong>：<spanclass="math inline">\(L_a=k_aI_a\)</span></li><li>漫反射项<strong>Diffuse</strong>：<spanclass="math inline">\(L_d=k_d\frac{I}{r^2}\max(0,\textbf{n}·\textbf{l})\)</span></li><li>镜面反射项<strong>Specular</strong>：<spanclass="math inline">\(L_s=k_s\frac{I}{r^2}\max(0,\textbf{n}·\textbf{h})^p\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710115748614.png" alt="image-20230710115748614" style="zoom:80%;" /></p><h3 id="阴影">5.2.3 阴影</h3><p>目标问题：场景中看到的每个点，对于光源是否可见</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710115844674.png" alt="image-20230710115844674" style="zoom:80%;" /></p><p>解决方法：<strong>shadow map</strong></p><ol type="1"><li>从光的角度渲染一张深度图</li><li>观察时，每个点投影回光源的视角，根据深度判断是否可见</li></ol><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将当前点投影到shadow map</span></span><br><span class="line"><span class="type">vec4</span> proj_pos = shadow_viewproj * pos;</span><br><span class="line"><span class="comment">// 从 homogeneous 转化为 clip space</span></span><br><span class="line"><span class="type">vec2</span> shadow_uv = proj_pos.xy / proj_pos.w;</span><br><span class="line"><span class="comment">// 从 clip space 转化为 uv space</span></span><br><span class="line">shadow_uv = shadow_ucv * <span class="number">0.5</span> + <span class="type">vec2</span>(<span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// 获取当前点的深度 [-1, +1]</span></span><br><span class="line"><span class="type">float</span> real_depth = proj_pos.z / proj_pos.w;</span><br><span class="line"><span class="comment">// 标准化到[0, 1]</span></span><br><span class="line">real_depth = real_depth * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">// 从深度缓冲中读取深度</span></span><br><span class="line"><span class="type">float</span> shadow_depth = <span class="built_in">texture</span>(shadowmap, shadow_uv).x;</span><br><span class="line"><span class="comment">// 计算是否在阴影中</span></span><br><span class="line"><span class="type">float</span> shadow_factor = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">if</span>(shadow_depth &lt; real_depth)</span><br><span class="line">    shadow_factor = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710120120070.png" alt="image-20230710120120070" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710120752077.png" alt="image-20230710120752077" style="zoom:80%;" /></p><h2 id="基于预计算的全局光照空间换时间">5.3基于预计算的全局光照（空间换时间）</h2><p><strong>假设场景中90%的物体是不动的，每个场景太阳的角度是锁死的，那么就可以通过预计算，简化计算</strong></p><h3 id="全局光照直接光照间接光照">5.3.1 全局光照：直接光照+间接光照</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710121655099.png" alt="image-20230710121655099" style="zoom:80%;" /></p><h3 id="如何表示间接光照l_ixvecomega_i">5.3.2 如何表示间接光照<spanclass="math inline">\(L_i(x,\vec{\omega_i})\)</span></h3><h4 id="傅里叶变换">5.3.2.1 傅里叶变换：</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710122010062.png" alt="image-20230710122010062" style="zoom:80%;" /></p><h4 id="卷积定理">5.3.2.2 卷积定理：</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710122240919.png" alt="image-20230710122240919" style="zoom:80%;" /></p><h4 id="球谐函数-spherical-harmonics">5.3.2.3 球谐函数 SphericalHarmonics：</h4><p>球谐函数本质上是一组基于球坐标系<spanclass="math inline">\((\theta,\phi)\)</span>的基函数，基函数的计算公式为：<spanclass="math inline">\(Y_{lm}(\theta,\phi)   &amp;=N_{lm}P_{lm}(\cos\theta)e^{Im\phi} \\\)</span></p><ol type="1"><li>正交：任意两个基函数卷积为0</li><li>二阶导永远为0：函数永远是光滑的</li></ol>$$<span class="math display">\[\begin{aligned}Y_{0, 0}(\theta,\phi) &amp;= 1 \\ \\Y_{1,-1}(\theta,\phi) &amp;= y = \sin\theta\sin\phi \\Y_{1, 0}(\theta,\phi) &amp;= z = \cos\theta         \\Y_{1, 1}(\theta,\phi) &amp;= x = \sin\theta\cos\phi \\ \\Y_{2,-2}(\theta,\phi) &amp;= xy      = \sin^2\theta\sin\phi\cos\phi \\Y_{2,-1}(\theta,\phi) &amp;= yz      = \sin\theta\cos\theta\sin\phi \\Y_{2, 0}(\theta,\phi) &amp;= 3z^2-1  = 3\cos^2\theta-1              \\Y_{2, 1}(\theta,\phi) &amp;= zx      = \sin\theta\cos\theta\cos\phi \\Y_{2, 2}(\theta,\phi) &amp;= x^2-y^2 =\sin^2\theta(\cos^2\phi-\sin^2\phi) \\\end{aligned}\]</span><p>$$</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710122403478.png" alt="image-20230710122403478" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710142506684.png" alt="image-20230710142506684" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710142724812.png" alt="image-20230710142724812" style="zoom:80%;" /></p><p>由于环境光通常是低频的，因此只需要用二阶函数即可近似表达</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710143143488.png" alt="image-20230710143143488" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710143341600.png" alt="image-20230710143341600" style="zoom:80%;" /></p><h3 id="光照贴图-lightmap">5.3.3 光照贴图 Lightmap</h3><p>优点：</p><ol type="1"><li>runtime的时候效率很高</li><li>离线渲染，可以表示很多细节</li></ol><p>缺点：</p><ol type="1"><li>预计算时间非常长</li><li>只能处理静态物体、静态光</li><li>占用存储空间，通常在几十MB~一百MB</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710143550991.png" alt="image-20230710143550991" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710143647404.png" alt="image-20230710143647404" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710144115534.png" alt="image-20230710144115534" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710144140615.png" alt="image-20230710144140615" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710144204813.png" alt="image-20230710144204813" style="zoom:80%;" /></p><h3 id="光照探针-light-probe">5.3.4 光照探针 Light Probe</h3><p><strong>空间体素化</strong></p><ol type="1"><li>在场景中添加若干探针，针对每个探针计算全局光照</li><li>当需要某个点的全局光照时，对周围的探针进行插值</li></ol><p>优点：</p><ol type="1"><li>runtime时效率高</li><li>可以处理静态物体和动态物体，可以动态更新</li><li>处理了diffuse、specular的渲染</li></ol><p>缺点：</p><ol type="1"><li>无法实现类似lightmap的细节</li><li>SH light probe需要预计算</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710144730913.png" alt="image-20230710144730913" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710145020056.png" alt="image-20230710145020056" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710145217849.png" alt="image-20230710145217849" style="zoom:80%;" /></p><h2 id="基于物理的材质-physical-based-material-pbr">5.4 基于物理的材质Physical-Based Material PBR</h2><h3 id="微平面理论">5.4.1 微平面理论</h3><ol type="1"><li>假设任意面都由很多小的微平面组成，每个微平面都是镜面反射</li><li>如果微平面的法线方向集中，则是镜面反射；如果发散，则是漫反射</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710145814669.png" alt="image-20230710145814669" style="zoom:80%;" /></p><h3 id="基于微平面的brdf模型">5.4.2 基于微平面的BRDF模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710145923736.png" alt="image-20230710145923736" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710150553439.png" alt="image-20230710150553439" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710150927605.png" alt="image-20230710150927605" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710151100153.png" alt="image-20230710151100153" style="zoom:80%;" /></p><h3 id="disney-principled-brdf">5.4.3 Disney Principled BRDF</h3><p>五个原则</p><ol type="1"><li>参数的含义要足够直观</li><li>参数要尽可能少</li><li>参数的范围要尽可能在<code>[0,1]</code>之间</li><li>参数的范围也可以超过<code>[0,1]</code>，但是这必须是有意义的</li><li>参数的组合不会产生非常诡异的结果，每个参数的组合都是有意义的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152058624.png" alt="image-20230710152058624" style="zoom:80%;" /></p><h3 id="pbr-specular-glossiness">5.4.4 PBR Specular Glossiness</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152319575.png" alt="image-20230710152319575" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152356799.png" alt="image-20230710152356799" style="zoom:80%;" /></p><h3 id="pbr-metallic-roughness">5.4.5 PBR Metallic Roughness</h3><p>在SG模型的基础上进行封装，不是直接给出菲涅尔项的参数，而是通过metallic属性，对base_color进行插值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152711140.png" alt="image-20230710152711140" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152730662.png" alt="image-20230710152730662" style="zoom:80%;" /></p><h2 id="基于图像的光照image-based-lightingibl">5.5基于图像的光照：Image-Based Lighting（IBL）</h2><p>基础想法：对环境光照做一些预处理，从而快速计算环境光照与材质的卷积运算</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153710856.png" alt="image-20230710153710856" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153723495.png" alt="image-20230710153723495" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153902074.png" alt="image-20230710153902074" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153919760.png" alt="image-20230710153919760" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153937924.png" alt="image-20230710153937924" style="zoom:80%;" /></p><h2 id="经典阴影方法">5.6 经典阴影方法</h2><h3 id="cascade-shadow">5.6.1 Cascade Shadow</h3><ol type="1"><li>将环境分为不同层，离玩家越近，shadow map的精度越高</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154217910.png" alt="image-20230710154217910" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154229321.png" alt="image-20230710154229321" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154423464.png" alt="image-20230710154423464" style="zoom:80%;" /></p><h3 id="pcf">5.6.2 PCF</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154627569.png" alt="image-20230710154627569" style="zoom:80%;" /></p><h3 id="pcss">5.6.3 PCSS</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154641878.png" alt="image-20230710154641878" style="zoom:80%;" /></p><h3 id="variance-soft-shadow-mapvssm">5.6.4 Variance Soft ShadowMap（VSSM）</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154731623.png" alt="image-20230710154731623" style="zoom:80%;" /></p><h2 id="总结">5.7 总结</h2><ol type="1"><li>光：Lightmap + Lightporbe</li><li>材质：PBR + IBL</li><li>阴影：Cascade shadow + VSSM</li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-04：渲染：游戏引擎中的渲染实践</title>
      <link href="/2023/07/04/GAMES104/04--%E6%B8%B2%E6%9F%93%EF%BC%9A%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/07/04/GAMES104/04--%E6%B8%B2%E6%9F%93%EF%BC%9A%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="四渲染游戏引擎中的渲染实践">四、渲染：游戏引擎中的渲染实践</h1><h2 id="渲染流水线">4.1 渲染流水线</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707152906090.png" alt="image-20230707152906090" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707152954767.png" alt="image-20230707152954767" style="zoom:80%;" /></p><h2 id="可渲染物体-renderable">4.2 可渲染物体 Renderable</h2><p>shader代码也是Renderable，因为在渲染的时候，数据会和shader代码一起送往GPU，GPU根据shader代码绘制模型数据</p><h3 id="mesh-render-component">4.2.1 Mesh Render Component</h3><ol type="1"><li>游戏世界中的所有东西都是一个Game Object</li><li>只有当GO包含Mesh Render Component的时候，它才会被绘制到屏幕上</li></ol><h3 id="renderable的组成">4.2.2 Renderable的组成</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707160416640.png" alt="image-20230707160416640" style="zoom:80%;" /></p><h3 id="mesh-primitive">4.2.3 Mesh Primitive</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707160508258.png" alt="image-20230707160508258" style="zoom:80%;" /></p><h3 id="vertex和index缓存">4.2.4 Vertex和Index缓存</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707160553704.png" alt="image-20230707160553704" style="zoom:80%;" /></p><h3 id="mesh划分">4.2.5 Mesh划分</h3><ol type="1"><li>整个mesh存储在一个大的buffer</li><li>每个submesh的数据连续存储在buffer中的一小部分</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707161900791.png" alt="image-20230707161900791" style="zoom:80%;" /></p><h3 id="resource-pool">4.2.6 Resource Pool</h3><ol type="1"><li>将mesh、shader、texture分类存放在不同的地方</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707162106594.png" alt="image-20230707162106594" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707162130199.png" alt="image-20230707162130199" style="zoom: 80%;" /></p><h3 id="绘制时根据材质排序">4.2.7 绘制时根据材质排序</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707162737623.png" alt="image-20230707162737623" style="zoom:80%;" /></p><h3 id="gpu-batch-rendering">4.2.8 GPU Batch Rendering</h3><p>同时绘制一批类似的物体</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707163721729.png" alt="image-20230707163721729" style="zoom:80%;" /></p><h2 id="可见性裁剪">4.3 可见性裁剪</h2><h3 id="裁剪单个物体">4.3.1 裁剪单个物体</h3><ol type="1"><li>用视锥、包围盒裁剪单个物体</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707163851617.png" alt="image-20230707163851617" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164054000.png" alt="image-20230707164054000" style="zoom:80%;" /></p><h3 id="层次化视锥裁剪">4.3.2 层次化视锥裁剪</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164118391.png" alt="image-20230707164118391" style="zoom:80%;" /></p><h3 id="bvh的构建和插入">4.3.3 BVH的构建和插入</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164226928.png" alt="image-20230707164226928" style="zoom:80%;" /></p><h3 id="pvs潜在可视集合">4.3.4 PVS：潜在可视集合</h3><ol type="1"><li>将世界划分为不同的区域，只预加载PVS中的数据</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164305703.png" alt="image-20230707164305703" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164406281.png" alt="image-20230707164406281" style="zoom:80%;" /></p><h3 id="gpu-culling">4.3.5 GPU Culling</h3><ol type="1"><li>让GPU判断哪个物体可见，GPU返回一个bit，表示是否可见</li><li>GPU可以先绘制一次深度，通过深度判断是否可见</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707165105476.png" alt="image-20230707165105476" style="zoom:80%;" /></p><h2 id="纹理压缩">4.4 纹理压缩</h2><ol type="1"><li>计算机压缩图片与纹理压缩图片不同，计算机压缩的图片无法支持随机访问，且读取时需要很大计算量</li><li>Block Compression：BC7<ol type="1"><li>以4×4为基本块，记录最亮和最暗的颜色值，每个像素存储一个alpha值，表示这两个颜色通过当前比例混合，可以得到原像素值</li><li>计算消耗很低，可以进行实时压缩</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707165753355.png" alt="image-20230707165753355" style="zoom:80%;" /></p><h2 id="新的模型管线cluster-based-mesh-pipeline">4.5新的模型管线：Cluster-Based Mesh Pipeline</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707171224144.png" alt="image-20230707171224144" style="zoom:80%;" /></p><p>现代的游戏，模型精度越来越高，地图越来越大，数据量越来越多</p><ol type="1"><li>核心思想：将模型划分为小的<strong>面片</strong>，每个面片有固定的三角形数目(如32个/64个)，由GPU创建几何细节</li><li>当面皮的包含的三角形数目固定之后，可以由GPU并行地生成细节</li><li>用相同的算法，基于数据，凭空生成几何细节；并且根据距离相机的远近，选择精度<ol type="1"><li>GPU处理最高效的，就是相同的一个个小块</li></ol></li><li>可以基于面皮，进行可视性裁剪</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707171436864.png" alt="image-20230707171436864" style="zoom:80%;" /></p><ol type="1"><li>UE的Nanite技术就是基于这个思想，进行开发的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707171736708.png" alt="image-20230707171736708" style="zoom:80%;" /></p><h2 id="总结">4.5 总结</h2><ol type="1"><li>游戏引擎的设计，与现代显卡的架构及其相关</li><li>游戏引擎的核心问题，就是mesh、模型、材质这些数据之间的关系</li><li>在绘制的时候，尽可能通过运算，把需要绘制的物体减到越少越好</li><li>越来越多复杂的运算，从CPU移到了GPU，从而减轻CPU的负担</li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-03：总览：如何构建游戏世界</title>
      <link href="/2023/07/03/GAMES104/03--%E6%80%BB%E8%A7%88%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%B8%B8%E6%88%8F%E4%B8%96%E7%95%8C/"/>
      <url>/2023/07/03/GAMES104/03--%E6%80%BB%E8%A7%88%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%B8%B8%E6%88%8F%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="三总览如何构建游戏世界">三、总览：如何构建游戏世界</h1><h2 id="event机制">3.1 Event机制</h2><p>实现不同对象之间的交互：</p><ol type="1"><li><p>unity：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehavior</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span>&#123;</span><br><span class="line">        gameObject.SendMessage(<span class="string">&quot;ApplyDamage&quot;</span>, <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example2</span> : <span class="title">MonoBehavior</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ApplyDamage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span>&#123;</span><br><span class="line">        Debug.Log(damage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unreal：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143147437.png" alt="image-20230707143147437"  /></p></li></ol><p>为了确保时序的严格一致，所有GO要将消息发送给邮局，然后再由邮局在下一个tick的时候发送给不同的GO</p><ol type="1"><li>精彩回放：将每个人的输入保存下来，回放时重新跑一遍</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707144344760.png" alt="image-20230707144344760" style="zoom:80%;" /></p><h2 id="场景管理">3.2 场景管理</h2><p>当场景中的GO过多时，将世界划分为层级结构，每个GO仅与临近格子的GO交互</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143457464.png" alt="image-20230707143457464" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143700974.png" alt="image-20230707143700974" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143746289.png" alt="image-20230707143746289" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143901007.png" alt="image-20230707143901007" style="zoom:80%;" /></p><h2 id="go的绑定">3.3 GO的绑定</h2><p>先进行父节点的tick，然后再进行子节点的tick</p><h2 id="qa">3.4 Q&amp;A</h2><h3 id="如果一个tick时间过长怎么办">3.4.1如果一个tick时间过长怎么办</h3><ol type="1"><li>比如一个爆炸，瞬间产生了与非常多的GO的交互</li><li>此时我们可以将这些GO分批处理，在相邻的几帧分别处理，从而降低某一帧的计算量</li></ol><h3 id="空气墙和其他go有什么区别">3.4.2 空气墙和其他GO有什么区别</h3><ol type="1"><li>空气墙通常是很简单的几何体，如平面、长方体、参数曲面之类的，不会导入复杂mesh表示。</li><li>对于引擎而言，实际上没有太大区别</li></ol><h3 id="tick时渲染线程和逻辑线程怎么同步">3.4.3tick时，渲染线程和逻辑线程怎么同步</h3><ol type="1"><li>tick一般分为两大步：tick_logic、tick_render，分别使用不同的线程计算</li><li>tick_logic负责不同GO之间的交互，tick_render负责准备一些数据，如渲染相关的数据</li><li>一般是先tick_logic，然后再进行tick_render</li></ol><h3 id="空间划分如何处理动态物体">3.4.4 空间划分如何处理动态物体</h3><ol type="1"><li>通常就是树的插入与删除</li><li>一般而言，做引擎的时候会实现两三种经典的空间划分算法，供具体的游戏选择</li></ol><h3 id="物理和动画相互影响时怎么处理">3.4.5物理和动画相互影响时怎么处理</h3><ol type="1"><li>通常是插值的方法</li><li>在刚刚受击的时候，动画的位移影响大一点，越到后面越小</li><li>将动画的位移给到物理系统，让物理系统根据动画和物理进行模拟</li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104-02：总览：引擎架构分层与整体pipeline</title>
      <link href="/2023/07/02/GAMES104/02--%E6%80%BB%E8%A7%88%EF%BC%9A%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%95%B4%E4%BD%93pipeline/"/>
      <url>/2023/07/02/GAMES104/02--%E6%80%BB%E8%A7%88%EF%BC%9A%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%95%B4%E4%BD%93pipeline/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1id="二总览引擎架构分层与整体pipeline">二、总览：引擎架构分层与整体pipeline</h1><h2 id="游戏引擎分层简介-51">2.1 游戏引擎分层简介 5+1</h2><ol type="1"><li>工具层<strong>Tool Layer</strong>：各种编辑器</li><li>功能层<strong>FunctionLayer</strong>：让游戏Visible(渲染)、Movable(物理系统)、Playable(状态机&amp;人机交互)</li><li>资源层<strong>ResourceLayer</strong>：各种数据文件，如图形、几何、声音、视频、场景等等</li><li>核心层<strong>CoreLayer</strong>：引擎的工具箱，如内存管理、容器分配、数学运算等等</li><li>平台层<strong>Platform Layer</strong>：隐藏不同平台的不同接口</li></ol><p>第三方库文件<strong>3nd PartyLibraries</strong>，与各个层都会有关系</p><h2 id="资源层">2.2 资源层</h2><ol type="1"><li>将各种资源文件，转化成引擎统一的格式，如<strong>.uasset</strong></li><li>这一步会将很多冗余信息清除，将文件的格式转化为GPU可以高效绘制的格式</li><li>还需要生成一些资源文件，用于表示不同资源文件之间的关联</li><li>需要负责管理所有资产的<strong>生命周期</strong>：垃圾回收GC、延迟加载</li></ol><h2 id="功能层">2.3 功能层</h2><ol type="1"><li>每经过一个<strong>Tick</strong>，会将整个游戏的逻辑和渲染运行一遍</li><li><strong>tick</strong>会分为两个步骤：<strong>tickLogic()</strong>=&gt; <strong>tickRender()</strong><ol type="1"><li><strong>tickLogic()</strong>：对世界的模拟，如输入输出、物理系统、碰撞检测</li><li><strong>tickRender()</strong>：对世界的渲染</li></ol></li><li>功能层是整个引擎中最多的部分，会跟具体游戏有关联</li><li>功能层的某些模块既可以当作是引擎的模块，也可以当作是游戏的模块，如：相机的移动</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425210150246.png" alt="image-20230425210150246" style="zoom:80%;" /></p><p>多线程计算：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425210452719.png" alt="image-20230425210452719" style="zoom:80%;" /></p><h2 id="核心层">2.4 核心层</h2><ol type="1"><li>数学库：<ol type="1"><li>为了提高效率，因此会在核心层中，重写数学库</li><li>如用SIMD实现矩阵乘法</li></ol></li><li>数据结构和容器：<ol type="1"><li>也是为了提高效率，因此会在核心层中，重写数据结构，而不是直接使用STL容器</li></ol></li><li>内存管理<ol type="1"><li>游戏引擎会提前申请一大块内存，由引擎管理</li><li>三个原则：尽可能将数据放到一起、按顺序访问数据、一次申请/释放一整块数据</li></ol></li><li>一般来说，核心层的代码质量最高，轻易不会修改</li></ol><h2 id="平台层">2.5 平台层</h2><ol type="1"><li><p>掩盖掉不同平台之间的差异</p><ol type="1"><li><p>文件的路径</p></li><li><p>图形学API：用Render Hardware Interface(RHI)隐藏起来</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425211749281.png" alt="image-20230425211749281" style="zoom:80%;" /></p></li><li><p>硬件架构</p></li></ol></li><li><p>平台层的好坏影响了游戏在不同平台上的性能优劣</p></li></ol><h2 id="工具层">2.6 工具层</h2><p>允许所有人用引擎创建游戏</p><ol type="1"><li>保证工具层展示的结果和最终游戏的结果是一样的</li><li>以开发效率为优先，而不是以运行效率为优先</li></ol><p>DCC：Digital Content Creation</p><ol type="1"><li>将其他工具产生的数字资产，转化为引擎统一的数字资产</li></ol><h2 id="为什么要分层架构">2.7 为什么要分层架构</h2><ol type="1"><li>降低问题的复杂度，让每一层只需要考虑自己的任务<ol type="1"><li>越底层的东西越不会轻易改变</li><li>越往上，越灵活；越往下，越稳定</li></ol></li><li>要先将问题划分为不同层次的任务，然后再进行开发</li><li>只允许上层调用下层，下层不能调用上层</li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES104学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake指令合集</title>
      <link href="/2023/06/03/%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/cmake%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/"/>
      <url>/2023/06/03/%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/cmake%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一工程属性相关">一、工程属性相关</h1><h2 id="project">1.1 project</h2><p>指定工程的名字和支持的语言，默认支持所有语言</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO) <span class="comment"># 指定了工程的名字, 并支持所有语言--建议</span></span><br><span class="line"><span class="keyword">PROJECT</span>(HELLO CXX)<span class="comment"># 指定了工程的名字, 并且支持语言为C++</span></span><br><span class="line"><span class="keyword">PROJECT</span>(HELLO C CXX)<span class="comment"># 指定了工程的名字, 并且支持语言为C和C++</span></span><br></pre></td></tr></table></figure><p>该指定隐式定义了两个CMake的变量</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">&lt;projectname&gt;_BINARY_DIR</span><br><span class="line">&lt;projectname&gt;_SOURCE_DIR</span><br></pre></td></tr></table></figure><p>MESSAGE关键字就可以直接使用这两个变量，当前都指向当前的工作目录</p><ol type="1"><li>问题：如果改了工程名，这两个变量名也会改变</li><li>解决：CMake有两个预定义变量：<code>PROJECT_BINARY_DIR</code>和<code>PROJECT_SOURCE_DIR</code>，这两个变量和<code>HELLO_BINARY_DIR</code>，<code>HELLO_SOURCE_DIR</code>是一致的。所以改了工程名也没有关系</li></ol><h2 id="cmake_minimum_required">1.2 cmake_minimum_required</h2><p>指定最低cmake版本</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br></pre></td></tr></table></figure><h1 id="二变量相关">二、变量相关</h1><h2 id="预定义变量">2.1 预定义变量</h2><ol type="1"><li><code>PROJECT_SOURCE_DIR</code>：工程的根目录</li><li><code>PROJECT_BINARY_DIR</code>：运行 cmake命令的目录，通常是<code>$&#123;PROJECT_SOURCE_DIR&#125;/build</code></li><li><code>PROJECT_NAME</code>：返回通过 project 命令定义的项目名称</li><li><code>CMAKE_CURRENT_SOURCE_DIR</code>：当前处理的 CMakeLists.txt所在的路径</li><li><code>CMAKE_CURRENT_BINARY_DIR</code>：target 编译目录</li><li><code>CMAKE_CURRENT_LIST_DIR</code>：CMakeLists.txt 的完整路径</li><li><code>CMAKE_CURRENT_LIST_LINE</code>：当前所在的行</li><li><code>CMAKE_MODULE_PATH</code>：定义自己的 cmake模块所在的路径，<code>SET(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)</code>，然后可以用<code>INCLUDE</code>命令来调用自己的模块</li><li><code>EXECUTABLE_OUTPUT_PATH</code>：重新定义目标二进制可执行文件的存放位置</li><li><code>LIBRARY_OUTPUT_PATH</code>：重新定义目标链接库文件的存放位置</li></ol><h2 id="set">2.2 set</h2><p>显式指定变量</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST main.cpp)    <span class="comment"># 令SRC_LIST变量包含main.cpp</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST main.cpp t1.cpp t2.cpp)<span class="comment"># 令SRC_LIST变量包含main.cpp、t1.cpp、t2.cpp</span></span><br></pre></td></tr></table></figure><p>CMake缓存变量：</p><ol type="1"><li>Normal Variable 普通变量：在一个CMakeList中使用</li><li>Cache Variable 缓存变量：在同一个CMake工程的任何地方都可以使用</li></ol><p>定义缓存变量：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</span><br><span class="line"><span class="keyword">set</span>(BUILD_LIBRARY_TYPE <span class="string">&quot;STATIC&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Linking type for library&quot;</span>)</span><br></pre></td></tr></table></figure><ol type="1"><li><code>variable</code>：变量名称</li><li><code>value</code>：变量值列表</li><li><code>CACHE</code>：cache变量的标志</li><li><code>type</code>：变量类型，取决于变量的值。类型分为：<code>BOOL</code>、<code>FILEPATH</code>、<code>PATH</code>、<code>STRING</code>、<code>INTERNAL</code></li><li><code>docstring</code>：必须是字符串，作为变量概要说明</li><li><code>FORCE</code>：强制选项，强制修改变量值</li></ol><h2 id="set_property">2.3 set_property</h2><p>在给定范围内设置一个对象的属性</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(&lt;scope&gt; [APPEND] [APPEND_STRING] PROPERTY &lt;name&gt; [value...])</span><br><span class="line"><span class="keyword">set_property</span>(CACHE BUILD_LIBRARY_TYPE PROPERTY STRINGS STATIC SHARED)</span><br></pre></td></tr></table></figure><ol type="1"><li><p><code>scope</code>：属性的范围</p><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr><th style="text-align: center;">Scope</th><th style="text-align: center;">Description</th></tr></thead><tbody><tr><td style="text-align: center;">GLOBAL</td><tdstyle="text-align: center;">属性在全局范围内有效，属性名称需唯一</td></tr><tr><td style="text-align: center;">DIRECTORY</td><tdstyle="text-align: center;">在指定目录内有效，可以是相对路径也可以是绝对路径</td></tr><tr><td style="text-align: center;">TARGET</td><td style="text-align: center;">设置指定 TARGET 的属性</td></tr><tr><td style="text-align: center;">SOURCE</td><tdstyle="text-align: center;">属性对应零个或多个源文件。默认情况下，源文件属性仅对添加在同一目录(CMakeLists.txt) 中的目标可见</td></tr><tr><td style="text-align: center;">INSTALL</td><tdstyle="text-align: center;">属性对应零个或多个已安装的文件路径。这些可供CPack 使用以影响部署</td></tr><tr><td style="text-align: center;">TEST</td><td style="text-align: center;">属性对应零个或多个现有测试</td></tr><tr><td style="text-align: center;">CACHE</td><td style="text-align: center;">属性对应零个或多个缓存现有条目</td></tr></tbody></table></li><li><p><code>APPEND | APPEND_STRING</code>：表示属性是可扩展的列表</p><ol type="1"><li>如果设置了，那么后面的 <code>&lt;value1&gt;...</code>将以列表的形式附加到指定属性的后面</li><li><code>APPEND_STRING</code>表示后面的<code>&lt;value1&gt;</code>将以字符串的形式添加到属性的后面</li></ol></li><li><p><code>PROPERTY</code>：标识</p></li><li><p><code>name</code>：属性名称</p></li><li><p><code>value</code>：属性的值</p></li></ol><h2 id="list">2.4 list</h2><p>与SET命令类似，即使列表本身是在父域中定义的，LIST命令也只会在当前域创建新的变量</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(LENGTH &lt;<span class="keyword">list</span>&gt; &lt;output variable&gt;)</span><br><span class="line"><span class="keyword">list</span>(GET &lt;<span class="keyword">list</span>&gt; &lt;elementindex&gt; [&lt;element index&gt; ...]&lt;output variable&gt;)</span><br><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; &lt;element&gt; [&lt;element&gt; ...])</span><br><span class="line"><span class="keyword">list</span>(FIND &lt;<span class="keyword">list</span>&gt; &lt;value&gt; &lt;output variable&gt;)</span><br><span class="line"><span class="keyword">list</span>(INSERT &lt;<span class="keyword">list</span>&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])</span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br><span class="line"><span class="keyword">list</span>(REMOVE_AT &lt;<span class="keyword">list</span>&gt; &lt;index&gt; [&lt;index&gt; ...])</span><br><span class="line"><span class="keyword">list</span>(REMOVE_DUPLICATES&lt;<span class="keyword">list</span>&gt;)</span><br><span class="line"><span class="keyword">list</span>(REVERSE &lt;<span class="keyword">list</span>&gt;)</span><br><span class="line"><span class="keyword">list</span>(SORT &lt;<span class="keyword">list</span>&gt;)</span><br></pre></td></tr></table></figure><ol type="1"><li><code>LENGTH</code>：返回list的长度</li><li><code>GET</code>：返回list中index的element到value中</li><li><code>APPEND</code>：添加新element到list中</li><li><code>FIND</code>：返回list中element的index，没有找到返回-1</li><li><code>INSERT</code> ：将新element插入到list中index的位置</li><li><code>REMOVE_ITEM</code>：从list中删除某个element</li><li><code>REMOVE_AT</code>：从list中删除指定index的element</li><li><code>REMOVE_DUPLICATES</code>：从list中删除重复的element</li><li><code>REVERSE</code>：将list的内容反转</li><li><code>SORT</code>：将list按字母顺序排序</li></ol><h1 id="三配置相关">三、配置相关</h1><h3 id="add_definitions">3.1 add_definitions</h3><p>命令原型：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-DFOO -DBAR ...)</span><br></pre></td></tr></table></figure><p>说明： 在源文件的编译中添加 -D 标志。</p><p>测试用例</p><ol type="1"><li>假设代码中通过USE_MACRO 作为区分是否编译部分模块的代码。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MACRO</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以通过项目中中的CMakeLists.txt中添加如下代码控制代码的开启和关闭。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(USE_MACRO <span class="string">&quot;Build the project using macro&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(USE_MACRO)</span><br><span class="line"><span class="keyword">add_definitions</span>(-D USE_MACRO)</span><br><span class="line"><span class="keyword">endif</span>(USE_MACRO)</span><br></pre></td></tr></table></figure><p>运行构建项目的时候可以添加参数控制宏的开启和关闭。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -D USE_MACRO＝on<span class="comment"># 开启</span></span><br><span class="line">cmake -D USE_MACRO＝off<span class="comment"># 关闭</span></span><br></pre></td></tr></table></figure><p>说明</p><ol type="1"><li>当运行<code>cmake -DUSE_MACRO＝on</code>时，会编译<code>#ifdef USE_MACRO</code> 里的代码模块</li><li>当运行<code>cmake -DUSE_MACRO＝off</code>时，不会编译<code>#ifdef USE_MACRO</code> 里的代码模块。</li></ol><h2 id="option">3.2 option</h2><p>控制编译流程，相当于C语言中的宏条件编译</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(&lt;variable&gt; <span class="string">&quot;&lt;help_text&gt;&quot;</span> [value])</span><br><span class="line"><span class="keyword">option</span>(RENDERING_FORCE_OPENGL <span class="string">&quot;Rendering force opengl.&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><ol type="1"><li><code>variable</code>：定义选项名称</li><li><code>help_text</code>：说明选项的含义</li><li><code>value</code>：定义选项默认状态，一般是OFF或者ON，除去ON之外，其他所有值都为认为是OFF</li></ol><h1 id="四文件结构相关">四、文件结构相关</h1><h2 id="add_subdirectory">4.1 add_subdirectory</h2><p>向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><ul><li><code>EXCLUDE_FROM_ALL</code>函数是将写的目录从编译中排除，如程序中的example</li><li><code>ADD_SUBDIRECTORY(src bin)</code><ul><li>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin目录</li><li>如果不进行 bin目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</li></ul></li></ul><h2 id="add_library">4.2 add_library</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>hello</code>：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li><code>SHARED</code>，动态库 <code>STATIC</code>，静态库</li><li><code>$&#123;LIBHELLO_SRC&#125;</code> ：源文件</li></ul><h2 id="set_target_properties">4.3 set_target_properties</h2><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和API 版本</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="comment"># 重名为hello</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment"># cmake在构建一个新的target时,会尝试清理掉其他使用这个名字的库</span></span><br><span class="line"><span class="comment"># 因为在构建libhello.so时, 就会清理掉 libhello.a</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成共享库</span></span><br><span class="line"><span class="keyword">add_library</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="comment"># 重命名为hello</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(hello PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="include_directores">4.4 include_directores</h2><p>这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">include_directores(/usr/<span class="keyword">include</span>/hello)</span><br></pre></td></tr></table></figure><h2 id="link_directories">4.5 link_directories</h2><p>添加非标准的共享库搜索路径</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(/home/myproject/libs)</span><br></pre></td></tr></table></figure><h2 id="target_link_libraries">4.6 target_link_libraries</h2><p>添加需要链接的共享库，共享库需要在标准路径下</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链接动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main libhello.so)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main libhello.a)</span><br></pre></td></tr></table></figure><h1 id="五文件操作命令">五、文件操作命令</h1><h2 id="file">5.1 file</h2><h3 id="write">5.1.1 WRITE</h3><p>将一则信息写入文件<code>filename</code>中</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(WRITE filename <span class="string">&quot;message towrite&quot;</span>... )</span><br></pre></td></tr></table></figure><ol type="1"><li>如果该文件存在，它会覆盖它</li><li>如果不存在，它会创建该文件</li></ol><h3 id="append">5.1.2 APPEND</h3><p>如同WRITE，区别在于它将信息内容追加到文件末尾</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(APPEND filename <span class="string">&quot;message to write&quot;</span>... )</span><br></pre></td></tr></table></figure><h3 id="read">5.1.3 READ</h3><p>读取文件的内容并将其存入到变量中</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(READ filename variable [LIMIT numBytes] [OFFSEToffset] [HEX])</span><br></pre></td></tr></table></figure><ol type="1"><li>它会在给定的偏移量处开始读取最多<code>numBytes</code>个字节</li><li>如果指定了<code>HEX</code>参数，二进制数据将会被转换成十进制表示形式并存储到变量中</li></ol><h3 id="加密">5.1.4 加密</h3><p>计算出文件内容对应的加密散列</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(&lt;MD5|SHA1|SHA224|SHA256|SHA384|SHA512&gt; filenamevariable)</span><br></pre></td></tr></table></figure><h3 id="string">5.1.6 STRING</h3><p>从文件中解析出ASCII字符串列表并存储在变量中</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(STRINGS filename variable </span><br><span class="line"> [LIMIT_COUNT num]</span><br><span class="line">     [LIMIT_INPUT numBytes] </span><br><span class="line">     [LIMIT_OUTPUT numBytes]</span><br><span class="line">     [LENGTH_MINIMUM numBytes] </span><br><span class="line">     [LENGTH_MAXIMUMnumBytes]</span><br><span class="line">     [NEWLINE_CONSUME] </span><br><span class="line">     [REGEX regex]</span><br><span class="line">     [NO_HEX_CONVERSION])</span><br><span class="line"><span class="comment"># 将输入文件的每行内容存储在变量&quot;myfile&quot;中</span></span><br><span class="line"><span class="keyword">file</span>(STRINGS myfile.txt myfile)</span><br></pre></td></tr></table></figure><ol type="1"><li>文件中的二进制数据将被忽略。回车符(CR)也会被忽略</li><li>也能解析<code>Intel Hex</code>和<code>Motorola S-record</code>文件<ol type="1"><li>这两种文件在读取时会自动转换为二进制格式，可以使用参数<code>NO_HEX_CONVERSION</code>禁用这种自动转换</li></ol></li><li><code>LIMIT_COUNT</code>：设置可返回的最大数量的字符串</li><li><code>LIMIT_INPUT</code>：设置从输入文件中可读取的最大字节数</li><li><code>LIMIT_OUTPUT</code>：设置存储在输出变量中最大的字节数。</li><li><code>LENGTH_MINIMUM</code>：设置返回的字符串的最小长度。小于这个长度的字符串将被忽略。</li><li><code>LENGTH_MAXIMUM</code>：设置返回的字符串的最大长度。大于这个长度的字符串将被切分为长度不大于于最大长度值的子字符串</li><li><code>NEWLINE_CONSUME</code>：允许换行符包含进字符串中而不是截断它们</li><li><code>REGEX</code>：指定了返回的字符串必须匹配的正则表达式的模式典型用法</li></ol><h3 id="glob">5.1.7 GLOB</h3><p>会产生一个由所有匹配globbing表达式的文件组成的列表，并将其保存到变量中</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB variable [RELATIVE path] [globbingexpressions]...)</span><br></pre></td></tr></table></figure><ol type="1"><li><p>Globbing 表达式与正则表达式类似，但更简单</p></li><li><p>如果指定了<code>RELATIVE</code>标记，返回的结果将是与指定的路径相对的路径构成的列表</p></li><li><p>通常不推荐使用GLOB命令来从源码树中收集源文件列表</p><ol type="1"><li>原因是：如果CMakeLists.txt文件没有改变，即便在该源码树中添加或删除文件，产生的构建系统也不会知道何时该要求CMake重新产生构建文件</li></ol></li><li><p>globbing 表达式包括：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*.cxx      <span class="comment">// match all files with extension cxx</span></span><br><span class="line">*.vt?      <span class="comment">// match all files with extension vta,...,vtz</span></span><br><span class="line">f[<span class="number">3</span><span class="number">-5</span>].txt <span class="comment">// match files f3.txt,f4.txt, f5.txt</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="glob_recurse">5.1.8 GLOB_RECURSE</h3><p>与GLOB类似，区别在于它会遍历匹配目录的所有文件以及子目录下面的文件</p><ol type="1"><li>对于属于符号链接的子目录，只有FOLLOW_SYMLINKS指定一或者cmake策略CMP0009没有设置为NEW时，才会遍历这些目录</li><li><code>/dir/*.py</code>：match all Python files in /dir andsubdirectories</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE variable </span><br><span class="line"> [RELATIVE path] </span><br><span class="line">     [FOLLOW_SYMLINKS] </span><br><span class="line">     [globbingexpressions]...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="rename">5.1.9 RENAME</h3><p>将文件系统中的文件或目录移动到目标位置，并自动替换目标位置处的文件或目录</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(RENAME &lt;oldname&gt; &lt;newname&gt;)</span><br></pre></td></tr></table></figure><h3 id="remove">5.1.10 REMOVE</h3><p>删除指定的文件以及子目录下的文件</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(<span class="keyword">REMOVE</span> [file1 ...])</span><br></pre></td></tr></table></figure><h3 id="remove_recurse">5.1.11 REMOVE_RECURSE</h3><p>删除指定的文件及子目录，包括非空目录</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(REMOVE_RECURSE [file1 ...])</span><br></pre></td></tr></table></figure><h3 id="make_directory">5.1.12 MAKE_DIRECTORY</h3><p>在指定目录处创建子目录，如果它们的父目录不存在，也会创建它们的父目录</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> [directory1 directory2 ...])</span><br></pre></td></tr></table></figure><h3 id="relative_path">5.1.13 RELATIVE_PATH</h3><p>推断出指定文件相对于特定目录的路径</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(RELATIVE_PATH variable directory <span class="keyword">file</span>)</span><br></pre></td></tr></table></figure><h3 id="to_cmake_path">5.1.14 TO_CMAKE_PATH</h3><p>将路径转换成cmake风格的路径表达形式</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(TO_CMAKE_PATH path result)</span><br></pre></td></tr></table></figure><h3 id="to_native_path">5.1.15 TO_NATIVE_PATH</h3><p>与TO_CMAKE_PATH类似，但执行反向操作，将cmake风格的路径转换为操作系统特定风格的路径表式形式</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH path result)</span><br></pre></td></tr></table></figure><h3 id="download">5.1.16 DOWNLOAD</h3><p>下载指定URL的资源到指定的文件上</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(DOWNLOAD url <span class="keyword">file</span> </span><br><span class="line"> [INACTIVITY_TIMEOUT timeout]</span><br><span class="line">     [TIMEOUT timeout] </span><br><span class="line">     [STATUS status] </span><br><span class="line">     [LOG log] </span><br><span class="line">     [SHOW_PROGRESS]</span><br><span class="line">     [EXPECTED_MD5 sum])</span><br></pre></td></tr></table></figure><ol type="1"><li>如果指定了<code>LOG</code>参数，将会把下载的日志保存到相应的变量中</li><li>如果指定了<code>STATUS</code>变量，操作的状态信息就会保存在相应的变量中。返回的状态是一个长度为2的列表。第一个元素是操作的返回值。0表示操作过程中无错误发生</li><li>如果指定了<code>TIMEOUT</code>，单位为秒，且必须为整数，那么在指定的时间后，操作将会超时，</li><li><code>INACTIVITY_TIMEOUT</code>指定了操作在处于活动状态超过指定的秒数后，应该停止。如果指定了EXPECTED_MD5，如果操作会检验下载后的文件的实际md5校验和是否与预期的匹配，如果不匹配，操作将会失败，并返回相应的错误码。如果指定了SHOW_PROGRESS，那么进度的信息将会被打印成状态信息直到操作完成。</li></ol><h2 id="get_filename_component">5.2 get_filename_component</h2><p>获取完整文件名的特定部分</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get_filename_component</span>(&lt;variable&gt; &lt;Filename&gt; &lt;mode&gt; [CACHE])</span><br></pre></td></tr></table></figure><ol type="1"><li><code>variable</code>：保存获取部分的变量</li><li><code>Filename</code>：完整的文件名</li><li><code>mode</code>：要获取文件名的哪个部分<ol type="1"><li><code>DIRECTORY</code>：文件所在目录</li><li><code>NAME</code>：没有目录的文件名</li><li><code>EXT</code>：最长的扩展名，即第一个<code>.</code>开始</li><li><code>NAME_WE</code>：没有目录和扩展名的文件名</li><li><code>LAST_EXT</code>：最后一个扩展名</li><li><code>NAME_WLE</code>：没有目录和最后一个扩展名的文件名</li></ol></li><li><code>CACHE</code>：若指定，则获取到的结果变量会放到缓存中</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get_filename_component</span>(&lt;variable&gt; &lt;Filename&gt; &lt;mode&gt; [BASE_DIR &lt;dir&gt;] [CACHE])</span><br></pre></td></tr></table></figure><ol type="1"><li><code>variable</code>：保存获取部分的变量</li><li><code>Filename</code>：完整的文件名</li><li><code>mode</code>：要获取文件名的哪个部分<ol type="1"><li><code>ABSOLUTE</code>：文件的绝对路径</li><li><code>REALPATH</code>：如果为符号连接文件，取得实际的文件的绝对路径。如果不是连接文件，则与ABSOLUTE一样</li></ol></li><li><code>BASE_DIR &lt;dir&gt;</code>：如果指定基本目录，则获取的绝对路径为基本目录+文件名。如果不指定，则基于<code>CMAKE_CURRENT_SOURCE_DIR</code>目录</li><li><code>CACHE</code>：若指定，则获取到的结果变量会放到缓存中</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get_filename_component</span>(&lt;variable&gt; &lt;Filename&gt; PROGRAM [PROGRAM_ARGS &lt;arg_var&gt;] [CACHE])</span><br></pre></td></tr></table></figure><ol type="1"><li><code>variable</code>：保存获取部分的变量</li><li><code>Filename</code>：完整的文件名</li><li><code>PROGRAM_ARGS &lt;arg_var&gt;</code>：FileName的字符串分离为程序名和参数，然后把参数保存在arg_var中</li><li><code>CACHE</code>：若指定，则获取到的结果变量会放到缓存中</li></ol>]]></content>
      
      
      <categories>
          
          <category> 常用指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake学习笔记</title>
      <link href="/2023/06/02/%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/02/%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一cmake的helloworld编译">一、CMake的HelloWorld编译</h1><ol type="1"><li><p>写一个<code>Hello World</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写一个<code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (HELLO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(SRC_LIST main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is BINARY dir&quot;</span> <span class="variable">$&#123;HELLO_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is SOURCE dir&quot;</span> <span class="variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p>控制台输入命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure></li><li><p>然后就生成了一个名为<code>HELLO</code>的VS工程</p></li></ol><h1 id="二cmake语法介绍">二、CMake语法介绍</h1><h2 id="关键字">2.1 关键字</h2><h3 id="project">2.1.1 PROJECT</h3><p>用于指定工程的名字和支持的语言，默认支持所有语言</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO) <span class="comment"># 指定了工程的名字, 并支持所有语言--建议</span></span><br><span class="line"><span class="keyword">PROJECT</span>(HELLO CXX)<span class="comment"># 指定了工程的名字, 并且支持语言为C++</span></span><br><span class="line"><span class="keyword">PROJECT</span>(HELLO C CXX)<span class="comment"># 指定了工程的名字, 并且支持语言为C和C++</span></span><br></pre></td></tr></table></figure><p>该指定隐式定义了两个CMake的变量</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">&lt;projectname&gt;_BINARY_DIR</span><br><span class="line">&lt;projectname&gt;_SOURCE_DIR</span><br></pre></td></tr></table></figure><p>MESSAGE关键字就可以直接使用这两个变量，当前都指向当前的工作目录</p><ol type="1"><li>问题：如果改了工程名，这两个变量名也会改变</li><li>解决：CMake有两个预定义变量：<code>PROJECT_BINARY_DIR</code>和<code>PROJECT_SOURCE_DIR</code>，这两个变量和<code>HELLO_BINARY_DIR</code>，<code>HELLO_SOURCE_DIR</code>是一致的。所以改了工程名也没有关系</li></ol><h3 id="set关键字">2.1.2 SET关键字</h3><p>显式指定变量</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(SRC_LIST main.cpp)    <span class="comment"># 令SRC_LIST变量包含main.cpp</span></span><br><span class="line"><span class="keyword">SET</span>(SRC_LIST main.cpp t1.cpp t2.cpp)<span class="comment"># 令SRC_LIST变量包含main.cpp、t1.cpp、t2.cpp</span></span><br></pre></td></tr></table></figure><h3 id="message关键字">2.1.3 MESSAGE关键字</h3><p>向终端输出用户自定义的信息，主要包含三种信息：</p><ul><li><code>SEND_ERROR</code>：如果产生错误，那么生成过程就会被跳过</li><li><code>SATUS</code>：输出前缀为<code>--</code>的信息</li><li><code>FATAL_ERROR</code>：立即终止所有 cmake 过程.</li></ul><h3 id="add_executable关键字">2.1.4 ADD_EXECUTABLE关键字</h3><p>生成可执行文件</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;SRC_LIST&#125;</span>)<span class="comment">#生成的可执行文件名是hello, 源文件读取变量SRC_LIST中的内容</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp)<span class="comment">#本例中两者含义相同</span></span><br></pre></td></tr></table></figure><p>上述例子可以简化的写成</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h2 id="语法的基本原则">2.2 语法的基本原则</h2><ul><li><p>变量使用<code>$&#123;&#125;</code>方式取值，但是在 <code>IF</code>控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2...)参数使用括弧括起，参数之间使用空格或分号分开</p><ul><li><p>以上面的 <code>ADD_EXECUTABLE</code> 指令为例，如果存在另外一个<code>func.cpp</code> 源文件，就要写成：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp func.cpp)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp;func.cpp)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但推荐全部使用大写指令</p></li><li><p><code>SET(SRC_LIST main.cpp)</code>可以写成<code>SET(SRC_LIST “main.cpp”)</code></p><ul><li>如果源文件名中含有空格，就必须要加双引号</li></ul></li><li><p><code>ADD_EXECUTABLE(hello main)</code>后缀可以不写，它会自动去找<code>.c</code>和<code>.cpp</code></p><ul><li>最好不要这样写，可能会有这两个文件<code>main.cpp</code>和<code>main</code></li></ul></li></ul><h1 id="三内部构建和外部构建">三、内部构建和外部构建</h1><ul><li>上述例子就是内部构建，它生成的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响</li><li>强烈建议使用<strong>外部构建方式</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>注意外部构建的两个变量</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">HELLO_SOURCE_DIR  <span class="comment"># 还是工程路径</span></span><br><span class="line">HELLO_BINARY_DIR  <span class="comment"># 编译路径 也就是 /root/cmake/bulid</span></span><br></pre></td></tr></table></figure><h1 id="四让hello-world看起来更像一个工程">四、让HelloWorld看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a>脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README安装到/usr/share/doc/cmake/</li></ul><h2 id="将目标文件放入构建目录的-bin-子目录">4.1将目标文件放入构建目录的 bin 子目录</h2><p><strong>每个目录下都要有一个CMakeLists.txt</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><ol type="1"><li><p>外层CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure></li><li><p>src下的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure></li></ol><h2 id="add_subdirectory-指令">4.2 ADD_SUBDIRECTORY 指令</h2><p>向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><ul><li><code>EXCLUDE_FROM_ALL</code>函数是将写的目录从编译中排除，如程序中的example</li><li><code>ADD_SUBDIRECTORY(src bin)</code><ul><li>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin目录</li><li>如果不进行 bin目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</li></ul></li></ul><h2 id="更改二进制的保存路径">4.3 更改二进制的保存路径</h2><p>SET指令重新定义<code>EXECUTABLE_OUTPUT_PATH</code>和<code>LIBRARY_OUTPUT_PATH</code>变量，来指定最终的目标二进制的位置</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure><h1 id="五使用cmake进行安装">五、使用CMake进行安装</h1><ul><li>一种是从代码编译后直接 <code>make install</code> 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：<code>make install DESTDIR=/tmp/test</code></li><li>稍微复杂一点可以这样指定目录：<code>./configure –prefix=/usr</code></li></ul></li></ul><h2 id="如何安装helloword">5.1 如何安装HelloWord</h2><p>使用CMAKE一个新的指令：<code>INSTALL</code></p><ul><li>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</li></ul><p>使用CMAKE一个新的变量：<code>CMAKE_INSTALL_PREFIX</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录树结构</span></span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── doc</span><br><span class="line">│   └── hello.txt</span><br><span class="line">├── README</span><br><span class="line">├── runhello.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><h2 id="安装文件copyright和readme">5.2 安装文件COPYRIGHT和README</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src bin)</span><br><span class="line"><span class="keyword">INSTALL</span>(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</span><br></pre></td></tr></table></figure><p><code>FILES</code>：文件</p><p><code>DESTINATION</code>：目标路径，可以写绝对路径，也可以写相对路径</p><ol type="1"><li>相对路径实际路径是：<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/&lt;DESTINATION 定义的路径&gt;</code><ul><li><code>CMAKE_INSTALL_PREFIX</code>默认是在<code>usr/local/</code></li><li><code>cmake -DCMAKE_INSTALL_PREFIX=/usr</code>在cmake的时候指定<code>CMAKE_INSTALL_PREFIX</code>变量的路径</li></ul></li></ol><h2 id="安装脚本runhello.sh">5.3 安装脚本runhello.sh</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(PROGRAMS runhello.sh DESTINATION bin)</span><br></pre></td></tr></table></figure><p><code>PROGRAMS</code>：非目标文件的可执行程序安装(比如脚本之类)</p><ul><li>说明：实际安装到的是<code>/usr/local/bin</code></li></ul><h2 id="安装目录doc中的-hello.txt">5.4 安装目录<code>/doc</code>中的hello.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(DIRECTORY doc/ DESTINATION share/doc/cmake)</span><br></pre></td></tr></table></figure><p><code>DIRECTORY</code> 后面连接的是所在 <code>Source</code>目录的相对路径</p><ol type="1"><li>注意：abc 和 abc/有很大的区别<ol type="1"><li>目录名不以/结尾：这个目录将被安装为目标路径下的</li><li>目录名以/结尾：将这个目录中的内容安装到目标路径</li></ol></li></ol><h2 id="安装过程">5.5 安装过程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h1 id="六静态库和动态库的构建">六、静态库和动态库的构建</h1><p>任务：</p><ol type="1"><li>建立一个静态库和动态库，提供 HelloFunc函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串</li><li>安装头文件与共享库</li></ol><h2 id="静态库和动态库的区别">6.1 静态库和动态库的区别</h2><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="构建实例">6.2 构建实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── lib</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── hello.cpp</span><br><span class="line">    └── hello.h</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hello_H</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最外层的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(lib bin)</span><br></pre></td></tr></table></figure><p>lib中的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="add_library关键字">6.3 ADD_LIBRARY关键字</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>hello</code>：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li><code>SHARED</code>，动态库 <code>STATIC</code>，静态库</li><li><code>$&#123;LIBHELLO_SRC&#125;</code> ：源文件</li></ul><h1 id="七同时构建静态和动态库">七、同时构建静态和动态库</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="set_target_properties关键字">7.1SET_TARGET_PROPERTIES关键字</h2><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和API 版本</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="comment"># 重名为hello</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment"># cmake在构建一个新的target时,会尝试清理掉其他使用这个名字的库</span></span><br><span class="line"><span class="comment"># 因为在构建libhello.so时, 就会清理掉 libhello.a</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成共享库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="comment"># 重命名为hello</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="动态库的版本号">7.2 动态库的版本号</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES VERSION <span class="number">1.2</span> SOVERSION <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol type="1"><li><code>VERSION</code>：动态库版本</li><li><code>SOVERSION</code>：API 版本</li></ol><h2 id="安装共享库和头文件">7.3 安装共享库和头文件</h2><p>本例中我们将 hello的共享库安装到<code>&lt;prefix&gt;/lib</code>目录，</p><p>将 hello.h 安装到<code>&lt;prefix&gt;/include/hello</code>目录</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件放到该目录下</span></span><br><span class="line"><span class="keyword">INSTALL</span>(FILES hello.h DESTINATION <span class="keyword">include</span>/hello)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制，静态库，动态库安装都用TARGETS</span></span><br><span class="line"><span class="comment"># ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span></span><br><span class="line"><span class="keyword">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>注意：安装的时候，指定一下路径，放到系统下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -D CMAKE_INSTALL_PREFIX=/usr ..</span><br></pre></td></tr></table></figure><h1 id="八使用外部共享库和头文件">八、使用外部共享库和头文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最外层的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(/usr/<span class="keyword">include</span>/hello)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.cpp)</span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(hello libhello.so)</span><br></pre></td></tr></table></figure><h2 id="include_directories关键字">8.1 INCLUDE_DIRECTORIES关键字</h2><p>这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(/usr/<span class="keyword">include</span>/hello)</span><br></pre></td></tr></table></figure><h2 id="link_directories关键字">8.2 LINK_DIRECTORIES关键字</h2><p>添加非标准的共享库搜索路径</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LINK_DIRECTORIES</span>(/home/myproject/libs)</span><br></pre></td></tr></table></figure><h2 id="target_link_libraries关键字">8.3TARGET_LINK_LIBRARIES关键字</h2><p>添加需要链接的共享库，共享库需要在标准路径下</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链接动态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main libhello.so)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main libhello.a)</span><br></pre></td></tr></table></figure><h2 id="特殊的环境变量-cmake_include_path-和-cmake_library_path">8.4特殊的环境变量 <code>CMAKE_INCLUDE_PATH</code> 和<code>CMAKE_LIBRARY_PATH</code></h2><ol type="1"><li>注意：这两个是环境变量而不是 cmake变量，可以在linux的bash中进行设置</li><li>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</li><li>我们还可以使用另外一种方式，使用环境变量exportCMAKE_INCLUDE_PATH=/usr/include/hello</li></ol><h2 id="补充生产debug版本的方法">8.5 补充：生产debug版本的方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -D CMAKE_BUILD_TYPE=debug</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用指令</title>
      <link href="/2023/06/01/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/06/01/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>在<code>Blog</code>目录下，执行下列命令，更新网页，并推送到远程：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy &amp;&amp; hexo server</span><br></pre></td></tr></table></figure><p>本地查看效果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>推送到远端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>在<code>_posts</code>中新建页面：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;GAMES101&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能</title>
      <link href="/2023/03/04/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
      <url>/2023/03/04/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一逻辑与推理">一、逻辑与推理</h1><ol type="1"><li><strong>符号主义</strong>人工智能中，所有概念均可通过人类可理解的“符号”及符号之间的关系来表示</li><li><strong>符号主义</strong>人工智能方法基于如下假设：<ol type="1"><li>可通过逻辑方法来对符号及其关系进行计算，实现逻辑推理，辨析符号所描述内容是否正确</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308101352133.png" alt="image-20230308101352133" style="zoom:80%;" /></p><h2 id="命题逻辑-proposition-logic">1.1 命题逻辑 proposition logic</h2><h3 id="定义">1.1.1 定义</h3><ol type="1"><li><p><strong>命题逻辑</strong>：是应用一套形式化规则对以符号表示的描述性陈述进行推理的系统</p></li><li><p><strong>原子命题</strong>：一个或真或假的描述性陈述被称为原子命题</p><ol type="1"><li>对原子命题的内部结构不做任何解析</li></ol></li><li><p><strong>复合命题(compoundproposition)</strong>：若干原子命题可通过逻辑运算符来构成复合命题</p></li><li><p><strong>命题联结词(connectives)</strong>：通过命题联结词对已有命题进行组合，得到新命题</p><ol type="1"><li>通过命题联结词得到的命题被称为复合命题</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308103020259.png" alt="image-20230308103020259" style="zoom:80%;" /></p></li><li><p>通过<strong>真值表</strong>来计算复合命题的真假</p><ol type="1"><li><strong>p=&gt;q</strong>是一个蕴含关系，表示<strong>p∈q</strong></li><li>如果<strong>p=False</strong>，则<strong>p=&gt;q</strong>恒为<strong>True</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308103137719.png" alt="image-20230308103137719" style="zoom:80%;" /></p></li></ol><h3 id="逻辑等价">1.1.2 逻辑等价</h3><ol type="1"><li><strong>逻辑等价：</strong>给定命题p和命题q，如果p和q在所有情况下都具有同样真假结果，那么p和q在逻辑上等价，即<strong>p≡q</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308103501121.png" alt="image-20230308103501121" style="zoom:80%;" /></p><h3 id="推理规则">1.1.3 推理规则</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308104140298.png" alt="image-20230308104140298" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308104247799.png" alt="image-20230308104247799" style="zoom:80%;" /></p><blockquote><p>示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308105126317.png" alt="image-20230308105126317" style="zoom:80%;" /></p></blockquote><h3 id="命题范式">1.1.4 命题范式</h3><p><strong>范式（normalform)</strong>：把命题公式化归为一种标准的形式</p><ol type="1"><li><p>范式最大的作用是可以进行两个命题的等价判定</p></li><li><p><strong>析取范式</strong>：有限个简单合取式构成的析取式</p></li><li><p><strong>合取范式</strong>：有限个简单析取式构成的合取式</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308105600298.png" alt="image-20230308105600298" style="zoom:80%;" /></p></li><li><p>一个析取范式是不成立的，当且仅当：它的每个简单合取式都不成立</p></li><li><p>一个合取范式是成立的，当且仅当：它的每个简单析取式都是成立的</p></li><li><p>任一命题公式都存在着与之等值的析取范式与合取范式</p><ol type="1"><li>注意：命题公式的析取范式与合取范式都不是唯一的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308105751140.png" alt="image-20230308105751140" style="zoom:80%;" /></p></li></ol><h2 id="谓词逻辑">1.2 谓词逻辑</h2><h3 id="个体与谓词">1.2.1 个体与谓词</h3><ol type="1"><li><p><strong>个体</strong>：个体是指所研究领域中可以独立存在的具体或抽象的概念</p></li><li><p><strong>谓词</strong>：谓词是用来刻画个体属性或者描述个体之间关系存在性的元素，其值为真或为假</p><ol type="1"><li>包含一个参数的谓词称为<strong>一元谓词</strong>，表示一元关系</li><li>包含多个参数的谓词称为<strong>多元谓词</strong>，表示个体之间的多元关系</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308110626463.png" alt="image-20230308110626463" style="zoom:80%;" /></p></li><li><p>函数与谓词的区别：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308111153776.png" alt="image-20230308111153776" style="zoom:80%;" /></p></li></ol><h3 id="量词">1.2.2 量词</h3><ol type="1"><li><strong>全称量词</strong>(universal quantifier,<strong>∀</strong>)：<strong>∀xP(x)</strong>表示定义域中的所有个体具有性质P</li><li><strong>存在量词</strong>(existential quantifier,<strong>∃</strong>)：<strong>∃xP(x)</strong>表示定义域中存在一个个体或若干个体具有性质P</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308111508713.png" alt="image-20230308111508713" style="zoom:80%;" /></p><h3 id="变元">1.2.3 变元</h3><ol type="1"><li><p><strong>约束变元</strong>：在全称量词或存在量词的约束条件下的变量符号称为约束变元</p></li><li><p><strong>自由变元</strong>：不受全称量词或存在量词约束的变量符号称为自由变元</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308111625830.png" alt="image-20230308111625830" style="zoom:80%;" /></p></li><li><p>在约束变元相同的情况下，量词的运算满足<strong>分配律</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308112024333.png" alt="image-20230308112024333" style="zoom:80%;" /></p></li><li><p>当公式中存在多个量词时，若多个量词都是全称量词或者都是存在量词，则量词的位置可以互换；若多个量词中既有全称量词又有存在量词，则量词的位置不可以随意互换</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308112056373.png" alt="image-20230308112056373" style="zoom:80%;" /></p></li></ol><h3 id="项与原子谓词公式">1.2.4 项与原子谓词公式</h3><ol type="1"><li>项：项是描述对象的逻辑表达式，被递归地定义为：<ol type="1"><li>常量符号和变量符号是项；</li><li>若<span class="math inline">\(f(x_1,x_2,⋯,x_n)\)</span>是<spanclass="math inline">\(n\)</span>元函数符号，<spanclass="math inline">\(t_1,t_2,⋯,t_n\)</span>是项，则<spanclass="math inline">\(f(t_1,t_2,⋯,t_n)\)</span>是项；</li><li>有限次数地使用上述规则产生的符号串是项。</li></ol></li><li>原子谓词公式：<ol type="1"><li>若<span class="math inline">\(P(x_1,x_2,⋯,x_n)\)</span>是<spanclass="math inline">\(n\)</span>元谓词，<spanclass="math inline">\(t_1,t_2,⋯,t_n\)</span>是项，则称<spanclass="math inline">\(P(t_1,t_2,⋯,t_n)\)</span>是原子谓词公式，简称原子公式</li></ol></li></ol><h3 id="合式公式">1.2.5 合式公式</h3><p>合式公式是由<strong>逻辑联结词</strong>和<strong>原子公式</strong>构成的用于陈述事实的复杂语句，又称<strong>谓词公式</strong>，由以下规则定义：</p><ol type="1"><li>命题常项、命题变项、原子谓词公式是合式公式</li><li>如果A是合式公式，则¬A也是合式公式</li><li>如果A和B是合式公式，则A∧B、A∨B、A→B 、B→A、A⟷B 都是合式公式</li><li>如果A是合式公式，x是个体变项，则(∃x)A(x) 和(∀x)A(x)也是合式公式</li><li>有限次数地使用上述规则构成的表达式是合式公式</li></ol><h3 id="推理规则-1">1.2.6 推理规则</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308112437690.png" alt="image-20230308112437690" style="zoom:80%;" /></p><h3 id="专家系统的构成">1.2.7 专家系统的构成</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308113530071.png" alt="image-20230308113530071" style="zoom:80%;" /></p><h2 id="知识图谱">1.3 知识图谱</h2><h3 id="基本概念">1.3.1 基本概念</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308114245048.png" alt="image-20230308114245048" style="zoom: 80%;" /></p><ol type="1"><li><strong>知识图谱</strong>可视为包含多种关系的图<ol type="1"><li>在图中，每个<strong>节点</strong>是一个实体（如人名、地名、事件和活动等）</li><li>任意两个节点之间的<strong>边</strong>表示这两个节点之间存在的关系</li><li>一般而言，可将知识图谱中<strong>任意两个相连节点及其连接边</strong>表示成一个三元组（triplet）,即 <strong>(left_node, relation, right_node)</strong></li></ol></li><li>知识图谱中存在连线的两个实体可表达为形如<strong>&lt;left_node,relation, right_node &gt;</strong>的三元组形式<ol type="1"><li>这种三元组也可以表示为一阶逻辑<strong>(first order logic,FOL)</strong>的形式，从而为基于知识图谱的推理创造了条件</li><li>例如从&lt;奥巴马，出生地，夏威夷&gt;和&lt;夏威夷，属于，美国&gt;两个三元组，可推理得到&lt;奥巴马，国籍，美国&gt;</li></ol></li></ol><h3 id="知识图谱推理">1.3.2 知识图谱推理</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308114752378.png" alt="image-20230308114752378" style="zoom:80%;" /></p><ol type="1"><li>可利用<strong>一阶谓词</strong>来表达刻画知识图谱中节点之间存在的关系<ol type="1"><li>如图中形如&lt;James,Couple,David&gt;的关系可用一阶逻辑的形式来描述，即Couple(James,David)</li><li>Couple(x,y)是一阶谓词，Couple是图中实体之间具有的关系，x和y是谓词变量</li><li>从图中已有关系可推知David和Ann具有父女关系，但这一关系在图中初始图(无红线)中并不存在，是需要推理的目标</li></ol></li></ol><h3 id="归纳学习">1.3.3 归纳学习</h3><ol type="1"><li><strong>归纳逻辑程序设计ILP</strong>(Inductive LogicProgramming)：是机器学习和逻辑程序设计交叉领域的研究内容</li><li>ILP使用一阶谓词逻辑进行知识表示，通过修改和扩充逻辑表达式对现有知识归纳，完成推理任务</li><li>作为ILP的代表性方法，<strong>FOIL</strong>(First Order InductiveLearner)通过<strong>序贯覆盖</strong>实现规则推理</li></ol><h3 id="一阶推导学习-foil">1.3.4 一阶推导学习 FOIL</h3><blockquote><p><strong>FOIL</strong>：First Order Inductive Learner</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308121022320.png" alt="image-20230308121022320" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308121146128.png" alt="image-20230308121146128" style="zoom:80%;" /></p><ol type="1"><li><p><strong>目标谓词：</strong><code>Father(x, y)</code></p></li><li><p><strong>正例</strong>：目标谓词只有一个正例<code>Father(David, Mike)</code>。</p></li><li><p><strong>反例</strong>：在知识图谱中一般不会显式给出，但可从知识图谱中构造出来</p><ol type="1"><li>如从知识图谱中已经知道<code>Couple(David, James)</code>成立，则<code>Father(David, James)</code>可作为目标谓词P的一个反例，记为<code>¬Father (David, James)</code>。</li><li>只能在已知两个实体的关系且确定其关系与目标谓词相悖时，才能将这两个实体用于构建目标谓词的反例</li><li>而不能在不知两个实体是否满足目标谓词前提下将它们来构造目标谓词的反例</li></ol></li><li><p><strong>背景知识</strong>：知识图谱中目标谓词以外的其他谓词实例化结果，如<code>Sibling(Ann, Mike)</code></p></li><li><p><strong>推理思路：</strong>从一般到特殊，逐步给目标谓词添加前提约束谓词，直到所构成的推理规则<strong>不覆盖任何反例</strong></p><ol type="1"><li><strong>从一般到特殊</strong>：对目标谓词或前提约束谓词中的变量赋予具体值</li><li>如将<code>(∀x)(∀y)(∀z)(Mother(z, y)∧Couple(x,z) → Father(x, y))</code>这一推理规则所包含的目标谓词<code>Father(x, y)</code>中<code>x</code>和<code>y</code>分别赋值为<code>David</code>和<code>Ann</code>，进而进行推理</li></ol></li><li><p>如何选择约束谓词：<strong>信息增益值最大</strong></p><ol type="1"><li>要求添加该谓词后，可以覆盖的正例更多，负例更少</li><li>直到只覆盖正例，不覆盖负例</li></ol></li><li><p><strong>信息增益值：描述了添加某个谓词后，<spanclass="math inline">\(\frac{正例}{正例+反例}\)</span>的比例变化</strong><span class="math display">\[FOIL\_Gain=\hat{m_+}(\log_2\frac{\hat{m_+}}{\hat{m_+}+\hat{m_-}}-\log_2\frac{m_+}{m_++m_-})\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308115343756.png" alt="image-20230308115343756" style="zoom:80%;" /></p></li></ol><blockquote><p>示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308115624013.png" alt="image-20230308115624013" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308115903721.png" alt="image-20230308115903721" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120227606.png" alt="image-20230308120227606" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120240453.png" alt="image-20230308120240453" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120259169.png" alt="image-20230308120259169" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120313852.png" alt="image-20230308120313852" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120348725.png" alt="image-20230308120348725" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120452139.png" alt="image-20230308120452139" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120757276.png" alt="image-20230308120757276" style="zoom:80%;" /></p></blockquote><h3 id="路径排序推理-pra">1.3.5 路径排序推理 PRA</h3><blockquote><p><strong>Path Ranking Algorithm</strong></p></blockquote><ol type="1"><li><strong>基本思想：将实体之间的关联路径作为特征，来学习目标关系的分类器</strong></li><li>工作流程主要分为三步：<ol type="1"><li><strong>特征抽取</strong>：生成并选择路径特征集合<ol type="1"><li>生成路径的方式有：随机游走、广度优先搜索、深度优先搜索等</li></ol></li><li><strong>特征计算</strong>：计算每个训练样例的特征值<spanclass="math inline">\(𝑃(𝑠→𝑡;𝜋_𝑗)\)</span><ol type="1"><li>该特征值可以是：从实体节点<spanclass="math inline">\(𝑠\)</span>出发，通过关系路径<spanclass="math inline">\(𝜋_𝑗\)</span>到达实体节点<spanclass="math inline">\(𝑡\)</span>的概率；</li><li>也可以是：<strong>布尔值，表示实体<spanclass="math inline">\(𝑠\)</span>到实体<spanclass="math inline">\(𝑡\)</span>之间是否存在路径<spanclass="math inline">\(𝜋_𝑗\)</span>；</strong></li><li>还可以是：实体<span class="math inline">\(𝑠\)</span>和实体<spanclass="math inline">\(𝑡\)</span>之间路径出现频次、频率等</li></ol></li><li><strong>分类器训练</strong>：根据训练样例的特征值，为目标关系训练分类器<ol type="1"><li>当训练好分类器后，即可将该分类器用于推理两个实体之间是否存在目标关系</li></ol></li></ol></li></ol><blockquote><p>特征向量的含义：布尔值，表示实体<spanclass="math inline">\(𝑠\)</span>到实体<spanclass="math inline">\(𝑡\)</span>之间是否存在路径<spanclass="math inline">\(𝜋_𝑗\)</span>；</p><ol type="1"><li>[Couple→Mother，Father→Mother<sup>-1</sup>，Mother→Sibling，Couple→Father]</li></ol><p>如(David,Ann)：只可以通过Couple→Mother这条路径链接，因此特征向量是[1, 0, 0,0]</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315102434738.png" alt="image-20230315102434738" style="zoom:80%;" /></p><h3 id="基于分布式的知识推理">1.3.6 基于分布式的知识推理</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315102756553.png" alt="image-20230315102756553" style="zoom:80%;" /></p><h3 id="马尔可夫逻辑网络">1.3.7 马尔可夫逻辑网络</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315102819660.png" alt="image-20230315102819660" style="zoom:80%;" /></p><h2 id="不考1.4-因果推理">(不考)1.4 因果推理</h2><ol type="1"><li><p>传统以统计建模为核心的推理手段：AI学习联合分布的概率</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315103929751.png" alt="image-20230315103929751" style="zoom:80%;" /></p></li><li><p>因果推理：改变控制变量的取值后，会导致结果如何变化</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315104033233.png" alt="image-20230315104033233" style="zoom:80%;" /></p></li></ol><h3 id="不考1.4.1-三种因果推理">(不考)1.4.1 三种因果推理</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315105108127.png" alt="image-20230315105108127" style="zoom:80%;" /></p><h3 id="不考1.4.2-因果推理的主要模型">(不考)1.4.2因果推理的主要模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315105456694.png" alt="image-20230315105456694" style="zoom:80%;" /></p><h3 id="不考1.4.3-结构因果模型">(不考)1.4.3 结构因果模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110036244.png" alt="image-20230315110036244" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315105725408.png" alt="image-20230315105725408" style="zoom:80%;" /></p><h2 id="不考1.5-因果图模型">(不考)1.5 因果图模型</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110335591.png" alt="image-20230315110335591" style="zoom:80%;" /></p><h3 id="不考1.5.1-联合概率分布">(不考)1.5.1 联合概率分布</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110202244.png" alt="image-20230315110202244" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110432875.png" alt="image-20230315110432875" style="zoom:80%;" /></p><h3 id="不考1.5.2-链">(不考)1.5.2 链</h3><blockquote><p><strong>中间节点<spanclass="math inline">\(Z\)</span>一旦给定，两端的节点<spanclass="math inline">\(X,Y\)</span>条件独立</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110902668.png" alt="image-20230315110902668" style="zoom:80%;" /></p><h3 id="不考1.5.3-分连">(不考)1.5.3 分连</h3><blockquote><p><strong>中间节点<spanclass="math inline">\(Z\)</span>一旦给定，两端的节点<spanclass="math inline">\(X,Y\)</span>条件独立</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315111057252.png" alt="image-20230315111057252" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315111105731.png" alt="image-20230315111105731" style="zoom:80%;" /></p><h3 id="不考1.5.4-汇连">(不考)1.5.4 汇连</h3><blockquote><p><strong>中间节点<spanclass="math inline">\(Z\)</span>给定时，两端的节点<spanclass="math inline">\(X,Y\)</span>条件相关</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315111519449.png" alt="image-20230315111519449" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315111527551.png" alt="image-20230315111527551" style="zoom:80%;" /></p><h3 id="不考1.5.5-d-分离">(不考)1.5.5 D-分离</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315112208471.png" alt="image-20230315112208471" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315112216700.png" alt="image-20230315112216700" style="zoom:80%;" /></p><h3 id="不考1.5.6-干预的因果效应">(不考)1.5.6 干预的因果效应</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315112519863.png" alt="image-20230315112519863" style="zoom:80%;" /></p><h3 id="不考1.5.7-因果效应差">(不考)1.5.7 因果效应差</h3><blockquote><p>因果效应差越大，表示该变量对结果的因果效应越大</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315112809443.png" alt="image-20230315112809443" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315113312157.png" alt="image-20230315113312157" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315113138273.png" alt="image-20230315113138273" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315113700564.png" alt="image-20230315113700564" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315113745900.png" alt="image-20230315113745900" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114236896.png" alt="image-20230315114236896" style="zoom:80%;" /></p><h3 id="不考1.5.8-反事实模型">(不考)1.5.8 反事实模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114453721.png" alt="image-20230315114453721" style="zoom:80%;" /></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114501042.png" alt="image-20230315114501042" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114507047.png" alt="image-20230315114507047" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114515725.png" alt="image-20230315114515725" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114522281.png" alt="image-20230315114522281" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114533679.png" alt="image-20230315114533679" style="zoom:80%;" /></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114651422.png" alt="image-20230315114651422" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114705326.png" alt="image-20230315114705326" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114716032.png" alt="image-20230315114716032" style="zoom:80%;" /></p><h1 id="二搜索与求解">二、搜索与求解</h1><h2 id="搜索算法基础">2.1 搜索算法基础</h2><h3 id="搜索算法的形式化描述">2.1.1 搜索算法的形式化描述</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619174409045.png" alt="image-20230619174409045" style="zoom:80%;" /></p><ol type="1"><li><strong>状态</strong>：对智能体和环境当前情形的描述<ol type="1"><li>例如，在最短路径问题中，城市可作为状态</li><li>将原问题城市对应的状态称为初始状态</li></ol></li><li><strong>动作</strong>：从当前时刻所处状态转移到下一时刻所处状态所进行操作<ol type="1"><li>一般而言这些操作都是离散的</li></ol></li><li><strong>状态转移</strong>：智能体选择了一个动作之后，其所处状态的相应变化</li><li><strong>路径/代价</strong>：一个状态序列。该状态序列被一系列操作所连接<ol type="1"><li>如从A到K所形成的路径。</li></ol></li><li><strong>目标测试</strong>：评估当前状态是否为所求解的目标状态</li></ol><h3 id="评价指标">2.1.2 评价指标</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315120043120.png" alt="image-20230315120043120" style="zoom:80%;" /></p><h3 id="树搜索">2.1.3 树搜索</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315120320565.png" alt="image-20230315120320565" style="zoom:80%;" /></p><h3 id="剪枝搜索">2.1.4 剪枝搜索</h3><ol type="1"><li><p>主动放弃一些后继节点，可以提高搜索效率，而不会影响最终的搜索效果</p><ol type="1"><li>如删除已访问节点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315120803013.png" alt="image-20230315120803013" style="zoom:80%;" /></p></li></ol><h2 id="启发式搜索">2.2 启发式搜索</h2><h3 id="贪婪最佳优先搜索-greedy-best-first-search">2.2.1贪婪最佳优先搜索 Greedy best-first search</h3><p><strong>评价函数<code>f(n)</code> =启发函数<code>h(n)</code></strong></p><ol type="1"><li><code>f(n)</code>：评价函数，判定下一个节点是谁</li><li><code>h(n)</code>：启发函数，预估完成任务的最小代价</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315121011296.png" alt="image-20230315121011296" style="zoom:80%;" /></p><h3 id="a算法">2.2.2 A*算法</h3><h4 id="a算法的定义">2.2.2.1 A*算法的定义</h4><p><strong>评价函数<code>f(n) = g(n) + h(n)</code></strong></p><ol type="1"><li><code>f(n)</code>：评价函数，判定下一个节点是谁</li><li><code>h(n)</code>：启发函数，预估完成任务的最小代价</li><li><code>g(n)</code>：从起始节点到当前节点的代价</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322100826151.png" alt="image-20230322100826151" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322101907861.png" alt="image-20230322101907861" style="zoom:80%;" /></p><h4 id="不考2.2.2.2-a算法的性能分析">(不考)2.2.2.2 A*算法的性能分析</h4><ol type="1"><li><p>A*算法的完备性、最优性，取决于搜索问题和启发函数的性质</p><ol type="1"><li>完备性：一定能找到解</li><li>最优性：解最优</li></ol></li><li><p>相关定义</p><ol type="1"><li><code>f(n)</code>：评价函数，判定下一个节点是谁</li><li><code>h(n)</code>：启发函数，预估完成任务的最小代价</li><li><code>g(n)</code>：从起始节点到当前节点的代价</li><li><code>c(n,a,n')</code>：从节点n，执行动作a，到达节点n'的单步代价</li><li><code>h*(n)</code>：从节点n到终点的实际最小代价</li></ol></li><li><p>启发函数<code>h(n)</code>需要满足的性质：</p><ol type="1"><li><p><strong>可容性admissible</strong>：<code>h(n) ≤ h*(n)</code>，预估代价不超过实际代价</p></li><li><p><strong>一致性consistency</strong>：<code>h(n) ≤ c(n,a,n') + h(n')</code>，从当前节点直接到达终点的代价，不超过到达下一节点，然后再到达终点的代价</p></li><li><p><strong>满足一致性，一定满足可容性</strong>：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322102849176.png" alt="image-20230322102849176" style="zoom:80%;" /></p></li></ol></li></ol><h4 id="不考2.2.2.3-a算法的完备性">(不考)2.2.2.3 A*算法的完备性</h4><ol type="1"><li><strong>完备性</strong>：如果在起始节点和终止节点之间有路径存在，那么一定可以得到解。得不到解一定说明没有解存在</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322103132962.png" alt="image-20230322103132962" style="zoom:80%;" /></p><h4 id="不考2.2.2.4-a算法的最优性">(不考)2.2.2.4 A*算法的最优性</h4><ol type="1"><li>树搜索算法：如果启发函数满足<strong>可容性</strong>，则A*算法满足<strong>最优性</strong></li><li>图搜索算法：如果启发函数满足<strong>一致性</strong>，则A*算法满足<strong>最优性</strong></li><li>对于任意一个状态<strong>t</strong>，它第一次被加入搜索树时的路径必然是最短路径</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322103300921.png" alt="image-20230322103300921" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322104535118.png" alt="image-20230322104535118" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322104917057.png" alt="image-20230322104917057" style="zoom:80%;" /></p><h2 id="对抗搜索博弈搜索">2.3 对抗搜索/博弈搜索</h2><blockquote><p>Adversarial / Game Search</p></blockquote><ol type="1"><li><p>在一个竞争的环境中，智能体(agents)之间通过竞争实现相反的利益，一方<strong>最大化</strong>这个利益，另外一方<strong>最小化</strong>这个利益</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322105746718.png" alt="image-20230322105746718" style="zoom:80%;" /></p></li><li><p>分为三种搜索策略</p><ol type="1"><li><strong>最小最大搜索(MinimaxSearch)</strong>：最小最大搜索是在对抗搜索中最为基本的一种让玩家来计算最优策略的方法</li><li><strong>Alpha-Beta剪枝搜索(PruningSearch)</strong>：一种对最小最大搜索进行改进的算法，即在搜索过程中可剪除无需搜索的分支节点，且不影响搜索结果。</li><li><strong>蒙特卡洛树搜索(Monte-Carlo TreeSearch)</strong>：通过采样而非穷举方法来实现搜索</li></ol></li><li><p>本书的讨论范围：</p><ol type="1"><li>确定的、全局可观察的、竞争对手轮流行动、零和游戏</li></ol></li><li><p>形式化描述：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322105943064.png" alt="image-20230322105943064" style="zoom:80%;" /></p></li></ol><h3 id="最小最大搜索-minimax">2.3.1 最小最大搜索 Minimax</h3><blockquote><ol type="1"><li>当前收益：<code>minimax(s)</code></li><li>选择动作<code>a</code>后的可能收益：<code>minimax(result(s,a))</code></li></ol></blockquote><ol type="1"><li>如果为终止状态：返回当前状态的得分<code>utility(s)</code></li><li>如果当前玩家为MAX：选择可能收益最大的动作，返回执行该动作后的可能收益</li><li>如果当前玩家为MIN：选择可能收益最小的动作，返回执行该动作后的可能收益</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322110053522.png" alt="image-20230322110053522" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619180342828.png" alt="image-20230619180342828" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 玩家MAX行动下, 当前的最优动作ans</span></span><br><span class="line"><span class="function">Action <span class="title">MinimaxDecision</span><span class="params">(State s)</span></span>&#123;</span><br><span class="line">    Action ans = null;</span><br><span class="line">    Value maxValue = -INF;</span><br><span class="line">    <span class="keyword">for</span>(a in <span class="built_in">Action</span>(s))&#123;</span><br><span class="line">        State nextState = <span class="built_in">result</span>(s,a);</span><br><span class="line">        Value nextValue = <span class="built_in">MinValue</span>(nextState);</span><br><span class="line">        <span class="keyword">if</span>(maxValue &lt; nextValue)&#123;</span><br><span class="line">            ans = a;</span><br><span class="line">            maxValue = nexValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 玩家MAX行动下, 当前状态的得分 v = minimax(s, MAX)</span></span><br><span class="line"><span class="function">Value <span class="title">MaxValue</span><span class="params">(State s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == terminal_state) <span class="keyword">return</span> <span class="built_in">utility</span>(s);</span><br><span class="line">    Value v = -INF;</span><br><span class="line">    <span class="keyword">for</span>(a in <span class="built_in">Action</span>(s))&#123;</span><br><span class="line">        State nextState = <span class="built_in">result</span>(s,a);</span><br><span class="line">        Value nextValue = <span class="built_in">MinValue</span>(nextState);</span><br><span class="line">        v = <span class="built_in">max</span>(v, nextValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 玩家MIN行动下, 当前状态的得分 v = minimax(s, MINs)</span></span><br><span class="line"><span class="function">Value <span class="title">MinValue</span><span class="params">(State s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == terminal_state) <span class="keyword">return</span> <span class="built_in">utility</span>(s);</span><br><span class="line">    Value v = INF;</span><br><span class="line">    <span class="keyword">for</span>(a in <span class="built_in">Action</span>(s))&#123;</span><br><span class="line">        State nextState = <span class="built_in">result</span>(s,a);</span><br><span class="line">        Value nextValue = <span class="built_in">MaxValue</span>(nextState);</span><br><span class="line">        v = <span class="built_in">min</span>(v, nextValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="alpha-beta剪枝搜索">2.3.2 Alpha-Beta剪枝搜索</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322111238257.png" alt="image-20230322111238257" style="zoom:80%;" /></p><blockquote><p>MIN节点<span class="math inline">\(m\)</span>：alpha剪枝</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322111253530.png" alt="image-20230322111253530" style="zoom:80%;" /></p><blockquote><p>MAX节点<span class="math inline">\(m\)</span>：beta剪枝</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322111434761.png" alt="image-20230322111434761" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322111745307.png" alt="image-20230322111745307" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619180431404.png" alt="image-20230619180431404" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619180437563.png" alt="image-20230619180437563" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 玩家MAX行动下, 当前的最优动作ans</span></span><br><span class="line">&#123;Value,Action&#125; <span class="built_in">AlphaBetaDecision</span>(State s)&#123;</span><br><span class="line">    Action ans;</span><br><span class="line">    Value v;</span><br><span class="line">    &#123;v, ans&#125; = <span class="built_in">MaxValue</span>(s, -INF, INF);</span><br><span class="line">    <span class="keyword">return</span> &#123;v, ans&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家MIN行动下, 当前状态的得分 v = minimax(s, MIN)和最优动作 ans</span></span><br><span class="line">&#123;Value,Action&#125; <span class="built_in">MuValue</span>(State s, Value α, Value β)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == terminal_state) <span class="keyword">return</span> &#123;<span class="built_in">utility</span>(s), null&#125;;</span><br><span class="line">    Value v = INF;</span><br><span class="line">    Action ans = null;</span><br><span class="line">    <span class="keyword">for</span>(a in <span class="built_in">Action</span>(s))&#123;</span><br><span class="line">        State nextState = <span class="built_in">result</span>(s,a);</span><br><span class="line">        &#123;vv, aa&#125; = <span class="built_in">MaxValue</span>(nextState, α, β);</span><br><span class="line">       <span class="keyword">if</span>(vv &lt; v)&#123;</span><br><span class="line">            v = vv; </span><br><span class="line">            ans = aa;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        β = <span class="built_in">min</span>(β, v);</span><br><span class="line">        <span class="keyword">if</span>(α &gt; β) <span class="keyword">return</span> &#123;v, ans&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>算法性能：</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322112244614.png" alt="image-20230322112244614" style="zoom:80%;" /></p><h2 id="蒙特卡洛树搜索">2.4 蒙特卡洛树搜索</h2><h3 id="问题定义">2.4.1 问题定义</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114448673.png" alt="image-20230322114448673" style="zoom:80%;" /></p><h3 id="相关概念">2.4.2 相关概念</h3><blockquote><p>核心：降低悔值函数的取值</p><p>悔值函数：期望T次操作的得分 - 实际T次操作的得分</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322112850905.png" alt="image-20230322112850905" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114532149.png" alt="image-20230322114532149" style="zoom:80%;" /></p><h3 id="贪心算法策略">2.4.3 贪心算法策略</h3><blockquote><p>在第t步，选择过去t-1步，平均的得分最高的赌博机</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114605324.png" alt="image-20230322114605324" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114641449.png" alt="image-20230322114641449" style="zoom:80%;" /></p><h3 id="ε-贪心算法">2.4.4 ε-贪心算法</h3><blockquote><p>在第t步，1-ε的概率取平均分最高，ε的概率取一个随机的赌博机</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114709158.png" alt="image-20230322114709158" style="zoom:80%;" /></p><h3 id="上限置信区间算法ucd1upper-confidence-bounds">2.4.5上限置信区间算法UCD1：Upper Confidence Bounds</h3><blockquote><p>估计每一个动作的奖励区间，优先选取上限高的动作</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114742922.png" alt="image-20230322114742922" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114332302.png" alt="image-20230322114332302" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114838614.png" alt="image-20230322114838614" style="zoom:80%;" /></p><h3 id="对抗搜索蒙特卡洛树搜索">2.4.6 对抗搜索：蒙特卡洛树搜索</h3><blockquote><p>使用UCB1算法，预估下一步操作的收益</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114946852.png" alt="image-20230322114946852" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115203632.png" alt="image-20230322115203632" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115316924.png" alt="image-20230322115316924" style="zoom:80%;" /></p><blockquote><p>示例</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115348387.png" alt="image-20230322115348387" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115358630.png" alt="image-20230322115358630" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115410222.png" alt="image-20230322115410222" style="zoom:80%;" /></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115632518.png" alt="image-20230322115632518" style="zoom:80%;" /></p><h1 id="三监督学习">三、监督学习</h1><h2 id="机器学习的基本概念">3.1 机器学习的基本概念</h2><ol type="1"><li>从原始数据中提取<strong>特征</strong></li><li>学习<strong>映射函数𝑓</strong></li><li>通过映射函数𝑓将<strong>原始数据</strong>映射到<strong>语义任务空间</strong>，即寻找数据和任务目标之间的关系</li></ol><h3 id="机器学习的分类">3.1.1 机器学习的分类</h3><ol type="1"><li><strong>监督学习</strong>：数据有标签，一般为回归/分类等任务</li><li><strong>无监督学习</strong>：数据无标签，一般为聚类/若干降维任务<ol type="1"><li>同一类物体之间总有一定的相似性</li></ol></li><li><strong>半监督学习</strong>：有的数据有标签，有的数据无标签</li><li><strong>强化学习</strong>：序列数据决策学习，一般为从环境交互中学习</li></ol><h3 id="监督学习的重要元素">3.1.2 监督学习的重要元素</h3><ol type="1"><li><strong>标注数据</strong>：标识了类别信息的数据，学什么</li><li><strong>学习模型</strong>：如何学习到映射模型，如何学</li><li><strong>损失函数</strong>：如何对学习结果进行度量，是否学到</li></ol><blockquote><p>没有免费午餐定理NFL：任何机器学习模型在<strong>所有问题</strong>上的<strong>性能都是相同</strong>的，其总误差和模型本身是没有关系的。一种算法（算法A）在特定数据集上的表现优于另一种算法（算法B）的同时，一定伴随着算法A在另外某一个特定的数据集上有着不如算法B的表现</p></blockquote><h3 id="监督学习">3.1.3 监督学习</h3><h4 id="损失函数">3.1.3.1 损失函数</h4><ol type="1"><li>设共有n个标注数据，第i个标记数据为<spanclass="math inline">\((x_i,y_i)\)</span>，其中<spanclass="math inline">\(x_i\)</span>为样本数据，<spanclass="math inline">\(y_i\)</span>是标注信息</li><li>设学习到的映射函数为<span class="math inline">\(f\)</span>，对<spanclass="math inline">\(x_i\)</span>的预测结果为<spanclass="math inline">\(f(x_i)\)</span></li><li>损失函数即为计算<span class="math inline">\(y_i\)</span>和<spanclass="math inline">\(f(x_i)\)</span>之间的差值的函数</li><li>训练的目标是：在训练数据集上得到的损失之和最小，即<spanclass="math inline">\(min\sum_{i=1}^nLoss(f(x_i),y_i)\)</span></li><li>典型损失函数：<ol type="1"><li><strong>0-1损失函数</strong>：<spanclass="math inline">\(Loss(y_i,f(x_i))=\{1, f(x_i)\ne y_i;\ \0,f(x_i)=y_i\}\)</span></li><li><strong>平方损失函数</strong>：<spanclass="math inline">\(Loss(y_i,f(x_i))=(y_i-f(x_i))^2\)</span></li><li><strong>绝对损失函数</strong>：<spanclass="math inline">\(Loss(y_i,f(x_i))=|y_i-f(x_i)|\)</span></li><li><strong>对数损失函数/对数似然损失函数</strong>：<spanclass="math inline">\(Loss(y_i,P(y_i|x_i))=-\logP(y_i|x_i)\)</span></li></ol></li></ol><h4 id="训练数据与测试数据">3.1.3.2 训练数据与测试数据</h4><ol type="1"><li><strong>训练精度</strong>：在<strong>测试数据集</strong>上的精度，因为在训练集上一定是100%通过的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329104355044.png" alt="image-20230329104355044" style="zoom:80%;" /></p><h4 id="经验风险期望风险">3.1.3.3 经验风险、期望风险</h4><p><strong>经验风险 empiricalrisk</strong>：<strong>训练集</strong>中数据产生的损失</p><ol type="1"><li><p>经验风险越小说明学习模型对训练数据拟合程度越好</p></li><li><p>经验风险最小化<strong>ERM</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329104913964.png" alt="image-20230329104913964" style="zoom:80%;" /></p></li></ol><p><strong>期望风险 expectedrisk</strong>：当测试集中存在<strong>无穷多数据</strong>时产生的损失</p><ol type="1"><li><p>期望风险越小，学习所得模型越好</p></li><li><p>期望风险最小化<strong>ERM</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329104945313.png" alt="image-20230329104945313" style="zoom:80%;" /></p></li></ol><h4 id="过学习-欠学习">3.1.3.4 过学习 &amp; 欠学习</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329105537971.png" alt="image-20230329105537971" style="zoom:80%;" /></p><h4 id="结构风险最小">3.1.3.5 结构风险最小</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329105621040.png" alt="image-20230329105621040" style="zoom:80%;" /></p><h4 id="判别模型-生成模型">3.1.3.6 判别模型 &amp; 生成模型</h4><ol type="1"><li><p><strong>判别模型</strong>：</p><ol type="1"><li>建立输入到输出的映射函数：<spanclass="math inline">\(f(输入)=人脸\)</span></li><li>判断输入属于输出空间的概率有多大：<spanclass="math inline">\(P(人脸|输入)=0.99\)</span></li></ol></li><li><p><strong>生成模型</strong>：</p><ol type="1"><li><p>学习联合概率分布<spanclass="math inline">\(P(X,Y)\)</span>（通过似然概率<spanclass="math inline">\(P(X|Y)\)</span>和类概率<spanclass="math inline">\(P(Y)\)</span>的乘积来求取）</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329110247031.png" alt="image-20230329110247031" style="zoom: 80%;" /></p></li><li><p>典型方法：贝叶斯方法、隐马尔科夫链</p></li><li><p>似然概率：计算导致样本<spanclass="math inline">\(X\)</span>出现的模型参数值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329110443829.png" alt="image-20230329110443829" style="zoom:80%;" /></p></li><li><p>联合概率分布<spanclass="math inline">\(P(X,Y)\)</span>、似然概率<spanclass="math inline">\(P(X|Y)\)</span>求取很困难</p></li></ol></li></ol><h2 id="回归分析">3.2 回归分析</h2><h3 id="线性回归">3.2.1 线性回归</h3><ol type="1"><li><strong>回归分析</strong>：分析不同变量之间存在的关系</li><li><strong>回归模型</strong>：刻画不同变量之间关系的模型</li><li><strong>线性回归模型</strong>：回归模型是线性的</li></ol><h4 id="一元线性回归">3.2.1.1 一元线性回归</h4><ol type="1"><li><p>一个变量，对另一个变量的影响</p></li><li><p>回归模型：<spanclass="math inline">\(f(x_i)=ax_i+b\)</span></p></li><li><p>要求：<span class="math inline">\(\frac{1}{N}\sum(y-\haty)^2\)</span>最小</p></li><li><p>计算结果： <span class="math display">\[b=\overline{y}-a\overline{x}\\a=\frac{\sum_{i=1}^{n}x_iy_i-n\overline{x}·\overline{y}}{\sum_{i=1}^{n}x_i^2-n\overline{x}^2}\]</span></p></li></ol><blockquote><p>计算过程：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329114630713.png" alt="image-20230329114630713" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329114704437.png" alt="image-20230329114704437" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329114740563.png" alt="image-20230329114740563" style="zoom:80%;" /></p></blockquote><h4 id="多元线性回归">3.2.1.2 多元线性回归</h4><ol type="1"><li>多个变量，对一个变量产生影响</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329112909723.png" alt="image-20230329112909723" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329113152461.png" alt="image-20230329113152461" style="zoom:80%;" /></p><h4 id="logistics-回归对数几率回归">3.2.1.3 logistics回归/对数几率回归</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329112837126.png" alt="image-20230329112837126" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329113104137.png" alt="image-20230329113104137" style="zoom:80%;" /></p><h4 id="二分类问题">3.2.1.4 二分类问题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329113409355.png" alt="image-20230329113409355" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329113443038.png" alt="image-20230329113443038" style="zoom:80%;" /></p><h4 id="基于似然函数的参数优化">3.2.1.5 基于似然函数的参数优化</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329120546389.png" alt="image-20230329120546389" style="zoom:80%;" /></p><blockquote><p>使用梯度下降公式，快速到达导数接近0的位置，出口为：</p><ol type="1"><li>迭代次数到达预定次数</li><li>相邻两次差值小于某个值</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329115050889.png" alt="image-20230329115050889" style="zoom:80%;" /></p><h4 id="mle最大似然估计-map最大后验概率估计">3.2.1.6 MLE最大似然估计&amp; MAP最大后验概率估计</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329115330878.png" alt="image-20230329115330878" style="zoom:80%;" /></p><h2 id="决策树">3.3 决策树</h2><p>决策树是一种通过树形结构来进行分类的方法。</p><ol type="1"><li>在决策树中，树形结构中每个非叶子节点表示对分类目标在某个属性上的一个判断，每个分支代表基于该属性做出的一个判断，最后树形结构中每个叶子节点代表一种分类结果</li><li>所以决策树可以看作是一系列以叶子节点为输出的决策规则</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412100433480.png" alt="image-20230412100433480" style="zoom:80%;" /></p></blockquote><h3 id="信息熵-ed">3.3.1 信息熵 E(D)</h3><blockquote><p>构建决策树时<strong>划分属性的顺序</strong>选择是重要的。</p><p>性能好的决策树随着划分不断进行，决策树分支结点样本集的“纯度”会越来越高，即其所包含样本尽可能属于相同类别，即<strong>E(D)尽可能小</strong></p></blockquote><ol type="1"><li><p>假设有<spanclass="math inline">\(K\)</span>个信息，组成了集合样本<spanclass="math inline">\(D\)</span>，第<spanclass="math inline">\(k\)</span>个信息发生的概览为<spanclass="math inline">\(p_k(1\le k\le K)\)</span>，则这<spanclass="math inline">\(K\)</span>个信息的<strong>信息熵</strong>为：<span class="math display">\[E(D)=-\sum_{k=1}^Kp_k\log_2\ p_k\]</span></p><ol type="1"><li>其中，<span class="math inline">\(\sum_{k=1}^{K}p_k=1\)</span></li></ol></li><li><p><span class="math inline">\(E(D)\)</span>值越小，表示<spanclass="math inline">\(D\)</span>包含的信息越确定，即<spanclass="math inline">\(D\)</span>的纯度越高</p><ol type="1"><li>当<span class="math inline">\(p_k=1\)</span>时，<spanclass="math inline">\(E(D)=0\)</span>，信息熵为0，即包含的信息量很小</li></ol></li></ol><blockquote><table><thead><tr><th style="text-align: center;">年龄属性取值 a<sub>i</sub></th><th style="text-align: center;">“&gt;30”</th><th style="text-align: center;">“20~30”</th><th style="text-align: center;">“&lt;20”</th></tr></thead><tbody><tr><td style="text-align: center;">对应样本数 |D<sub>i</sub>|</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">正负样本数量</td><td style="text-align: center;">(2+, 3-)</td><td style="text-align: center;">(4+，0-)</td><td style="text-align: center;">(3+，2-)</td></tr></tbody></table><p>计算E(D)：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412101818991.png" alt="image-20230412101818991" style="zoom:80%;" /></p></blockquote><h3 id="信息增益-gainda">3.3.2 信息增益 Gain(D,A)</h3><ol type="1"><li><p>得到信息熵后，可进一步计算使用某个特定属性<strong>A</strong>对原样本集<strong>D</strong>进行划分后的<strong>信息增益</strong>，计算公式为：<span class="math display">\[Gain(D,A)=E(D)-\sum_{i=1}^{n}\frac{|D_i|}{|D|}E(D_i)\]</span></p><ol type="1"><li>其中，属性<span class="math inline">\(A\)</span>将<spanclass="math inline">\(D\)</span>划分为了<spanclass="math inline">\(n\)</span>类，分别为<spanclass="math inline">\(D_1,...D_n\)</span></li></ol></li><li><p>取<strong>信息增益最大</strong>的属性，作为决策树中靠近根节点的属性</p></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412102039855.png" alt="image-20230412102039855" style="zoom:80%;" /></p></blockquote><h3 id="信息熵和物理熵的区别">3.3.3 信息熵和物理熵的区别</h3><ol type="1"><li>信息熵：描述信息的价值，某个信息发生概率越小，带来的信息量越大，信息熵就越大<ol type="1"><li>香农用信息熵的概念来描述信源的不确定度</li></ol></li><li>物理熵：表示分子状态混乱程度的物理量<ol type="1"><li>熵越大，越失去次序，不确定性越大</li></ol></li></ol><h2 id="线性区别分析-lda">3.4 线性区别分析 LDA</h2><blockquote><p><strong>Linear discriminant analysis</strong></p></blockquote><p>线性判别分析是一种基于监督学习的<strong>降维方法</strong>，也称为Fisher线性判别分析</p><ol type="1"><li>对于一组具有标签信息的高维数据样本，LDA利用其类别信息，将其线性投影到一个低维空间</li><li>在低维空间中同一类别样本尽可能靠近，不同类别样本尽可能彼此远离，不要有交叉的部分</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412102938493.png" alt="image-20230412102938493" style="zoom:80%;" /></p></blockquote><h3 id="符号定义">3.4.1 符号定义</h3><ol type="1"><li>设样本集为：<spanclass="math inline">\(D=\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}\)</span><ol type="1"><li><span class="math inline">\(x_i\inR^d\)</span>表示样本，对应的标签为<spanclass="math inline">\(y_i\)</span></li><li><span class="math inline">\(y_i \in\{C_1,C_2,...,C_k\}\)</span>，表示一共有<spanclass="math inline">\(K\)</span>类样本</li></ol></li><li><span class="math inline">\(X\)</span>：所有样本构成的集合</li><li><span class="math inline">\(N_i\)</span>：第<spanclass="math inline">\(i\)</span>个类别包含的样本个数</li><li><span class="math inline">\(X_i\)</span>：第<spanclass="math inline">\(i\)</span>类样本的集合</li><li><span class="math inline">\(m\)</span>：所有样本的均值向量</li><li><span class="math inline">\(m_i\)</span>：第<spanclass="math inline">\(i\)</span>类样本的均值向量</li><li><span class="math inline">\(\Sigma_i\)</span>：第<spanclass="math inline">\(i\)</span>类样本的协方差矩阵，<spanclass="math inline">\(\Sigma_i=\sum_{x\inX_i}(x-m_i)(x-m_i)^T\)</span></li></ol><h3 id="二分类问题-1">3.4.2 二分类问题</h3><p><spanclass="math inline">\(K=2\)</span>时，表示二分类问题，其样本的标签为<spanclass="math inline">\(\{C_1,C_2\}\)</span>，并通过线性函数<spanclass="math inline">\(y(x)=w^Tx\ \ \ (w\inR^n)\)</span>投影到一维空间</p><ol type="1"><li><spanclass="math inline">\(w\)</span>：系数<strong>矩阵</strong>，需要通过数据学习</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412104306809.png" alt="image-20230412104306809" style="zoom:80%;" /></p></blockquote><p>计算系数矩阵<span class="math inline">\(w\)</span>的方法： <spanclass="math display">\[w=S_w^{-1}(m_2-m_1)=(\Sigma_1+\Sigma_2)^{-1}(m_2-m_1)\]</span><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412104553768.png" alt="image-20230412104553768" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412104858207.png" alt="image-20230412104858207" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412105046102.png" alt="image-20230412105046102" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412105534388.png" alt="image-20230412105534388" style="zoom:80%;" /></p><p>投影过程中，保持方差结构不变：即原来两类包含的是某些样本，投影完之后依旧分别包含这些样本</p><h3 id="多分类问题">3.4.3 多分类问题</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412110526430.png" alt="image-20230412110526430" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412110537158.png" alt="image-20230412110537158" style="zoom:80%;" /></p><h3 id="线性判别分析的降维步骤">3.4.4 线性判别分析的降维步骤</h3><ol type="1"><li>计算数据样本集中，每个类别样本的均值<spanclass="math inline">\(m_i\)</span></li><li>计算类内散度矩阵<spanclass="math inline">\(S_w\)</span>、类间散度矩阵<spanclass="math inline">\(S_b\)</span></li><li>根据<span class="math inline">\(S_w^{-1}S_bW=\lambdaW\)</span>，求解<spanclass="math inline">\(S_w^{-1}S_b\)</span>对应的前<spanclass="math inline">\(r\)</span>个最大特征根对应的特征向量<spanclass="math inline">\((w_1,w_2,...,w_r)\)</span>，构成投影矩阵<spanclass="math inline">\(W\)</span></li><li>通过矩阵<spanclass="math inline">\(W\)</span>将每个样本映射到低维空间，实现特征降维</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412110824855.png" alt="image-20230412110824855" style="zoom:80%;" /></p><h2 id="ada-boosting">3.5 Ada Boosting</h2><blockquote><p>adaptive boosting，自适应提升</p></blockquote><ol type="1"><li>对于一个复杂的分类任务，可以将其分解为若干子任务，然后将若干子任务完成方法综合，最终完成该复杂任务</li><li>将若干个弱分类器(weak classifiers)组合起来，形成一个强分类器(strongclassifier)</li></ol><h3 id="计算学习理论霍夫丁不等式">3.5.1 计算学习理论：霍夫丁不等式</h3><ol type="1"><li>学习任务：统计某个电视节目在全国的收视率</li><li>方法：不可能去统计整个国家中每个人是否观看电视节目、进而算出收视率。只能抽样一部分人口，然后将<strong>抽样人口</strong>中观看该电视节目的比例作为该电视节目的全国收视率</li><li><strong>霍夫丁不等式</strong>：全国人口中看该电视节目的人口比例<spanclass="math inline">\(x\)</span>与抽样人口中观看该电视节目的人口比例<spanclass="math inline">\(y\)</span>满足关系：<spanclass="math inline">\(P(|x-y|\ge \epsilon) \le2e^{-2N\epsilon^2}\)</span><ol type="1"><li><span class="math inline">\(N\)</span>：采样人口总数</li><li><span class="math inline">\(\epsilon\in(0,1)\)</span>：设定的可容忍误差范围</li><li>当<spanclass="math inline">\(N\)</span>足够大时，“全国人口中电视节目收视率”与“样本人口中电视节目收视率”差值超过误差范围<spanclass="math inline">\(\epsilon\)</span>的概率非常小</li></ol></li></ol><h3 id="计算学习理论概率近似正确-pac">3.5.2 计算学习理论：概率近似正确PAC</h3><blockquote><p><strong>probably approximately correct</strong></p></blockquote><ol type="1"><li>对于统计电视节目收视率这样的任务，可以通过不同的采样方法（即不同模型）来计算收视率。每个模型会产生不同的误差</li><li>任务：得到完成该任务的<strong>若干“弱模型”</strong>，将这些弱模型组合起来<strong>形成一个“强模型”</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412112007331.png" alt="image-20230412112007331" style="zoom:80%;" /></p><h3 id="ada-boosting思路描述">3.5.3 Ada Boosting：思路描述</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412112101726.png" alt="image-20230412112101726" style="zoom:80%;" /></p><p>两个核心问题：</p><ol type="1"><li>在每个<strong>弱分类器学习</strong>过程中：<strong>改变训练数据的权重</strong><ol type="1"><li><strong>提高</strong>在上一轮中分类<strong>错误样本的权重</strong></li><li>即关注上一个弱分类器无法解决的结果，进行优化</li></ol></li><li>如何将一系列弱分类器<strong>组合成强分类器</strong>：<strong>加权多数表决方法</strong><ol type="1"><li>提高分类误差小的弱分类器的权重，让其在最终分类中起到更大作用</li><li>减少分类误差大的弱分类器的权重，让其在最终分类中仅起到较小作用</li></ol></li></ol><h3 id="ada-boosting算法描述">3.5.4 Ada Boosting：算法描述</h3><h4 id="数据样本权重初始化">3.5.4.1 数据样本权重初始化</h4><ol type="1"><li>给定包含<spanclass="math inline">\(N\)</span>个标注数据的训练集合<spanclass="math inline">\(\Gamma\)</span><ol type="1"><li><spanclass="math inline">\(\Gamma=\{(x_1,y_1),...,(x_N,y_N)\}\)</span>，其中<spanclass="math inline">\(x_i\in X\sub R^n, y_i\in Y=\{-1,1\}\)</span></li></ol></li><li>初始化每个训练样本的权重：<ol type="1"><li><span class="math inline">\(D_1=(w_{11},...,w_{1N}),\w_{1i}=\frac{1}{N}\)</span></li></ol></li></ol><h4 id="第m个弱分类器的训练">3.5.4.2 第m个弱分类器的训练</h4><p>对于<span class="math inline">\(m=1,2,...M\)</span></p><ol type="1"><li>使用具有分布权重<spanclass="math inline">\(D_m\)</span>的训练数据，学习得到第m个弱分类器<spanclass="math inline">\(G_m\)</span><ol type="1"><li><span class="math inline">\(G_m(x): X \rightarrow\{-1,1\}\)</span></li></ol></li><li>计算<spanclass="math inline">\(G_m(x)\)</span>在训练数据集上的分类误差：<ol type="1"><li><span class="math inline">\(err_m=\sum_{i=1}^Nw_{mi}\ I(G_m(x_i)\neqy_i)\)</span></li><li>其中，<span class="math inline">\(I(G_m(x_i)\neqy_i)\)</span>表示：当<span class="math inline">\(G_m(x_i)\neqy_i\)</span>时为1，否则为0</li></ol></li><li>计算<spanclass="math inline">\(G_m(x)\)</span>的权重：<strong>弱分类器的权重和不为1</strong><ol type="1"><li><span class="math inline">\(\alpha_m=\frac{1}{2}\ln\frac{1-err_m}{err_m}\)</span></li></ol></li><li>更新训练样本数据的分布权重：<strong>每一轮样本的权重和为1</strong><ol type="1"><li><spanclass="math inline">\(D_{m+1}=w_{m+1,i}=\frac{w_{m,i}}{Z_m}e^{-\alpha_my_iG_m(x_i)}\)</span></li><li>其中，<spanclass="math inline">\(Z_m\)</span>是归一化因子，使得<spanclass="math inline">\(D_{m+1}\)</span>为概率分布</li><li><spanclass="math inline">\(Z_m=\sum_{i=1}^Nw_{m,i}e^{-\alpha_my_iG_m(x_i)}\)</span></li></ol></li></ol><h4 id="弱分类器组合成强分类器">3.5.4.3 弱分类器组合成强分类器</h4><ol type="1"><li>以线性加权形式来组合弱分类器<spanclass="math inline">\(f(x)\)</span>：<spanclass="math inline">\(f(x)=\sum_{i=1}^M\alpha_mG_m(x)\)</span></li><li>得到强分类器<span class="math inline">\(G(x)\)</span>：<spanclass="math inline">\(G(x)=sign(f(x))=sign(\sum_{i=1}^M\alpha_mG_m(x))\)</span></li></ol><h3 id="ada-boosting算法解释">3.5.5 Ada Boosting：算法解释</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114227541.png" alt="image-20230412114227541" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114209654.png" alt="image-20230412114209654" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114237511.png" alt="image-20230412114237511" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114246140.png" alt="image-20230412114246140" style="zoom:80%;" /></p><h3 id="ada-boosting回看霍夫丁不等式">3.5.6 AdaBoosting：回看霍夫丁不等式</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114318932.png" alt="image-20230412114318932" style="zoom:80%;" /></p><h3 id="ada-boosting优化目标">3.5.7 Ada Boosting：优化目标</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114340961.png" alt="image-20230412114340961" style="zoom:80%;" /></p><h3 id="回归和分类的区别">3.5.8 回归和分类的区别</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412115552314.png" alt="image-20230412115552314" style="zoom:80%;" /></p><h2 id="不考3.6-支持向量机">(不考)3.6 支持向量机</h2><h3 id="不考3.6.1-vc维与结构风险最小化">(不考)3.6.1VC维与结构风险最小化</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412120217404.png" alt="image-20230412120217404" style="zoom:80%;" /></p><blockquote><p>h：反应机器复杂程度的VC维，要求机器本身不要太复杂</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412120649871.png" alt="image-20230412120649871" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412120933462.png" alt="image-20230412120933462" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121034169.png" alt="image-20230412121034169" style="zoom:80%;" /></p><h3 id="不考3.6.2-线性可分支持向量机">(不考)3.6.2线性可分支持向量机</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121242624.png" alt="image-20230412121242624" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121251130.png" alt="image-20230412121251130" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121440464.png" alt="image-20230412121440464" style="zoom:80%;" /></p><h3 id="不考3.6.3-松弛变量软间隔与hinge损失函数">(不考)3.6.3松弛变量，软间隔与hinge损失函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121602099.png" alt="image-20230412121602099" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121629302.png" alt="image-20230412121629302" style="zoom:80%;" /></p><h2 id="不考3.7-生成学习模型">(不考)3.7 生成学习模型</h2><p>生成学习方法从数据中学习联合概率分布<spanclass="math inline">\(P(X,C)\)</span>，然后求出条件概率分布<spanclass="math inline">\(P(C|X)\)</span>作为预测模型，即<spanclass="math inline">\(P(c_i|x)=\frac{P(x,c_i)}{P(x)}\)</span></p><ol type="1"><li><span class="math inline">\(P(x,c_i)=P(x|c_i)×P(c_i)\)</span><ol type="1"><li><span class="math inline">\(P(x|c_i)\)</span>：似然概率</li><li><span class="math inline">\(P(c_i)\)</span>：先验概率</li></ol></li><li><spanclass="math inline">\(P(c_i|x)=\frac{P(x,c_i)}{P(x)}=\frac{P(x|c_i)×P(c_i)}{P(x)}\)</span><ol type="1"><li><spanclass="math inline">\(P(c_i|x)\)</span>：后验概率，表示样本<spanclass="math inline">\(x\)</span>属于类别<spanclass="math inline">\(c_i\)</span>的概率</li><li><span class="math inline">\(P(x,c_i)\)</span>：联合概率</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419101607549.png" alt="image-20230419101607549" style="zoom:80%;" /></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419101552222.png" alt="image-20230419101552222" style="zoom:80%;" /></p><p>生成式学习：</p><ol type="1"><li>学习某个输入与某个类别同时出现的概率，根据某个输入出现的概率，计算某个输入对应某个类别的概率</li><li>模拟了数据生成的方法</li><li>但是联合概率难以学习，因为训练数据中输入与类别没有同时出现，不代表以后永远不会同时出现</li><li>以购买商品为例：<ol type="1"><li>联合概率<spanclass="math inline">\(P(x,c_i)\)</span>：某个人购买了某个商品的概率</li><li>似然概率<spanclass="math inline">\(P(x|c_i)\)</span>：某个商品让某个人购买的概率，某个人没有买，但是与之类似的人买过，此时可以转换为某个商品让某个人购买的概率有多大</li><li>先验概率<spanclass="math inline">\(P(c_i)\)</span>：某个商品出现的概率，即在所有卖出的商品中，该商品出现的概率</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419101626670.png" alt="image-20230419101626670" style="zoom:80%;" /></p><p>判别式学习：直接学习某个输入对应某个类别的概率</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419102048725.png" alt="image-20230419102048725" style="zoom:80%;" /></p></blockquote><h1 id="四无监督学习">四、无监督学习</h1><p>无监督学习从<strong>非标注样本</strong>出发来<strong>学习数据的分布</strong>，这是一个异常困难的工作。由于无法利用标注信息，因此在无监督学习只能利用假设数据具有某些结构来进行学习。正如拉普拉斯所言“概率论只不过是把常识用数学公式表达了出来”，无监督学习就是把预设数据具有某种结构作为一种“知识”来指导模型的学习。</p><h2 id="k均值聚类">4.1 K均值聚类</h2><p>输入：n个数据，无标注信息</p><p>输出：k个聚类结果</p><p>目的：将n个数据聚类到k个集合(类簇)</p><h3 id="算法描述">4.1.1 算法描述</h3><p>定义：</p><ol type="1"><li>n个m维数据<span class="math inline">\(\{x_1,x_2,...x_n\}, x_i\inR^m\)</span></li><li>两个m维数据之间的欧氏距离为：<spanclass="math inline">\(d(x_i,x_j)=\sqrt{(x_{i1}-x_{j1})^2+(x_{i2}-x_{j2})^2+...+(x_{im}-x_{jm})^2}\)</span><ol type="1"><li>欧氏距离并不一定能够刻画语义上的相似性</li><li>但是总要找一个函数表示数据之间的相似性，这里就以欧氏距离为例</li></ol></li><li>聚类集合数目：<span class="math inline">\(k\)</span></li></ol><h4 id="初始化聚类质心">4.1.1.1 初始化聚类质心</h4><ol type="1"><li>初始化<span class="math inline">\(k\)</span>个聚类质心<spanclass="math inline">\(c=\{c_1, c_2,...,c_k\}\)</span>，<spanclass="math inline">\(c_j\in R^m,1\le j \le k\)</span></li><li>每个聚类质心<spanclass="math inline">\(c_j\)</span>所在的集合记为<spanclass="math inline">\(G_j\)</span></li></ol><h4 id="将每个待聚类数据放入唯一一个聚类集合中">4.1.1.2将每个待聚类数据放入唯一一个聚类集合中</h4><ol type="1"><li>计算待聚类数据<span class="math inline">\(x_i\)</span>和质心<spanclass="math inline">\(c_j\)</span>之间的欧氏距离<spanclass="math inline">\(d(x_i,c_j)\)</span>，<spanclass="math inline">\(1\le i\le n, 1\le j \le k\)</span></li><li>将每个<spanclass="math inline">\(x_i\)</span>放入与之距离最近的聚类质心所在聚类集合中，即</li></ol><p><span class="math display">\[argmin_{c_{j\in C}}d(x_i,c_j)\]</span></p><h4 id="根据聚类结果更新聚类质心">4.1.1.3根据聚类结果，更新聚类质心</h4><ol type="1"><li>聚类<span class="math inline">\(G_j\)</span>的新的聚类质心<spanclass="math inline">\(c_j\)</span>为：</li></ol><p><span class="math display">\[c_j=\frac{1}{|G_j|}\sum_{x_i\in G_j}x_i\]</span></p><h4 id="算法循环迭代直到满足条件">4.1.1.4算法循环迭代，直到满足条件</h4><ol type="1"><li>在新的聚类质心基础上，根据欧氏距离的大小，将每个待聚类数据放入唯一一个聚类集合中</li><li>根据聚类结果，更新聚类质心</li><li>重复上述两个步骤，直到满足一下任意一个条件：<ol type="1"><li>前后两次迭代中，聚类质心基本保持不变<ol type="1"><li>此时算法收敛，结果相对来说比较好</li></ol></li><li>迭代次数达到上限<ol type="1"><li>此时算法不收敛，可能是由于欧氏距离并不能很好的刻画数据的相似度</li></ol></li></ol></li></ol><h3 id="另一个视角最小化每个类簇的方差">4.1.2另一个视角：最小化每个类簇的方差</h3><p>方差：计算变量(观察值)与样本平均值之间的差异 <spanclass="math display">\[argmin_{G}\sum_{i=1}^k\sum_{x \inG_i}|x-G_i|^2=argmin_{G}\sum_{i=1}^k|G_i|Var\ G_i\]</span> 第<span class="math inline">\(i\)</span>个类簇的方差： <spanclass="math display">\[var(G_i)=\frac{1}{|G_i|}\sum_{x \in G_i}|x-G_i|^2\]</span></p><ol type="1"><li>欧氏距离与方差量纲相同</li><li>最小化每个类簇方差将使得最终聚类结果中每个聚类集合中所包含数据呈现出来差异性最小</li></ol><h3 id="k均值聚类算法的不足">4.1.3 K均值聚类算法的不足</h3><ol type="1"><li>需要事先确定聚类数目，很多时候我们并不知道数据应被聚类的数目</li><li>需要初始化聚类质心，初始化聚类中心对聚类结果有较大的影响</li><li>算法是迭代执行，时间开销非常大</li><li>欧氏距离假设数据每个维度之间的重要性是一样的</li></ol><h2 id="主成分分析-pca">4.2 主成分分析 PCA</h2><blockquote><p><strong>Principle Component Analysis</strong></p></blockquote><p>主成分分析是一种<strong>特征降维</strong>方法（与线性区别分析的目的是一样的）</p><ol type="1"><li>要尽可能将投影后的数据打散，即方差最大</li><li>设原数据为<spanclass="math inline">\(X_{n×d}\)</span>，投影后的数据为<spanclass="math inline">\(Y_{n×l}\)</span>，投影矩阵为<spanclass="math inline">\(W_{d×l}\)</span>，则有<spanclass="math inline">\(Y=XW\)</span></li><li>投影矩阵<spanclass="math inline">\(W_{d×l}\)</span>为：协方差矩阵<spanclass="math inline">\(\Sigma\)</span>前<spanclass="math inline">\(l\)</span>个最大的特征根对应的特征向量<spanclass="math inline">\(_{d×1}\)</span>组成的矩阵<spanclass="math inline">\(_{d×l}\)</span></li></ol><h3 id="相关概念-1">4.2.1 相关概念</h3><p>假设有n个数据，记为<span class="math inline">\(X=\{x_i\},i=1,...n\)</span></p><ol type="1"><li><strong>方差</strong>：描述样本数据的波动程度 <spanclass="math display">\[Var(X)=\frac{1}{n}\sum_{i=1}^n(x_i-u)^2\\u=\frac{1}{n}\sum_{i=1}^n x_i\]</span></li></ol><p>假设有n个二维变量数据，记为<spanclass="math inline">\((X,Y)=\{(x_i,y_i)\}, i=1,...n\)</span></p><ol type="1"><li><p><strong>协方差</strong>：衡量两个维度之间的相关度</p><ol type="1"><li>协方差<spanclass="math inline">\(cov(X,Y)&gt;0\)</span>时：正相关</li><li>协方差<spanclass="math inline">\(cov(X,Y)&lt;0\)</span>时：负相关</li><li>协方差<spanclass="math inline">\(cov(X,Y)=0\)</span>时：线性意义下不相关</li></ol><p><span class="math display">\[cov(X,Y)=\frac{1}{n}\sum_{i=1}^n(x_i-E(X))(y_i-E(Y))\\E(X)=\frac{1}{n}\sum_{i=1}^nx_i,\ \ E(Y)=\frac{1}{n}\sum_{i=1}^ny_i\]</span></p></li><li><p><strong>皮尔逊相关系数</strong>：将协方差归一化</p><ol type="1"><li><span class="math inline">\(|corr(X,Y)|\le1\)</span></li><li><span class="math inline">\(|corr(X,Y)=1|\)</span> &lt;=&gt;存在常数<span class="math inline">\(a,b\)</span>，使得<spanclass="math inline">\(Y=aX+b\)</span></li><li><span class="math inline">\(corr(X,Y)=corr(Y,X)\)</span></li></ol><p><span class="math display">\[corr(X,Y)=\frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}=\frac{Cov(X,Y)}{\sigma_x\sigma_y}\]</span></p></li><li><p><strong>相关性</strong>与<strong>独立性</strong>：</p><ol type="1"><li>如果<span class="math inline">\(X\)</span>与<spanclass="math inline">\(Y\)</span>线性不相关，则<spanclass="math inline">\(|corr(X,Y)|=0\)</span></li><li>如果<span class="math inline">\(X\)</span>与<spanclass="math inline">\(Y\)</span>独立，则<spanclass="math inline">\(|corr(X,Y)|=0\)</span>，且<spanclass="math inline">\(X\)</span>与<spanclass="math inline">\(Y\)</span>不存在任何线性、非线性关系</li><li>独立一定不相关，但不相关不一定独立</li></ol></li></ol><h3 id="算法动机">4.2.2 算法动机</h3><ol type="1"><li>在数理统计中，方差被经常用来度量数据和其数学期望（即均值）之间偏离程度，这个偏离程度反映了数据分布结构</li><li>在许多实际问题中，研究数据和其均值之间的偏离程度有着很重要的意义</li><li>在降维之中，需要尽可能将数据向<strong>方差最大方向</strong>进行投影，使得数据所蕴含信息没有丢失，彰显个性。如左下图所示，向𝒚方向投影（使得二维数据映射为一维）就比向𝒙方向投影结果在降维这个意义上而言要好；右下图则是向黑斜线方向投影要好。</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419112131702.png" alt="image-20230419112131702" style="zoom:80%;" /></p><ol type="1"><li>主成分分析思想是将𝒏维特征数据映射到𝒍维空间(𝒏 ≫𝒍)，去除原始数据之间的冗余性（通过去除相关性手段达到这一目的）。</li><li>将原始数据向这些数据方差最大的方向进行投影。一旦发现了方差最大的投影方向，则继续寻找保持方差第二的方向且进行投影。</li><li>将每个数据从𝒏维高维空间映射到𝒍维低维空间，每个数据所得到最好的𝒌维特征就是使得每一维上样本方差都尽可能大。</li></ol><h3 id="算法描述-1">4.2.3 算法描述</h3><ol type="1"><li>假设有<span class="math inline">\(𝑛\)</span>个<spanclass="math inline">\(𝑑\)</span>维样本数据所构成的集合<spanclass="math inline">\(𝐷=\{x_1,x_2,…,x_n\}\)</span>，其中<spanclass="math inline">\(x_i(1≤i≤n)∈R^d\)</span></li><li>集合<span class="math inline">\(𝐷\)</span>可以表示成矩阵<spanclass="math inline">\(X_{𝑛×𝑑}\)</span><ol type="1"><li>假定每一维度的特征均值均为零（已经标准化）</li></ol></li><li>主成分分析的目的是求映射矩阵<spanclass="math inline">\(W_{𝑑×𝑙}\)</span><ol type="1"><li>给定一个样本<span class="math inline">\(x_𝑖\)</span>，可将$x_𝑖 <spanclass="math inline">\(从\)</span>𝑑<spanclass="math inline">\(维空间如下映射到\)</span>𝑙$维空间： <spanclass="math inline">\((x_i)_{1×d}(W)_{d×l}\)</span></li></ol></li><li>将所有降维后数据用<spanclass="math inline">\(Y\)</span>表示，有<spanclass="math inline">\(Y=XW\)</span><ol type="1"><li><span class="math inline">\(Y\)</span>：降维结果，<spanclass="math inline">\(n×l\)</span></li><li><span class="math inline">\(X\)</span>：原始数据，<spanclass="math inline">\(n×d\)</span></li><li><span class="math inline">\(W\)</span>：映射矩阵，<spanclass="math inline">\(d×l\)</span></li></ol></li></ol><p>投影矩阵<spanclass="math inline">\(W_{d×l}\)</span>为：协方差矩阵<spanclass="math inline">\(\Sigma\)</span>前<spanclass="math inline">\(l\)</span>个最大的特征根对应的特征向量<spanclass="math inline">\(_{d×1}\)</span>组成的矩阵<spanclass="math inline">\(_{d×l}\)</span></p><p>最优方差为：协方差矩阵<spanclass="math inline">\(\Sigma\)</span>前<spanclass="math inline">\(l\)</span>个最大的特征根之和</p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419113127137.png" alt="image-20230419113127137" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419113624996.png" alt="image-20230419113624996" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419113632079.png" alt="image-20230419113632079" style="zoom:80%;" /></p></blockquote><h3 id="其他常用降维方法">4.2.4 其他常用降维方法</h3><ol type="1"><li>非负矩阵分解 NMF：non-negative matrix factorization</li><li>多为尺度法MDS：Metric multidimensional</li><li>局部先行嵌入LLE：Locally Linear Embedding</li></ol><h2 id="特征人脸方法">4.3 特征人脸方法</h2><h3 id="动机">4.3.1 动机</h3><ol type="1"><li>特征人脸方法是一种应用主成份分析来实现<strong>人脸图像降维</strong>的方法</li><li>其本质是用一种称为<strong>“特征人脸(eigenface)”</strong>的特征向量按照线性组合形式来表达每一张原始人脸图像，进而实现人脸识别</li><li>由此可见，这一方法的关键之处在于如何得到特征人脸</li><li>用特征人脸表示人脸，而非用像素点表示人脸</li></ol><h3 id="算法描述-2">4.3.2 算法描述</h3><ol type="1"><li><p>将每幅人脸图像转化为列向量</p><ol type="1"><li>例如：将一幅32×32的人脸图像转化为1024×1的列向量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419115115486.png" alt="image-20230419115115486" style="zoom:80%;" /></p></li><li><p>执行PCA特征降维</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419115230356.png" alt="image-20230419115230356" style="zoom:80%;" /></p></li><li><p>每个人脸特征向量<spanclass="math inline">\(w_i\)</span>与原始人脸数据<spanclass="math inline">\(x_i\)</span>的维数是一样的，均为<spanclass="math inline">\(1024\)</span></p></li><li><p>可将每个特征向量还原为𝟑𝟐×𝟑𝟐的人脸图像，称之为特征人脸，因此可得到<spanclass="math inline">\(l\)</span>个特征人脸</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419115421635.png" alt="image-20230419115421635" style="zoom:80%;" /></p></li><li><p>将每幅人脸分别与特征人脸做矩阵乘法，得到一个相关系数</p></li><li><p>每幅人脸得到<span class="math inline">\(l\)</span>个相关系数=&gt; 每幅人脸从1024维约简到<spanclass="math inline">\(l\)</span>维</p></li><li><p>由于每幅人脸是所有特征人脸的线性组合，因此就实现人脸从“像素点表达”到“特征人脸表达”的转变。每幅人脸从1024维约减到<spanclass="math inline">\(l\)</span>维</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419120306729.png" alt="image-20230419120306729" style="zoom:80%;" /></p></li></ol><h3 id="其他人脸表达的方法聚类pca非负矩阵分解">4.3.3其他人脸表达的方法：聚类、PCA、非负矩阵分解</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419120942125.png" alt="image-20230419120942125" style="zoom:80%;" /></p><h2 id="潜在语义分析">4.4 潜在语义分析</h2><blockquote><p><strong>latent semantic analysis</strong>、<strong>latent semanticindexing</strong></p></blockquote><p><strong>潜在语义分析(LSA或LSI)</strong>：又叫隐形语义分析</p><ol type="1"><li>是一种从海量文本数据中学习<strong>单词-单词</strong>、<strong>单词-文档</strong>以及<strong>文档-文档</strong>之间隐性关系，进而得到<strong>文档和单词</strong>表达<strong>特征</strong>的方法</li><li><strong>基本思想</strong>：综合考虑某些单词在哪些文档中同时出现，以此来决定该词语的含义与其他的词语的相似度</li></ol><h3 id="潜在语义分析思想">4.4.1 潜在语义分析思想</h3><ol type="1"><li>先构建一个<strong>单词-文档</strong>(term-document)<strong>矩阵A</strong></li><li>进而寻找该<strong>矩阵的低秩逼近</strong>(low rankapproximation)，来挖掘<strong>单词-单词、单词-文档以及文档-文档</strong>之间的关联关系</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426101927415.png" alt="image-20230426101927415" style="zoom:80%;" /></p></blockquote><h3 id="分析过程">4.4.2 分析过程</h3><ol type="1"><li><p>计算<strong>单词-文档矩阵：<spanclass="math inline">\(A_{m×n}\)</span></strong></p><ol type="1"><li>某个term在某个document中出现了几次，对应的值即为几</li><li>也可以统计：TF×iDF，TF在某个文章中出现的频率，DF在所有文章中出现的频率</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426101941266.png" alt="image-20230426101941266" style="zoom:80%;" /></p></li><li><p><strong>奇异值分解</strong>：<spanclass="math inline">\(A_{m×n}=U_{m×r}D_{r×r}V^T_{r×n}\)</span></p><ol type="1"><li>SVD分解：将矩阵<spanclass="math inline">\(A_{m×n}\)</span>分解为三个矩阵的的乘积<spanclass="math inline">\(U_{m×r}D_{r×r}V^T_{r×n}\)</span></li><li><spanclass="math inline">\(D_{r×r}=diag(\sigma_1,\sigma_2,...,\sigma_r)\)</span>，是<spanclass="math inline">\(A_{m×n}\)</span>的所有奇异值，也是<spanclass="math inline">\(AA^T\)</span>特征值的非负平方根，满足<spanclass="math inline">\(\sigma_1\ge\sigma_2\ge,...,\ge\sigma_r&gt;0\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426102742675.png" alt="image-20230426102742675" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426103032436.png" alt="image-20230426103032436" style="zoom:80%;" /></p></li><li><p><strong>重建矩阵</strong>：<spanclass="math inline">\(A_{k}=U_{m×k}D_{k×k}V^T_{k×n}\)</span></p><ol type="1"><li>选取前k个特征根及其对应的特征向量，对矩阵A进行重建</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426103044250.png" alt="image-20230426103044250" style="zoom:80%;" /></p></li><li><p><strong>挖掘语义关系</strong></p><ol type="1"><li>根据由主题重建出来的矩阵<spanclass="math inline">\(A_k\)</span>，计算皮尔逊相关系数</li><li>通过分解和重建，可以将主题相关的两个文档之间的相关系数变得更大</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426103537877.png" alt="image-20230426103537877" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426103752281.png" alt="image-20230426103752281" style="zoom:80%;" /></p></li></ol><h2 id="期望最大化算法-em">4.5 期望最大化算法 EM</h2><blockquote><p><strong>expectation maximization</strong></p></blockquote><h3 id="模型参数估计">4.5.1 模型参数估计</h3><ol type="1"><li><p>最大似然估计：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426104845910.png" alt="image-20230426104845910" style="zoom:80%;" /></p></li><li><p>最大后验估计：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426104854324.png" alt="image-20230426104854324" style="zoom:80%;" /></p></li><li><p>无论是最大似然估计算法或者是最大后验估计算法，都是充分利用已有数据，在<strong>参数模型确定</strong>（只是参数值未知）情况下，对所优化目标中的<strong>参数求导</strong>，<strong>令导数为0</strong>，求取模型的参数值</p></li><li><p>在解决一些具体问题时，难以事先就将模型确定下来，然后利用数据来求取模型中的参数值。在这样情况下，无法直接利用最大似然估计算法或者最大后验估计算法来求取模型参数</p></li></ol><h3 id="期望最大化算法">4.5.2 期望最大化算法</h3><blockquote><p>Expectation Maximization</p></blockquote><ol type="1"><li>EM算法是一种重要的用于解决<strong>含有隐变量</strong>(latentvariable)问题的<strong>参数估计方法</strong></li><li>EM算法分为<strong>求取期望</strong>(E步骤，expectation)和<strong>期望最大化</strong>(M步骤，maximization)两个步骤<ol type="1"><li>在EM算法的<strong>E步骤</strong>时，先假设模型参数的初始值，估计隐变量取值</li><li>在EM算法的<strong>M步骤</strong>时，基于观测数据、模型参数和隐变量取值一起来最大化“拟合”数据，更新模型参数</li><li>基于所更新的模型参数，得到新的隐变量取值(EM算法的 E步)，然后继续极大化“拟合”数据，更新模型参数(EM算法的M步)</li><li>以此类推迭代，直到算法收敛，得到合适的模型参数</li></ol></li></ol><h3 id="em示例二硬币投掷例子">4.5.3 EM示例：二硬币投掷例子</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110545341.png" alt="image-20230426110545341" style="zoom:80%;" /></p><p><strong>目标/模型参数</strong>：求A/B为正面的概率<spanclass="math inline">\(\{\theta_A,\theta_B\}\)</span></p><p><strong>隐变量</strong>：某一轮是A投出的，还是B投出的</p><blockquote><p>初始化模型参数<spanclass="math inline">\(\{\theta_A,\theta_B\}\)</span>，即可得到得出某一轮结果是由A/B投出的概率</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426105838487.png" alt="image-20230426105838487" style="zoom:80%;" /></p><blockquote><p>然后即可得某一轮结果中，A/B投为正/反面的期望次数</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110335936.png" alt="image-20230426110335936" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110349882.png" alt="image-20230426110349882" style="zoom:80%;" /></p><blockquote><p>根据之前的计算结果，得出A/B投为正/反面的期望次数，从而更新A/B分别投正面的概率</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110256967.png" alt="image-20230426110256967" style="zoom:80%;" /></p><blockquote><p>不断迭代上述过程，直到算法收敛，就可以得到A/B投为正面的概率</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110404057.png" alt="image-20230426110404057" style="zoom:80%;" /></p><h3 id="em示例三硬币投掷例子">4.5.4 EM示例：三硬币投掷例子</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426112028228.png" alt="image-20230426112028228" style="zoom:80%;" /></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426112208421.png" alt="image-20230426112208421" style="zoom:80%;" /></p></blockquote><p><strong>目标/模型参数</strong>：求0/1/2为正面的概率<spanclass="math inline">\(\{\lambda,p_1,p_2\}\)</span></p><p><strong>隐变量</strong>：硬币0的投掷结果</p><blockquote><p>初始化模型参数<spanclass="math inline">\(\{\lambda,p_1,p_2\}\)</span>：通过假设每一次0号硬币的结果得出</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426112602109.png" alt="image-20230426112602109" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426112910620.png" alt="image-20230426112910620" style="zoom:80%;" /></p><blockquote><p>迭代更新模型参数值，直到收敛</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426113059647.png" alt="image-20230426113059647" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426113104146.png" alt="image-20230426113104146" style="zoom:80%;" /></p><h3 id="em算法的一般形式">4.5.5 EM算法的一般形式</h3><p>​ 对n个相互独立的样本<spanclass="math inline">\(X=\{x_1,x_2,...,x_n\}\)</span>及其对应的隐变量<spanclass="math inline">\(Z=\{z_1,z_2,...,z_n\}\)</span>，在假设样本的模型参数为<spanclass="math inline">\(\Theta\)</span>前提下，观测数据<spanclass="math inline">\(x_i\)</span>的概率为<spanclass="math inline">\(P(x_i|\Theta)\)</span>，完全数据<spanclass="math inline">\((x_i,z_i)\)</span>的<strong>似然函数</strong>为<spanclass="math inline">\(P(x_i,z_i|\Theta)\)</span></p><p>​ 在这种表示基础上，优化目标为：求解合适的<spanclass="math inline">\(\Theta\)</span>和<spanclass="math inline">\(Z\)</span>，使得<strong>对数似然函数</strong>最大：<span class="math display">\[(\Theta,Z)=argmax_{\Theta,Z}L(\Theta,Z)=argmax_{\Theta,Z}\sum_{i=1}^nlog\sum_{z_i}P(x_i,z_i|\Theta)\]</span> ​ 但是，优化求解含有未观测数据Z的对数似然函数<spanclass="math inline">\(L(\Theta,Z)\)</span>十分困难，EM算法不断构造对数似然函数<spanclass="math inline">\(L(\Theta,Z)\)</span>的一个<strong>下界(E步骤)</strong>，然后<strong>最大化这个下界(M步骤)</strong>，以迭代方式逼近模型参数所能取得极大似然值</p><h1 id="五深度学习">五、深度学习</h1><h2 id="深度学习的历史发展">5.1 深度学习的历史发展</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426115207956.png" alt="image-20230426115207956" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426115150060.png" alt="image-20230426115150060" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426115238544.png" alt="image-20230426115238544" style="zoom:80%;" /></p><h2 id="前馈神经网络-fnn">5.2 前馈神经网络 FNN</h2><h3 id="浅层学习-vs-深层学习分段学习逐层端到端学习">5.2.1 浅层学习 vs深层学习：分段学习=&gt;逐层端到端学习</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426115528872.png" alt="image-20230426115528872" style="zoom:80%;" /></p><h3 id="深度学习以端到端的方式逐层抽象逐层学习">5.2.2深度学习：以端到端的方式逐层抽象、逐层学习</h3><ol type="1"><li>深度学习所得的模型可以视为一个复杂函数</li><li>非线性变换与映射的过程：像素点→语义</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514150442883.png" alt="image-20230514150442883" style="zoom:80%;" /></p><h3 id="mcp神经元">5.2.3 MCP神经元</h3><ol type="1"><li>对n个输入数据<spanclass="math inline">\(x_i\)</span>进行线性加权求和，然后利用函数<spanclass="math inline">\(\Phi(·)\)</span>将结果映射为0/1</li><li>特点：<ol type="1"><li>可计算、清晰描述</li><li>既包含了物理反应(线性加权求和)，也包含了化学反应(阈值函数)</li></ol></li><li>缺点：<ol type="1"><li>权重<spanclass="math inline">\(w_i\)</span>是人工定制的，没有通过数据驱动，没有学习的过程</li><li>阈值函数的阈值也是人工定制的</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426121027846.png" alt="image-20230426121027846" style="zoom:80%;" /></p><h3 id="激活函数对输入信息进行非线性变换">5.2.3激活函数：对输入信息进行非线性变换</h3><h4 id="常用激活函数sigmoidtanhrelu">5.2.3.1常用激活函数：sigmoid、tanh、ReLU</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514151508626.png" alt="image-20230514151508626" style="zoom:80%;" /></p><h4 id="softmax函数将输出映射到01概率空间">5.2.3.2softmax函数：将输出映射到[0,1]概率空间</h4><p><span class="math display">\[y_i=softmax(x_i)=\frac{e^{x_i}}{\sum_{j=1}^k e^{x_j}}\]</span></p><ol type="1"><li>将输入数据<span class="math inline">\(x_i\)</span>映射到[0,1]的概率空间，用于刻画每个输入的<strong>相对重要程度</strong></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514151849630.png" alt="image-20230514151849630" style="zoom:80%;" /></p></blockquote><h3 id="单个神经元的功能加权累加-非线性变换">5.2.4单个神经元的功能：加权累加 + 非线性变换</h3><p><strong>参数是学习出来的</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514152116968.png" alt="image-20230514152116968" style="zoom:80%;" /></p><h3 id="损失函数-loss-function">5.2.5 损失函数 Loss Function</h3><p><strong>损失函数</strong>：又称为<strong>代价函数</strong>(CostFunction)</p><ol type="1"><li>用来计算<strong>模型预测值</strong>与<strong>真实值</strong>之间的<strong>误差</strong></li><li>损失函数是神经网络设计中的一个重要组成部分，通过定义与任务相关的良好损失函数，在训练过程中可根据损失函数来计算神经网络的误差大小，进而优化神经网络参数</li></ol><p>两种最常用损失函数：</p><ol type="1"><li>均方误差损失函数</li><li>交叉熵损失函数</li></ol><h4 id="均方误差损失-mse预测值和实际值之间的差">5.2.5.1 均方误差损失MSE：预测值和实际值之间的差</h4><p>均方误差损失函数：</p><ol type="1"><li>计算预测值和实际值之间的<strong>距离</strong>(即误差)<strong>的平方</strong>，衡量模型的优劣</li><li>设有n个训练数据<spanclass="math inline">\(x_i\)</span>，每个训练数据的真实输出为<spanclass="math inline">\(y_i\)</span>，模型对<spanclass="math inline">\(x_i\)</span>的预测为<spanclass="math inline">\(\hat{y_i}\)</span>，则该模型在n个训练数据下产生的均方误差损失为：</li></ol><p><span class="math display">\[MSE=\frac{1}{n}\sum_{i=1}^n(y_i-\hat{y_i})^2\]</span></p><h4 id="交叉熵损失函数两个概率分布之间的距离">5.2.5.2交叉熵损失函数：两个概率分布之间的距离</h4><p>交叉熵(cross entropy)：</p><ol type="1"><li>交叉熵刻画了<strong>两个概率分布之间的距离</strong>，旨在描绘通过概率分布q来表达概率分布p的困难程度</li><li><strong>交叉熵越小，两个概率分布p和q越接近</strong></li><li>设p和q是数据x的两个概率分布，则<strong>通过q来表示p的交叉熵</strong>为：</li></ol><p><span class="math display">\[H(p,q)=-\sum_x p(x)*\log q(x)\]</span></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514153303851.png" alt="image-20230514153303851" style="zoom:80%;" /></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194138200.png" alt="image-20230514194138200" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194151894.png" alt="image-20230514194151894" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194235428.png" alt="image-20230514194235428" style="zoom:80%;" /></p><h3 id="感知机模型">5.2.6 感知机模型</h3><h4 id="单层感知机">5.2.6.1 单层感知机</h4><ol type="1"><li>早期的感知机结构和MCP模型相似，由一个输入层和一个输出层构成，因此也被称为“单层感知机”</li><li>感知机的输入层负责接收实数值的输入向量，输出层则能输出1或-1两个值</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514153853900.png" alt="image-20230514153853900" style="zoom:80%;" /></p><ol type="1"><li>单层感知机可被用来<strong>区分线性可分数据</strong></li><li>在下图中，AND、NAND和OR为线性可分函数，所以可利用单层感知机来模拟这些逻辑函数</li><li>但是，由于XOR是非线性可分的逻辑函数，因此单层感知机无法模拟逻辑异或函数的功能</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514154041975.png" alt="image-20230514154041975" style="zoom:80%;" /></p><h4 id="多层感知机前馈神经网络fnn">5.2.6.2多层感知机/前馈神经网络(FNN)</h4><p><strong>多层感知机</strong>：由<strong>输入层</strong>、<strong>输出层</strong>和至少一层的<strong>隐藏层</strong>构成</p><ol type="1"><li>网络中各个隐藏层中神经元可接收相邻<strong>前序隐藏层</strong>中<strong>所有神经元</strong>传递而来的信息，经过加工处理后将信息输出给相邻<strong>后续隐藏层</strong>中<strong>所有神经元</strong></li><li>各个神经元接受前一级的输入，并输出到下一级，模型中没有反馈</li><li>层与层之间通过“<strong>全连接</strong>”进行链接，即两个相邻层之间的神经元完全成对连接，但层内的神经元不相互连接</li><li><strong>前馈神经网络 feedforward neural network</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514154308251.png" alt="image-20230514154308251" style="zoom:80%;" /></p><h3 id="参数优化">5.2.7 参数优化</h3><blockquote><p><strong>目标：最小化损失函数</strong></p></blockquote><h4 id="梯度下降-gradient-descent">5.2.7.1 梯度下降 GradientDescent</h4><p><strong>梯度</strong>：</p><ol type="1"><li><p><strong>一元变量</strong>所构成的函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x\)</span>处的梯度为： <spanclass="math display">\[\frac{df(x)}{dx}=\lim_{h→0} \frac{f(x+h)-f(x)}{h}\]</span></p></li><li><p>在<strong>多元函数</strong>中，梯度是对<strong>每一变量所求导数</strong>组成的<strong>向量</strong></p></li><li><p><strong>梯度的反方向</strong>是函数值下降最快的方向，因此是损失函数求解的方向</p></li><li><p>在实际中，引入<strong>步长η(为定值)</strong>，用<spanclass="math inline">\(x-η𝜵f(x)\)</span>来更新<spanclass="math inline">\(x\)</span></p></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514191448977.png" alt="image-20230514191448977" style="zoom:80%;" /></p><blockquote><p><strong>证明过程</strong>：</p><ol type="1"><li><p>设损失函数<spanclass="math inline">\(f(x)\)</span>是连续可微的多元变量函数，其泰勒展开为：<span class="math display">\[f(x+Δx) = f(x) + f&#39;(x)Δx +\frac{1}{2}f&#39;&#39;(x)(Δx)^2+...+\frac{1}{n!}f^{(n)}(Δx)^n\\f(x+Δx) - f(x) ≈ (𝜵f(x))^TΔx\]</span></p></li><li><p>因为我们的目的是最小化损失函数<spanclass="math inline">\(f(x)\)</span>，则<spanclass="math inline">\(f(x+Δx) &lt; f(x)\)</span>，即<spanclass="math inline">\((𝜵f(x))^TΔx&lt;0\)</span></p></li><li><p>在<span class="math inline">\((𝜵f(x))^TΔx =|𝜵f(x)||Δx|cosθ\)</span>中，<spanclass="math inline">\(|𝜵f(x)|\)</span>为损失函数梯度的模，<spanclass="math inline">\(|Δx|\)</span>为下一轮迭代中x取值增量的模，两者均为正数。为了保证损失误差减少，只要保证<spanclass="math inline">\(cos θ&lt;0\)</span></p></li><li><p>当<span class="math inline">\(θ = 180°\)</span>时，<spanclass="math inline">\(cos θ=-1\)</span>，此时损失函数减少的幅度值<spanclass="math inline">\((𝜵f(x))^TΔx\)</span>取到最小值</p></li><li><p>因此<span class="math inline">\(Δx\)</span>的选取应该为<spanclass="math inline">\(𝜵f(x)\)</span>的<strong>反方向</strong></p></li></ol></blockquote><h4 id="误差反向传播-bp">5.2.7.2 误差反向传播 BP</h4><blockquote><p><strong>Error Back Propagation</strong></p></blockquote><ol type="1"><li>BP算法是一种将<strong>输出层误差</strong>反向传播给<strong>隐藏层</strong>进行<strong>参数更新</strong>的方法</li><li>将误差从后向前传递，将误差分摊给各层所有单元，从而获得各层单元所产生的误差，进而依据这个误差来让各层单元负起各自责任、修正各单元参数</li><li>每个参数经过误差反向传播后，新的参数值为：</li></ol><p><span class="math display">\[\begin{aligned}w^{new} &amp;=  w_1-η×\frac{\partial{\mathcal{L}}}{\partial{w_1}}\\        &amp;=  w_1-η×\frac{d\mathcal{L}}{d\mathcal{O}}×\frac{d\mathcal{O}}{d\mathcal{X}}×\frac{d\mathcal{X}}{d\mathcal{w_1}}\\        &amp;=  w_1-η×\frac{d\mathcal{L}}{d\mathcal{O}}×\frac{1}{1+e^{-x}}×(1-\frac{1}{1+e^{-x}})×out_1\end{aligned}\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514191608315.png" alt="image-20230514191608315" style="zoom:80%;" /></p><h4 id="链式求导法则">5.2.7.3 链式求导法则</h4><ol type="1"><li>由于<span class="math inline">\(w_1\)</span>与加权累加函数<spanclass="math inline">\(\mathcal{X}\)</span>和<strong>sigmoid</strong>函数均有关，因此<spanclass="math inline">\(\frac{d\mathcal{L}}{dw_1}=\frac{d\mathcal{L}}{d\mathcal{O}}·\frac{d\mathcal{O}}{d\mathcal{X}}·\frac{d\mathcal{X}}{d\mathcal{w_1}}\)</span></li><li>在这个链式求导中：<ol type="1"><li><spanclass="math inline">\(\frac{d\mathcal{L}}{d\mathcal{O}}\)</span>：与损失函数的定义有关</li><li><spanclass="math inline">\(\frac{d\mathcal{O}}{d\mathcal{X}}\)</span>：是对<strong>sigmoid</strong>函数求导，结果为<spanclass="math inline">\(\frac{1}{1+e^{-x}}·(1-\frac{1}{1+e^{-x}})\)</span></li><li><spanclass="math inline">\(\frac{d\mathcal{X}}{dw_1}\)</span>：是加权累加函数<spanclass="math inline">\(\sum_{i=1}^n w_i·out_i\)</span>，结果为<spanclass="math inline">\(out_i\)</span></li></ol></li><li>链式求导实现了<strong>损失函数对某个自变量求偏导</strong>，好比将损失误差从输出端向输入端逐层传播，通过这个传播过程来更新该自变量取值。梯度下降法告诉我们，只要沿着损失函数梯度的反方向来更新参数，就可使得损失函数下降最快</li></ol><h3 id="机器学习的能力在于拟合和优化">5.2.8机器学习的能力在于拟合和优化</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194017518.png" alt="image-20230514194017518" style="zoom:80%;" /></p><h2 id="卷积神经网络-cnn">5.3 卷积神经网络 CNN</h2><blockquote><p><strong>convolution neural network</strong></p></blockquote><p>CNN引入了一个卷积层，将原始图像先经过一次卷积(即下采样)，然后再送入FNN进行学习</p><ol type="1"><li><strong>CNN = 卷积层 + 池化层 + 全连接层 +Softmax激活函数</strong></li></ol><h3 id="卷积操作线性操作">5.3.1 卷积操作：线性操作</h3><h4 id="卷积核的权重是通过学习得出的">5.3.1.1卷积核的权重是通过学习得出的</h4><ol type="1"><li><strong>图像</strong>中像素点具有很强的<strong>空间依赖性</strong>，卷积就是针对像素点的空间依赖性来对图像进行处理的一种技术</li><li>在图像卷积计算中，需要定义一个<strong>卷积核(kernel)</strong><ol type="1"><li>卷积核是一个<strong>二维矩阵</strong></li><li><strong>矩阵中数值</strong>为对图像中与卷积核同样大小的子块像素点进行卷积计算时所采用的<strong>权重</strong></li><li>卷积核中的<strong>权重系数w<sub>i</sub></strong>是通过数据驱动机制<strong>学习</strong>得到，其用来捕获图像中某像素点及其邻域像素点所构成的特有空间模式</li><li>一旦从数据中学习得到权重系数，这些<strong>权重系数</strong>就刻画了<strong>图像中像素点构成的空间分布不同模式</strong></li></ol></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194854168.png" alt="image-20230514194854168" style="zoom:80%;" /></p></blockquote><h4 id="对图像进行卷积操作">5.3.1.2 对图像进行卷积操作</h4><ol type="1"><li>如果卷积核中心位置的权重系数越小且与其它卷积权重系数差别越小，则卷积所得到图像滤波结果越模糊，这被称为<strong>图像平滑操作</strong></li><li><strong>7×7</strong>大小的图像，通过<strong>3×3大小卷积核</strong>以<strong>1的步长</strong>进行卷积操作，可得到<strong>5×5</strong>大小的卷积结果</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514195631109.png" alt="image-20230514195631109" style="zoom:80%;" /></p><h4 id="卷积核特征图感受野">5.3.1.3 卷积核、特征图、感受野</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514195930797.png" alt="image-20230514195930797" style="zoom:80%;" /></p><h3 id="池化操作非线性操作">5.3.2 池化操作：非线性操作</h3><ol type="1"><li>进一步进行<strong>下采样</strong>操作</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514200028614.png" alt="image-20230514200028614" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514200107035.png" alt="image-20230514200107035" style="zoom:80%;" /></p><h3 id="神经网络正则化解决过拟合问题">5.3.3神经网络正则化：解决过拟合问题</h3><p>为了缓解神经网络在训练过程中出现的<strong>过拟合</strong>问题，需要采取一些<strong>正则化技术</strong>来提升神经网络的<strong>泛化能力</strong>(generalization)</p><ol type="1"><li><p><strong>Dropout</strong>：随机删除一定比例的连接</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514200437118.png" alt="image-20230514200437118" style="zoom:67%;" /></p></li><li><p><strong>Batch-Normalization</strong>：一次送入一批图像，而不是一张图像，一批图像之间有一定的关联度</p></li><li><p><strong>L1-Norm &amp; L2-Norm</strong>：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514200544741.png" alt="image-20230514200544741" style="zoom:80%;" /></p></li></ol><h2 id="循环神经网络-rnn"><strong>5.4 循环神经网络 RNN</strong></h2><p>循环神经网络：处理<strong>序列数据</strong>时所采用的网络结构</p><ol type="1"><li>先前所介绍的前馈神经网络或卷积神经网络所需要处理的输入数据一次性给定，难以处理存在前后依赖关系的数据</li><li>循环神经网络的本质是希望模拟人所具有的记忆能力，在学习过程中<strong>记住部分已经出现的信息</strong>，并利用所记住的信息影响后续结点输出</li><li>循环神经网络在自然语言处理，例如语音识别、情感分析、机器翻译等领域有重要应用</li></ol><h3 id="rnn的结构">5.4.1 RNN的结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514214259608.png" alt="image-20230514214259608" style="zoom:80%;" /></p><ol type="1"><li><p>循环神经网络在处理数据过程中构成了一个循环体</p><ol type="1"><li>对于一个序列数据，在每一时刻<spanclass="math inline">\(t\)</span>，循环神经网络单元会读取当前输入数据<spanclass="math inline">\(x_t\)</span>和前一时刻输入数据<spanclass="math inline">\(x_{t−1}\)</span>所对应的隐式编码结果<spanclass="math inline">\(h_{t−1}\)</span>，一同生成<spanclass="math inline">\(t\)</span>时刻的隐式编码结果<spanclass="math inline">\(h_t\)</span></li><li>接着将<span class="math inline">\(h_t\)</span>后传，去参与生成<spanclass="math inline">\(t+1\)</span>时刻输入数据<spanclass="math inline">\(x_{t+1}\)</span>的隐式编码<spanclass="math inline">\(h_{t+1}\)</span></li></ol></li><li><p><strong>时刻<spanclass="math inline">\(t\)</span>所得到的隐式编码<spanclass="math inline">\(h_t\)</span>是由上一时刻隐式编码<spanclass="math inline">\(h_{t-1}\)</span>和当前输入<spanclass="math inline">\(x_t\)</span>共同参与生成的</strong></p><ol type="1"><li>这可认为隐式编码<spanclass="math inline">\(h_{t-1}\)</span>已经“记忆”了<spanclass="math inline">\(t\)</span>时刻之前的时序信息，或者说前序时刻信息影响了后续时刻信息的处理</li><li>与前馈神经网络和卷积神经网络在处理时需要将所有数据一次性输入不同，这体现了循环神经网络可刻画<strong>序列数据存在时序依赖</strong>这一重要特点</li></ol></li><li><p>在时刻<spanclass="math inline">\(t\)</span>，一旦得到当前输入数据<spanclass="math inline">\(x_t\)</span>，RNN会结合前一时刻的隐式编码<spanclass="math inline">\(h_{t-1}\)</span>，生成当前时刻的隐式编码<spanclass="math inline">\(h_t\)</span>： <span class="math display">\[\begin{aligned}h_t  &amp;=  \Phi(U×x_t+W×h_{t-1}) \\&amp;=  \Phi(U×x_t+W×\Phi(U×x_{t-1}+W×h_{t-2})) \\&amp;=  \Phi(U×x_t+W×\Phi(U×x_{t-1}+W×\Phi(U×x_{t-2}+...))))\end{aligned}\]</span></p><ol type="1"><li><spanclass="math inline">\(\Phi(·)\)</span>：激活函数，一般为Sigmoid或Tanh，使模型能够忘掉一些信息，同时更新记忆内容</li><li><spanclass="math inline">\(U、W\)</span>：模型参数，对于每一时刻都是共用的</li></ol></li></ol><h3 id="沿时间反向传播算法-bptt">5.4.2 沿时间反向传播算法 BPTT</h3><blockquote><p><strong>Back Propagation Through Time</strong></p></blockquote><h4 id="思想">5.4.2.1 思想</h4><ol type="1"><li>按照时间将RNN展开后，可以得到一个和FNN相似的网络结构</li><li>这个网络结构可以利用BP和GradientDescent算法来训练模型参数，这种训练方法被称为<strong>BPTT</strong></li><li>由于RNN每一时刻都有一个输出，因此在计算RNN的损失时，需要将所有时刻上的损失进行累加</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514220258231.png" alt="image-20230514220258231" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514220315167.png" alt="image-20230514220315167" style="zoom:80%;" /></p></blockquote><h4 id="算法">5.4.2.2 算法</h4><ol type="1"><li><p>设时刻<span class="math inline">\(t\)</span>隐式编码如下得到：<span class="math display">\[h_t=tanh(W_xt_x+W_hh_{t-1}+b)\]</span></p></li><li><p>使用交叉熵损失函数计算时刻<spanclass="math inline">\(t\)</span>预测输出与实际输出的误差为<spanclass="math inline">\(E_t\)</span>，则整个序列产生的误差为： <spanclass="math display">\[E=\frac{1}{2}\sum_{t=1}^T E_t\]</span></p></li><li><p>根据时刻<spanclass="math inline">\(t\)</span>所得到的误差来更新参数<spanclass="math inline">\(W_x\)</span>的方法为：</p><ol type="1"><li>在时刻<span class="math inline">\(t\)</span>计算所得的<spanclass="math inline">\(O_t\)</span>不仅涉及到了<spanclass="math inline">\(t\)</span>时刻的<spanclass="math inline">\(W_x\)</span>，而且也涉及了前面所有时刻的<spanclass="math inline">\(W_x\)</span></li><li>按照链式求导法则，<span class="math inline">\(E_t\)</span>对<spanclass="math inline">\(W_x\)</span>求导时，也需要对前面时刻的<spanclass="math inline">\(W_x\)</span>依次求导，然后再将求导结构进行累加，即：</li></ol><p><span class="math display">\[\frac{\partial E_t}{\partial W_x}=\sum_{i=1}^y\frac{dE_t}{dO_t}·\frac{dO_t}{dh_t}·(\prod_{j=i+1}^t\frac{dh_j}{dh_{j-1}})·\frac{dh_i}{dW_x}\\其中, \prod_{j=i+1}^t \frac{dh_j}{dh_{j-1}}=\prod_{j=i+1}^ttanh&#39;×W_h\]</span></p></li><li><p>令<span class="math inline">\(t=3\)</span>，则有： <spanclass="math display">\[\begin{aligned}\frac{\partial E_3}{\partialW_x}&amp;=\frac{dE_3}{dO_3}·\frac{dO_3}{dh_3}·\frac{dh_3}{dW_x}\\&amp;+\frac{dE_3}{dO_3}·\frac{dO_3}{dh_3}·\frac{dh_3}{dh_2}·\frac{dh_2}{dW_x}\\&amp;+\frac{dE_3}{dO_3}·\frac{dO_3}{dh_3}·\frac{dh_3}{dh_2}·\frac{dh_2}{dh_1}·\frac{dh_1}{dW_x}\end{aligned}\]</span></p></li><li><p>由于tanh函数的导数取值位于[0,1]区间，对于长序列而言，若干个[0,1]区间的小数相乘，会使得参数求导结果很小，引发<strong>梯度消失</strong>问题。<spanclass="math inline">\(E_t\)</span>对<spanclass="math inline">\(W_h\)</span>的求导类似。</p></li><li><p>为了解决梯度消失问题，提出了<strong>长短时记忆模型(LSTM)</strong></p></li></ol><h4 id="应用">5.4.2.3 应用</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514221952266.png" alt="image-20230514221952266" style="zoom:80%;" /></p><h3 id="长短时记忆模型-lstm解决rnn梯度消失的问题">5.4.3 长短时记忆模型LSTM：解决RNN梯度消失的问题</h3><blockquote><p><strong>Long-Short-Term-Memory</strong></p></blockquote><h4 id="思想-1">5.4.3.1 思想</h4><p>LSTM网络中引入了<strong>内部记忆单元(internal memorycell)</strong>和<strong>门(gates)</strong>两种结构来对当前时刻输入信息以及前序时刻所生成信息进行整合和传递</p><ol type="1"><li>在这里，内部记忆单元中信息可视为对“历史信息”的累积</li><li>常见的LSTM模型中有<strong>输入门(inputgate)</strong>、<strong>遗忘门(forgetgate)</strong>和<strong>输出门(output gate)</strong>三种门结构</li><li>对于给定的当前时刻输入数据<spanclass="math inline">\(x_t\)</span>和前一时刻隐式编码<spanclass="math inline">\(h_{t-1}\)</span>，输入门、遗忘门和输出门通过各自参数对其编码，分别得到三种门结构的输出<spanclass="math inline">\(i_t, f_t, o_t\)</span></li><li>在此基础上，再进一步结合前一时刻内部记忆单元信息<spanclass="math inline">\(c_{t-1}\)</span>来更新当前时刻内部记忆单元信息<spanclass="math inline">\(c_t\)</span>，最终得到当前时刻的隐式编码<spanclass="math inline">\(h_t\)</span></li><li><span class="math inline">\(h_t\)</span>对应短期记忆，<spanclass="math inline">\(c_t\)</span>对应长期记忆<ol type="1"><li>RNN直接传递短期记忆，因此容易遗忘</li><li>而LSTM通过门的作用，将短期记忆转化为长期记忆，因此记忆能力更强</li></ol></li></ol><h4 id="符号定义-1">5.4.3.2 符号定义</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514223119712.png" alt="image-20230514223119712" style="zoom:80%;" /></p><ol type="1"><li>输入门、遗忘门和输出门通过各自参数对当前时刻输入数据<spanclass="math inline">\(x_𝑡\)</span>和前一时刻隐式编码<spanclass="math inline">\(h_{t-1}\)</span>处理后，利用<spanclass="math inline">\(𝑠𝑖𝑔𝑚𝑜𝑖𝑑\)</span>对处理结果进行非线性映射，因此三种门结构的输出<spanclass="math inline">\(i_t,f_t,o_t \in(0,1)\)</span></li><li>正是由于三个门结构的输出值为位于0到1之间的向量，因此其在信息处理中起到了“调控开关”的“门”作用</li><li>三个门结构所输出向量的维数、内部记忆单元的维数和隐式编码的维数均相等</li></ol><h4 id="lstm结构">5.4.3.3 LSTM结构</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515001733288.png" alt="image-20230515001733288" style="zoom:80%;" /></p><ol type="1"><li>在每个时刻<span class="math inline">\(t\)</span><ol type="1"><li>包含序列信息的变量为：<spanclass="math inline">\(c_t，h_t\)</span></li><li>输出为<span class="math inline">\(t\)</span>时刻的隐式编码：<spanclass="math inline">\(h_t=o_t⊙tanh(c_t)\)</span></li></ol></li><li>LSTM中的参数有：<ol type="1"><li>输入门<span class="math inline">\(i_t\)</span>的参数： <spanclass="math inline">\(W_{xi},W_{hi},b_i →i_t=sigmoid(W_{xi}x_t+W_{hi}h_{t-1}+b_i)\)</span></li><li>遗忘门<span class="math inline">\(f_t\)</span>的参数： <spanclass="math inline">\(W_{xf},W_{hf},b_f→f_t=sigmoid(W_{xf}x_t+W_{hf}h_{t-1}+b_f)\)</span></li><li>输出门<span class="math inline">\(o_t\)</span>的参数： <spanclass="math inline">\(W_{xo},W_{ho},b_o→o_t=sigmoid(W_{xo}x_t+W_{ho}h_{t-1}+b_o)\)</span></li><li>内部记忆单元<span class="math inline">\(c_t\)</span>的参数：<spanclass="math inline">\(W_{xc},W_{hc},b_c\)</span></li></ol></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515191651335.png" alt="image-20230515191651335" style="zoom:80%;" /></p></blockquote><ol start="3" type="1"><li>从<spanclass="math inline">\(c_t=f_t⊙c_{t-1}+i_t⊙tanh(W_{xc}x_t+W_{hc}h_{t-1}+b_c)\)</span>可以得出，对于当前时刻<spanclass="math inline">\(t\)</span>所对应内部记忆单元种信息的调整，涉及到：<ol type="1"><li>遗忘门信息<span class="math inline">\(f_t\)</span></li><li><spanclass="math inline">\(t-1\)</span>时刻所对应内部记忆单元中的信息<spanclass="math inline">\(c_{t-1}\)</span></li><li>输入门信息<span class="math inline">\(i_t\)</span></li><li><span class="math inline">\(t-1\)</span>时刻的隐式编码<spanclass="math inline">\(h_{t-1}\)</span></li></ol></li><li><spanclass="math inline">\(sigmoid(x)\in(0,1)\)</span>：因此输入门、输出门、遗忘门三种门结构起到了信息控制门的作用</li><li><spanclass="math inline">\(tanh(x)\in(-1,1)\)</span>：因此内部记忆单元<spanclass="math inline">\(c_t\)</span>、隐式编码<spanclass="math inline">\(h_t\)</span>在进行信息整合时，可以起到信息增(为正)或信息减(为负)的效果</li></ol><h4 id="lstm如何克服梯度消失">5.4.3.4 LSTM如何克服梯度消失</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515193712715.png" alt="image-20230515193712715" style="zoom:80%;" /></p><h3 id="gru门控循环单元神经网络">5.4.4 GRU门控循环单元神经网络</h3><p>与LSTM类似，引入<strong>门结构</strong>解决梯度消失问题</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515193901099.png" alt="image-20230515193901099" style="zoom:80%;" /></p><h2 id="不考5.5-深度生成学习">(不考)5.5 深度生成学习</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515194317721.png" alt="image-20230515194317721" style="zoom:80%;" /></p><ol type="1"><li>在本章之前的介绍中，神经网络模型从数据中提取出高层语义在数据中所蕴含的<strong>“模式”</strong>，并利用这些模式实现<strong>对数据的分类和检测</strong>等，这种模型通常称为<strong>判别模型</strong>：判别模型不关心数据如何生成，它只关心数据蕴含哪些模式以及如何将数据进行分类</li><li>与之相对的模型类型被称为<strong>生成模型(generativemodel)</strong>：生成模型需要学习目标数据的分布规律，以<strong>合成</strong>属于目标数据空间的<strong>新数据</strong></li><li>生成模型代表：<ol type="1"><li>变分自编码器(variational auto-encoder, VAE)</li><li>自回归模型(Autoregressive models)</li><li>生成对抗网络（generative adversarial network，GAN）</li></ol></li></ol><h2 id="深度学习应用">5.6 深度学习应用</h2><h3 id="自然语言中词向量生成">5.6.1 自然语言中词向量生成</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515195126133.png" alt="image-20230515195126133" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515195158097.png" alt="image-20230515195158097" style="zoom:80%;" /></p><h3 id="word2vec模型">5.6.2 Word2Vec模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515195221719.png" alt="image-20230515195221719" style="zoom:80%;" /></p><ol type="1"><li><p>假设词典中有<spanclass="math inline">\(V\)</span>个不同的单词，现在考虑如何生成第<spanclass="math inline">\(k\)</span>个单词的<spanclass="math inline">\(N\)</span>维词向量</p><ol type="1"><li>首先，将该单词表示成<spanclass="math inline">\(V\)</span>维<strong>one-hot向量</strong><spanclass="math inline">\(X\)</span>，向量<spanclass="math inline">\(X\)</span>中第<spanclass="math inline">\(k\)</span>个位置取值为1、其余位置取值均为0，one-hot向量<spanclass="math inline">\(X\)</span>表示词典中的一个单词</li><li>隐藏层神经元大小为<spanclass="math inline">\(N\)</span>，每个神经元记为<spanclass="math inline">\(h_i (1≤i≤N)\)</span></li><li>向量<span class="math inline">\(X\)</span>中每个<spanclass="math inline">\(x_i(1≤i≤V)\)</span>与隐藏层神经元是全连接，连接权重矩阵为<spanclass="math inline">\(W_{V×N}\)</span></li><li>输出层是<spanclass="math inline">\(V\)</span>维归一化的概率值，其中<spanclass="math inline">\(y_k\)</span>对应第<spanclass="math inline">\(k\)</span>个单词归一化的概率值，显然其取值应该远大于其它输出所对应的归一化概率值</li></ol></li><li><p>因此，某个输入单词对应的<spanclass="math inline">\(N\)</span>维词向量为：<spanclass="math inline">\([w_{k1},w_{k2},...,w_{kN}]\)</span></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515200909879.png" alt="image-20230515200909879" style="zoom:80%;" /></p></blockquote></li><li><p>训练词向量模型的目标为：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515200951193.png" alt="image-20230515200951193" style="zoom:80%;" /></p></li></ol><h3 id="cbow模型通过上下文预测单词">5.6.3CBOW模型：通过上下文预测单词</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515201117406.png" alt="image-20230515201117406" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515201230336.png" alt="image-20230515201230336" style="zoom:80%;" /></p><h3 id="图像分类和目标定位">5.6.4 图像分类和目标定位</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515201257374.png" alt="image-20230515201257374" style="zoom:80%;" /></p><h1 id="六强化学习">六、强化学习</h1><h2 id="强化学习问题定义">6.1 强化学习问题定义</h2><h3 id="强化学习中的概念">6.1.1 强化学习中的概念</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517103207132.png" alt="image-20230517103207132" style="zoom:80%;" /></p><ol type="1"><li><strong>智能体（agent）</strong>：智能体是强化学习算法的主体，它能够根据经验做出主观判断并执行动作，是整个智能系统的核心</li><li><strong>环境（environment）</strong>：智能体以外的一切统称为环境，环境在与智能体的交互中，能被智能体所采取的动作影响，同时环境也能向智能体反馈状态和奖励</li><li><strong>状态（state）</strong>：状态可以理解为智能体对环境的一种理解和编码，通常包含了对智能体所采取决策产生影响的信息</li><li><strong>动作（action）</strong>：动作是智能体对环境产生影响的方式</li><li><strong>策略（policy）</strong>：策略是智能体在所处状态下去执行某个动作的依据，即给定一个状态，智能体可根据一个策略来选择应该采取的动作</li><li><strong>奖励（reward）</strong>：奖励是智能体序贯式采取一系列动作后从环境获得的收益</li></ol><h3 id="强化学习的特点">6.1.2 强化学习的特点</h3><ol type="1"><li><strong>基于评估</strong>：强化学习利用环境评估当前策略，以此为依据进行优化</li><li><strong>交互性</strong>：强化学习的数据在与环境的交互中产生</li><li><strong>序列决策过程</strong>：智能主体在与环境的交互中需要作出一系列的决策，这些决策往往是前后关联的</li><li>注：现实中强化学习问题往往还具有<strong>奖励滞后</strong>，<strong>基于采样的评估</strong>等特点</li></ol><h3 id="马尔可夫决策过程">6.1.3 马尔可夫决策过程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517103826163.png" alt="image-20230517103826163" style="zoom: 50%;" /></p><p>序列优化问题描述：</p><ol type="1"><li>在下图网格中，假设有一个机器人位于<spanclass="math inline">\(s_1\)</span>，其每一步只能向上或向右移动一格，跃出方格会被惩罚（且游戏停止）</li><li>如何使用强化学习找到一种策略，使机器人从<spanclass="math inline">\(s_1\)</span>到达<spanclass="math inline">\(s_9\)</span>？</li></ol><table><thead><tr><th style="text-align: center;">智能主体 Agent</th><th style="text-align: center;">迷宫机器人</th></tr></thead><tbody><tr><td style="text-align: center;">环境</td><td style="text-align: center;">3×3方格</td></tr><tr><td style="text-align: center;">状态</td><td style="text-align: center;">机器人当前时刻所处方格</td></tr><tr><td style="text-align: center;">动作</td><td style="text-align: center;">每次移动一个方格</td></tr><tr><td style="text-align: center;">奖励</td><td style="text-align: center;">到达<spanclass="math inline">\(s_9\)</span>时给予奖励，越界时给予惩罚</td></tr></tbody></table><h4 id="离散马尔可夫过程-discrete-markov-process">6.1.3.1离散马尔可夫过程 Discrete Markov Process</h4><ol type="1"><li><p><strong>离散随机过程</strong>：一个随机过程实际上是一系列随时间变化的随机变量，其中当时间是离散量时，一个随机过程可以表示为<spanclass="math inline">\(\{X_t\}_{t=0,1,2...}\)</span>，其中每个<spanclass="math inline">\(X_t\)</span>都是一个随机变量，这被称为离散随机过程</p></li><li><p><strong>马尔科夫链</strong>：满足马尔可夫性质的离散随机过程。也被称为离散马尔可夫过程</p><ol type="1"><li>马尔可夫性质：<strong>t+1时刻状态仅与t时刻状态相关</strong></li></ol><p><span class="math display">\[P(X_{t+1}=x_{t+1}|X_0=x_0,X_1=x_1,...,X_t=x_t)=P(X_{t+1}=x_{t+1}|X_t=x_t)\]</span></p></li></ol><h4 id="马尔可夫奖励过程-markov-reward-process引入奖励">6.1.3.2马尔可夫奖励过程 Markov Reward Process：引入奖励</h4><h5 id="奖励机制">6.1.3.2.1 奖励机制</h5><p>为了在序列决策中对目标进行优化，在马尔可夫随机过程框架中加入了奖励机制：</p><ol type="1"><li>奖励函数<span class="math inline">\(𝑹:𝑺×𝑺↦ℝ\)</span>，其中<spanclass="math inline">\(𝑹(𝑺_𝒕,𝑺_{𝒕+𝟏})\)</span>描述了从第<spanclass="math inline">\(𝒕\)</span>步状态转移到第<spanclass="math inline">\(𝒕+𝟏\)</span>步状态所获得奖励</li><li>在一个序列决策过程中，不同状态之间的转移产生了一系列的奖励<spanclass="math inline">\((𝑹_𝟏,𝑹_𝟐,⋯)\)</span>，其中<spanclass="math inline">\(𝑹_{𝒕+𝟏}\)</span>为<spanclass="math inline">\(𝑹(𝑺_𝒕,𝑺_{𝒕+𝟏})\)</span>的简便记法。</li><li>引入奖励机制，这样可以衡量任意序列的优劣，即对序列决策进行评价。</li></ol><h5 id="反馈折扣系数">6.1.3.2.2 反馈、折扣系数</h5><p>问题：给定两个因为状态转移而产生的奖励序列<spanclass="math inline">\((𝟏,𝟏,𝟎,𝟎)\)</span>和<spanclass="math inline">\((𝟎,𝟎,𝟏,𝟏)\)</span>，哪个奖励序列更好？</p><ol type="1"><li><strong>反馈 Return</strong>：反应累加奖励，<spanclass="math inline">\(G_t=R_{t+1}+\gamma R_{t+w}+\gamma^2R_{t+3}+...\)</span></li><li><strong>折扣系数 discount factor</strong>：<spanclass="math inline">\(\gamma \in [0,1]\)</span></li><li>反馈值反映了某个时刻后所得到累加奖励，当衰退系数小于1时，越是遥远的未来对累加反馈的贡献越少</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517104754931.png" alt="image-20230517104754931" style="zoom:80%;" /></p></blockquote><h4 id="马尔可夫决策过程-markov-decision-process引入动作">6.1.3.3马尔可夫决策过程 Markov Decision Process：引入动作</h4><p>在强化学习问题中，智能主体与环境交互过程中可自主决定所采取的动作，不同<strong>动作</strong>会对环境产生不同影响，为此：</p><ol type="1"><li>定义智能主体能够采取的<strong>动作集合</strong>为<spanclass="math inline">\(𝑨\)</span></li><li>由于不同的动作对环境造成的影响不同，因此状态转移概率定义为<spanclass="math inline">\(𝑷(𝑺_{𝒕+𝟏}│𝑺_𝒕,𝒂_𝒕 )\)</span>，其中<spanclass="math inline">\(𝒂_𝒕∈𝑨\)</span>为第<spanclass="math inline">\(𝒕\)</span>步采取的动作</li><li>奖励可能受动作的影响，因此修改奖励函数为<spanclass="math inline">\(𝑹(𝑺_𝒕,𝒂_𝒕,𝑺_{𝒕+𝟏})\)</span></li><li>动作集合<spanclass="math inline">\(𝑨\)</span>可以是有限的，也可以是无限的</li><li>状态转移可是确定（deterministic）的，也可以是随机概率性（stochastic）的。</li><li>确定状态转移相当于发生从<spanclass="math inline">\(𝑺_𝒕\)</span>到<spanclass="math inline">\(𝑺_{𝒕+𝟏}\)</span>的转移概率为1</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517105910270.png" alt="image-20230517105910270" style="zoom:80%;" /></p><h4 id="使用离散马尔可夫过程描述机器人移动问题">6.1.3.4使用离散马尔可夫过程描述机器人移动问题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517110515225.png" alt="image-20230517110515225" style="zoom:50%;" /></p><ol type="1"><li>随机变量序列<spanclass="math inline">\(\{S_t\}_{t=0,1,2,...}\)</span>：<spanclass="math inline">\(S_t\)</span>表示机器人第<spanclass="math inline">\(t\)</span>步的位置(即状态)，每个随机变量<spanclass="math inline">\(S_t\)</span>的取值范围为<spanclass="math inline">\(S={s_1,s_2,⋯, s_9,s_d}\)</span></li><li>动作集合：<span class="math inline">\(A=\{上,右\}\)</span></li><li>状态转移概率<span class="math inline">\(P(S_{t+1}|S_t,a_t)\)</span>：满足马尔可夫性，其中<spanclass="math inline">\(a_t\in A\)</span>，状态转移如图所示</li><li>奖励函数：<span class="math inline">\(R(S_t,a_t,S_{t+𝟏})\)</span>，从<span class="math inline">\(S_t\)</span>采取行动<spanclass="math inline">\(a_t\)</span>到<spanclass="math inline">\(S_{t+1}\)</span>所获得奖励</li><li>衰退系数：<span class="math inline">\(\gamma∈[0, 1]\)</span></li><li>综上，可以使用<span class="math inline">\(MDP=\{S, A, P, R,\gamma\}\)</span>来刻画马尔可夫决策过程</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517110654230.png" alt="image-20230517110654230" style="zoom:67%;" /></p><p>马尔可夫过程中产生的状态序列称为<strong>轨迹(trajectory)</strong>，可以如下表示：<span class="math display">\[(S_0,a_0,R_1,S_1,a_1,R_2,...,S_T)\]</span></p><ol type="1"><li>轨迹长度可以是无限的，也可以有终止状态<spanclass="math inline">\(S_T\)</span></li><li>有终止状态的问题叫做<strong>分段的(episodic,即存在回合的)</strong>，否则叫做<strong>持续的(continuing)</strong></li><li>分段问题中，一个从初始状态到终止状态的完整轨迹称为一个<strong>片段或回合(episode)</strong>。如围棋对弈中一个胜败对局为一个回合</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517110917886.png" alt="image-20230517110917886" style="zoom:80%;" /></p></blockquote><h3 id="强化学习中的策略学习">6.1.4 强化学习中的策略学习</h3><p><strong>策略函数</strong>：</p><ol type="1"><li>策略函数<span class="math inline">\(𝜋:𝑆×𝐴↦[0, 1]\)</span>，其中<spanclass="math inline">\(𝜋(𝑠,𝑎)\)</span>的值表示在状态<spanclass="math inline">\(s\)</span>下采取动作<spanclass="math inline">\(a\)</span>的概率。</li><li>策略函数的输出可以是确定的，即给定<spanclass="math inline">\(s\)</span>情况下，只有一个动作<spanclass="math inline">\(a\)</span>使得概率<spanclass="math inline">\(𝜋(𝑠,𝑎)\)</span>取值为1</li><li>对于确定的策略，记为<span class="math inline">\(𝑎=𝜋(𝑠)\)</span></li></ol><h3 id="强化学习问题定义-1">6.1.5 强化学习问题定义</h3><ol type="1"><li>给定一个马尔可夫决策过程<spanclass="math inline">\(MDP=(S,A,P,R,\gamma)\)</span>，学习一个最优策略<spanclass="math inline">\(\pi^*\)</span>，对于任意<spanclass="math inline">\(s\in S\)</span>，使得<spanclass="math inline">\(V_{\pi^*}(s)\)</span>的值最大<ol type="1"><li><strong>策略函数</strong>：<span class="math inline">\(𝜋:𝑆×𝐴↦[0,1]\)</span>，<spanclass="math inline">\(𝜋(𝑠,𝑎)\)</span>表示智能体在状态<spanclass="math inline">\(𝑠\)</span>下采取动作<spanclass="math inline">\(𝑎\)</span>的概率</li><li>最大化每一时刻的<strong>回报值</strong>：<spanclass="math inline">\(G_t=R_{t+1}+\gamma R_{t+w}+\gamma^2R_{t+3}+...\)</span></li><li><strong>价值函数</strong>：<spanclass="math inline">\(𝑉:𝑆↦R\)</span>，其中<spanclass="math inline">\(𝑉_𝜋 (𝑠)=𝔼_𝜋 [𝐺_𝑡 |𝑆_𝑡=𝑠]\)</span><ol type="1"><li>表示在第<span class="math inline">\(t\)</span>步状态为<spanclass="math inline">\(s\)</span>时，按照策略<spanclass="math inline">\(\pi\)</span>行动后，在未来所获得反馈值的期望</li></ol></li><li><strong>动作-价值函数</strong>：<spanclass="math inline">\(𝑞:𝑆×𝐴↦R\)</span>，其中<spanclass="math inline">\(𝑞_𝜋 (𝑠,𝑎)= E_𝜋 [𝐺_𝑡 |𝑆_𝑡=𝑠,𝐴_𝑡=𝑎]\)</span><ol type="1"><li>表示在第𝑡步状态为𝑠时，按照策略𝜋采取动作𝑎后，在未来所获得反馈值的期望</li></ol></li><li><strong>价值函数</strong>和<strong>动作-价值函数</strong>反映了智能体在某一策略下所对应状态序列<strong>获得回报的期望</strong>，它比回报本身更加准确地刻画了智能体的目标</li><li><strong>价值函数</strong>和<strong>动作-价值函数</strong>的定义之所以能够成立，离不开决策过程所具有的马尔可夫性，即当位于当前状态<spanclass="math inline">\(s\)</span>时，无论当前时刻<spanclass="math inline">\(t\)</span>的取值是多少，一个策略回报值的期望是一定的。<strong>当前状态只与前一状态有关，与时间无关</strong></li></ol></li></ol><h3 id="贝尔曼方程-动态规划方程">6.1.6 贝尔曼方程 &lt;=&gt;动态规划方程</h3><blockquote><p><strong>Bellman Equation</strong> &lt;=&gt; <strong>DynamicProgramming Equation</strong></p></blockquote><ol type="1"><li><p><strong>价值函数</strong>：<spanclass="math inline">\(V_\pi(s)=E_\pi [R_{t+1}+\gamma R_{t+2}+\gamma^2R_{t+3}+... |S_t=s]\)</span></p></li><li><p><strong>动作-价值函数</strong>：<spanclass="math inline">\(q_\pi(s,a)=E_\pi [R_{t+1}+\gamma R_{t+2}+\gamma^2R_{t+3}+... |S_t=s, A_t=a]\)</span></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517114027577.png" alt="image-20230517114027577" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517114407250.png" alt="image-20230517114407250" style="zoom:80%;" /></p></blockquote></li><li><p><strong>贝尔曼方程</strong>：</p><ol type="1"><li><p><strong>价值函数的贝尔曼方程</strong>： <spanclass="math display">\[V_\pi(s)=\sum_{a\in A}\pi(s,a)q_\pi(s,a)\]</span><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517115250091.png" alt="image-20230517115250091" style="zoom:80%;" /></p><ol type="1"><li>描述了当前状态价值函数和其后续状态价值函数之间的关系</li><li>即当前状态价值函数等于瞬时奖励的期望加上后续状态的（折扣）价值函数的期望</li></ol></li><li><p><strong>动作-价值函数的贝尔曼方程</strong>： <spanclass="math display">\[q_\pi(s,a)=\sum_{s&#39;\in S}P(s&#39;|s,a)[R(s,a,s&#39;)+\gammaV_\pi(s&#39;)]\]</span><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517115306429.png" alt="image-20230517115306429" style="zoom:80%;" /></p><ol type="1"><li>描述了当前动作-价值函数和其后续动作-价值函数之间的关系</li><li>即当前状态下的动作-价值函数等于瞬时奖励的期望加上后续状态的（折扣）动作-价值函数的期望</li></ol></li></ol></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517115337147.png" alt="image-20230517115337147" style="zoom:80%;" /></p></blockquote><h2 id="基于价值的强化学习">6.2 基于价值的强化学习</h2><p>强化学习问题的定义：</p><ol type="1"><li>给定一个马尔可夫决策过程<spanclass="math inline">\(MDP=(S,A,P,R,\gamma)\)</span></li><li>学习一个最优策略<spanclass="math inline">\(\pi^*\)</span>，对于任意<spanclass="math inline">\(s\in S\)</span>，使得<spanclass="math inline">\(V_{\pi^*}(s)\)</span>的值最大</li></ol><h3 id="策略迭代">6.2.1 策略迭代</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517115738367.png" alt="image-20230517115738367" style="zoom:80%;" /></p><ol type="1"><li>从一个任意的策略开始，首先计算该策略下价值函数（或动作-价值函数），然后根据价值函数调整改进策略使其更优，不断迭代这个过程直到策略收敛</li><li>通过策略计算价值函数的过程叫做<strong>策略评估（policyevaluation）</strong></li><li>通过价值函数优化策略的过程叫做<strong>策略优化（policyimprovement）</strong></li><li>策略评估和策略优化交替进行的强化学习求解方法叫做<strong>通用策略迭代（GeneralizedPolicy Iteration，GPI）</strong></li></ol><h3 id="强化学习中的策略优化">6.2.2 强化学习中的策略优化</h3><p><strong>策略优化定理</strong>：</p><ol type="1"><li>对于确定的策略<span class="math inline">\(\pi\)</span>和<spanclass="math inline">\(\pi&#39;\)</span>，如果对于任意状态<spanclass="math inline">\(s\in S\)</span>，均有<spanclass="math inline">\(q_\pi(s,\pi&#39;(s)) \geq_\pi(s,\pi(s))\)</span></li><li>那么对于任意状态<span class="math inline">\(s\in S\)</span>，有<spanclass="math inline">\(V_{\pi&#39;}(s) \ge V_{\pi}(s)\)</span></li></ol><p>给定当前策略<span class="math inline">\(\pi\)</span>、价值函数<spanclass="math inline">\(V_\pi\)</span>、行动-价值函数<spanclass="math inline">\(q_\pi\)</span>，构造新策略<spanclass="math inline">\(\pi&#39;\)</span>满足如下条件： <spanclass="math display">\[\forall s \in S,\pi&#39;(s)=argmax_a\ q_{\pi}(s,a)\]</span></p><ol type="1"><li>则<span class="math inline">\(\pi&#39;\)</span>就是对<spanclass="math inline">\(\pi\)</span>的一个改进</li><li>于是对于<span class="math inline">\(\forall s \inS\)</span>，有：</li></ol><p><span class="math display">\[q_\pi(s,\pi&#39;(s))=q_\pi(s,argmax_a\ q_\pi(s,a))=max_{a}\ q_\pi(s,a)\ge q_\pi(s,\pi(s))\]</span></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517120713430.png" alt="image-20230517120713430" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517120730339.png" alt="image-20230517120730339" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517120756408.png" alt="image-20230517120756408" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517120829356.png" alt="image-20230517120829356" style="zoom:80%;" /></p></blockquote><h3 id="强化学习中的策略评估方法">6.2.3 强化学习中的策略评估方法</h3><p>假定当前策略为<spanclass="math inline">\(𝜋\)</span>，<strong>策略评估</strong>指的是：根据策略<spanclass="math inline">\(𝜋\)</span>来计算相应的价值函数<spanclass="math inline">\(𝑉_𝜋\)</span>或动作-价值函数<spanclass="math inline">\(𝑞_𝜋\)</span>。</p><p>这里将介绍在状态集合有限前提下三种常见的策略评估方法，它们分别是</p><ol type="1"><li>动态规划</li><li>蒙特卡洛采样</li><li>时序差分（temporal difference）</li></ol><h4 id="动态规划">6.2.3.1 动态规划</h4><p>基于动态规划的价值函数更新：使用<strong>迭代</strong>的方法<strong>求解贝尔曼方程组</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524103752806.png" alt="image-20230524103752806" style="zoom:80%;" /></p><p>缺点：</p><ol type="1"><li>agent需要事先知道状态转移概率<spanclass="math inline">\(Pr(s&#39;|s,a)\)</span></li><li>无法处理状态集合大小无限的情况</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524104106939.png" alt="image-20230524104106939" style="zoom:80%;" /></p></blockquote><h4 id="蒙特卡洛采样">6.2.3.2 蒙特卡洛采样</h4><p>基于蒙特卡洛采样的价值函数更新：</p><ol type="1"><li>轨迹：从当前状态出发，不停采样，直到到达终止状态</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524104237120.png" alt="image-20230524104237120" style="zoom:80%;" /></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524104717419.png" alt="image-20230524104717419" style="zoom:80%;" /></p></blockquote><p>优点：</p><ol type="1"><li>agent不必知道状态转移的概率</li><li>容易扩展到无限状态集合的问题中</li></ol><p>缺点：</p><ol type="1"><li>状态集合比较大时，一个状态在轨迹可能非常稀疏，不利于估计期望</li><li>在实际问题中，最终反馈需要在终止状态才能知晓，导致反馈周期较长</li></ol><h4 id="时序差分-temporal-difference">6.2.3.3 时序差分 TemporalDifference</h4><p><span class="math display">\[\begin{aligned}V_\pi(s) &amp;← (1-\alpha)V_\pi(s) + \alpha[R+\gamma V_\pi(s&#39;)]\\         &amp;= V_\pi(s) + \alpha[R+\gamma V_\pi(s&#39;)-V_\pi(s)]\end{aligned}\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111034692.png" alt="image-20230524111034692" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111010163.png" alt="image-20230524111010163" style="zoom:80%;" /></p><ol type="1"><li><strong>时序差分法</strong>可以看作<strong>蒙特卡罗方法</strong>和<strong>动态规划方法</strong>的有机结合<ol type="1"><li>时序差分算法与蒙特卡洛方法相似之处在于：时序差分方法从实际经验中获取信息，无需提前获知环境模型的全部信息</li><li>时序差分算法与动态规划方法的相似之处在于：时序差分方法能够利用前序已知信息来进行在线实时学习，无需等到整个片段结束（终止状态抵达）再进行价值函数的更新</li></ol></li><li>动态规划法根据贝尔曼方程迭代更新价值函数，要求算法事先知道状态之间的转移概率，这往往是不现实的。为了解决这个问题，时序差分法借鉴蒙特卡洛法思想，通过<strong>采样动作<spanclass="math inline">\(a\)</span>和下一状态<spanclass="math inline">\(s&#39;\)</span>来估计计算<spanclass="math inline">\(V_\pi(s)\)</span></strong><ol type="1"><li>由于通过采样进行计算，所得结果可能不准确，因此时序差分法并没有将这个估计值照单全收，而是<strong>以<spanclass="math inline">\(\alpha\)</span>作为权重来接受新的估计值</strong>，即把价值函数更新为<spanclass="math inline">\((1−𝛼)𝑉_𝜋(𝑠)+𝛼[𝑅+𝛾𝑉_𝜋 (s&#39;)]\)</span></li><li>对这个式子稍加整理就能得到算法中的形式：<spanclass="math inline">\(𝑉_𝜋(𝑠)←𝑉_𝜋(𝑠)+𝛼[𝑅+𝛾𝑉_𝜋(s&#39;)−𝑉_𝜋(𝑠)]\)</span><ol type="1"><li>时序差分目标：<spanclass="math inline">\(𝑅+𝛾𝑉_𝜋(𝑠&#39;)\)</span></li><li>时序差分偏差：<spanclass="math inline">\(𝑅+𝛾𝑉_𝜋(𝑠&#39;)−𝑉_𝜋(𝑠)\)</span></li></ol></li></ol></li><li>时序差分法和蒙特卡洛法都是通过采样若干个片段来进行价值函数更新的，但是时序差分法并非使用一个片段中的终止状态所提供的实际回报值来估计价值函数，而是<strong>根据下一个状态的价值函数来估计价值函数</strong>，这样就克服了采样轨迹的稀疏性可能带来样本方差较大的不足问题，同时也缩短了反馈周期</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524110051895.png" alt="image-20230524110051895" style="zoom:80%;" /></p></blockquote><h4 id="q-learning直接计算q_pi">6.2.3.4 Q-learning：直接计算<spanclass="math inline">\(q_\pi\)</span></h4><p><span class="math display">\[\begin{aligned}q_\pi(s,a) &amp;← (1-\alpha)q_\pi(s,a) + \alpha[R+\gamma \max_{a&#39;}q_\pi(s&#39;,a&#39;)]\\           &amp;= q_\pi(s,a) + \alpha[R+\gamma \max_{a&#39;}q_\pi(s&#39;,a&#39;)-q_\pi(s,a)]\end{aligned}\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524110407594.png" alt="image-20230524110407594" style="zoom:80%;" /></p><ol type="1"><li>Q-learning中<strong>直接记录和更新动作-价值函数<spanclass="math inline">\(q_\pi\)</span></strong><ol type="1"><li>这是因为策略优化要求已知动作-价值函数<spanclass="math inline">\(q_\pi\)</span>，如果算法仍然记录值函数<spanclass="math inline">\(V_\pi\)</span>，在不知道状态转移概率的情况下将无法求出<spanclass="math inline">\(q_\pi\)</span></li><li>于是，Q-learning中，只有动作-价值函数（即q函数）参与计算</li></ol></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111115648.png" alt="image-20230524111115648" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111206856.png" alt="image-20230524111206856" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111559060.png" alt="image-20230524111559060" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111640888.png" alt="image-20230524111640888" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111811375.png" alt="image-20230524111811375" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524112203863.png" alt="image-20230524112203863" style="zoom:80%;" /></p></blockquote><h4 id="ε-greedy策略策略学习中探索与利用的平衡">6.2.3.5ε-greedy策略：策略学习中探索与利用的平衡</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524112703162.png" alt="image-20230524112703162" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619221300001.png" alt="image-20230619221300001" style="zoom:80%;" /></p><ol type="1"><li>ε-greedy策略：大体上遵循最优策略的决定，偶尔(以ε的概率)进行探索<ol type="1"><li>如上一个例子中，如果偶尔在某些状态随机选择"向右移动一个方格"的动作，则可克服机器人无法走到终点<spanclass="math inline">\(s_9\)</span>这一不足</li></ol></li><li>将动作采样从"确定地选取最优动作" 改为”按照ε-greedy策略选取动作“</li><li>更新时仍保持用max操作选取最佳策略</li><li>像这样，更新时的目标策略与采样策略不同的方法，称为<strong>离策略off-policy</strong>方法</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524113241486.png" alt="image-20230524113241486" style="zoom:80%;" /></p></blockquote><h4 id="deep-q-learning用神经网络拟合q_pi">6.2.3.6 DeepQ-learning：用神经网络拟合<spanclass="math inline">\(q_\pi\)</span></h4><p>思路：将<strong>q函数参数化</strong>，用一个非线性回归模型来拟合q函数</p><ol type="1"><li>能够用有限的参数刻画无限的状态</li><li>由于回归函数的连续性，没有探索过的状态也可以通过周围状态来估计</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524113539570.png" alt="image-20230524113539570" style="zoom:80%;" /></p><ol type="1"><li>损失函数刻画了<strong>q的估计值<span class="math inline">\(R+\gamma\max_{a&#39;}q_\pi(s&#39;,a&#39;;\theta)\)</span>与当前值的平方误差</strong></li><li>利用梯度下降算法优化参数<spanclass="math inline">\(\theta\)</span></li><li>如果使用深度神经网络来拟合q函数，则该算法称为<strong>DeepQ-learning/深度强化学习</strong></li></ol><h2 id="不考6.3-基于策略的强化学习">(不考)6.3 基于策略的强化学习</h2><p>基于价值的强化学习：</p><ol type="1"><li>以<strong>对价值函数/动作-价值函数的建模</strong>为核心</li></ol><p>基于策略的强化学习：</p><ol type="1"><li>直接<strong>参数化策略函数</strong>，求解参数化的策略函数的梯度</li><li>策略函数的参数化可以表示为<span class="math inline">\(𝝅_𝜽(𝒔,𝒂)\)</span>，其中<spanclass="math inline">\(𝜽\)</span>为一组参数，函数取值表示在状态<spanclass="math inline">\(𝒔\)</span>下选择动作<spanclass="math inline">\(𝒂\)</span>的概率</li><li>和Q学习的<spanclass="math inline">\(𝝐\)</span>贪心策略相比，这种参数化的一个显著好处是：选择一个动作的概率是随着参数的改变而光滑变化的，实际上这种光滑性对算法收敛有更好的保证。</li></ol><h3 id="不考6.3.1-策略梯度定理">(不考)6.3.1 策略梯度定理</h3><p>最大化目标： <span class="math display">\[MAX\ J(\theta)=V_{\pi_\theta}(s_0), 从初始状态出发的价值函数\]</span> 策略梯度定理： <span class="math display">\[∇_\theta J(\theta) \propto \sum_s\mu_{\pi_\theta}(s)\sum_aq_{\pi_\theta}(s,a)∇_\theta\pi_\theta(s,a)\]</span><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524120505284.png" alt="image-20230524120505284" style="zoom:80%;" /></p><h3 id="不考6.3.2-基于蒙特卡洛采样的策略梯度法">(不考)6.3.2基于蒙特卡洛采样的策略梯度法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524120622673.png" alt="image-20230524120622673" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121005545.png" alt="image-20230524121005545" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121431806.png" alt="image-20230524121431806" style="zoom:80%;" /></p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121443343.png"alt="image-20230524121443343" /><figcaption aria-hidden="true">image-20230524121443343</figcaption></figure><h3 id="不考6.3.3-基于时序差分的策略梯度法actor-critic">(不考)6.3.3基于时序差分的策略梯度法：Actor-Critic</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121517685.png" alt="image-20230524121517685" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121527223.png" alt="image-20230524121527223" style="zoom:80%;" /></p><h2 id="不考6.4-深度强化学习的应用">(不考)6.4 深度强化学习的应用</h2><h3 id="不考6.4.1-deep-q-learning围棋博弈">(不考)6.4.1 DeepQ-Learning：围棋博弈</h3><blockquote><p>围棋游戏的一个片段的轨迹</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121625616.png" alt="image-20230524121625616" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121642810.png" alt="image-20230524121642810" style="zoom:80%;" /></p><h3 id="不考6.4.2-deep-q-learning雅达利游戏">(不考)6.4.2 DeepQ-Learning：雅达利游戏</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121731339.png" alt="image-20230524121731339" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121902690.png" alt="image-20230524121902690" style="zoom:80%;" /></p><h3 id="不考6.4.3-难以探索的例子">(不考)6.4.3 难以探索的例子</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121930690.png" alt="image-20230524121930690" style="zoom:80%;" /></p><h2 id="强化学习的分类">6.5 强化学习的分类</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524122000911.png" alt="image-20230524122000911" style="zoom:80%;" /></p><p>图中从两个角度对强化学习算法做了分类 1.其中依靠对环境（即马尔可夫随机过程）的先验知识或建模的算法称为<strong>基于模型（Model-based）的方法</strong>，反之称为<strong>无模型的方法（Model-free）</strong>2.只对价值函数建模并利用策略优化定理求解的方法称为<strong>基于价值（Value-based）的方法</strong>，对策略函数建模并利用策略梯度定理求解的方法称为<strong>基于策略（Policy-based）的方法</strong></p><h1 id="七人工智能博弈">七、人工智能博弈</h1><h2 id="博弈论的相关概念">7.1 博弈论的相关概念</h2><h3 id="博弈的要素">7.1.1 博弈的要素</h3><ol type="1"><li><strong>参与者/玩家 player</strong>：参与博弈的决策主体</li><li><strong>策略strategy</strong>：参与者可以采取的行动方案，是在采取行动之前就已经准备好的完整方案<ol type="1"><li>每个参与者可采纳策略的全体组合形成了<strong>策略集 strategyset</strong></li><li>所有参与者各自采取行动后形成的状态被称为<strong>局势outcome</strong></li><li>如果参与者可以通过一定概率分布来选择若干个不同的策略，这样的策略称为<strong>混合策略mixed strategy</strong>。</li><li>若参与者每次行动都选择某个确定的策略，这样的策略称为<strong>纯策略pure strategy</strong></li></ol></li><li><strong>收益 payoff</strong>：各个参与者在不同局势下得到的利益<ol type="1"><li>混合策略意义下的收益应为<strong>期望收益 expectedpayoff</strong></li></ol></li><li><strong>规则rule</strong>：对参与者行动的先后顺序、参与者获得信息多少等内容的规定</li></ol><h3 id="研究范式">7.1.2 研究范式</h3><p><strong>研究范式</strong>：建模者对参与者规定可采取的策略集和取得的收益，观察当参与者选择若干策略以最大化其收益时会产生什么结果</p><h3 id="囚徒困境-prisoners-dilemma">7.1.3 囚徒困境 Prisoner'sDilemma</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531105937279.png" alt="image-20230531105937279" style="zoom:80%;" /></p><ol type="1"><li><strong>均衡解</strong>：在当前情况下，任意一个人改变策略，而其他人保持不变，改变策略的人得到的收益一定变低</li></ol><h3 id="博弈的分类">7.1.4 博弈的分类</h3><p>合作博弈与非合作博弈</p><ol type="1"><li><strong>合作博弈 cooperativegame</strong>：部分参与者可以组成联盟以获得更大的收益</li><li><strong>非合作博弈 non-cooperativegame</strong>：参与者在决策中都彼此独立，不事先达成合作意向</li></ol><p>静态博弈与动态博弈</p><ol type="1"><li><strong>静态博弈 staticgame</strong>：所有参与者同时决策，或参与者互相不知道对方的决策</li><li><strong>动态博弈 dynamicgame</strong>：参与者所采取行为的先后顺序由规则决定，且后行动者知道先行动者所采取的行为</li></ol><p>完全信息博弈与不完全信息博弈</p><ol type="1"><li><strong>完全信息 completeinformation</strong>：所有参与者均了解其他参与者的策略集、收益等信息</li><li><strong>不完全信息 incompleteinformation</strong>：并非所有参与者均掌握了所有信息</li></ol><p>囚徒困境是一种非合作、不完全信息的静态博弈</p><h3 id="纳什均衡">7.1.5 纳什均衡</h3><p>博弈的稳定局势即为<strong>纳什均衡 Nash equilibrium</strong>：</p><ol type="1"><li>指的是参与者所作出的这样一种策略组合，在该策略组合上，任何参与者单独改变策略都不会得到好处</li><li>换句话说，如果在一个策略组合上，当所有其他人都不改变策略时，没有人会改变自己的策略，则该策略组合就是一个纳什均衡</li><li>纳什均衡的本质：不后悔</li></ol><p><strong>Nash定理</strong>：</p><ol type="1"><li>若参与者有限，每位参与者的策略集有限，收益函数为实值函数，则博弈必<strong>存在</strong>混合策略意义下的纳什均衡</li></ol><p>囚徒困境中两人同时认罪就是这一问题的纳什均衡</p><p><strong>混合策略纳什均衡</strong>：</p><ol type="1"><li>博弈过程中，博弈方通过概率形式随机从可选策略中选择一个策略而达到的纳什均衡</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531111906949.png" alt="image-20230531111906949" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531111834818.png" alt="image-20230531111834818" style="zoom:80%;" /></p><p>设雇主检查的概率为<spanclass="math inline">\(\alpha\)</span>，雇员偷懒的概率为<spanclass="math inline">\(\beta\)</span>，则雇主-雇员之间博弈的期望收益为：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531112006083.png" alt="image-20230531112006083" style="zoom:80%;" /></p><p><strong>纳什均衡</strong>：其他参与者策略不变的情况下，某个参与者单独采取其他策略都不会使得收益增加⇔<strong>无论雇主是否检查，雇主的收益都一样；无论雇员是否偷懒，雇员的收益都一样</strong></p><ol type="1"><li>于是有<span class="math inline">\(𝑻_𝟏=𝑻_𝟐\)</span> 以及<spanclass="math inline">\(𝑻_𝟑=𝑻_𝟒\)</span></li><li>在纳什均衡下，由于<spanclass="math inline">\(𝑻_𝟑=𝑻_𝟒\)</span>，可知雇主采取检查策略的概率（雇主趋向于用这个概率去检查）：<spanclass="math inline">\(𝜶=\frac{𝑯}{𝑾+𝑭}\)</span></li><li>在纳什均衡下，由于<spanclass="math inline">\(𝑻_𝟏=𝑻_𝟐\)</span>，可知雇员采取偷懒策略的概率（雇员趋向于用这个概率去偷懒）：<spanclass="math inline">\(𝜷=\frac{𝑪}{𝑾+𝑭}\)</span></li><li>在检查概率为𝜶之下，雇主的收益：<spanclass="math inline">\(𝑻_𝟏=𝑻_𝟐=𝑽−𝑾−\frac{𝑪𝑽}{𝑾+𝑭}\)</span></li><li>对上式中<span class="math inline">\(𝑾\)</span>求导，则当<spanclass="math inline">\(𝑾=\sqrt{𝑪𝑽}−𝑭\)</span>时，雇主的收益最大，其值为<spanclass="math inline">\(𝑻_{𝒎𝒂𝒙}=𝑽−𝟐\sqrt{𝑪𝑽}+𝑭\)</span></li></ol></blockquote><h3 id="策梅洛定理">7.1.6 策梅洛定理</h3><p><strong>策梅洛定理 Zermelo's theorem</strong>：</p><ol type="1"><li>对于任意一个<strong>有限步</strong>的<strong>双人完全信息零和</strong>动态博弈，一定存在<strong>先手必胜</strong>策略或<strong>后手必胜</strong>策略或<strong>双方保平</strong>策略</li><li>策梅洛定理仅对<strong>两人博弈</strong>有效，如果博弈竞技者超过了2人，如对于三人博弈，策梅洛定理无法保证三方中一定有一方获胜、其他两方必败或者三方和局的策略</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531113435683.png" alt="image-20230531113435683" style="zoom:80%;" /></p></blockquote><h2 id="不考7.2-博弈策略求解">(不考)7.2 博弈策略求解</h2><p>动机</p><ol type="1"><li>博弈论提供了许多问题的数学模型</li><li>纳什定理确定了博弈过程问题存在解</li><li>人工智能的方法可用来求解均衡局面或者最优策略</li></ol><p>主要问题</p><ol type="1"><li>如何高效求解博弈参与者的策略以及博弈的均衡局势？</li></ol><p>应用领域</p><ol type="1"><li>大规模搜索空间的问题求解：围棋</li><li>非完全信息博弈问题求解：德州扑克</li><li>网络对战游戏智能：Dota、星球大战</li><li>动态博弈的均衡解：厂家竞争、信息安全</li></ol><h3 id="不考7.2.1-虚拟遗憾最小化算法-regret-minimization">(不考)7.2.1虚拟遗憾最小化算法 Regret Minimization</h3><ol type="1"><li><p>对于一个有<spanclass="math inline">\(N\)</span>个玩家参加的博弈，玩家<spanclass="math inline">\(i\)</span>在博弈中采取的策略为<spanclass="math inline">\(\sigma_i\)</span></p></li><li><p>对于所有玩家来说，他们的所有策略构成了一个策略组合，记为<spanclass="math inline">\(\sigma=\{\sigma_1,\sigma_2,...,\sigma_N\}\)</span></p></li><li><p>策略组中，除玩家<spanclass="math inline">\(i\)</span>外，其它玩家的策略组合记为<spanclass="math inline">\(\sigma_{-i}=\{\sigma_1,\sigma_2,...,\sigma_{i-1},\sigma_{i+1},...,\sigma_N\}\)</span></p></li><li><p>给定策略组合<spanclass="math inline">\(\sigma\)</span>，玩家<spanclass="math inline">\(i\)</span>在终结局势下的收益记为<spanclass="math inline">\(u_i(\sigma)\)</span></p></li><li><p>在给定其它玩家的策略组合<spanclass="math inline">\(\sigma_{-i}\)</span>的情况下，对玩家<spanclass="math inline">\(i\)</span>而言的<strong>最优反应策略<spanclass="math inline">\(\sigma_i^*\)</span></strong>满足如下条件： <spanclass="math display">\[u_i(\sigma_i^*,\sigma_{-i}) \ge \max_{\sigma_i&#39;\in\sum_i}u_i(\sigma_i&#39;,\sigma_{-i})\]</span></p><ol type="1"><li><span class="math inline">\(\sum_i\)</span>是玩家<spanclass="math inline">\(i\)</span>可以选择的所有策略</li><li>如上条件表示当玩家<spanclass="math inline">\(i\)</span>采用最优反应策略时，玩家<spanclass="math inline">\(i\)</span>能够获得最大收益</li></ol></li></ol><h4 id="不考7.2.1.1-纳什均衡策略的定义">(不考)7.2.1.1纳什均衡策略的定义</h4><ol type="1"><li><p>在策略组合<spanclass="math inline">\(𝜎^∗\)</span>中，如果每个玩家的策略相对于其他玩家的策略而言都是最佳反应策略，那么策略组合<spanclass="math inline">\(𝜎^∗\)</span>就是一个<strong>纳什均衡策略</strong></p><ol type="1"><li>在有限对手、有限策略情况下，纳什均衡一定存在</li><li>策略组<spanclass="math inline">\(𝜎^∗=\{𝜎_1^∗,𝜎_2^∗,…,𝜎_𝑁^∗\}\)</span>对任意玩家<spanclass="math inline">\(𝑖=1,..,𝑁\)</span>，满足如下条件：</li></ol></li></ol><p><span class="math display">\[   𝑢_𝑖(𝜎^∗) ≥ \max_{𝜎_𝑖^′∈Σ_𝑖} 𝜇_𝑖 (𝜎_1^∗,𝜎_2^∗,…,𝜎_𝑖^′,…,𝜎_𝑁^∗)\]</span></p><ol start="2" type="1"><li><p>在博弈策略求解的过程中，希望求解得到<strong>每个玩家最优反应策略</strong>，若所有玩家都是理性的，则算法求解最优反应策略就是一个纳什均衡</p></li><li><p>考虑到计算资源有限这一前提，难以通过遍历博弈中所有策略组合来找到一个最优反应策略，因此需要找到一种能<strong>快速发现近似纳什均衡</strong>的方法</p></li></ol><h4 id="不考7.2.1.2-遗憾最小化算法">(不考)7.2.1.2 遗憾最小化算法</h4><p>遗憾最小化算法是一种<strong>根据以往博弈过程中所得遗憾程度来选择未来行为</strong>的方法</p><ol type="1"><li><p>在过去<span class="math inline">\(𝑇\)</span>轮中，玩家<spanclass="math inline">\(𝑖\)</span>采取策略<spanclass="math inline">\(𝜎_𝑖\)</span>的<strong>累加遗憾值</strong>定义如下：<span class="math display">\[Regret_i^T (𝜎_i)=\sum_{𝑡=1}^𝑇 (u_i(𝜎_i,𝜎_{−i}^t) − u_i(𝜎^t))\]</span></p><ol type="1"><li><span class="math inline">\(𝜎^𝑡\)</span>表示：第<spanclass="math inline">\(𝑡\)</span>轮中所有玩家的策略组合</li><li><span class="math inline">\(𝜎_{−𝑖}^𝑡\)</span>表示：第<spanclass="math inline">\(𝑡\)</span>轮中除了玩家<spanclass="math inline">\(𝑖\)</span>以外的策略组合</li></ol></li><li><p>简单地说，累加遗憾值代表：</p><ol type="1"><li>在过去<span class="math inline">\(𝑇\)</span>轮中，玩家<spanclass="math inline">\(𝑖\)</span>在每一轮中选择策略<spanclass="math inline">\(𝜎_𝑖\)</span>所得收益与采取其他策略所得收益之差的累加</li></ol></li></ol><h4 id="不考7.2.1.3-有效遗憾值">(不考)7.2.1.3 有效遗憾值</h4><ol type="1"><li><p>在得到玩家<spanclass="math inline">\(i\)</span>的所有可选策略的遗憾值后，可以根据遗憾值的大小来选择后续第<spanclass="math inline">\(𝑇+1\)</span>轮博弈的策略，这种选择方式被称为<strong>遗憾匹配</strong></p></li><li><p>当然，通常遗憾值为负数的策略被认为不能提升下一时刻收益，所以如下定义有效遗憾值：<span class="math display">\[𝑅𝑒𝑔𝑟𝑒𝑡_𝑖^{𝑇,+} 𝜎_𝑖=\max (𝑅𝑒𝑔𝑟𝑒𝑡_𝑖^𝑇(𝜎_𝑖),0)\]</span></p></li><li><p>利用有效遗憾值的遗憾匹配，可得到玩家<spanclass="math inline">\(𝑖\)</span>在第<spanclass="math inline">\(T+1\)</span>轮选择策略<spanclass="math inline">\(𝜎_𝑖\)</span>的概率<spanclass="math inline">\(𝑃(𝜎_𝑖^{T+1})\)</span>为：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531115940689.png" alt="image-20230531115940689" style="zoom:80%;" /></p><ol type="1"><li><span class="math inline">\(|Σ_i|\)</span>表示玩家<spanclass="math inline">\(𝑖\)</span>所有策略的总数</li><li>显然，如果在过往<span class="math inline">\(𝑇\)</span>轮中策略<spanclass="math inline">\(𝜎_𝑖\)</span>所带来的遗憾值大、其他策略<spanclass="math inline">\(𝜎_𝑖^′\)</span>所带来的遗憾值小，则在第<spanclass="math inline">\(𝑇+1\)</span>轮选择策略<spanclass="math inline">\(𝜎_𝑖\)</span>的概率值<spanclass="math inline">\(𝑃(𝜎_𝑖^{𝑇+1})\)</span>就大</li><li>即：<strong>带来越大遗憾值的策略具有更高的价值，因此其在后续被选择的概率就应该越大</strong></li><li>如果没有一个能够提升前<spanclass="math inline">\(T\)</span>轮收益的策略，则在后续轮次中随机选择一种策略</li></ol></li><li><p>可以依照一定的概率选择行动</p><ol type="1"><li>为了防止对手发现自己所采取的策略，如采取遗憾值最大的策略</li></ol></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531120014258.png" alt="image-20230531120014258" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531120224753.png" alt="image-20230531120224753" style="zoom:80%;" /></p></blockquote><h4 id="不考7.2.1.4-计算理论">(不考)7.2.1.4 计算理论</h4><ol type="1"><li><p>对于任何序贯决策的博弈对抗，可将博弈过程表示成一棵博弈树，博弈树中的每一个中间节点都是一个<strong>信息集<spanclass="math inline">\(I\)</span></strong>，信息集中包含了博弈中当前的状态</p><ol type="1"><li>给定博弈树的每一个节点，玩家都可以从一系列的动作中选择一个，然后状态发生转换，如此周而复始，直到终局（博弈树的叶子节点）</li><li>玩家在当前状态下可采取的策略就是当前状态下所有可能动作的一个概率分布</li></ol></li><li><p>具体而言，在信息集<spanclass="math inline">\(𝐼\)</span>下，玩家可以采取的<strong>行动集合记作<spanclass="math inline">\(𝐴(𝐼)\)</span></strong></p><ol type="1"><li>玩家<span class="math inline">\(𝑖\)</span>所采取的行动<spanclass="math inline">\(𝑎_𝑖∈𝐴(𝐼)\)</span>可认为是其采取的策略<spanclass="math inline">\(𝜎_𝑖\)</span>的一部分</li><li>在信息集<span class="math inline">\(𝐼\)</span>下采取行动<spanclass="math inline">\(𝑎\)</span>所代表的策略记为<spanclass="math inline">\(𝜎_{𝐼→𝑎}\)</span></li><li>这样，要计算虚拟遗憾值的对象，就是博弈树中每个中间节点在信息集下所采取的行动，并根据遗憾值匹配得到该节点在信息集下应该采取的策略<spanclass="math inline">\(𝜎_{𝐼→𝑎}\)</span></li></ol></li><li><p>在一次博弈中，所有玩家交替采取的<strong>行动序列记为<spanclass="math inline">\(ℎ\)</span></strong>（从根节点到当前节点的路径）</p><ol type="1"><li>对于所有玩家的策略组合<spanclass="math inline">\(𝜎\)</span>，行动序列ℎ出现的概率记为<spanclass="math inline">\(𝜋^𝜎(ℎ)\)</span>，不同的行动序列可以从根节点到达当前节点的信息集<spanclass="math inline">\(𝐼\)</span>（即不同决策路径可到达博弈树中同一个中间节点）</li><li>在策略组合<spanclass="math inline">\(𝜎\)</span>下，所有能够到达该信息集的行动序列的概率累加就是该信息集的出现概率，即<spanclass="math inline">\(𝜋^𝜎(𝐼)=∑_{ℎ∈𝐼}𝜋^𝜎 (ℎ)\)</span></li></ol></li><li><p>博弈的<strong>终结局势集合</strong>也就是博弈树中叶子节点的集合，记为<spanclass="math inline">\(𝑍\)</span></p><ol type="1"><li>对于任意一个终结局势<spanclass="math inline">\(𝑧∈𝑍\)</span>，玩家<spanclass="math inline">\(𝑖\)</span>在此终点局势下的<strong>收益记作<spanclass="math inline">\(𝑢_𝑖 (𝑧)\)</span></strong></li><li>给定行动序列<spanclass="math inline">\(ℎ\)</span>，依照策略组合<spanclass="math inline">\(𝜎\)</span>最终到达终结局势<spanclass="math inline">\(𝑧\)</span>的<strong>概率记作<spanclass="math inline">\(𝜋^𝜎 (ℎ,𝑧)\)</span></strong></li></ol></li><li><p>在策略组合<span class="math inline">\(𝜎\)</span>下，对玩家<spanclass="math inline">\(𝑖\)</span>而言，如下计算从根节点到当前节点的<strong>行动序列路径<spanclass="math inline">\(ℎ\)</span>的虚拟价值<spanclass="math inline">\(v_i(σ,h)\)</span></strong>：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111149556.png" alt="image-20230607111149556" style="zoom:80%;" /></p><ol type="1"><li>在上式中，<spanclass="math inline">\(𝜋_{−𝑖}^𝜎(ℎ)\)</span>表示从根节点出发，不考虑玩家<spanclass="math inline">\(𝑖\)</span>的策略，仅考虑其他玩家策略而经过路径<spanclass="math inline">\(ℎ\)</span>到达当前节点的概率</li><li>也就是说，即使玩家𝑖有其他策略，总是要求玩家<spanclass="math inline">\(𝑖\)</span>在每次选择时都选择路径ℎ中对应的动作，以保证从根节点出发能够到达当前节点</li><li>可见，行动序列路径ℎ的虚拟价值等于如下三项结果的乘积：不考虑玩家𝑖的策略（仅考虑其他玩家策略）经过路径ℎ到达当前节点的概率、从当前节点走到叶子结点（博弈结束）的概率、所到达叶子节点的收益。</li></ol></li><li><p>在定义了行动序列路径ℎ的虚拟价值之后，就可如下计算玩家<spanclass="math inline">\(𝑖\)</span>在基于路径<spanclass="math inline">\(ℎ\)</span>到达当前节点采取行动<spanclass="math inline">\(𝑎\)</span>的<strong>遗憾值</strong>： <spanclass="math display">\[𝑟_𝑖 (ℎ,𝑎)=𝑣_𝑖(𝜎_{𝐼→𝑎},ℎ)−𝑣_𝑖 (𝜎,ℎ)\]</span></p><ol type="1"><li>该遗憾值是玩家<spanclass="math inline">\(𝑖\)</span>通过行动序列<spanclass="math inline">\(ℎ\)</span>到达当前节点采取行动<spanclass="math inline">\(𝑎\)</span>所得虚拟价值减去采用策略<spanclass="math inline">\(𝜎\)</span>所得路径<spanclass="math inline">\(ℎ\)</span>的虚拟价值</li></ol></li><li><p>对能够到达同一个信息集<spanclass="math inline">\(𝐼\)</span>（即博弈树中同一个中间节点）的所有行动序列的遗憾值进行累加，即可得到信息集<spanclass="math inline">\(𝐼\)</span>的遗憾值： <span class="math display">\[𝑟_𝑖(𝐼,𝑎)=\sum_{ℎ∈𝐼}𝑟_𝑖(ℎ,𝑎)\]</span></p></li><li><p>类似于遗憾最小化算法，虚拟遗憾最小化的遗憾值是𝑇轮重复博弈后的累加值：<span class="math display">\[𝑅𝑒𝑔𝑟𝑒𝑡_𝑖^𝑇 (𝐼,𝑎)=∑_{𝑡=1}^𝑇 𝑟_𝑖^𝑡 (𝐼,𝑎)\]</span></p><ol type="1"><li><span class="math inline">\(𝑟_𝑖^𝑡 (𝐼,𝑎)\)</span>表示玩家<spanclass="math inline">\(𝑖\)</span>在第<spanclass="math inline">\(𝑡\)</span>轮中于当前节点选择行动<spanclass="math inline">\(𝑎\)</span>的遗憾值</li></ol></li><li><p>进一步可以定义有效虚拟遗憾值： <span class="math display">\[𝑅𝑒𝑔𝑟𝑒𝑡_𝑖^{𝑇,+}(𝐼,𝑎)=\max(𝑅_𝑖^𝑇 (𝐼,𝑎),0)\]</span></p></li><li><p>根据有效虚拟遗憾值进行遗憾匹配以计算经过<spanclass="math inline">\(𝑇\)</span>轮博弈后，玩家<spanclass="math inline">\(𝑖\)</span>在信息集<spanclass="math inline">\(𝐼\)</span>情况下于后续<spanclass="math inline">\(𝑇+1\)</span>轮选择行动<spanclass="math inline">\(𝑎\)</span>的概率：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531121756780.png" alt="image-20230531121756780" style="zoom:80%;" /></p></li></ol><h4 id="不考7.2.1.5-虚拟最小化算法步骤">(不考)7.2.1.5虚拟最小化算法步骤</h4><p>在虚拟最小化算法的求解过程中，同样需要反复模拟多轮博弈来拟合最佳反应策略，算法步骤如下</p><ol type="1"><li>初始化遗憾值和累加策略表为0</li><li>采用随机选择的方法来决定策略</li><li>利用当前策略与对手进行博弈</li><li>计算每个玩家采取每次行为后的遗憾值</li><li>根据博弈结果计算每个行动的累加遗憾值大小来更新策略</li><li>重复3)到5)步若干次，不断的优化策略</li><li>根据重复博弈最终的策略，完成最终的动作选择</li></ol><h4 id="不考7.2.1.6-示例">(不考)7.2.1.6 示例</h4><p>双人库恩扑克游戏</p><ol type="1"><li><p>规则：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607104906067.png" alt="image-20230607104906067" style="zoom:80%;" /></p></li><li><p>先手玩家A对应的博弈树</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607110005718.png" alt="image-20230607110005718" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607105608061.png" alt="image-20230607105608061" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607105558855.png" alt="image-20230607105558855" style="zoom:80%;" /></p></li><li><p>计算节点<spanclass="math inline">\(\{1PB\}\)</span>的虚拟价值：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607105808959.png" alt="image-20230607105808959" style="zoom:80%;" /></p></li><li><p>计算玩家A在节点<spanclass="math inline">\(\{1PB\}\)</span>选择过牌行动后的虚拟价值：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607110243336.png" alt="image-20230607110243336" style="zoom:80%;" /></p></li><li><p>计算玩家A在节点<spanclass="math inline">\(\{1PB\}\)</span>选择过牌行动后的虚拟遗憾值：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607110537655.png" alt="image-20230607110537655" style="zoom:80%;" /></p></li></ol><h2 id="博弈规则设计">7.3 博弈规则设计</h2><h3 id="研究的问题">7.3.1 研究的问题</h3><ol type="1"><li>在现实生活中，如果所有博弈者都追求自己利益最大化，很可能会导致两败俱伤的下场</li><li>那么应该如何设计博弈的规则使得博弈的最终局势能尽可能达到整体利益的最大化呢？</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111305301.png" alt="image-20230607111305301" style="zoom:80%;" /></p></blockquote><h3 id="双边匹配算法">7.3.2 双边匹配算法</h3><ol type="1"><li>在生活中，人们常常会碰到与资源匹配相关的决策问题(如求职就业、报考录取等)，这些需要双向选择的情况被称为是<strong>双边匹配问题</strong></li><li>在双边匹配问题中，需要双方互相满足对方的需求才会达成匹配</li></ol><h4 id="稳定婚姻问题-stable-marriage-problem">7.3.2.1 稳定婚姻问题Stable Marriage Problem</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112146858.png" alt="image-20230607112146858" style="zoom:80%;" /></p><blockquote><p>假设有4名单身男性{𝟏,𝟐,𝟑,𝟒}和4名单身女性{𝑨,𝑩,𝑪,𝑫}，他（她）们的、爱慕序列如表8.9所示</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111451720.png" alt="image-20230607111451720" style="zoom:80%;" /></p><p>按照“修补”策略，匹配和修补过程如下</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111528939.png" alt="image-20230607111528939" style="zoom:80%;" /></p></blockquote><h4 id="双边匹配问题g-s算法">7.3.2.2 双边匹配问题：G-S算法</h4><p>算法过程：</p><ol type="1"><li>单身男性向最喜欢的女性表白</li><li>所有收到表白的女性从向其表白男性中选择最喜欢的男性，暂时匹配</li><li>未匹配的男性继续向没有拒绝过他的女性表白</li><li>收到表白的女性如果没有完成匹配，则从这一批表白者中选择最喜欢男性。即使收到表白的女性已经完成匹配，但是如果她认为有她更喜欢的男性，则可以拒绝之前的匹配者，重新匹配</li><li>如此循环迭代，直到所有人都成功匹配为止</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111755649.png" alt="image-20230607111755649" style="zoom:80%;" /></p><ol type="1"><li>在第一轮中，4名男性分别向自己最喜欢的女性告白，而收到3人告白的女性𝐴选择了自己最喜欢的男性3，另一个收到告白的女性𝐵选择了男性4</li><li>在第二轮中，尚未匹配的男性1和男性2继续向自己第二喜欢的对象告白，收到告白的女性𝐵选择了自己更喜欢的男性2而放弃了男性4</li><li>同理继续三轮告白和选择，所有人都找到了自己的伴侣，且所有匹配都是稳定的</li><li>可以看出，使用G-S算法得到了稳定匹配的结果。</li></ol></blockquote><h3 id="单边匹配问题最大交易圈算法-top-trading-cycle-ttc">7.3.3单边匹配问题：最大交易圈算法 Top-trading cycle TTC</h3><p>算法流程：</p><ol type="1"><li>首先记录每个物品的初始占有者，或者对物品进行随机分配</li><li>每个交易者连接一条指向他最喜欢的物品的边，并从每一个物品连接到其占有者或是具有高优先权的交易者</li><li>此时形成一张有向图，且必存在环，这种环被称为“交易圈”，对于交易圈中的交易者，将每人指向节点所代表的物品赋予交易者，同时交易者放弃原先占有的物品，占有者和匹配成功的物品离开匹配市场</li><li>接着从剩余的交易者和物品之间重复进行交易圈匹配，直到无法形成交易圈，算法停止</li></ol><blockquote><p><strong>稳定室友匹配</strong>问题就是一个典型的单边匹配问题</p><p>假设某寝室有A、B、C、D四位同学和1、2、3、4四个床位，当前给A、B、C、D四位同学随机分配4、3、2、1四个床位</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112416470.png" alt="image-20230607112416470" style="zoom:80%;" /></p><p>第一轮单边匹配：A和D之间构成一个交易圈，可达成交易，所以A得到床位1，D得到床位4，之后将A和D以及1和4从匹配图中移除</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112509623.png" alt="image-20230607112509623" style="zoom:80%;" /></p><p>第二轮单边匹配：B和C都希望得到床位2，无法再构成交易圈，但是由于C是床位的本身拥有者，所以C仍然得到床位2，B只能选择床位3</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112551559.png" alt="image-20230607112551559" style="zoom:80%;" /></p><p>最后交易结果A→1，B →3，C →2，D →4</p></blockquote><h2 id="非完全信息博弈的实际应用">7.4 非完全信息博弈的实际应用</h2><h3 id="博弈论研究内容">7.4.1 博弈论研究内容</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112747539.png" alt="image-20230607112747539" style="zoom:80%;" /></p><h3 id="求解非完全信息博弈纳什均衡的一般方法">7.4.2求解非完全信息博弈纳什均衡的一般方法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112801250.png" alt="image-20230607112801250" style="zoom:80%;" /></p><h3 id="与深度强化学习相结合">7.4.3 与深度强化学习相结合</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112837994.png" alt="image-20230607112837994" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112848255.png" alt="image-20230607112848255" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多媒体技术</title>
      <link href="/2023/03/03/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/03/03/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一多媒体介绍">一、多媒体介绍</h1><h2 id="什么是多媒体">1.1 什么是多媒体</h2><ol type="1"><li>用于同时采集、处理、编辑、存储、表示两种及以上媒体类型的技术</li><li>一种能够创造、表示、处理、存储多种模态 信息的机器</li></ol><p>Perception Medium：感知媒介</p><ol type="1"><li>用于数据的采集和输入</li><li>如：麦克风、摄像头</li></ol><p>Representation Medium：表示媒介</p><ol type="1"><li>高效的将数据从一个地方传到另一个地方</li><li>如：网络、编码</li></ol><p>Presentation Medium：展示媒介</p><ol type="1"><li>将电信号转化为可以感知的信号</li><li>如：音响</li></ol><p>Storage Medium：存储媒介</p><ol type="1"><li>如：光盘、硬盘</li></ol><p>Transition Medium：传输媒介</p><h2 id="结构化数据">1.2 结构化数据</h2><p>对于某个特定数据，计算机可以明确、快速的找到该数据的语义</p><ol type="1"><li>非结构化数据：视频、音频、文本</li><li>结构化数据：关系型数据库</li></ol><p>多媒体的任务：将非结构化的数据转化为结构化数据，让计算机能够处理</p><h1 id="二图形和图像数据表示">二、图形和图像数据表示</h1><h2 id="基础图像类型">2.1 基础图像类型</h2><h3 id="bit-二值图像">2.1.1 1-bit 二值图像</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303080712834.png" alt="image-20230303080712834" style="zoom:80%;" /></p><ol type="1"><li>包含多个像素</li><li>每个像素存储1-bit：0--black，1--white<ol type="1"><li>1表示有光照，因此是白的</li></ol></li><li>图像的大小：<ol type="1"><li>设分辨率为640×480，则大小为：640×480/8 = 38.4KB</li></ol></li><li>用途：<ol type="1"><li>存储简单图形、文本图像</li></ol></li></ol><h3 id="bit-灰度图像">2.1.2 8-bit 灰度图像</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303081016469.png" alt="image-20230303081016469" style="zoom:80%;" /></p><ol type="1"><li>每个像素存储1-Byte = 0bit：有0~255共256个灰度等级<ol type="1"><li>256表示白色</li></ol></li><li>整个像素可以视为一个像素值的二维矩阵，被称为<strong>bitmap</strong><ol type="1"><li>8-bit灰度图像也可以视为8个1-bit图像的加权叠加</li></ol></li><li>图像的大小：<ol type="1"><li>设分辨率为640×480，则大小为：640×480 = 307,200 B</li></ol></li></ol><h3 id="将一个8-bit图像用一个1-bit打印机打印出来">2.1.3将一个8-bit图像用一个1-bit打印机打印出来</h3><ol type="1"><li><p><strong>DPI</strong>：Dot per inch</p><ol type="1"><li>DPI越高，代表打印机的质量越好</li></ol></li><li><p>1-bit打印机打印8-bit图像，本质上是用空间上的密度换取视觉上的感受</p><ol type="1"><li>抖动算法<strong>Dithering</strong>：用多个点替代原本的每一个像素</li><li>如果每个像素用<strong>N×N</strong>个点替代，则最多表示<strong>0~N<sup>2</sup></strong>的灰度等级</li><li>打印机的驱动程序：将8-bit灰度图像，通过抖动算法，转换为一个更大的二值图像</li></ol></li><li><p>抖动矩阵：</p><ol type="1"><li>将当前像素点的灰度值与抖动矩阵比较，如果抖动矩阵当前位的值 &gt;灰度值，则打印为黑色，否则打印为白色</li><li>不同硬件厂商，驱动中固化的抖动矩阵不同</li><li>对每一个像素，均通过抖动矩阵进行转化，从而可以得出一个更大的二值图像</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303082539666.png" alt="image-20230303082539666" style="zoom:80%;" /></p></li><li><p>示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303082901189.png" alt="image-20230303082901189" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303083306296.png" alt="image-20230303083306296" style="zoom:67%;" /></p></li></ol><h3 id="bit-真彩色图像">2.1.4 24-Bit 真彩色图像</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303083457810.png" alt="image-20230303083457810" style="zoom:80%;" /></p><ol type="1"><li>每个像素分为三个通道RGB，每个通道取值范围为0~255<ol type="1"><li>颜色种类数：256×255×256</li></ol></li><li>32-Bit图像多了一个alpha通道，表示透明度，用于特效设计</li></ol><h3 id="bit-彩色图像256色彩色图像">2.1.5 8-Bit彩色图像：256色彩色图像</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303084302637.png" alt="image-20230303084302637" style="zoom:80%;" /></p><ol type="1"><li>将8-Bit彩色图像，显示到RGB显示器中：颜色查找表<strong>Color LookupTable</strong><ol type="1"><li>每个像素存储的是颜色查找表中的索引</li><li>显示器显示该像素时，根据索引查找颜色查找表，然后显示表中对应项的RGB值</li></ol></li><li>将24-bit彩色图像转化为8-bit彩色图像，一定会失真<ol type="1"><li>不同算法，选出来的256种颜色不同</li></ol></li></ol><h3 id="颜色查找表-color-lookup-table">2.1.6 颜色查找表 Color LookupTable</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303084509065.png" alt="image-20230303084509065" style="zoom:80%;" /></p><ol type="1"><li><p>优点：只需要将颜色查找表替换，就能更改显示风格</p></li><li><p>用途：医学图像</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303084623638.png" alt="image-20230303084623638" style="zoom:80%;" /></p></li></ol><h3 id="设计颜色查找表">2.1.7 设计颜色查找表</h3><ol type="1"><li>本质上是做一个聚类Clustering<ol type="1"><li>将原本256×256×256个颜色，集合为256种颜色</li></ol></li></ol><h4 id="示例3-bit-r3-bit-g2-bit-b">2.1.7.1 示例：3-bit R，3-bit G，2-bitB</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303085744468.png" alt="image-20230303085744468" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303085753499.png" alt="image-20230303085753499" style="zoom:80%;" /></p><h4 id="颜色直方图">2.1.7.2 颜色直方图</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303085928266.png" alt="image-20230303085928266" style="zoom:80%;" /></p><ol type="1"><li>将一张图像，按照R、G、B通道分别统计每个值出现的频率</li><li>优化方法：让最后划分出来的256个桶中，像素个数基本相同</li></ol><h4 id="median-cut中值切分">2.1.7.3 Median-cut：中值切分</h4><ol type="1"><li>每一次分割：将颜色直方图切分为两个部分，要求两个部分的离散积分(包含的像素点)相同</li><li>首先，根据图像的R值统计，然后进行分割</li><li>然后，根据上一次分割的情况，对每一个组，再次根据G值统计，然后进行分割</li><li>继续下去，按顺序总计进行了8次分割：RGBRGBRG</li><li>对每一个桶中的像素，取平均，即为颜色查找表中的颜色</li></ol><h2 id="场景图像文件格式">2.2 场景图像文件格式</h2><ol type="1"><li>格式：图像的存储方式</li></ol><h3 id="gif">2.2.1 GIF</h3><ol type="1"><li>一般情况下，使用8-bit彩色图像</li><li>通常经过了压缩</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303091226783.png" alt="image-20230303091226783" style="zoom:80%;" /></p><h3 id="jpegjoint-photographic-experts-group">2.2.2 JPEG：JointPhotographic Experts Group</h3><ol type="1"><li>JPEG一般均为压缩过的，在尽可能保存原有图像的质量下，最大化压缩比</li><li>也支持无损图像的存储</li></ol><h3 id="bmpwindows的图像格式">2.2.3 BMP：Windows的图像格式</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230303091504780.png" alt="image-20230303091504780" style="zoom:80%;" /></p><ol type="1"><li>Original data without compression, most popular</li><li>Run Length Encoding：Used for 8-bits image（256 colors）BI-RLE8</li><li>RLE：used for 4-bits image (16 colors) BI_RLE4</li></ol><h1 id="三图像和视频中的颜色">三、图像和视频中的颜色</h1><h2 id="颜色科学">3.1 颜色科学</h2><h3 id="光与光谱-light-and-spectra">3.1.1 光与光谱 Light andSpectra</h3><h4 id="光是一种电磁波其颜色以波长为特征">3.1.1.1光是一种电磁波，其颜色以波长为特征</h4><ol type="1"><li>激光：单一波长</li><li>大多数光源：许多波长</li><li>短波–蓝色，长波–红色</li><li>可见光范围：400-700nm</li></ol><h4 id="不同波长的光携带的能量不同eλ">3.1.1.2不同波长的光，携带的能量不同：E(λ)</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308080613596.png" alt="image-20230308080613596" style="zoom:80%;" /></p><h4 id="人的视觉">3.1.1.3 人的视觉</h4><ol type="1"><li><p>柱状细胞：只对明暗产生响应</p></li><li><p>锥体细胞：只对RGB三种颜色中的一种产生响应，对三种颜色的感知细胞数量不同</p><ol type="1"><li>R : G : B = 40 : 20 : 1</li></ol></li><li><p>对不同波长的光，人眼的敏感度不同：<strong>Luminous-efficiencyfunction</strong></p><ol type="1"><li><spanclass="math inline">\(q(λ)=(q_R(λ),q_G(λ),q_B(λ))^T\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308081206201.png" alt="image-20230308081206201" style="zoom:80%;" /></p></li><li><p><span class="math inline">\(C(λ)=E(λ)S(λ)\)</span>：颜色信号</p><ol type="1"><li><span class="math inline">\(E(λ)\)</span>：光源强度</li><li><span class="math inline">\(S(λ)\)</span>：反射率</li></ol></li><li><p>颜色模型函数：</p><ol type="1"><li><span class="math inline">\(R=\int E(λ)S(λ)q_R(λ)\ dλ\)</span></li><li><span class="math inline">\(G=\int E(λ)S(λ)q_G(λ)\ dλ\)</span></li><li><span class="math inline">\(B=\int E(λ)S(λ)q_B(λ)\ dλ\)</span></li></ol></li></ol><h3 id="gamma矫正">3.1.2 Gamma矫正</h3><h4 id="crt显示原理">3.1.2.1 CRT显示原理</h4><ol type="1"><li><p>将RGB的数值转化为电压，通过电子轰击荧光涂层屏幕，使屏幕发光</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308081907023.png" alt="image-20230308081907023" style="zoom:80%;" /></p></li><li><p>CRT发出的光，与输入的电压值，并不是线性关系的</p><ol type="1"><li>CRT发出的光的强度与升高的电压成比例：<spanclass="math inline">\(R=&gt;R^γ\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308082014004.png" alt="image-20230308082014004" style="zoom:80%;" /></p></li><li><p>Gamma矫正：将期望的信号，首先进行一次放大，然后再输入给硬件</p><ol type="1"><li><spanclass="math inline">\(R=&gt;(R&#39;=R^\frac{1}{γ})=&gt;(R&#39;)^γ=&gt;R\)</span></li><li><span class="math inline">\(\frac{1}{γ}\)</span>通常为<spanclass="math inline">\(2.2\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308082520790.png" alt="image-20230308082520790" style="zoom:80%;" /></p></li></ol><h3 id="颜色匹配函数">3.1.3 颜色匹配函数</h3><ol type="1"><li><p>测量出的颜色匹配函数：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308083332082.png" alt="image-20230308083332082" style="zoom:80%;" /></p></li><li><p>通过线性变换，将所有值映射为正数</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308083515574.png" alt="image-20230308083515574" style="zoom:80%;" /></p></li><li><p>XYZ =&gt; RGB</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308083544437.png" alt="image-20230308083544437" style="zoom:80%;" /></p></li><li><p>亮度敏感度：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308083700425.png" alt="image-20230308083700425" style="zoom:80%;" /></p></li></ol><h3 id="l-a-b-cielab-颜色模型">3.1.4 L * a * b * (CIELAB) 颜色模型</h3><h4 id="韦伯定律">3.1.4.1 韦伯定律</h4><ol type="1"><li>人感受到的变化，是变化率，而不是绝对值</li><li><strong>人的视觉系统，对于明暗变化的敏感度，远大于对于颜色变化的敏感度</strong></li></ol><h4 id="l-a-b-颜色模型保证值的变化与人感知的变化相同">3.1.4.2 L * a * b* 颜色模型：保证值的变化与人感知的变化相同</h4><blockquote><p>相当于进行了一次线性变换</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308084130017.png" alt="image-20230308084130017" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308084422156.png" alt="image-20230308084422156" style="zoom:80%;" /></p><h4 id="其他颜色模型人脑--lhs">3.1.4.3 其他颜色模型：人脑--LHS</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308084336111.png" alt="image-20230308084336111" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308084320125.png" alt="image-20230308084320125" style="zoom:80%;" /></p><h2 id="图像中的颜色模型">3.2 图像中的颜色模型</h2><h3 id="crt显示rgb">3.2.1 CRT显示：RGB</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308085211240.png" alt="image-20230308085211240" style="zoom:80%;" /></p><h3 id="打印机cmyk">3.2.2 打印机：CMY(K)</h3><ol type="1"><li>打印机会使用四个墨盒</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308085252560.png" alt="image-20230308085252560" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308085452322.png" alt="image-20230308085452322" style="zoom:80%;" /></p><h3 id="rgb-cmy">3.2.3 RGB &lt;=&gt; CMY</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308085403909.png" alt="image-20230308085403909" style="zoom:80%;" /></p><h2 id="视频中的颜色模型">3.3 视频中的颜色模型</h2><p>YUV、YIQ、YCbCr模型</p><ol type="1"><li>Y：灰度</li><li>另外两层是对颜色的划分</li><li>由于人眼对明暗的敏感性远大于色彩，因此在压缩过程中，灰度是不会改变的</li></ol><h3 id="yuv颜色模型">3.3.1 YUV颜色模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308085810546.png" alt="image-20230308085810546" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308085938222.png" alt="image-20230308085938222" style="zoom:80%;" /></p><h3 id="yiq颜色模型">3.3.2 YIQ颜色模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308090901371.png" alt="image-20230308090901371" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308090049754.png" alt="image-20230308090049754" style="zoom:80%;" /></p><h3 id="ycbcr颜色模型">3.3.3 YCbCr颜色模型</h3><blockquote><p>JPEG图像，MPEG视频</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308090827897.png" alt="image-20230308090827897" style="zoom:80%;" /></p><h1 id="四视频基础概念">四、视频基础概念</h1><h2 id="视频信号类别">4.1 视频信号类别</h2><ol type="1"><li>Component Video：分量视频</li><li>Composite Video：复合视频</li><li>S-Video：介于两者之间</li></ol><h3 id="分量视频">4.1.1 分量视频</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310081325975.png" alt="image-20230310081325975" style="zoom:80%;" /></p><ol type="1"><li>三根线，每根线负责传输RGB其中一个通道的视频信号</li><li>优点：RGB三个通道互不干扰，传输信号质量高、带宽大<ol type="1"><li>干扰：crosstalk</li></ol></li><li>也可以传输YIQ、YUV等其他模型的信号<ol type="1"><li>Luminance-chrominance transformation from RGB：RGB亮度色度变换</li></ol></li><li>只能由彩色电视使用</li></ol><h3 id="复合视频">4.1.2 复合视频</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310081343053.png" alt="image-20230310081343053" style="zoom:80%;" /></p><ol type="1"><li>机顶盒：对数据进行解压，然后将数据送往电视机</li><li>将所有的信号，调制到一根电缆上传输<ol type="1"><li>更多使用YIQ、YUV等模型</li><li>要进行数据的压缩</li><li>Y用低频信号调制，UV/IQ用高频信号调制，然后再调制到一个通道上</li></ol></li><li>天然与黑白电视兼容<ol type="1"><li>可以在解码时只取Y通道</li></ol></li><li>缺点：三个信号之间会存在一定的干扰</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310081901918.png" alt="image-20230310081901918" style="zoom:80%;" /></p><h3 id="s-video">4.1.3 S-Video</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310081753068.png" alt="image-20230310081753068" style="zoom:80%;" /></p><ol type="1"><li>4个引脚<ol type="1"><li>1~2：接地</li><li>3：传输Y信号</li><li>4：传输颜色信号</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310081912967.png" alt="image-20230310081912967" style="zoom:80%;" /></p><h2 id="模拟视频制式与硬件有关">4.2 模拟视频制式(与硬件有关)</h2><h3 id="相关概念">4.2.1 相关概念</h3><ol type="1"><li><p>模拟信号是连续的，数字信号是离散的</p><ol type="1"><li>连续：在任何时间，均有对应取值</li><li>离散：只有在采样点处，才有对应取值</li></ol></li><li><p>模拟信号 Analog signal：f(t)，随时间变化的图像</p></li><li><p>CRT显示器(至少85Hz，每秒至少扫85帧)</p><ol type="1"><li>逐行扫描：从第一行开始，一行一行扫描</li><li>隔行扫描：从第一行开始，先扫1357...，再扫2468....<ol type="1"><li>奇数线扫描出的是奇数场图像，偶数线扫描出的是偶数场图像</li></ol></li><li>扫描线是斜线，但斜度较小<ol type="1"><li>field：场</li><li>水平回溯时间：上一条扫描线Q=&gt;下一条扫描线R</li><li>垂直回溯时间：上一次扫描U=&gt;下一次扫描V</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310082732135.png" alt="image-20230310082732135" style="zoom:80%;" /></p></li><li><p>电视机=&gt;隔行扫描，显示器=&gt;逐行扫描</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310083025314.png" alt="image-20230310083025314" style="zoom:80%;" /></p></li><li><p>示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310083146608.png" alt="image-20230310083146608" style="zoom:80%;" /></p></li><li><p>模拟电视的电视信号制式：</p><ol type="1"><li>NTSC：正交平衡调幅<ol type="1"><li>USA, Canada, Japan and Korea，1953 by USA</li></ol></li><li>PAL：逐行倒相正交平衡调幅<ol type="1"><li>Germany, England and China, 1962 by Germany</li></ol></li><li>SECAM：顺序传送彩色与存储<ol type="1"><li>France, Russia，1966 by France</li></ol></li></ol></li><li><p>均可以同时兼容黑白、彩色，明暗度也会单独传输</p></li></ol><h3 id="ntsc信号">4.2.2 NTSC信号</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310085636444.png" alt="image-20230310085636444" style="zoom:80%;" /></p><ol type="1"><li><p><strong>NTSC</strong>：National Television StandardsCommittee，正交平衡调幅</p><ol type="1"><li>长宽比：4:3</li><li>每一帧：525行</li><li>每一秒：30帧</li><li>颜色模型：YIQ</li></ol></li><li><p>详细参数：</p><ol type="1"><li>FPS：29.97，33.37ms每帧</li><li>隔行扫描，每个场262.5行</li><li>水平扫描频率：525×29.97 = 15734行</li><li>每一行时间：1/15734 = 63.6 μsec<ol type="1"><li>水平回溯：10.9</li><li>扫描：52.7</li></ol></li><li>垂直回溯：每个场20行的时间，因此每一帧只有485行的时间</li><li>水平扫描：保留光栅的1/6</li><li>水平分辨率：每行样本数</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310084119186.png" alt="image-20230310084119186" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310084128971.png" alt="image-20230310084128971" style="zoom:80%;" /></p></li><li><p>调制方式：<spanclass="math inline">\(Y+I\cos(F_{sc}t)+Q\sin(F_{sc}t)\)</span></p><ol type="1"><li><span class="math inline">\(YIQ\)</span>：为原始信号</li><li><span class="math inline">\(F_{sc}\)</span>：为一个高频信号</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310084420486.png" alt="image-20230310084420486" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310084434188.png" alt="image-20230310084434188" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310084443752.png" alt="image-20230310084443752" style="zoom:80%;" /></p></li><li><p>解调方式</p><ol type="1"><li>通过一个低通滤波器，将<span class="math inline">\(Y\)</span>、<spanclass="math inline">\(C=I\cos(F_{sc}t)+Q\sin(F_{sc}t)\)</span>分离</li><li>将<span class="math inline">\(C*2cos(F_{sc}t)\)</span>，可得<spanclass="math inline">\(I+I\cos(2F_{sc}t)+2Q\sin(2F_{sc}t)\)</span></li><li>然后使用低通滤波器，将<spanclass="math inline">\(I\)</span>分离出来</li></ol></li></ol><h3 id="pal信号">4.2.3 PAL信号</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310085507449.png" alt="image-20230310085507449" style="zoom:80%;" /></p><ol type="1"><li><p><strong>PAL</strong>：Phase AlterationLine，逐行倒相正交平衡调幅</p><ol type="1"><li>颜色模型：YUV</li></ol></li></ol><h3 id="secam信号">4.2.4 SECAM信号</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310085617972.png" alt="image-20230310085617972" style="zoom:80%;" /></p><ol type="1"><li><strong>SECAM</strong>：顺序传送彩色与存储</li></ol><h3 id="三种信号对比">4.2.5 三种信号对比</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310085726784.png" alt="image-20230310085726784" style="zoom:80%;" /></p><h2 id="数字视频">4.3 数字视频</h2><h3 id="数字视频的优点">4.3.1 数字视频的优点</h3><ol type="1"><li>将视频存储在数字设备或存储器中</li><li>可随时处理并集成到各种多媒体应用程序中</li><li>直接访问：非线性视频编辑</li><li>重复记录而不降低图像质量</li><li>易于加密，更好地容忍信道噪声</li></ol><h3 id="色度下采样-chroma-subsampling">4.3.2 色度下采样 Chromasubsampling</h3><blockquote><p><strong>色彩模型的转换，不会产生数据损失</strong></p></blockquote><ol type="1"><li>人类视觉：对明暗变化的敏感度，远大于对于颜色变化的敏感度</li><li>每四个原始像素，实际发送的像素值是多少？<ol type="1"><li>4:4:4：表示无二次采样</li><li>4:2:2：表示Cb和Cr的水平二次采样，系数为2<ol type="1"><li>水平的两个像素，用一个像素值表示</li></ol></li><li>4:1:1：表示Cb和Cr的水平二次采样，系数为4<ol type="1"><li>水平的四个像素，用一个像素值表示</li></ol></li><li>4:2:0：分别表示Cb和Cr的水平和垂直二次采样，系数为2<ol type="1"><li>水平&amp;垂直的2×2共4个像素，用一个像素值表示</li></ol></li></ol></li><li>JPEG和MPEG中通常使用的4:2:0方案</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310090543092.png" alt="image-20230310090543092" style="zoom:80%;" /></p><h3 id="ccir标准">4.3.3 CCIR标准</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091159598.png" alt="image-20230310091159598" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091208390.png" alt="image-20230310091208390" style="zoom:80%;" /></p><h3 id="cif标准">4.3.4 CIF标准</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091227244.png" alt="image-20230310091227244" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091241022.png" alt="image-20230310091241022" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091258675.png" alt="image-20230310091258675" style="zoom:80%;" /></p><h3 id="hdtvhigh-definition-tv">4.3.5 HDTV：High Definition TV</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091341936.png" alt="image-20230310091341936" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091349518.png" alt="image-20230310091349518" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091404438.png" alt="image-20230310091404438" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230310091420604.png" alt="image-20230310091420604" style="zoom:80%;" /></p><h1 id="五数字音频基础">五、数字音频基础</h1><h2 id="声音的数字化">5.1 声音的数字化</h2><h3 id="什么是声音">5.1.1 什么是声音</h3><ol type="1"><li>声音是像光一样的波动现象<ol type="1"><li>没有空气–没有声音</li><li>声音是一种压力波，具有连续值</li></ol></li><li>声音具有波的特性和行为<ol type="1"><li>反射</li><li>折射</li><li>衍射</li></ol></li><li>声音可以通过将压力转换为电压水平来测量</li></ol><h3 id="数字化">5.1.2 数字化</h3><ol type="1"><li>振幅Amplitude：连续值和随时间变化<ol type="1"><li>在时间维度和振幅维度采样</li></ol></li><li>时间维度：以均匀间隔采样<ol type="1"><li>典型范围：8kHz至48kHz</li><li>人类可以听到20Hz到20kHz的声音</li></ol></li><li>量化：振幅维度的采样<ol type="1"><li>均匀采样 Uniform Sampling：等距采样</li><li>非均匀采样 Nonuniform Sampling：如u-law规则</li><li>典型的均匀量化率：<ol type="1"><li>8位，256级</li><li>16位，65536级</li></ol></li></ol></li><li>三个关键问题<ol type="1"><li>采样频率是多少？</li><li>采样到的数据如何量化？分成多少级？</li><li>音频数据如何存储？文件格式是什么？</li></ol></li></ol><blockquote><p>在时间维度和振幅维度采样，需要将两个轴均离散化</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315081333664.png" alt="image-20230315081333664" style="zoom:80%;" /></p><h3 id="奈奎斯特定理">5.1.3 奈奎斯特定理</h3><ol type="1"><li>奈奎斯特速率 Nyquist Rate：<ol type="1"><li>采样频率必须是原始信号最大频率的2倍</li></ol></li><li>奈奎斯特定理 Nyquist Theorem：<ol type="1"><li>如果原始信号的最大频率为<strong>f1</strong>，最低频率为<strong>f2</strong>，带宽为<strong>f1-f2</strong>，则采样频率至少为<strong>2(f1-f2)</strong></li></ol></li><li>奈奎斯特频率 Nyquist Frequency：<ol type="1"><li>如果数字信号的频率为<strong>F</strong>，则能够还原的无失真信号的最大频率为<strong>F/2</strong></li></ol></li></ol><h3 id="信噪比snr">5.1.4 信噪比SNR</h3><p><span class="math inline">\(SNR = 10\log_10\frac{V_{signal}^2}{V_{noise}^2}=10\log_10\frac{V_{signal}}{V_{noise}}\)</span></p><ol type="1"><li>SNR：信号与噪声的功率之比称为信噪比，这是信号质量的度量。</li><li>单位：分贝dB，其中1dB为十分之一贝尔</li><li>信号的功率与电压的平方成正比<ol type="1"><li>例如，如果信号电压Vsignal是噪声的10倍，则SNR为20log10（10）＝20dB。</li></ol></li><li>在功率方面，如果十把小提琴的功率是一把小提琴的十倍，则功率比为10dB或1B</li></ol><h3 id="sqnr">5.1.5 SQNR</h3><p><spanclass="math inline">\(SQNR=20\log_{10}\frac{V_{signal}}{V_{quan\_noise}}=20\log_{10}\frac{2^{N-1}}{0.5}=20*N*\log_2=6.02N(dB)\)</span></p><ol type="1"><li>在量化时，会人为引入误差，也被称为人为引入噪音</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315083401485.png" alt="image-20230315083401485" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315083412440.png" alt="image-20230315083412440" style="zoom:80%;" /></p><h3 id="非线性采样">5.1.6 非线性采样</h3><ol type="1"><li>对于声音的采样来说，高频部分采样稀疏，低频部分采样密集</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315083327169.png" alt="image-20230315083327169" style="zoom:80%;" /></p><h3 id="声音过滤">5.1.7 声音过滤</h3><ol type="1"><li>在采样和AD转换之前，通过过滤音频信号来去除不需要的频率</li><li>保留的频率取决于具体应用：<ol type="1"><li>人的语音：50Hz至10kHz</li><li>音频音乐信号：20Hz至20kHz</li></ol></li><li>其他频率被带通滤波器（也称为限带滤波）过滤掉了<ol type="1"><li>band-pass filter，band-limiting filter</li></ol></li></ol><h3 id="音频质量与数据速率">5.1.8 音频质量与数据速率</h3><ol type="1"><li>未压缩的数据速率随着用于量化的比特数的增加而增加</li><li>音频质量：数据速率和带宽<ol type="1"><li>模拟设备，带宽以频率单位表示，赫兹</li><li>数字设备，比特每秒，bps</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315083645880.png" alt="image-20230315083645880" style="zoom:80%;" /></p><h3 id="合成声音">5.1.9 合成声音</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315083956623.png" alt="image-20230315083956623" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315084009750.png" alt="image-20230315084009750" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315084025378.png" alt="image-20230315084025378" style="zoom:80%;" /></p><h2 id="乐器数字接口">5.2 乐器数字接口</h2><h3 id="midi">5.2.1 MIDI</h3><ol type="1"><li>MIDI存储的是合成声音的指令，而不是原始信号</li><li>机器根据MIDI的指令，合成固化在硬件中的波形</li></ol><h2 id="音频的量化和传输">5.3 音频的量化和传输</h2><p>每个压缩模式包含三个阶段：</p><ol type="1"><li>对输入数据进行<strong>变换</strong>：不会产生信息差异</li><li><strong>量化</strong>：会导致信息丢失</li><li><strong>编码</strong></li></ol><h3 id="声音的编码">5.3.1 声音的编码</h3><ol type="1"><li>编码Coding：数据的量化与传输</li><li>时间上的冗余性：声音信号是连续的，即相邻的两个点的值差别不大<ol type="1"><li>因此可以减少存储的数据量</li></ol></li><li>编码调制<ol type="1"><li>PCM：脉冲编码调制</li><li>DPCM：脉冲编码调制的差分版本</li><li>ADPCM：Adaptive DPCM</li></ol></li></ol><h3 id="pcmpulse-code-modulation">5.3.2 PCM：Pulse Code Modulation</h3><ol type="1"><li><p>PCM的过程：确定采样点、求交、取整</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315085142376.png" alt="image-20230315085142376" style="zoom:80%;" /></p></li><li><p>均匀量化：对采样到的值均匀的分为多个等级</p></li><li><p>非均匀量化：在某些部分分的等级多，某些部分分的等级少</p></li></ol><blockquote><p>在数转模的过程中，会引入高频噪声，因此需要一个低通滤波器</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315085734942.png" alt="image-20230315085734942" style="zoom:80%;" /></p><h3 id="音频的差分编码-difference-coding-of-audio">5.3.3 音频的差分编码Difference coding of audio</h3><ol type="1"><li>存储当前采样点的值，与上一采样点的值的差值<ol type="1"><li>信号分布的范围越广，压缩的可能性越低</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315090256082.png" alt="image-20230315090256082" style="zoom:80%;" /></p><h3 id="无损预测编码-lossless-predictive-coding">5.3.4 无损预测编码Lossless Predictive Coding</h3><p>预测编码：</p><ol type="1"><li>预测当前时刻值，为上一时刻的值<span class="math inline">\(\hat f_n =f_{n-1}\)</span></li><li>但是肯定会有误差，存储的数据即为误差本身<spanclass="math inline">\(e_n=f_n-\hat f_n\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315090739975.png" alt="image-20230315090739975" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315090759711.png" alt="image-20230315090759711" style="zoom:80%;" /></p><p>无损预测编码：解码器产生与原始信号相同的信号</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315091336063.png" alt="image-20230315091336063" style="zoom:80%;" /></p><blockquote><p>示例：<span class="math inline">\(\hat f_n =\lfloor \frac{1}{2}(f_{n-1} + f_{n-2}) \rfloor\)</span>，<spanclass="math inline">\(e_n=f_n-\hat f_n\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315091407545.png" alt="image-20230315091407545" style="zoom:80%;" /></p></blockquote><h3 id="dpcm">5.3.5 DPCM</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315091540051.png" alt="image-20230315091540051" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315091823659.png" alt="image-20230315091823659" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315092320033.png" alt="image-20230315092320033" style="zoom:80%;" /></p><h1 id="六无损压缩算法">六、无损压缩算法</h1><h2 id="信息论基础">6.1 信息论基础</h2><h3 id="背景">6.1.1 背景</h3><ol type="1"><li>压缩的目的：<ol type="1"><li>节约存储空间、提高传输速率</li></ol></li><li>不同的数据，出现的频率不同：<ol type="1"><li>出现频率越高的数据，给越短的编码</li></ol></li></ol><h3 id="数据压缩范式">6.1.2 数据压缩范式</h3><ol type="1"><li>压缩率：<strong>B0/B1</strong><ol type="1"><li>B0：为压缩前的数据的bit数</li><li>B1：为压缩后的数据的bit数</li><li>压缩算法用到某些数据上后，可能会导致数据bit数变大</li></ol></li><li>压缩率越大，压缩算法越好</li><li>无损压缩：解码出的数据 == 压缩前的数据</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317081013933.png" alt="image-20230317081013933" style="zoom:80%;" /></p><h3 id="信息论基础-1">6.1.3 信息论基础</h3><ol type="1"><li><p><strong>熵 entropy</strong>：表征信源的信息量大小</p><ol type="1"><li>如果要压缩一个文本文档，那么文本文档本身是<strong>信源</strong>，ASCII码表是信源的<strong>码表</strong></li><li>熵越大，表示该系统更无序，压缩后的产物越大</li><li>压缩算法实际上就是降低信源的熵</li></ol></li><li><p>计算方法：设码表为<spanclass="math inline">\(S=\{s1,s2...,sn\}\)</span></p><ol type="1"><li>则熵为：<spanclass="math inline">\(\eta=H(S)=\sum_{i=1}^{n}p_i\log_2\frac{1}{p_i}=-\sum_{i=1}^{n}p_i\log_2p_i\)</span></li><li><span class="math inline">\(p_i\)</span>：表示<spanclass="math inline">\(s_i\)</span>在信源中出现的概率，<spanclass="math inline">\(p_i=\frac{s1出现的次数}{信源包含的字符数}\)</span></li><li><spanclass="math inline">\(\log_2\frac{1}{p_i}\)</span>：表示信号<spanclass="math inline">\(s_i\)</span>的熵 amount of information containedin characters</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317082205213.png" alt="image-20230317082205213" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317082522398.png" alt="image-20230317082522398" style="zoom:80%;" /></p></blockquote></li><li><p><strong>熵编码</strong>：高频出现的符号，码长更短</p></li><li><p>如果某个符号的熵为<strong>k</strong>，则使用<strong>熵编码</strong>后，其二进制位数至少为<strong>kbits</strong></p></li></ol><h2 id="无损编码算法">6.2 无损编码算法</h2><h3 id="run-length-coding-游程编码">6.2.1 Run-Length Coding游程编码</h3><p>思想：将连续出现多次的字符，转换为<strong>(字符,出现次数)</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317083422974.png" alt="image-20230317083422974" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317083623892.png" alt="image-20230317083623892" style="zoom:80%;" /></p><h3 id="variable-length-coding-可变长编码">6.2.2 Variable-Length Coding可变长编码</h3><p>思想：计算出所有符号的熵后，根据熵的大小，赋予编码值</p><ol type="1"><li><p>Shannon-Fano算法</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317083801102.png" alt="image-20230317083801102" style="zoom:80%;" /></p></li><li><p>Huffman编码</p><ol type="1"><li>先统计出现的概率，然后根据概率建树，最后对树进行编码</li><li>扩展Huffman编码：对于某些连续出现的字符，如abc，可以把它们作为整体定义为一个新的字符</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317083924140.png" alt="image-20230317083924140" style="zoom:80%;" /></p></li><li><p>自适应Huffman编码</p><ol type="1"><li>由于信源在不断发出信号，因此我们只能统计到当前位置，某个字符出现的概率</li><li>在编码器和解码器中，同时维护两棵树，根据发出的字符，动态调整树的结构</li></ol></li></ol><h3 id="dictionary-based-coding-字典编码">6.2.3 Dictionary-Based Coding字典编码</h3><p>思想：对出现的不同字符串，赋予一个编码，传输时同时传输码表</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317085238101.png" alt="image-20230317085238101" style="zoom:80%;" /></p><blockquote><ol type="1"><li>首先，将ABC分别赋予1、2、3</li><li>对于输入<code>ABABBABCABABBA</code></li><li>将<code>A</code>入栈，发现<code>A</code>在码表中，输出1，然后</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317085337366.png" alt="image-20230317085337366" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317085600752.png" alt="image-20230317085600752" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317085616473.png" alt="image-20230317085616473" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317085622861.png" alt="image-20230317085622861" style="zoom:80%;" /></p><h3 id="arithmetic-coding-算术编码">6.2.4 Arithmetic Coding算术编码</h3><blockquote><ol type="1"><li>将每个字符，按出现的频率，划分<code>[0~1)</code>的地盘</li><li>第一个字符为<code>C</code>，则将<code>[0.3,0.5)</code>的地盘再次根据频率划分地盘</li><li>第二个字符为<code>A</code>，则将<code>[0.3,0.34)</code>的地盘再次根据频率划分地盘</li><li>重复以上过程，直到所有的字符均读入过</li><li>在最后得到的区间范围内，随机选取一个小数，作为编码结果</li></ol></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317085851234.png"alt="image-20230317085851234" /><figcaption aria-hidden="true">image-20230317085851234</figcaption></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317085900934.png" alt="image-20230317085900934" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317090106383.png" alt="image-20230317090106383" style="zoom:80%;" /></p><blockquote><ol type="1"><li>接收到的小数为<code>0.33203125</code>，在<code>[0.3,0.5)</code>之间，则第一个字符为<code>C</code></li><li>第二个小数为<code>(0.33203125-0.3)/0.2=0.16015625</code>，在<code>[0.0,0.2)</code>之间，则第二个字符为<code>A</code></li><li>第三个小数为<code>(0.16015625-0.0)/0.2=0.80078125</code>，在<code>[0.55,0.85)</code>之间，则第三个字符为<code>E</code></li><li>重复上述操作，直到读到文档结束符号<code>$</code></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317090019427.png" alt="image-20230317090019427" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317090542579.png" alt="image-20230317090542579" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317090117733.png" alt="image-20230317090117733" style="zoom:80%;" /></p><h2 id="无损图像压缩">6.3 无损图像压缩</h2><h3 id="图像差分编码降低数据的熵">6.3.1 图像差分编码：降低数据的熵</h3><ol type="1"><li>简单差分算子：<spanclass="math inline">\(d(x,y)=I(x,y)-I(x-1,y)\)</span></li><li>离散二维拉普拉斯算子：<spanclass="math inline">\(d(x,y)=4I(x,y)-I(x,y-1)-I(x,y+1)-I(x+1,y)-I(x-1,y)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317090726189.png" alt="image-20230317090726189" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317090750890.png" alt="image-20230317090750890" style="zoom:80%;" /></p><h3 id="无损jpeg">6.3.2 无损JPEG</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317091521842.png" alt="image-20230317091521842" style="zoom:80%;" /></p><ol type="1"><li><p>JPEG中由很多种预测算法，目的是让预测尽可能的准确，从而让差分值接近0</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230317091313056.png" alt="image-20230317091313056" style="zoom:80%;" /></p></li></ol><h1 id="七有损压缩算法">七、有损压缩算法</h1><h2 id="损失测量-distortion-measures">7.2 损失测量 DistortionMeasures</h2><h3 id="distortion的数学测量">7.2.2 Distortion的数学测量</h3><ol type="1"><li><p>MSE：Mean Square Error，越大损失越多</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322080849919.png" alt="image-20230322080849919" style="zoom:80%;" /></p></li><li><p>SNR：Signal-to-noise Ratio，越大损失越少</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322080926021.png" alt="image-20230322080926021" style="zoom:80%;" /></p></li><li><p>PSNR：Peak-signal-to-noise Ratio，越大损失越少</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322080935703.png" alt="image-20230322080935703" style="zoom:80%;" /></p></li></ol><h2 id="失真率">7.3 失真率</h2><h3 id="r-d函数">7.3.2 R-D函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322081052871.png" alt="image-20230322081052871" style="zoom:80%;" /></p><h2 id="量化-quantization--产生损失">7.4 量化Quantization--产生损失</h2><h3 id="uniform-scalar-quantization">7.4.2 Uniform ScalarQuantization</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322081338775.png" alt="image-20230322081338775" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322081526737.png" alt="image-20230322081526737" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322081539088.png" alt="image-20230322081539088" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322081550567.png" alt="image-20230322081550567" style="zoom:80%;" /></p><h2 id="transform-coding">7.5 Transform Coding</h2><h3 id="基础思想">7.5.1 基础思想</h3><ol type="1"><li>对于单个标量编码的效率，不如直接对整个向量编码<ol type="1"><li>因为压缩成向量之后，相邻数据的相关性更低</li></ol></li><li>如果存在一个线性变换<code>T</code>，将向量<code>X</code>变换为<code>Y</code>，且<code>Y</code>的相关性小于<code>X</code>，则对<code>Y</code>编码的效率更高<ol type="1"><li><code>T</code>不会导致信息的损失</li></ol></li><li><strong>DCT</strong>：离散余弦变换<ol type="1"><li>定义了一个长度为8的DCT</li><li>输入是长度为8的向量<strong>f(i)</strong>，输出为长度为8的向量<strong>F(u)</strong></li><li><strong>C(u)</strong>为一个常数</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322082330702.png" alt="image-20230322082330702" style="zoom:80%;" /></p><blockquote><p><strong>使用DCT压缩数据</strong></p></blockquote><ol type="1"><li>输入为：<code>X</code></li><li>做一次DCT变换：<code>Y = dct(X)</code></li><li>量化：<code>Z = Y(0:7)</code>，此处产生了<strong>信息损失</strong></li><li>编码：将<code>Z</code>使用无损编码，进行保存&amp;传输</li><li>解码：<code>X' = idct(Z)</code></li></ol><p>目标：让<code>X'</code>与<code>X</code>尽可能接近</p><h3 id="dct离散余弦变换-discrete-cosine-transform">7.5.2DCT：离散余弦变换 Discrete Cosine Transform</h3><h4 id="一维dct变换">7.5.2.1 一维DCT变换</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322083459534.png" alt="image-20230322083459534" style="zoom:80%;" /></p><blockquote><p>将<strong>F(u)</strong>展开，<strong>f(i)</strong>前面的系数，相当于定义了一个线性变换的矩阵，并且只要<strong>u</strong>和<strong>N</strong>确定，矩阵就是一个常量</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322083654438.png" alt="image-20230322083654438" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322084012844.png" alt="image-20230322084012844" style="zoom:80%;" /></p><h4 id="在三维空间的dct变换示例">7.5.2.2 在三维空间的DCT变换示例</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322084258908.png" alt="image-20230322084258908" style="zoom:80%;" /></p><h4 id="dct是正交线性变换即不同行向量的内积为0">7.5.2.3DCT是正交线性变换，即不同行向量的内积为0</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322084525428.png" alt="image-20230322084525428" style="zoom:80%;" /></p><h4 id="dct是线性变换满足加法性质talpha-p-beta-q-alpha-p-beta-q">7.5.2.4DCT是线性变换，满足加法性质：<span class="math inline">\(T(\alpha p+\beta q) = \alpha p + \beta q\)</span></h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322085340281.png" alt="image-20230322085340281" style="zoom:80%;" /></p><h4id="dct的物理含义给定任意一个输入信号告诉该信号是如何有基信号组合而成的">7.5.2.5DCT的物理含义：给定任意一个输入信号，告诉该信号是如何有基信号组合而成的</h4><blockquote><ol type="1"><li>原始信号 = 基向量的线性组合</li><li>F[0]为DC系数，表示原始信号的直流系数；其他信号为AC系数，表示原始信号的交流系数<ol type="1"><li>DC = 0，表示原始信号没有直流分量</li><li>只有DC不为0，表示原始信号为直流信号</li><li>如果DC为负数，则说明输入信号的平均值 &lt; 0</li><li>如果AC为负数，说明输入信号与基信号的相位，相差半个周期</li></ol></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322085639314.png" alt="image-20230322085639314" style="zoom:80%;" /></p><h4 id="维dct变换定义了一组基矩阵">7.5.2.62维DCT变换：定义了一组基矩阵</h4><ol type="1"><li>计算方法：将输入信号，与每一个基矩阵做卷积(对应元素相乘求和)，然后将值写入对应位置<ol type="1"><li>正向变换：信号分解</li><li>逆向变换：信号组合</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322090401375.png" alt="image-20230322090401375" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322090541374.png" alt="image-20230322090541374" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322090716705.png" alt="image-20230322090716705" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322090839297.png" alt="image-20230322090839297" style="zoom:80%;" /></p><h3 id="dft离散傅里叶变换">7.5.2.6 DFT：离散傅里叶变换</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322091029900.png" alt="image-20230322091029900" style="zoom:80%;" /></p><h2 id="wavelet-based-coding-小波变换">7.6 Wavelet-Based Coding小波变换</h2><h3 id="小波变换示例">7.6.2 小波变换示例</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322091338669.png" alt="image-20230322091338669" style="zoom:80%;" /></p><h3 id="一维harr变换">7.6.3 一维Harr变换</h3><ol type="1"><li>设原始信号为：<code>&#123;a1,a2,a3,a4,a5,a6,a7,a8&#125;</code></li><li>做1次变换：<code>&#123;a12,a34,a56,a78,d12,d34,d56,d78&#125;</code></li><li>做2次变换：<code>&#123;a12,a34,a56,a78,d12,d34,d56,d78&#125;</code></li></ol><h3 id="二维harr变换">7.6.4 二维Harr变换</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322091903391.png" alt="image-20230322091903391" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322091929269.png" alt="image-20230322091929269" style="zoom:80%;" /></p><h1 id="八图像压缩标准">八、图像压缩标准</h1><h2 id="jpeg标准">8.1 JPEG标准</h2><blockquote><p>Joint Photographic Experts Group</p></blockquote><ol type="1"><li>标准名：ISO 10918-1</li><li>JEPG定义了图像的有损 &amp; 无损压缩的流程及方法</li><li>图像：是一个二位函数</li><li>图像的有损压缩，即对图像做2D DCT变换</li><li>观测到的三个事实<ol type="1"><li>图像具有空间冗余性，在某个较小的区域内，像素的颜色值变化不会很大</li><li>心理学实验告诉我们，人的视觉系统对于低频部分变化的感知能力，大于对于高频部分变化的感知能力：即对于<strong>低频信号</strong>敏感，高频信号不敏感</li><li>人的视觉系统，对于<strong>明暗</strong>变化的敏感度，大于对于色彩的敏感度</li></ol></li></ol><h3 id="jepg压缩步骤">8.1.1 JEPG压缩步骤</h3><ol type="1"><li>将RGB转换为YIQ/YUV，然后对颜色进行<strong>下采样</strong>：出现损失<ol type="1"><li>会有三个矩阵：一个较大的Y矩阵，两个较小的IQ/UV矩阵</li></ol></li><li>对图像矩阵进行DCT变换</li><li>进行<strong>量化</strong>：出现损失</li><li>Zigzag排序</li><li>对DC信号进行DPCM编码</li><li>对AC信号进行RLE编码</li><li>最后，进行熵编码</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324081842470.png" alt="image-20230324081842470" style="zoom:80%;" /></p><h4 id="dct">8.1.1.1 DCT</h4><ol type="1"><li>对图像切分为8×8的块，然后进行2D DCT变换<ol type="1"><li>8×8是对准确率和计算效率的折中</li><li>块很大时，会出现马赛克效应</li></ol></li></ol><h4 id="量化">8.1.1.2 量化</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324082307174.png" alt="image-20230324082307174" style="zoom:80%;" /></p><ol type="1"><li>量化时，不同层使用的量化矩阵不同<ol type="1"><li>量化矩阵是通过心理学实验测出来的</li><li>灰度层的量化表更细，颜色层的量化表更粗</li></ol></li><li>将图像矩阵<code>F(u,v)</code>与量化矩阵<code>Q(u,v)</code>对应元素相除，然后取整</li></ol><h4 id="zigzag展开">8.1.1.3 Zigzag展开</h4><ol type="1"><li>将8×8的矩阵，展开为长度64的向量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324083857493.png" alt="image-20230324083857493" style="zoom:80%;" /></p><h4 id="对ac信号做rle编码">8.1.1.4 对AC信号做RLE编码</h4><ol type="1"><li>RLE：游程编码</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324083951302.png" alt="image-20230324083951302" style="zoom:80%;" /></p><h4 id="对dc信号做dpcm编码">8.1.1.5 对DC信号做DPCM编码</h4><ol type="1"><li>将整张图的所有DC信号取出来，再做DPCM差分预测编码</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324084211225.png" alt="image-20230324084211225" style="zoom:80%;" /></p><h4 id="对结果做熵编码">8.1.1.6 对结果做熵编码</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324084312061.png" alt="image-20230324084312061" style="zoom:80%;" /></p><h3 id="jpeg模式">8.1.2 JPEG模式</h3><h4 id="顺序模式-sequential">8.1.2.1 顺序模式 Sequential</h4><p>JPEG的默认模式</p><ol type="1"><li>对图像进行编码时，使用从左到右，从上到下扫描方式</li><li>图像会从上到下依次显示</li></ol><h4 id="渐进模式-progressive">8.1.2.2 渐进模式 Progressive</h4><ol type="1"><li>方法一：先传输每一块的低频部分，然后传输每一块的高频部分<ol type="1"><li>解码时，先解码低频信号，然后解码高频信号，将后面的解码结果叠加到原来的图像上</li></ol></li><li>方法二：由于已经编码为二进制数，因此可以按每一个系数的位，依次传递<ol type="1"><li>比如，可以先传输二进制数的最高位，然后依次传输后面的位</li></ol></li><li>图像会由模糊变得清晰</li></ol><h4 id="层次模式-hierarchical">8.1.2.3 层次模式 Hierarchical</h4><ol type="1"><li>将图像做多次下采样</li><li>传输时，按层次传输，每一次传输与上一层的差值</li></ol><h4 id="无损模式-lossless">8.1.2.4 无损模式 Lossless</h4><ol type="1"><li>使用差分预测编码，而不是DCT编码</li></ol><h2 id="jepg2000标准">8.2 JEPG2000标准</h2><ol type="1"><li>同时提供了有损、无损两种形式</li><li>可以进行分区域编码：<strong>ROI</strong>(Region ofinsterest)，不同区域使用不同的压缩矩阵</li></ol><h1 id="九基础视频压缩算法">九、基础视频压缩算法</h1><h2 id="introduction">9.1 Introduction</h2><p>三个可以压缩的方向：</p><ol type="1"><li><p>空间信息冗余性：冗余度较小</p></li><li><p>颜色信息：将RGB转成YUV，然后再进行下采样</p></li><li><p>时间信息冗余性</p><ol type="1"><li><p>预测编码：假设第二帧和第一帧一样，传输差值，但是可能相邻两帧相差很大</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329081906495.png" alt="image-20230329081906495" style="zoom:80%;" /></p></li><li><p>因此不能直接对整张图像做差分，而是先将<strong>当前帧</strong>划分为16×16的<strong>宏块</strong>(MacroBlock)，到前一帧找到与它类似的宏块，然后再进行差分计算</p><ol type="1"><li>传输时，既要传输残差，也要传输每个宏块对应的上一帧的部分，与当前宏块的位移差</li><li>位移称为<strong>运动向量</strong></li><li>如果找不到，则直接传输当前宏块</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329082954544.png" alt="image-20230329082954544" style="zoom:80%;" /></p></li></ol></li></ol><h2 id="基于运动补偿的视频压缩">9.2 基于运动补偿的视频压缩</h2><h3 id="时间冗余性">9.2.1 时间冗余性</h3><ol type="1"><li>相邻的帧，通常很相似，因此需要通过差分信息进行编码</li><li>相邻两帧的差异，通常由于摄像机/物体的运动</li><li>基础思想：检测相邻两帧对应位置的差异<ol type="1"><li>运动估计：判断哪两个宏块为对应位置</li><li>运动补偿：计算对应宏块的差异</li></ol></li><li>两种帧：<ol type="1"><li>Intra-Frame I帧：独立编码，不做运动估计&amp;补偿</li><li>Inter-Frame：使用运动估计&amp;补偿进行压缩<ol type="1"><li>P帧：参考帧在前面</li><li>B帧：参考帧同时在前面&amp;后面</li></ol></li></ol></li></ol><h3 id="运动补偿-motion-compensation">9.2.2 运动补偿 MotionCompensation</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329083808182.png" alt="image-20230329083808182" style="zoom:80%;" /></p><p>运动估计：</p><ol type="1"><li>以当前<strong>宏块macroblocks</strong>所在位置为中心，划定一个<strong>区域</strong> (如2p+1 × 2p+1)，在该区域内进行搜索</li><li>如果能找到<strong>中心点</strong>在该区域，且与当前宏块类似，则停止该过程</li><li>计算当前宏块与对应位置的位移，称为<strong>运动向量</strong></li></ol><p>运动补偿：</p><ol type="1"><li>运动向量搜索</li><li>基于运动补偿的预测</li><li>对残差进行编码</li></ol><h2 id="搜索运动向量">9.3 搜索运动向量</h2><h3 id="判断是否匹配">9.3.1 判断是否匹配</h3><ol type="1"><li>C：当前帧</li><li>R：参考帧</li><li>判断是否相同：对应位置求差，然后将绝对值加和</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329085311384.png" alt="image-20230329085311384" style="zoom:80%;" /></p><h3 id="顺序搜索-sequential-search">9.3.2 顺序搜索 SequentialSearch</h3><ol type="1"><li>每次移动<strong>中心像素</strong>，每次移动一个像素</li><li>优点：可以在搜索区域内找到最优解</li><li>缺点：时间太长</li></ol><h3 id="维对数搜索-2d-logarithmic-search">9.3.3 2维对数搜索2D-Logarithmic-search</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329085943406.png" alt="image-20230329085943406" style="zoom:80%;" /></p><ol type="1"><li>以对应位置为中心，划定搜索范围，在整个范围内，均匀采样9个块</li><li>以最小的块为中心，搜索范围减半，均匀采样9个块，计算差值</li><li>重复第2步，直到搜索几次之后停止</li><li>优点：快</li><li>缺点：不一定能找到最优解</li></ol><h3 id="层次搜索-hierarchical-search">9.3.4 层次搜索 HierarchicalSearch</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329090155354.png" alt="image-20230329090155354" style="zoom:80%;" /></p><ol type="1"><li>先进行下采样，在低层次中使用较小的块，找到与之相似的块，返回到上一层求精</li></ol><h2 id="h.261">9.4 H.261</h2><h3 id="总览">9.4.1 总览</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329090717872.png" alt="image-20230329090717872" style="zoom:80%;" /></p><ol type="1"><li>箭头：从箭头的尾帧推出箭头的指向帧</li><li><strong>I帧</strong>：独立帧，只去除空间冗余性</li><li><strong>P帧</strong>：根据前一帧进行预测<ol type="1"><li>运动向量搜索只在Y层上做</li><li>差分在Y、U、V上均要做</li><li>对<strong>运动向量</strong>也要做差分预测编码</li></ol></li></ol><h3 id="intra-frame-coding">9.4.2 Intra-Frame Coding</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329091224103.png" alt="image-20230329091224103" style="zoom:80%;" /></p><h3 id="inter-frame-predictive-coding">9.4.3 Inter-Frame predictiveCoding</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329091353730.png" alt="image-20230329091353730" style="zoom:80%;" /></p><h3 id="量化-1">9.4.4 量化</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329091801118.png" alt="image-20230329091801118" style="zoom:80%;" /></p><h3 id="整个过程">9.4.5 整个过程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329091826070.png" alt="image-20230329091826070" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329091834234.png" alt="image-20230329091834234" style="zoom:80%;" /></p><h3 id="h.261-视频bit流">9.4.6 H.261 视频Bit流</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329091959599.png" alt="image-20230329091959599" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329092011224.png" alt="image-20230329092011224" style="zoom:80%;" /></p><h2 id="h.263">9.5 H.263</h2><ol type="1"><li>在宏块划分的基础上，允许对MV进行预测编码<ol type="1"><li>MV一定是无损压缩，仅仅是降低信息的熵</li></ol></li><li>在运动预测时，允许每次移动半个像素查找<ol type="1"><li>原本是每次只能移动一个像素，然后对应位判断差值</li><li>移动半个像素后，需要对像素进行差值</li><li>类似于提高了图像的分辨率</li></ol></li><li>可以将参考帧的边缘进行延展，从而实现不受限的匹配<ol type="1"><li>将边界进行复制</li></ol></li><li>使用算数编码</li><li>宏块的大小更加灵活</li><li>可以进行双向预测<ol type="1"><li>在前面的帧、后面的帧中均可找到一个相似的宏块</li><li>视频编解码可以有一定的延迟，因此可以等后面的帧出现了再进行预测</li><li>做残差时，与前后两个参考帧做残差，然后再做平均</li></ol></li></ol><h1 id="十mpeg视频编码">十、MPEG视频编码</h1><h2 id="mpeg-1">10.1 MPEG-1</h2><ol type="1"><li>只支持逐行扫描</li><li>4:2:0的色彩下采样</li></ol><h3 id="运动补偿">10.1.1 运动补偿</h3><ol type="1"><li>从前向的的I帧/P帧进行预测，可以跳帧匹配，从而找到更优匹配</li><li>也可以做双向预测，会乱序传递帧，但是可以通过帧编号确定顺序<ol type="1"><li>前后参考帧先求平均，然后再与预测帧做残差</li><li>如果找不到，可以直接舍弃该参考帧</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331083354656.png" alt="image-20230331083354656" style="zoom:80%;" /></p><h3 id="mpeg-1与h.261区别">10.1.2 MPEG-1与H.261区别</h3><p>支持的视频格式不同：</p><ol type="1"><li>H.261支持CIF、QCIF</li><li>MPEG-1支持SIF</li></ol><p>数据格式不同</p><ol type="1"><li>H.261将图像序列划分为了GOB</li><li>MPEG-1将图像序列划分为了slices<ol type="1"><li>不同slices之间相互独立，一个slice坏了，不影响其他区域的显示</li></ol></li></ol><p>量化不同</p><ol type="1"><li>H.261使用了很大的系数，直接进行压缩</li><li>MPEG-1使用了量化表，并且添加了缩放系数，可以压缩的更狠一点</li></ol><p>搜索范围不同</p><ol type="1"><li>H.261是[-15, 15]像素</li><li>MPEG-1是[-512, 511.5]像素，并且可以进行半像素搜索</li></ol><p>MPEG-1可以随机访问，因为有GOP(Group Of Picture)</p><ol type="1"><li>将一段时间的视频帧打包到一起</li></ol><h3 id="mpeg-1视频比特流">10.1.3 MPEG-1视频比特流</h3><p>GOP层 =&gt; 帧 =&gt; Slice(Block的组合) =&gt; Macroblock =&gt;Block</p><h2 id="mpeg-2">10.2 MPEG-2</h2><h3 id="总览-1">10.2.1 总览</h3><ol type="1"><li>定义了7种profiles，针对不同的应用，每个profile定义了最多4个画质等级</li></ol><h3 id="支持隔行扫描">10.2.2 支持隔行扫描</h3><ol type="1"><li>Frame-picture：完整的一帧<ol type="1"><li>Top-field：奇数场图像</li><li>bottom-field：偶数场图像</li><li>称为Field-picture</li></ol></li><li>奇数场的参考帧，可能是奇数场，也可能是偶数场</li><li>偶数场也一样</li></ol><p>5种预测模式</p><ol type="1"><li>Frame prediction for frame-pictures：<ol type="1"><li>对完整帧进行预测</li></ol></li><li>Field prediction for field-pictures：<ol type="1"><li>可以跨场预测</li></ol></li><li>Field prediction for frame-pictures：<ol type="1"><li>将奇数场和偶数场完全分离</li></ol></li><li>16 × 8场图像预测<ol type="1"><li>宏块大小为16×8</li></ol></li><li>Dual-prime for P-pictures</li></ol><p>Zigzag展开的方式也不太一样</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331090541377.png" alt="image-20230331090541377" style="zoom:80%;" /></p><h3 id="mpeg-2-scalabilities-可伸缩性">10.2.3 MPEG-2 Scalabilities可伸缩性</h3><h4 id="可伸缩编码-scalable-coding">10.2.3.1 可伸缩编码 ScalableCoding</h4><p>基本思想：</p><ol type="1"><li>将图像划分为Base Layer 和 Enhancement Layer<ol type="1"><li>将原有视频降低分辨率，得到Base Layer</li><li>再将Base Layer放大回去，与原视频做差，得到Enhancement Layer</li><li>Base Layer只有一个，但是Enhancement Layer可以有多个</li></ol></li><li>将这两层作为两个视频序列进行传输</li><li>接收端可以选择只接收Base Layer，或者两个都接受</li><li>两个都接受时，将Enhancement Layer叠加到Base Layer上即可</li></ol><h4 id="snr可伸缩">10.2.3.2 SNR可伸缩</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331091643001.png" alt="image-20230331091643001" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331091732289.png" alt="image-20230331091732289" style="zoom:80%;" /></p><h4 id="空间可伸缩">10.2.3.3 空间可伸缩</h4><ol type="1"><li>先进行下采样，得到基础层</li><li>然后再进行上采样，再与原有图像做差，得到增强层</li></ol><h4 id="时间可伸缩">10.2.3.4 时间可伸缩</h4><ol type="1"><li>直接按照时间顺序，将一部分帧作为基础层，一部分帧作为增强层</li></ol><h4 id="数据划分">10.2.3.5 数据划分</h4><ol type="1"><li>昨晚DCT变换后，进行Zigzag展开</li><li>将前一部分数据，作为基础层进行传输</li><li>将后面的数据，切分为若干个部分，作为增强层，进行传输</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331092120370.png" alt="image-20230331092120370" style="zoom:80%;" /></p><h3 id="其他区别">10.2.4 其他区别</h3><ol type="1"><li>MPEG-2有更好的容错率</li><li>MPEG-2既可以4:2:0，也可以4:2:2、4:4:4</li><li>Slice的划分不能跨越一行</li></ol><h1 id="十一mpeg视频编码ⅱ">十一、MPEG视频编码Ⅱ</h1><h2 id="mpeg-4">11.1 MPEG-4</h2><h3 id="概览">11.1.1 概览</h3><ol type="1"><li><p>一个更新的标准，除了压缩，还支持数据的上传</p></li><li><p>是基于对象的编码<strong>object-based coding</strong></p><ol type="1"><li>提高<strong>压缩比</strong></li><li>便于对视频的内容进行<strong>再加工</strong>，即交互行为</li><li>静态图像编码</li><li>Face对象编码、动画</li><li>Body对象编码、动画</li></ol></li><li><p>bit率：5kbps ~ 10 Mbps</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407081343431.png" alt="image-20230407081343431" style="zoom:80%;" /></p></li><li><p>分离对象 =&gt; 对每个对象分别编码压缩 =&gt;每个对象单独编码然后叠加</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407081256203.png" alt="image-20230407081256203" style="zoom:80%;" /></p></li><li><p>MPEG-4是一种全新的标准，可以支持：</p><ol type="1"><li>组合视频对象，从而创建出预期的场景</li><li>支持对视频不同质量的服务QoS</li><li>与音视频场景进行交互</li></ol></li><li><p>MPEG-4的结构：</p><ol type="1"><li>VS</li><li>VO</li><li>VOL：为了实现可伸缩编码，共享系数的GOV</li><li>GOV：相邻的一组VOP</li><li>VOP：某个时刻对于某个VO的一个快照</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407082043835.png" alt="image-20230407082043835" style="zoom:80%;" /></p></li></ol><h3 id="基于对象的编码">11.1.2 *基于对象的编码</h3><h4 id="frame-based-coding-vs-vop-based-coding">11.1.2.1 Frame-BasedCoding vs VOP-Based Coding</h4><ol type="1"><li><p>MPEG-1&amp;MPEG-2：基于块的运动估计，没有VOP的概念，直接对帧进行切割</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407082534795.png" alt="image-20230407082534795" style="zoom:80%;" /></p></li><li><p>MPEG-4：首先将帧分为Object，然后对不同的Object序列进行编码</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407082737695.png" alt="image-20230407082737695" style="zoom:80%;" /></p></li></ol><h4 id="vop-based-coding">11.1.2.2 VOP-Based Coding</h4><ol type="1"><li><p>依旧是使用运动向量估计的方法，进行压缩</p><ol type="1"><li>运动估计</li><li>基于运动向量的预测</li><li>对残差进行编码</li></ol></li><li><p>也有I帧、P帧、B帧的概念</p></li><li><p>VOP会有不同的形状，最好对于形状和纹理分别编码</p></li><li><p>使用宏块将框出对象的包围盒</p><ol type="1"><li>包围盒的大小一定是宏块的整数倍</li><li>内部宏块：完全在对象内部的宏块 ==&gt; 直接进行编码</li><li>边缘宏块：一部分在对象内，一部分在对象外 ==&gt;存在没有定义的像素，需要进行padding</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407083251149.png" alt="image-20230407083251149" style="zoom:80%;" /></p></li></ol><h4 id="motion-compensation">11.1.2.3 Motion Compensation</h4><ol type="1"><li><p>对于边缘宏块，在目标帧和参考帧之间，会存在没有定义的像素的预测，需要进行padding</p><ol type="1"><li>即填充像素的值，使得边缘宏块填充完整</li><li>水平填充、垂直填充：对边缘像素进行延申</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407083902071.png" alt="image-20230407083902071" style="zoom:80%;" /></p></li></ol><h4 id="纹理编码">11.1.2.4 纹理编码</h4><ol type="1"><li><p>I-VOP：和JPEG的编码相同</p></li><li><p>P-VOP、B-VOP：需要进行编码</p></li><li><p>SA-DCT变换：</p><ol type="1"><li>先将图像推到上面，然后对每一列进行DCT变换</li><li>然后将图像推导左边，然后对每一行进行DCT变换</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407084222031.png" alt="image-20230407084222031" style="zoom:80%;" /></p></li></ol><h4 id="形状编码">11.1.2.5 形状编码</h4><ol type="1"><li>恢复原图像时，仅有纹理信息是不够的，还需要有形状信息：<ol type="1"><li>对<strong>形状</strong>也进行DCT变换，记录下来</li><li>二元编码 Binary Shape coding</li><li>灰度编码 gray scale coding</li></ol></li></ol><h4 id="静态纹理压缩-static-texture-coding">11.1.2.6 静态纹理压缩 StaticTexture Coding</h4><ol type="1"><li>使用<strong>小波变换</strong>进行编码</li></ol><h4 id="动态编码-sprite-coding">11.1.2.7 动态编码 Sprite Coding</h4><ol type="1"><li>可以将图像分为背景+运动物体的合成</li><li>对背景、运动物体分别处理<ol type="1"><li>背景：将大背景全部传过去，在每一帧时，修正相机的姿态，选取对应的位置</li><li>运动物体：正常编码</li><li>每一帧，将选中的背景与运动物体合成到一起</li></ol></li></ol><h3 id="动态物体编码">11.1.3 动态物体编码</h3><ol type="1"><li><p>先将整个形象传过去，然后只需要传输人物的姿态变化</p><ol type="1"><li>第一帧：对角色进行网格剖分</li><li>之后每一帧：传输运动信息</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230407085901742.png" alt="image-20230407085901742" style="zoom:80%;" /></p></li></ol><h1 id="十二基于内容的多媒体检索">十二、基于内容的多媒体检索</h1><h2 id="cbmr基于内容的多媒体检索">12.1 CBMR：基于内容的多媒体检索</h2><ol type="1"><li>用于检索到各种类型的多媒体数据</li><li>包含图像、视频、音频、物理等</li><li>基于物理内容、语义内容，而不是字符串匹配</li></ol><p>CBMR的基础方法</p><ol type="1"><li>对多媒体数据进行表示</li><li>特称抽取</li><li>相似度匹配</li><li>结果排序</li><li>用户反馈</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412081908864.png" alt="image-20230412081908864" style="zoom:80%;" /></p><h2 id="cbir基于内容的图像检索">12.2 CBIR：基于内容的图像检索</h2><p>给定一个查询图像，返回与之相似的图像</p><ol type="1"><li>由于图像的尺寸不同，因此需要提取图像的有效特征<strong>features</strong></li><li>基于抽象特征，做索引</li><li>定义两个特征的相似度评价</li></ol><p>语义鸿沟 Semantic Gap</p><ol type="1"><li>如何让计算机理解图像/视频的内容</li><li>如何判断高维图像和低维语义之间的关系</li></ol><h3 id="特征">12.2.1 特征</h3><p>用内容特征表示图像</p><ol type="1"><li><p>颜色</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412083118857.png" alt="image-20230412083118857" style="zoom:80%;" /></p></li><li><p>形状</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412083201460.png" alt="image-20230412083201460" style="zoom:80%;" /></p></li><li><p>纹理</p></li></ol><h3 id="相似度计算">12.2.2 相似度计算</h3><p>用向量表示特征</p><ol type="1"><li>图像1：<span class="math inline">\(I = [f_{11}\ f_{12}\ ...\f_{1n}]\)</span></li><li>图像2：<span class="math inline">\(Q = [f_{21}\ f_{22}\ ...\f_{2n}]\)</span></li><li>相似度/距离函数：<ol type="1"><li><span class="math inline">\(D_1=\sum_{i=1}^{n}|I_i -Q_i|\)</span></li><li><span class="math inline">\(D_1=\sum_{i=1}^{n}(I_i -Q_i)^2\)</span></li><li>还可以计算两个向量的夹角、距离等等</li></ol></li></ol><h2 id="dmr">12.3 3DMR</h2><h3 id="特征提取">12.3.1 特征提取</h3><ol type="1"><li>基于几何的方法<ol type="1"><li>提取形状</li><li>提取拓扑结构</li></ol></li><li>将模型投影为图像<ol type="1"><li>从不同角度进行拍照(形状采样)，然后编号</li><li>穷举对应顺序，取最小的作为相似度(取平均也可以)</li><li>也可以先分析重心，找到主轴，让主轴的方向相同，然后再拍照</li></ol></li></ol><h1 id="十三视频结构化">十三、视频结构化</h1><h2 id="视频结构">13.1 视频结构</h2><h3 id="概念">13.1.1 概念</h3><ol type="1"><li><strong>帧Frame</strong>：视频流中的基本组成单元<ol type="1"><li>物理上的最小单元</li><li>每一帧均可看成一个独立的图像</li><li>视频流数据就是由连续图像帧构成的</li></ol></li><li><strong>关键帧Key Frame</strong>：用来代表镜头内容的图像<ol type="1"><li>从一个镜头包含的帧中抽取一部分帧，代表这个镜头的内容</li></ol></li><li><strong>镜头Shot</strong>：摄像机拍下的不间断帧序列<ol type="1"><li>逻辑上的最小单元</li><li>是视频数据流进一步结构化的基础结构层</li><li>在同一组镜头中，属于同一组镜头的图像帧之间的特征保持稳定，如果相邻图像帧之间的特征发生了明显变化，认为发生了镜头变化，需要对视频数据进行切分</li></ol></li><li><strong>组Group</strong>：介于物理镜头和语义场景之间的结构<ol type="1"><li>例如：一段采访录像，镜头在主持人与被采访者之间频繁切换，整个采访属于一个场景，而那些关于主持人的所有镜头属于一组，关于被采访者的所有镜头属于另一组</li></ol></li><li><strong>场景Scecne</strong>：语义上相关和时间上相邻的若干组镜头组成了一个场景<ol type="1"><li>场景是视频所蕴含的高层抽象概念和语义表达</li><li>场景可以使用属于这个场景的若干个镜头所对应的关键帧来表示</li></ol></li><li><strong>视频Video</strong></li></ol><h3 id="视频结构化的任务">13.1.2 视频结构化的任务</h3><ol type="1"><li>划分镜头</li><li>分组</li><li>构成场景</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419081815165.png" alt="image-20230419081815165" style="zoom:80%;" /></p><h2 id="镜头检测">13.2 镜头检测</h2><p>问题定义：给定一个视频V包含n个镜头，找到每个镜头的起始和结束</p><ol type="1"><li>也被称为 边界检测boundary detection 或 过渡检测transitiondetection</li></ol><h3 id="镜头的分类">13.2.1 镜头的分类</h3><ol type="1"><li>Hard cuts：硬切，直接在两个镜头之间切换</li><li>Fades：前一个镜头淡出，下一个镜头淡入</li><li>Dissolves：上一个镜头淡出的同时，下一个镜头淡入，两个镜头之间会叠加起来</li><li>Wipe：其他花样切换方式</li></ol><h3 id="特征提取-1">13.2.2 特征提取</h3><p>每次计算相邻两帧的特征差<spanclass="math inline">\(\Delta=f(t+1)-f(t)\)</span>，如果发生跳变<spanclass="math inline">\(\Delta&gt;T(k)\)</span>，则说明发生了镜头切换</p><ol type="1"><li>特征：可以是每一帧的直方图，彩色图像可以转化为灰度图像然后再计算直方图</li></ol><h3 id="镜头边缘检测算法">13.2.3 镜头边缘检测算法</h3><p>实质：</p><ol type="1"><li>找到一种或几种良好的视频图像特征</li><li>然后基于这样的特征定义，计算其相似度函数</li><li>确定阈值</li></ol><h4 id="绝对帧间差法">13.2.3.1 绝对帧间差法</h4><ol type="1"><li>判断相邻图像帧之间特征的绝对差是否大</li><li>具体特征：某一帧中所有像素的色彩亮度之和</li></ol><h4 id="图像像素差法">13.2.3.2 图像像素差法</h4><ol type="1"><li>判断相邻图像帧中像素点发生变化的多少</li><li>缺点：对镜头移动十分明暗，对噪声的容错性较差</li></ol><h4 id="颜色直方图法">13.2.3.3 颜色直方图法</h4><ol type="1"><li>将图像转化为灰度图像，然后计算归一化后的颜色直方图</li><li>判断特征差<ol type="1"><li><spanclass="math inline">\(d(f,f&#39;)=\sum_{j=0}^{N}|H(f,j)-H(f&#39;,j)|\)</span></li><li>也可以是带权直方图、两个特征向量的夹角</li></ol></li></ol><h3 id="渐变镜头的数学模型">13.2.4 渐变镜头的数学模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419083834479.png" alt="image-20230419083834479" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419084038381.png" alt="image-20230419084038381" style="zoom:80%;" /></p><blockquote><p>灰度均值：开口向下的抛物线</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419084101885.png" alt="image-20230419084101885" style="zoom:80%;" /></p><blockquote><p>灰度方差：开口向上的抛物线</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419084200871.png" alt="image-20230419084200871" style="zoom:80%;" /></p><h2 id="关键帧抽取">13.3 关键帧抽取</h2><ol type="1"><li>视频数据流中的图像帧之间存在空间和时间冗余度</li><li>可以从视频中找到一些代表性的帧，用这些少量的帧来代表冗长的视频数据流，使用户看过关键帧后，就能知道整个视频数据流所蕴含的内容，再通过提取这些帧的底层信息来建立索引，方便用户对视频内容查询</li></ol><h3 id="镜头边界法">13.3.1 镜头边界法</h3><ol type="1"><li>将镜头中的第一幅图像和最后一幅图像作为镜头关键帧</li><li>每个镜头的关键帧只能有2个关键帧</li></ol><h3 id="基于特征转变法">13.3.2 基于特征转变法</h3><ol type="1"><li>将镜头当前帧与之前判断的最后一个关键帧作比较，如果差异较大，则作为新的关键帧</li></ol><h3 id="基于运动分析法">13.3.3 基于运动分析法</h3><ol type="1"><li>如果两个帧的重叠部分小于某个阈值，则将后一帧作为新的关键帧</li></ol><h3 id="基于聚类的关键帧提取">13.3.4 基于聚类的关键帧提取</h3><ol type="1"><li>K平均聚类方法，聚类之后，从每一类中选择一个帧作为关键帧</li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理导论</title>
      <link href="/2023/03/02/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%AF%BC%E8%AE%BA/"/>
      <url>/2023/03/02/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一全连接前馈神经网络-fcfn">一、全连接前馈神经网络 FCFN</h1><blockquote><p>全连接前馈网络：<strong>Fully Connect FeedforwardNetwork</strong></p></blockquote><h2 id="机器学习-寻找目标函数">1.1 机器学习 =&gt; 寻找目标函数</h2><ol type="1"><li><p>给定一个函数的集合，机器学习实际上就是找到这个集合中的一个函数，能够符合预期要求</p></li><li><p>训练数据：相当于一套卷子，通过做这套卷子的得分，判断哪个函数更好</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307133803594.png" alt="image-20230307133803594" style="zoom:80%;" /></p></li><li><p>推理<strong>Testing</strong>：找到给定的函数后，对于其他的输入，期望得到目标输出，也就是<strong>泛化</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307134010506.png" alt="image-20230307134010506" style="zoom:80%;" /></p></li><li><p>机器学习的三个步骤：</p><ol type="1"><li>定义函数集合</li><li>设计评价函数(损失函数)：函数=&gt;得分</li><li>找到最优函数</li></ol></li><li><p><strong>神经网络 NeuralNetwork</strong>：即为一种定义函数集合的方式</p></li></ol><h2 id="神经网络定义函数集合">1.2 神经网络：定义函数集合</h2><h3 id="神经元-neuron">1.2.1 神经元 Neuron</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307135519031.png" alt="image-20230307135519031" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307135530474.png" alt="image-20230307135530474" style="zoom:80%;" /></p><ol type="1"><li>Sigmoid函数：用于门控，当输入大到某一个值后，输出为最大值<ol type="1"><li>是一个归一化函数，将一个比较大的值，变成一个小的值</li></ol></li><li>神经元函数：<spanclass="math inline">\(\sigma(z)=\sigma(a_1w_1+a_2w_2+...+a_kw_k+b)=\sigma(\veca · \vec w)\)</span><ol type="1"><li>输入<span class="math inline">\(\vec a\)</span>与权重<spanclass="math inline">\(\vec w\)</span>越接近，输出越大</li><li>因此类似于一次<code>if</code>操作，只不过<code>if</code>的判断条件是学习出来的</li></ol></li></ol><h3 id="神经网络">1.2.2 神经网络</h3><p>将多个神经元相连，组成一个神经网络</p><ol type="1"><li>神经网络的参数<code>θ</code>：即为所有神经元的全部weights和bias</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307140434604.png" alt="image-20230307140434604" style="zoom:80%;" /></p><h3 id="全连接前馈网络-fcfn">1.2.3 全连接前馈网络 FCFN</h3><blockquote><p><strong>Fully Connect Feedforward Network</strong></p></blockquote><p>前一层所有神经元的输出，会输入到后一层的所有神经元上</p><ol type="1"><li>当参数一定时，就是一个确定函数</li><li>定义了神经网络的结构，也就定义了一个函数集合</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307140645890.png" alt="image-20230307140645890" style="zoom:80%;" /></p><h3 id="深度学习">1.2.4 深度学习</h3><p><strong>FCFN</strong>一般分为三个部分：输入层、隐藏层、输出层</p><ol type="1"><li>深度学习：有多个隐藏层</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307140756614.png" alt="image-20230307140756614" style="zoom:80%;" /></p><h3 id="为什么需要深度">1.2.5 为什么需要深度</h3><ol type="1"><li>现在的激活函数：达到阈值后，输出=输入；相当于用多条直线拟合函数图像</li><li>在参数量相同时，层数越多，拟合能力越强</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307142616233.png" alt="image-20230307142616233" style="zoom:80%;" /></p><h2 id="设计评价函数">1.3 设计评价函数</h2><h3 id="训练数据">1.3.1 训练数据</h3><p>训练数据：</p><ol type="1"><li>准备图像及其标签</li><li>学习目标被定义在训练数据中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307143000140.png" alt="image-20230307143000140" style="zoom:80%;" /></p><h3 id="学习目标">1.3.2 学习目标</h3><ol type="1"><li>输入层：将训练数据转化为一维向量</li><li>输出层：根据目标定义</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307143132718.png" alt="image-20230307143132718" style="zoom:80%;" /></p><h3 id="输出层">1.3.3 输出层</h3><p>使用Softmax作为输出层</p><ol type="1"><li>不用max函数，是因为max函数不可导</li><li>通过Softmax层后，输入的差距会变得更大</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307143431742.png" alt="image-20230307143431742" style="zoom:80%;" /></p><h3 id="损失">1.3.4 损失</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307143624220.png" alt="image-20230307143624220" style="zoom:80%;" /></p><h3 id="总损失">1.3.5 总损失</h3><ol type="1"><li>参数确定后，神经网络确定，对于所有输入的输出就一定，总损失<code>L</code>就一定</li><li>因此<code>L</code>是关于参数<code>θ</code>的函数</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307143658423.png" alt="image-20230307143658423" style="zoom:80%;" /></p><h2 id="找到最优函数">1.4 找到最优函数</h2><h3 id="gradient-descent-梯度下降">1.4.1 Gradient Descent 梯度下降</h3><ol type="1"><li><p><code>L</code>是关于<code>θ</code>的函数，因此可以得到一条<code>L-θ</code>的图像（<code>θ</code>是一个高维变量）</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307144109525.png" alt="image-20230307144109525" style="zoom:80%;" /></p></li><li><p>任务是找到一个令<code>L</code>最小的<code>θ</code>值：求导，但是由于求导的要求过高，因此会求<spanclass="math inline">\(\frac{∂L}{∂w}\)</span></p><ol type="1"><li>随机选择<code>w</code>的一个起始值</li><li>计算<code>L</code>关于<code>w</code>的偏导</li><li>将<code>w</code>的值更改为<spanclass="math inline">\(w-η\frac{∂L}{∂w}\)</span>，<strong>η</strong>称为<strong>learningrate</strong>，会影响神经网络的训练效率</li><li>重复2、3，直到<spanclass="math inline">\(\frac{∂L}{∂w}\)</span>足够小位置</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307144657908.png" alt="image-20230307144657908" style="zoom:80%;" /></p></li></ol><h3 id="局部最小值">1.4.2 局部最小值</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307144831943.png" alt="image-20230307144831943" style="zoom:80%;" /></p><p>不同的初始点，会得到不同的局部最小值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307145119198.png" alt="image-20230307145119198" style="zoom:80%;" /></p><h3 id="backpropagation">1.4.3 Backpropagation</h3><ol type="1"><li>用于在神经网络中计算<spanclass="math inline">\(\frac{∂L}{∂w}\)</span>，在当下一般都是自动计算</li></ol><h1 id="二词向量-word-embeddings">二、词向量 Word Embeddings</h1><p>Embedding：高维空间的低维结构</p><h2 id="词语的表示">2.1 词语的表示</h2><ol type="1"><li>狄拉克函数</li><li>独热值 one-hot representation：<ol type="1"><li>定义一个大向量，该向量对应一个词语</li><li>大向量的每个位置都表示一个单词，如果该单词出现，则对应位置为1，否则为0</li></ol></li><li>缺点：<ol type="1"><li>字典的大小要远大于单词的个数</li><li>单词与单词的独热值是正交的，无法表示同义词语</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307152357159.png" alt="image-20230307152357159" style="zoom:80%;" /></p><h2 id="将词语降维">2.2 将词语降维</h2><ol type="1"><li>存储词语的含义，而不是词语本身</li><li>将相同意思的不同词语，映射到同一个语义上</li><li>利用几个基础语义，重建词语本身</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307152936192.png" alt="image-20230307152936192" style="zoom:80%;" /></p><h2 id="词向量-word2vec">2.3 词向量 word2vec</h2><ol type="1"><li><p>通过上下文，确定某个单词的含义</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307153254540.png" alt="image-20230307153254540" style="zoom:80%;" /></p></li><li><p>通过学习两个W矩阵，获得词向量</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307154832077.png" alt="image-20230307154832077" style="zoom:80%;" /></p></li><li><p>词向量：<code>input vector</code>，左边矩阵中对应输入的一行</p></li></ol><h2 id="训练的过程相当于是一个softmax">2.4训练的过程：相当于是一个Softmax</h2><ol type="1"><li>训练的过程，相当于就是拉近输入与输出的距离</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307155134579.png" alt="image-20230307155134579" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307155152048.png" alt="image-20230307155152048" style="zoom:80%;" /></p><h2 id="hierarchical-softmax">2.5 Hierarchical Softmax</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230307155244123.png" alt="image-20230307155244123" style="zoom:80%;" /></p><h2 id="缺点">2.6 缺点</h2><ol type="1"><li>解决了多词一义，但不能解决一词多义</li><li>难以判断不同词向量的差异，如各种颜色的上下文基本相同</li><li>完全忽略了词语的顺序</li></ol><h1 id="三卷积神经网络-cnn">三、卷积神经网络 CNN</h1><blockquote><p>卷积神经网络：<strong>Convolutional NeuralNetworks</strong>，常用于图形处理</p></blockquote><h2 id="为什么需要cnn">3.1 为什么需要CNN</h2><ol type="1"><li><p>在图像识别中，特征点所在的位置在不同的图像中并不相同</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314142912562.png" alt="image-20230314142912562" style="zoom:80%;" /></p></li><li><p>对图像进行下采样，并不影响我们对图像的判断</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314142919829.png" alt="image-20230314142919829" style="zoom:80%;" /></p></li></ol><h2 id="cnn的结构">3.2 CNN的结构</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314144831022.png" alt="image-20230314144831022" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314145022637.png" alt="image-20230314145022637" style="zoom:80%;" /></p><h3 id="卷积-convolution">3.2.1 卷积 Convolution</h3><blockquote><p>卷积操作可以保持<strong>平移不变性</strong>：同一特征在不同位置均可检测出来</p><p>不能保持<strong>翻转不变性</strong>：将特征旋转/翻转后，就需要另一个卷积核了</p></blockquote><ol type="1"><li>每一次的操作，都是两个大小相等的矩阵，逐位相乘再相加</li><li>与Filter的卷积，实质上是在大图像上，寻找与Filter相似的区域<ol type="1"><li>图像的某个区域与Filter越相近，得到的值越大</li></ol></li><li>stride：每一次移动的长度</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314143819063.png" alt="image-20230314143819063" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314143837181.png" alt="image-20230314143837181" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314144048313.png" alt="image-20230314144048313" style="zoom:80%;" /></p><blockquote><p><strong>卷积与神经网络的联系</strong>：相当于只对图像的一个小区域进行检测，而不是全连接中的整个图像</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314144221305.png" alt="image-20230314144221305" style="zoom:80%;" /></p><h3 id="最大池化-max-pooling">3.2.2 最大池化 Max Pooling</h3><ol type="1"><li>实质上就是对图像进行一次下采样，降低计算量</li><li>将卷积后的图像分为若干个不相交的区域，然后每个区域取最大值<ol type="1"><li>最大池化：检测信号的强弱</li><li>平均池化：检测模式在某个区域是否比较普遍</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314144553443.png" alt="image-20230314144553443" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314144600316.png" alt="image-20230314144600316" style="zoom:80%;" /></p><h3 id="扁平化-flatten">3.2.3 扁平化 Flatten</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314145209844.png" alt="image-20230314145209844" style="zoom:80%;" /></p><h2 id="cnn变种">3.3 CNN变种</h2><h3 id="vggnet">3.3.1 VGGNet</h3><ol type="1"><li>在CNN的基础上，变得更深了</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314151621521.png" alt="image-20230314151621521" style="zoom:80%;" /></p><h3 id="googlenetinception">3.3.2 GoogLeNet(Inception)</h3><ol type="1"><li><p>增加网络的宽度：每一层有多种大小的卷积核</p><ol type="1"><li>防止由于识别得过早，导致没有识别出特征</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314151723899.png" alt="image-20230314151723899" style="zoom:80%;" /></p></li><li><p>1×1卷积核：</p><ol type="1"><li>将卷积核得到的多张图像，按照权重加和，得到一张图像</li><li>相当于进行了一次压缩</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314151830269.png" alt="image-20230314151830269" style="zoom:80%;" /></p></li></ol><h3 id="resnet">3.3.3 ResNet</h3><ol type="1"><li>添加了skipconnection：将输入直接送到下一层，缓解了梯度消失的问题</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314151935829.png" alt="image-20230314151935829" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314152222879.png" alt="image-20230314152222879" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314152848905.png" alt="image-20230314152848905" style="zoom:80%;" /></p><h2 id="convolution">3.4 Convolution</h2><h3 id="d-convolution">3.4.1 1D Convolution</h3><ol type="1"><li>本质上在做滑动窗口</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314153116179.png" alt="image-20230314153116179" style="zoom:80%;" /></p><h3 id="d-convolution-1">3.4.2 2D Convolution</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314153331895.png" alt="image-20230314153331895" style="zoom:80%;" /></p><h3 id="d-convolution-2">3.4.3 3D Convolution</h3><blockquote><p>将3D分为多个通道，每个通道进行2D Convolution</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314153347937.png" alt="image-20230314153347937" style="zoom:80%;" /></p><blockquote><p>使用3D卷积核进行计算</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314153452092.png" alt="image-20230314153452092" style="zoom:80%;" /></p><h3 id="图卷积">3.4.4 图卷积</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314153521147.png" alt="image-20230314153521147" style="zoom:80%;" /></p><h3 id="球卷积">3.4.5 球卷积</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314153653895.png" alt="image-20230314153653895" style="zoom:80%;" /></p><h3 id="转置卷积逆卷积">3.4.6 转置卷积/逆卷积</h3><blockquote><p>把小图像变大：上采样</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314153736364.png" alt="image-20230314153736364" style="zoom:80%;" /></p><h3 id="胶囊网络">3.4.7 胶囊网络</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314154349021.png" alt="image-20230314154349021" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314154337181.png" alt="image-20230314154337181" style="zoom:80%;" /></p><blockquote><p>通过动态路由，在使用时仍要通过一定的规则，计算参数</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314154439731.png" alt="image-20230314154439731" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314154511464.png" alt="image-20230314154511464" style="zoom:80%;" /></p><h2 id="nlp中的cnn">3.5 NLP中的CNN</h2><h3 id="bag-of-words">3.5.1 Bag of Words</h3><ol type="1"><li>识别一个句子</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314154923595.png" alt="image-20230314154923595" style="zoom:80%;" /></p><h3 id="bag-of-n-grams">3.5.2 Bag of n-grams</h3><ol type="1"><li>将句子的语序也考虑进去</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314154939075.png" alt="image-20230314154939075" style="zoom:80%;" /></p><h3 id="nlp中的cnn-1">3.5.3 NLP中的CNN</h3><h4 id="stride">3.5.3.1 Stride</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314155250898.png" alt="image-20230314155250898" style="zoom:80%;" /></p><h4 id="pooling">3.5.3.2 Pooling</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314155310389.png" alt="image-20230314155310389" style="zoom:80%;" /></p><h4 id="示例">3.5.3.3 示例</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314155548957.png" alt="image-20230314155548957" style="zoom:80%;" /></p><h4 id="stacked-convolution">3.5.3.4 Stacked Convolution</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314155653982.png" alt="image-20230314155653982" style="zoom:80%;" /></p><h4 id="dilated-convolution-膨胀卷积">3.5.3.5 Dilated Convolution膨胀卷积</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314155716083.png" alt="image-20230314155716083" style="zoom:80%;" /></p><h4 id="structured-convolution-结构卷积">3.5.3.6 Structured Convolution结构卷积</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314155803703.png" alt="image-20230314155803703" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314155810494.png" alt="image-20230314155810494" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230314155831870.png" alt="image-20230314155831870" style="zoom:80%;" /></p><h1 id="四循环神经网络-rnn">四、循环神经网络 RNN</h1><blockquote><p><strong>Recurrent NeuralNetworks</strong>，可以看作有一定记忆能力的神经网络</p></blockquote><h2 id="rnn">4.1 RNN</h2><h3 id="rnn-1">4.1.1 RNN</h3><ol type="1"><li>某一个时刻<code>t</code>的输出<code>y2</code>，与当前时刻的输入<code>x2</code>、上一个时刻的输入有关<code>x1</code>，需要通过一个存储<code>h1</code>保留上一时刻的信息</li><li><code>f</code>即为神经网络函数</li><li>在每一时刻，<code>h,x,y,</code>均变化，但<code>f</code>不变</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321133635450.png" alt="image-20230321133635450" style="zoom:80%;" /></p><h3 id="deep-rnn">4.1.2 Deep RNN</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321134021758.png" alt="image-20230321134021758" style="zoom:80%;" /></p><h3 id="双向rnn">4.1.3 双向RNN</h3><ol type="1"><li>通常用于编码阶段</li><li>既需要某个词的含义，也需要某个词的上下文</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321134156375.png" alt="image-20230321134156375" style="zoom:80%;" /></p><h3 id="naive-rnn">4.1.4 Naive RNN</h3><blockquote><p>最基础的RNN</p></blockquote><p><strong>训练难</strong>：神经网络学习时</p><ol type="1"><li>如果在<code>yn</code>处存在损失，则会将损失一步一步传回<code>h0</code>处</li><li>实际中，会将RNN展开为一个很深的神经网络，只不过每个部分的参数是共享的</li><li>由于深度过深，会存在<strong>梯度消失</strong>问题</li><li>由于参数共享，最后的输出相当于<code>f(xn,f(...f(x2,f(x1,h0)))</code>，会产生<strong>梯度爆炸</strong>问题：<ol type="1"><li>类似于变量在指数上，输入变化一点，输出会发生巨大变化</li><li>会导致<strong>梯度墙</strong>现象：在某些地方，w稍微变化一点，L会变化非常多，而在其它地方，w变化很多，L也不会变得非常大</li><li>在最初训练时，L对于w的变化很小，导致learningrate非常大，从而非常快的撞向梯度墙，导致在上一时刻时，导数还很小，下一时刻，导数会变得非常大，从而导致训练失败</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321134639335.png" alt="image-20230321134639335" style="zoom:80%;" /></p><h2 id="lstm">4.2 LSTM</h2><blockquote><p>一般说RNN指的即为LSTM</p></blockquote><h3 id="lstm算法">4.2.1 LSTM算法</h3><p>解决<strong>遗忘问题</strong>：h的变化通常会很大，导致记忆不稳定</p><ol type="1"><li><code>h</code>的变化是乘法，<code>c</code>的变化是加法</li><li>因此，用<code>h</code>表示瞬时记忆，<code>c</code>表示长期记忆</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321140303207.png" alt="image-20230321140303207" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321140539845.png" alt="image-20230321140539845" style="zoom:80%;" /></p><blockquote><p>peephole：可以将长期记忆c<sup>t</sup>当作输入送入网络，但是对其进行计算时，通常只会乘一个对角阵</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321141306070.png" alt="image-20230321141306070" style="zoom:80%;" /></p><blockquote><p>LSTM的每个cell</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321141011210.png" alt="image-20230321141011210" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321141033941.png" alt="image-20230321141033941" style="zoom:80%;" /></p><h3 id="对lstm不同参数的研究">4.2.2 对LSTM不同参数的研究</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321141508217.png" alt="image-20230321141508217" style="zoom:80%;" /></p><h3 id="gru">4.2.3 GRU</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321141651913.png" alt="image-20230321141651913" style="zoom:80%;" /></p><h2 id="nlp中的rnn">4.3 NLP中的RNN</h2><ol type="1"><li><p>NLP充满了序列化的数据</p><ol type="1"><li>一篇文章中的句子、一个句子中的单词、一个单词中的字母</li></ol></li><li><p>RNN善于进行长距离依赖</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321142040687.png" alt="image-20230321142040687" style="zoom:80%;" /></p></li></ol><h3 id="rnn加工一个序列">4.3.1 RNN加工一个序列</h3><ol type="1"><li>每一时刻，吃进去一个词向量，然后根据上一时刻的内容，输出label</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321142147455.png" alt="image-20230321142147455" style="zoom:80%;" /></p><h3 id="rnn既可以做编码器也可以做解码器">4.3.2RNN既可以做编码器，也可以做解码器</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321142555369.png" alt="image-20230321142555369" style="zoom:80%;" /></p><h3 id="encoder-decoder模型">4.3.3 Encoder-decoder模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321142801222.png" alt="image-20230321142801222" style="zoom:80%;" /></p><h2 id="attention-注意力">4.4 Attention 注意力</h2><h3 id="计算注意力">4.4.1 计算注意力</h3><ol type="1"><li>decoder的某个状态得到的输出queryvector，与encoder中的所有状态的词向量<code>ki</code>点乘，然后再进行一次softmax，得到一个attentionscore <code>ai</code></li><li>用<code>ai</code>与对应的<code>ki</code>进行数乘，然后再相加，得到一个注意力向量</li><li>然后可以用这个注意力向量进行后续操作</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321144512781.png" alt="image-20230321144512781" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321144519311.png" alt="image-20230321144519311" style="zoom:80%;" /></p><h3 id="注意力得分函数">4.4.2 注意力得分函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321144917618.png" alt="image-20230321144917618" style="zoom:80%;" /></p><h3 id="attention的用途">4.4.3 Attention的用途</h3><ol type="1"><li>copy机制：直接从上下文中，将某个单词拷贝到语义库</li><li>关注前置单词（输入、输出）</li><li>关注多模态输入（图像、语言）</li><li>关注多种输入源</li></ol><h3 id="hierarchical-structure">4.4.4 Hierarchical Structure</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321145315038.png" alt="image-20230321145315038" style="zoom:80%;" /></p><h3 id="hard-attention">4.4.5 Hard Attention</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321145450210.png" alt="image-20230321145450210" style="zoom:80%;" /></p><h2 id="pointer-network">4.5 Pointer Network</h2><h3 id="使用注意力做选择问题">4.5.1 使用注意力做选择问题</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321150554682.png" alt="image-20230321150554682" style="zoom:80%;" /></p><ol type="1"><li>输出是输入的一个子集</li><li>可以使用<strong>注意力</strong>进行<strong>选择</strong>问题</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321150649836.png" alt="image-20230321150649836" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321150802011.png" alt="image-20230321150802011" style="zoom:80%;" /></p><h3 id="copy机制">4.5.2 Copy机制</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321150845928.png" alt="image-20230321150845928" style="zoom:80%;" /></p><h2 id="attention-and-augmented-rnn">4.6 Attention and AugmentedRNN</h2><h3 id="ntmneural-turing-machines">4.6.1 NTM：Neural TuringMachines</h3><ol type="1"><li><p><strong>RNN</strong>是<strong>图灵完全</strong>的，理论上可以用来模拟任何函数，当然也可以模拟任何程序的功能</p></li><li><p>通过注意力，实现NTM的寻址、读写</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321151739061.png" alt="image-20230321151739061" style="zoom:80%;" /></p></li></ol><h3 id="dncdifferentiable-neural-computer">4.6.2 DNC：DifferentiableNeural Computer</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321151849169.png" alt="image-20230321151849169" style="zoom:80%;" /></p><h3 id="actadaptive-computation-time">4.6.4 ACT：Adaptive ComputationTime</h3><blockquote><p>让神经网络的结构，根据具体问题而改变</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321151954839.png" alt="image-20230321151954839" style="zoom:80%;" /></p><h3 id="neural-programmer">4.6.5 Neural Programmer</h3><blockquote><p>让神经网络学会编程、计算</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321152621791.png" alt="image-20230321152621791" style="zoom:80%;" /></p><h1 id="五生成模型语言生成">五、生成模型、语言生成</h1><h2 id="生成模型-generative-models">5.1 生成模型 Generative Models</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328142916146.png" alt="image-20230328142916146" style="zoom:80%;" /></p><h3 id="高斯混合模型-gmmgaussian-mixture-models">5.1.1 高斯混合模型GMM：Gaussian Mixture Models</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328144039207.png" alt="image-20230328144039207" style="zoom:80%;" /></p><h3 id="流形假设-manifold-assumption">5.1.2 流形假设 ManifoldAssumption</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328144143806.png" alt="image-20230328144143806" style="zoom:80%;" /></p><h3 id="auto-encoder">5.1.3 Auto-Encoder</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328144406530.png" alt="image-20230328144406530" style="zoom:80%;" /></p><p>训练时：要求Decoder的输出与Encoder的输入相同</p><ol type="1"><li>此时，可以得到两个模型：Encoder、Decoder</li><li>而<strong>Decoder</strong>就可以作为<strong>Generator</strong>使用</li><li><strong>code</strong>即为这个模型中的<strong>流形</strong></li></ol><h4 id="generator">5.1.3.1 Generator</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328144600228.png" alt="image-20230328144600228" style="zoom:80%;" /></p><ol type="1"><li>一个神经网络，输入是一个vector，输出是一个图像</li><li>期望vector中的每一维控制不同的特征</li><li>但实际上vector的每一维之间是紧密耦合的，需要进行解耦操作才可以实现预期效果</li></ol><blockquote><p>code为2维时，训练出的模型</p><p>通过对code进行差值然后得到输出，可以判断模型是否学习到了某些知识，而不是仅仅通过记忆</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328144836779.png" alt="image-20230328144836779" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328144848270.png" alt="image-20230328144848270" style="zoom:80%;" /></p></blockquote><h3 id="variational-autoencoders">5.1.4 Variational AutoEncoders</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328145516752.png" alt="image-20230328145516752" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328150231245.png" alt="image-20230328150231245" style="zoom:80%;" /></p><h3 id="flow-based-deep-generative-models">5.1.6 Flow-based DeepGenerative Models</h3><ol type="1"><li>Inverse是Flow的逆操作<ol type="1"><li>将一个图像分为两半，下半根据上半打乱</li><li>然后再翻转</li><li>重复12步，可以得到一个模糊后的图像</li><li>通过原图、模糊后的图像、模糊的过程，可以训练出Inverse</li></ol></li><li>只要能够训练出来Inverse，那么任给一个高斯模糊后的图像，一定能生成其原图像</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328150439408.png" alt="image-20230328150439408" style="zoom:80%;" /></p><h3 id="pixelrnnpixelcnn">5.1.7 PixelRNN、PixelCNN</h3><ol type="1"><li>用编码器，做解码器的工作</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328151128895.png" alt="image-20230328151128895" style="zoom:80%;" /></p><h2 id="自然语言生成-nlg">5.2 自然语言生成 NLG</h2><h3 id="语言模型">5.2.1 语言模型</h3><p><strong>Language Modeling</strong> 语言建模：给定历史单词<spanclass="math inline">\(y_1,...y_{t-1}\)</span>，生成下一个单词<spanclass="math inline">\(y_t\)</span></p><ol type="1"><li>实质上是一个概率密度函数<spanclass="math inline">\(P(y_t|y_1,...,y_{t-1})\)</span>，表示<spanclass="math inline">\(y_t\)</span>可能是该词的概率</li><li>生成这个概率密度函数的系统，被称为<strong>LanguageModel</strong></li><li>如果这个系统是一个RNN，则称为<strong>RNN-LM</strong></li></ol><p><strong>Conditional Language Modeling</strong>传统语言建模：给定历史单词<spanclass="math inline">\(y_1,...y_{t-1}\)</span>，和一些其他输入<spanclass="math inline">\(x\)</span>，生成下一个单词<spanclass="math inline">\(y_t\)</span></p><ol type="1"><li>概率密度函数<spanclass="math inline">\(P(y_t|y_1,...,y_{t-1}|x)\)</span></li></ol><h3 id="训练rnn-lm">5.2.2 训练RNN-LM</h3><ol type="1"><li>在训练时，如果上一步生成了一个错误的结果，则需要将其抛弃掉，将正确的结果送给下一步<ol type="1"><li>称为<strong>Teacher Forcing</strong></li><li>当实际数据与训练数据差距很大时，会导致模型崩溃</li><li>实际上，会在训练一段时间后，再次训练时，一定的概率将生成的结果直接送到下一步</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328152257417.png" alt="image-20230328152257417" style="zoom:80%;" /></p><h3 id="生成句子">5.2.3 生成句子</h3><p>已经有了模型<spanclass="math inline">\(P(Y|X)\)</span>，如何使用这个模型生成一个句子？</p><ol type="1"><li><strong>Sampling</strong>：根据概率密度函数，生成一个随机的句子</li><li><strong>Argmax</strong>：生成一个具有最大可能性的句子</li></ol><p><strong>Ancestral Sampling</strong>:</p><ol type="1"><li>一个接一个的随机生成单词</li><li>只需要一个明确的对<spanclass="math inline">\(P(X)\)</span>的采样方法</li></ol><p><strong>Greedy Search</strong>：</p><ol type="1"><li>一个接一个的，每次选择概率最大的单词</li><li>存在的问题：<ol type="1"><li>会经常优先生成一些简单的的单词</li><li>会优先生成常用的单词</li></ol></li></ol><h4 id="基于采样的decoding">5.2.3.1 基于采样的decoding</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328154047572.png" alt="image-20230328154047572" style="zoom:80%;" /></p><h4 id="beam-search">5.2.3.2 Beam Search</h4><ol type="1"><li>同时保留几个比较好的结果，作为输出</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328154115544.png" alt="image-20230328154115544" style="zoom:80%;" /></p><blockquote><p>确定一个最优的 beam size k</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328154132426.png" alt="image-20230328154132426" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328154140221.png" alt="image-20230328154140221" style="zoom:80%;" /></p><h4 id="softmax-temperature">5.2.3.3 Softmax Temperature</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328154204531.png" alt="image-20230328154204531" style="zoom:80%;" /></p><h3 id="decoding算法总结">5.2.4 Decoding算法总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328154242209.png" alt="image-20230328154242209" style="zoom:80%;" /></p><h2 id="评估-evaluation">5.3 评估 Evaluation</h2><h3 id="human-evaluation">5.3.1 Human Evaluation</h3><ol type="1"><li>是否重复？是否流畅？排序是多少？</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328154535201.png" alt="image-20230328154535201" style="zoom:80%;" /></p><h3 id="bleu">5.3.2 BLEU</h3><ol type="1"><li>Reference：翻译的准确结果</li><li>System：系统生成的结果</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328155050395.png" alt="image-20230328155050395" style="zoom:80%;" /></p><h3 id="meteor">5.3.3 METEOR</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328155110147.png" alt="image-20230328155110147" style="zoom:80%;" /></p><h3 id="perplexity">5.3.4 Perplexity</h3><ol type="1"><li>计算单词在不做生成的情况下的困惑程度</li><li>优点：自然解决多参考问</li><li>缺点：不考虑解码或实际生成输出</li><li>对于有很多歧义的问题可能是合理的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328155327829.png" alt="image-20230328155327829" style="zoom:80%;" /></p><h3 id="unconditional-generation">5.3.5 Unconditional Generation</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230328155345704.png" alt="image-20230328155345704" style="zoom:80%;" /></p><h1 id="六机器翻译-transformer">六、机器翻译 &amp; Transformer</h1><h2 id="统计机器翻译smt">6.1 统计机器翻译SMT</h2><blockquote><p>Statistical Machine Translation</p></blockquote><ol type="1"><li><p>设给定中文句子<strong>x</strong>，要翻译为英文句子<strong>y</strong>，则需要找到令<strong>P(y|x)</strong>最大的<strong>y</strong></p></li><li><p>利用贝叶斯公式可得：<strong>P(x,y) = P(x|y)×P(y) =P(y|x)×P(x)</strong></p></li><li><p>由于<strong>P(x)</strong>在<strong>x</strong>给定时是定值，因此我们只需要令<strong>P(x|y)×P(y)</strong>最大即可</p></li><li><p><strong>P(y)</strong>：先验，表示给定英文句子<strong>y</strong>，这是一个合法的英文句子的概率，很容易就能训练出来</p></li><li><p><strong>P(x|y)</strong>：似然函数，表示给定英文句子<strong>y</strong>，翻译为中文句子<strong>x</strong>的概率</p><ol type="1"><li><p>首先，需要大量的平行语料进行训练，即由人翻译的中文&lt;=&gt;英文</p></li><li><p>添加一个隐变量<strong>a(alignment)</strong>，计算当<strong>x,y</strong>给定时，对应的<strong>P(x,a|y)</strong></p><blockquote><p>alignment类似与attention</p><p>可以是一对多：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404135949111.png" alt="image-20230404135949111" style="zoom:80%;" /></p><p>可以是多对一：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404135957259.png" alt="image-20230404135957259" style="zoom:80%;" /></p><p>可以是多对多：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404140008070.png" alt="image-20230404140008070" style="zoom:80%;" /></p></blockquote></li></ol></li></ol><h2 id="神经网络机器翻译nmt">6.2 神经网络机器翻译NMT</h2><p>Sequence-To-Sequence model (NIPS 2014)</p><ol type="1"><li>直接对<strong>P(Y|X)</strong>进行建模</li><li>翻译不需要显式定义alignment</li><li>缺点：所有信息包含在了内部状态之中，解释性差，长句子的翻译效果很差</li></ol><p>Attention Model</p><ol type="1"><li>通过访问所有encoder的状态，降低了长句子翻译的缺点</li></ol><h3 id="v1encoder-decoder">6.2.1 V1：Encoder-Decoder</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404141308449.png" alt="image-20230404141308449" style="zoom:80%;" /></p><h3 id="v2基于attention的encoder-decoder">6.2.2V2：基于Attention的Encoder-Decoder</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404141333992.png" alt="image-20230404141333992" style="zoom:80%;" /></p><h3 id="v3双向encoder">6.2.3 V3：双向Encoder</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404141356209.png" alt="image-20230404141356209" style="zoom:80%;" /></p><h3 id="v4深度学习">6.2.4 V4：深度学习</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404141413901.png" alt="image-20230404141413901" style="zoom:80%;" /></p><h3 id="v5并行优化">6.2.5 V5：并行优化</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404141445841.png" alt="image-20230404141445841" style="zoom:80%;" /></p><h3 id="v6residuals-are-the-new-hotness">6.2.6 V6：Residuals are the newhotness</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404141506487.png" alt="image-20230404141506487" style="zoom:80%;" /></p><h2 id="nmt的近代发展">6.3 NMT的近代发展</h2><h3 id="multilingual-model">6.3.1 Multilingual Model</h3><ol type="1"><li><p>训练时，对每一个语料，添加一个标签，表示要翻译成哪种语言</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404141727860.png" alt="image-20230404141727860" style="zoom:80%;" /></p></li><li><p>Zero-Shot翻译：</p><ol type="1"><li>翻译时需要将日文翻译为韩文，但是训练数据并没有对应的语料</li><li>有日文到英文的翻译，有英文到韩文的翻译</li><li>相当于把英语作为一个桥梁</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404141839817.png" alt="image-20230404141839817" style="zoom:80%;" /></p></li></ol><h3 id="code-switching">6.3.2 Code-Switching</h3><blockquote><p>可以将两种语言混合在一起，进行翻译</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404142333392.png" alt="image-20230404142333392" style="zoom:80%;" /></p><h3 id="big-picture">6.3.3 Big Picture</h3><blockquote><p>训练的结构图</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404142449787.png" alt="image-20230404142449787" style="zoom:80%;" /></p><h3 id="unsupervised-mt">6.3.4 Unsupervised MT</h3><blockquote><p>当平行语料比较少的时候，可以使用这种方法</p></blockquote><ol type="1"><li>用两个编码器，分别学习两种语言，对应到两种语义空间</li><li>找到一些锚点，将两个语义空间拉近（如一些已经翻译好的句子对应的语义空间）</li><li>最后，将两个语义空间对齐</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404142819802.png" alt="image-20230404142819802" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404142857482.png" alt="image-20230404142857482" style="zoom:80%;" /></p><h3 id="对偶学习-dual-learning">6.3.5 对偶学习 Dual Learning</h3><blockquote><p>在没有平行语料的时候，可以使用该方法</p></blockquote><ol type="1"><li>一个模型负责将X翻译成Y，另一个模型负责将Y翻译为X</li><li>至少其中一个模型比较强</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404143249529.png" alt="image-20230404143249529" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404143347520.png" alt="image-20230404143347520" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404143405023.png" alt="image-20230404143405023" style="zoom:80%;" /></p><blockquote><p>两个模型可以互相做评价，将损失定义为两者的差值</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404143724216.png" alt="image-20230404143724216" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404143804931.png" alt="image-20230404143804931" style="zoom:80%;" /></p><h2 id="transformer">6.4 Transformer</h2><h3 id="sequence">6.4.1 Sequence</h3><ol type="1"><li>RNN对于长序列较好，但是无法并行计算</li><li>CNN可以并行计算，但是长序列就不行了</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404144359912.png" alt="image-20230404144359912" style="zoom:80%;" /></p><ol type="1"><li>将RNN的模型隐藏起来，我们需要的实际上就是给定一段输入，返回一段输出</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404144606817.png" alt="image-20230404144606817" style="zoom:80%;" /></p><h3 id="self-attention">6.4.2 Self-Attention</h3><ol type="1"><li>注意力：用query查询key，将v返回</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404145353403.png" alt="image-20230404145353403" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404145541028.png" alt="image-20230404145541028" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404145556039.png" alt="image-20230404145556039" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404145640050.png" alt="image-20230404145640050" style="zoom:80%;" /></p><blockquote><p>此时，我们对每一个ai，都输出了一个bi</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404145701766.png" alt="image-20230404145701766" style="zoom:80%;" /></p><blockquote><p>可以并行计算了</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404145834496.png" alt="image-20230404145834496" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404145905298.png" alt="image-20230404145905298" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404150000446.png" alt="image-20230404150000446" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404150010886.png" alt="image-20230404150010886" style="zoom:80%;" /></p><blockquote><p>整个操作过程</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404150026185.png" alt="image-20230404150026185" style="zoom:80%;" /></p><h3 id="multi-head-self-attention">6.4.3 Multi-head Self-Attention</h3><p>将得到的qkv矩阵分为两个，再进行操作</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404150311857.png" alt="image-20230404150311857" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404150344686.png" alt="image-20230404150344686" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404150354170.png" alt="image-20230404150354170" style="zoom: 80%;" /></p><h3 id="positional-encoding">6.4.4 Positional Encoding</h3><ol type="1"><li>自注意力的缺点：没有顺序信息，ai可以任意更改顺序，只需要将bi更改对应顺序即可</li><li>位置编码：在词向量ai的基础上添加位置信息ei<ol type="1"><li>既要求表示绝对位置，也要表示相对位置</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404150855053.png" alt="image-20230404150855053" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404150956742.png" alt="image-20230404150956742" style="zoom:80%;" /></p><h3 id="transform">6.4.5 Transform</h3><ol type="1"><li>Decoder只能一个词一个词吐出来，无法并行</li><li>实际上只有Encoder变快了</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404151358884.png" alt="image-20230404151358884" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230404151812547.png" alt="image-20230404151812547" style="zoom:80%;" /></p><h1 id="七预训练模型bert和它的参数">七、预训练模型：BERT和它的参数</h1><p>预训练：体现在<strong>模型参数的初始值</strong>上</p><ol type="1"><li>直接对目标任务进行训练，可能会因为数据不够而导致得不到好的效果</li><li>通过对预训练任务进行训练，调整模型的参数，然后再针对目标任务的数据进行训练即可<ol type="1"><li>预训练任务与目标任务有一定的联系，但通常是两种任务</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411144445974.png" alt="image-20230411144445974" style="zoom:80%;" /></p><h2 id="什么是预训练模型">7.1 什么是预训练模型</h2><ol type="1"><li>词向量<strong>Word2Vec</strong>：本质是将高维向量进行低维投影，解决了一义多词的问题<ol type="1"><li>训练时，需要一个字典×词向量维度的矩阵</li><li>使用时，相当于进行了一次查表操作</li></ol></li><li>上下文相关的词向量<strong>Contextualized WordEmbedding</strong>：将单词与上下文联系在一起，作为输入</li><li>预训练模型很多都是<strong>计算的词向量模型</strong>的变种</li></ol><h2 id="如何使用预训练模型fine-tune">7.2如何使用预训练模型：fine-tune</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411152012538.png" alt="image-20230411152012538" style="zoom:80%;" /></p><h3 id="nlp的常见任务">7.2.1 NLP的常见任务</h3><ol type="1"><li>输入：一个句子、多个句子</li><li>输出：分类、每个token的分类(如专有名词的类别)、从输入中取特定的部分(概括文章主旨)、句子(对话系统、风格转化、翻译)</li></ol><h4 id="输入多个句子">7.2.1.1 输入：多个句子</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411152404130.png" alt="image-20230411152404130" style="zoom:80%;" /></p><h4 id="输出分类">7.2.1.2 输出：分类</h4><ol type="1"><li>输入中添加一个特定的token<code>[CLS]</code></li><li><code>[CLS]</code>对应的输出，即为最后的分类信息</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411152511409.png" alt="image-20230411152511409" style="zoom:80%;" /></p><h4 id="输出每个词的分类">7.2.1.3 输出：每个词的分类</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411152859914.png" alt="image-20230411152859914" style="zoom: 80%;" /></p><h4 id="输出从输入中取特定的部分">7.2.1.4输出：从输入中取特定的部分</h4><ol type="1"><li>将question作为一个向量，与document中的单词计算注意力</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411152959409.png" alt="image-20230411152959409" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411153153376.png" alt="image-20230411153153376" style="zoom:80%;" /></p><h4 id="输出另一个序列">7.2.1.5 输出：另一个序列</h4><blockquote><p>方法一：</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411153314137.png" alt="image-20230411153314137" style="zoom:80%;" /></p><blockquote><p>方法二：前面一部分做编码器，后面一部分做解码器，中间添加一个特殊字符<code>[SEP]</code></p><p>需要有机制防止"偷看"</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411153431207.png" alt="image-20230411153431207" style="zoom:80%;" /></p><h3 id="微调预训练模型-fine-tune">7.2.2 微调预训练模型 fine-tune</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411153548436.png" alt="image-20230411153548436" style="zoom:80%;" /></p><h4 id="直接对模型进行微调">7.2.2.1 直接对模型进行微调</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411153832143.png" alt="image-20230411153832143" style="zoom:80%;" /></p><h4 id="在模型上面添加一个可变部分-adaptor">7.2.2.2在模型上面添加一个可变部分 Adaptor</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411153819676.png" alt="image-20230411153819676" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411153905240.png" alt="image-20230411153905240" style="zoom:80%;" /></p><h4 id="调整参数的权重">7.2.2.3 调整参数的权重</h4><ol type="1"><li>WeightedFeatures：学习一系列的权重，将每层的输出按权重组合起来，作为最后的输出<ol type="1"><li>如ELMo，它会训练出三个vector，一个是原本的vector，一个包含了之前的单词信息，一个包含了之后的单词信息。</li><li>实际输出时，学习权重，将三个vector拼起来</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411154203818.png" alt="image-20230411154203818" style="zoom:80%;" /></p><h2 id="如何得到预训练模型">7.3 如何得到预训练模型</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411154727634.png" alt="image-20230411154727634" style="zoom:80%;" /></p><h3 id="通过机器翻译进行pre-training">7.3.1通过机器翻译进行Pre-training</h3><blockquote><p><strong>Context Vector：CoVe</strong></p></blockquote><ol type="1"><li>不能通过句子分类进行预训练：因为句子分类只需要句子中出现某些特定的组合即可分类，并不能用到所有的词</li><li>而翻译需要句子中每个词的含义，进行一一对应</li><li>问题：需要有一个Decoder，并且需要有配对的数据</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411154930969.png" alt="image-20230411154930969" style="zoom:80%;" /></p><h3 id="自监督学习-self-supervised-learning">7.3.2 自监督学习Self-supervised Learning</h3><ol type="1"><li>监督 &lt;=&gt; 标签</li><li>词向量的训练需要监督，但是标签是机器自己标记的，并不需要人去标记</li><li><strong>自监督</strong>：从数据中拆出一部分，作为标签，监督另一部分的数据</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411155120375.png" alt="image-20230411155120375" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411155454429.png" alt="image-20230411155454429" style="zoom:80%;" /></p><h3 id="如何让一部分的数据作为监督信号masking-input">7.3.3如何让一部分的数据作为监督信号：Masking Input</h3><blockquote><p><strong>BERT</strong></p></blockquote><ol type="1"><li>将某个token掩盖掉，让模型还原这个词<ol type="1"><li>带还原的词就是监督信号</li></ol></li><li>有时不是直接mask掉某个token，而是将这个token换为另一个token</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411155828761.png" alt="image-20230411155828761" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411155709403.png" alt="image-20230411155709403" style="zoom:80%;" /></p><h3 id="xlnet">7.3.4 XLNet</h3><blockquote><p>随机将某些传递边删除</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411160020222.png" alt="image-20230411160020222" style="zoom:80%;" /></p><h3 id="预测下一个token">7.3.5 预测下一个token</h3><blockquote><p>用Transformer的编码器预测下一个token</p><ol type="1"><li>因此输入的时候会将输入w1与输出w2同时送进去</li><li>因此需要在模型的传递时，不让w2影响w1的输出，防止模型选择直接将w2输出</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411160042897.png" alt="image-20230411160042897" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411160111851.png" alt="image-20230411160111851" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411160156572.png" alt="image-20230411160156572" style="zoom:80%;" /></p><h3 id="用bert编码器做生成任务">7.3.6 用BERT编码器做生成任务</h3><blockquote><p>MASS / BART</p><ol type="1"><li>输入的x是带噪音的</li><li>要求输出正确的x</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411160350598.png" alt="image-20230411160350598" style="zoom:80%;" /></p><blockquote><p>MASS：</p><ol type="1"><li>将某个token遮盖住</li></ol><p>BART：5种方法破坏输入</p><ol type="1"><li>将某个token遮盖住</li><li>删除某个token</li><li>permutation：将输入和输出交换</li><li>rotation：将输出的某些部分放到输入里面</li><li>text infilling：删除某些token并用mask替代他们</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230411160520450.png" alt="image-20230411160520450" style="zoom:80%;" /></p><p>翻译时，由于结果是同时输出的，因此可能会出现"哈好"、"你喽"之类的错误输出</p><ol type="1"><li>将第一次输出的结果，放入模型中进行评估，将错误的词进行mask，然后再放入BERT中进行生成</li><li>重复这一过程，直到结果较好</li></ol><h3 id="unilm">7.3.7 UniLM</h3><blockquote><p>用一个模型将BERT、GPT、BART/MASS结合起来</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418134357052.png" alt="image-20230418134357052" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418134337390.png" alt="image-20230418134337390" style="zoom:80%;" /></p><h3 id="electra">7.3.8 ELECTRA</h3><blockquote><p><strong>Efficiently Learning an Encoder that Classifies TokenReplacements Accurately (ELECTRA)</strong></p><p>判断输入中的某个词是否被修改过</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418134519790.png" alt="image-20230418134519790" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418134711495.png" alt="image-20230418134711495" style="zoom:80%;" /></p><h3 id="sentence-level">7.3.9 Sentence Level</h3><blockquote><p>进行语句级别的预训练</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418134942168.png" alt="image-20230418134942168" style="zoom:80%;" /></p><h2 id="bert的变种">7.4 BERT的变种</h2><h3 id="albert">7.4.1 ALBERT</h3><p>减小BERT的参数</p><blockquote><p>将词向量先做降维，在用的时候再升维，存储只存储降维后的向量</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418135231884.png" alt="image-20230418135231884" style="zoom:80%;" /></p><blockquote><p>不同层之间共享参数</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418135303211.png" alt="image-20230418135303211" style="zoom:80%;" /></p><blockquote><p>语句级别的预训练任务：判断句子的顺序</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418135405316.png" alt="image-20230418135405316" style="zoom:80%;" /></p><h1id="八使用高效transformer建模长句子">八、使用高效Transformer建模长句子</h1><blockquote><p>文档级别的语言建模</p></blockquote><h2 id="transformer-xl">8.1 Transformer-XL</h2><p><strong>Transformer-XL</strong> : Truncated BPTT + Transformer</p><ol type="1"><li>将文章分解为一块一块的</li><li>每一层均可以向前看一步</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418141103223.png" alt="image-20230418141103223" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418141118933.png" alt="image-20230418141118933" style="zoom:80%;" /></p><h2 id="优化self-attention">8.2 优化Self-attention</h2><p>设句子的长度为N，则注意力计算需要进行N*N次，因为每个词均需要对所有剩下的次进行一次自注意力判断</p><blockquote><p>Transformer的快与慢：当显存足够时，计算是很快的；当显存不足时，需要使用很多方法模拟显存足够的情况。类似于C中的大整数乘法需要用一个数组模拟</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418141449470.png" alt="image-20230418141449470" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418143730478.png" alt="image-20230418143730478" style="zoom:80%;" /></p><h3 id="sparse-attention少算一部分">8.2.1 SparseAttention：少算一部分</h3><h4 id="heuristic启发式的设计计算方法以减少计算量">8.2.1.1Heuristic：启发式的，设计计算方法以减少计算量</h4><ol type="1"><li><p>Local Attention：设置window size，每个词只能看到与它相邻的词</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418141804543.png" alt="image-20230418141804543" style="zoom:80%;" /></p></li><li><p>Stride Attention：跳着做自注意力</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418142049314.png" alt="image-20230418142049314" style="zoom:80%;" /></p></li><li><p>Global Attention：每个词均与Global计算自注意力</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418142242502.png" alt="image-20230418142242502" style="zoom:80%;" /></p></li><li><p>其他方法：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418142426287.png" alt="image-20230418142426287" style="zoom:80%;" /></p></li><li><p>Sparse Transformers</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418142642949.png" alt="image-20230418142642949" style="zoom:80%;" /></p></li><li><p>Compressive Transformers</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418142654990.png" alt="image-20230418142654990" style="zoom:80%;" /></p></li><li><p>Adaptive Span Transformers</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418142705882.png" alt="image-20230418142705882" style="zoom:80%;" /></p></li></ol><h4 id="clustering聚类">8.2.1.2 Clustering：聚类</h4><blockquote><p>如：Reformer</p></blockquote><p>估计自注意力的计算结果，只考虑结果较大的部分，较小的部分直接设成0</p><ol type="1"><li>当query和key比较像的时候，attention比较大</li><li>因此可以先做聚类，分为几个类，然后在类内进行自注意力计算</li><li><strong>LSH</strong>：学习一个Hash函数，让长得像的东西离得比较近</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418143111866.png" alt="image-20230418143111866" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418143221160.png" alt="image-20230418143221160" style="zoom:80%;" /></p><h4 id="learnable">8.2.1.3 Learnable：</h4><blockquote><p>如：Sinkhorn</p></blockquote><ol type="1"><li>按照query，把key按照相关性排序，排序的结果就是自注意力的结果</li><li>需要学习一个排序函数，函数是一个神经网络</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418143925108.png" alt="image-20230418143925108" style="zoom:80%;" /></p><h4 id="representative-key">8.2.1.4 Representative key</h4><blockquote><p>如：Linformer</p></blockquote><ol type="1"><li>注意力矩阵是一个低秩的矩阵，有很多冗余信息</li><li>query只和有代表性的key进行注意力计算</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418144235584.png" alt="image-20230418144235584" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418144637207.png" alt="image-20230418144637207" style="zoom:80%;" /></p><h3 id="attention-approximation">8.2.2 Attention Approximation</h3><p>注意力的计算方法：本质上是矩阵乘法，而矩阵乘法满足结合律，可以先计算V×K<sup>T</sup></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418144935443.png" alt="image-20230418144935443" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418145135070.png" alt="image-20230418145135070" style="zoom:80%;" /></p><p>但是由于中间有一步softmax，实际上是不能直接这样计算的</p><ol type="1"><li>需要找到一个函数Φ，使得Φ(K×Q)=Φ(K)×Φ(Q)：等变函数</li><li>用神经网络拟合这个函数</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418145443421.png" alt="image-20230418145443421" style="zoom:80%;" /></p><blockquote><p>Low-rank Approximation</p><ol type="1"><li>选出代表性的K和Q，计算注意力，用计算出的结果重建剩下的KQ计算结果</li><li>如已知Q1 * K5，Q4 * K1，Q1 * K1，可以重建出Q4 * K5</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418145703875.png" alt="image-20230418145703875" style="zoom:80%;" /></p><h3 id="attention-free">8.2.3 Attention free</h3><h4 id="synthesizer">8.2.3.1 Synthesizer</h4><p>将attention score作为待学习的参数，固定下来，而不是每次重新计算</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418150305857.png" alt="image-20230418150305857" style="zoom:80%;" /></p><h4 id="其他attention-free方法">8.2.3.2 其他Attention-free方法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230418150540689.png" alt="image-20230418150540689" style="zoom:80%;" /></p><h2 id="如何评估文档模型">8.3 如何评估文档模型</h2><ol type="1"><li>Perplexity：<ol type="1"><li>计算模型生成整个句子的概率</li><li>加log之后，可以变为生成整个句子每个单词的期望，由于概率均为负数，需要加一个负号</li><li>缺点：如果预测错高频词，则惩罚很大，从而会忽略掉低频词的贡献</li></ol></li><li>sentence scrambling<ol type="1"><li>将整个文档打乱，让模型对句子进行排序</li></ol></li><li>Final sentence prediction<ol type="1"><li>给定一个故事，让模型预测故事的结尾</li></ol></li><li>Final word prediction<ol type="1"><li>给定一个文章，让模型预测文章的主题</li></ol></li></ol><h1id="九prompting-and-data-efficient-fine-tuning-for-pretrained-lms">九、Promptingand Data-Efficient Fine-tuning for Pretrained LMs</h1><p>NLP技术发展的四个阶段</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425143050215.png" alt="image-20230425143050215" style="zoom:80%;" /></p><p>Prompt Engineering 特点：</p><ol type="1"><li>NLP任务完全依赖于预训练语言模型LM</li><li>不对LM进行调整，而是输入不同的提示Prompt，让它执行不同的任务</li><li>需要设计比较好的Prompt</li></ol><p>Prompt Engineering 的过程：</p><ol type="1"><li>设计prompt template</li><li>选择语言模型</li><li>将输出映射到想要的结果中</li><li>多Prompt映射</li></ol><blockquote><p>示例：情感分类</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425143543627.png" alt="image-20230425143543627" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425143701236.png" alt="image-20230425143701236" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425143732274.png" alt="image-20230425143732274" style="zoom:80%;" /></p></blockquote><h2 id="选择预训练模型">9.1 选择预训练模型</h2><h3 id="预训练模型的类型">9.1.1 预训练模型的类型</h3><ol type="1"><li>生成式模型：GPT</li><li>遮罩式模型：BERT，RoBERTa</li><li>Prefix模型：UniLM，UniLM2</li><li>Encoder-Decoder：T5，MASS，BART</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425144129416.png" alt="image-20230425144129416" style="zoom:80%;" /></p></blockquote><h3 id="根据目标任务选择语言模型">9.1.2 根据目标任务选择语言模型</h3><ol type="1"><li>遮罩式模型：目标输出非常简单，通常只有一个token</li><li>Prefix LM / Encoder-Decoder：基于生成的信息抽取和问答</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425144258348.png" alt="image-20230425144258348" style="zoom:80%;" /></p></blockquote><h3 id="设计合适的prompt-template">9.1.3 设计合适的prompt template</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425144357586.png" alt="image-20230425144357586" style="zoom:80%;" /></p><p>根据提示的形式分类：</p><ol type="1"><li><p>Cloze提示：在文本中间挖空</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425144454062.png" alt="image-20230425144454062" style="zoom:80%;" /></p></li><li><p>Prefix提示：提示是答案的前缀</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425144508800.png" alt="image-20230425144508800" style="zoom:80%;" /></p></li></ol><p>根据设计者：</p><ol type="1"><li><p>Hand-Crafted：人工设计</p></li><li><p>Automated Search：自动设计</p><ol type="1"><li><p>在离散空间内搜索：词空间</p><ol type="1"><li><p>Prompt Mining：启发式方法生成prompt</p><ol type="1"><li>Middle-wordPrompts：已知两个词之间有关系，用这两个词对所有输入做过滤，他们之间出现的所有句子，可能会表示这两个词之间的联系，如[姚明]<code>出生在</code>[上海]</li><li>Dependency-based Prompts：在语法树上找这两个词之间的关系</li></ol></li><li><p>Prompt Paraphrasing</p></li><li><p>Gradient-basedSearch：基于梯度的搜索。给定输入x和预期输出y，随机填进prompt，如果没有得到y，则将梯度回传，根据梯度修改prompt</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425145250183.png" alt="image-20230425145250183" style="zoom:80%;" /></p></li></ol></li><li><p>在连续空间内搜索：向量空间</p></li></ol></li></ol><h3 id="将lm的输出映射到目标任务的输出上">9.1.4将LM的输出映射到目标任务的输出上</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425145822062.png" alt="image-20230425145822062" style="zoom:80%;" /></p><p>人工设计：</p><ol type="1"><li>Unconstrained Space：不对词典进行约束</li><li>Constrained Space：只保留某些词对答案有贡献</li></ol><p>自动搜索：(离散空间)</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425150118652.png" alt="image-20230425150118652" style="zoom:80%;" /></p><h3 id="多提示学习">9.1.5 多提示学习</h3><blockquote><p>Prompt Ensembling：设计多个类似的提示，将结果集成起来</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425150350065.png" alt="image-20230425150350065" style="zoom:80%;" /></p><blockquote><p>Prompt Augmentation：提示增强，先给几个成功的例子，然后再提问</p><ol type="1"><li>核心步骤：成功例子的选择、顺序</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425150445963.png" alt="image-20230425150445963" style="zoom:80%;" /></p><blockquote><p>Prompt Composition：将多个问题组合起来一起问</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425150842018.png" alt="image-20230425150842018" style="zoom:80%;" /></p><blockquote><p>Prompt Decomposition：问题过于复杂时，将问题分解为多个子问题</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425150912054.png" alt="image-20230425150912054" style="zoom:80%;" /></p><h2 id="data-efficient-fine-tuning">9.2 Data-Efficient Fine-tuning</h2><p>Fine-tuning的过程：对每一层的参数进行修改</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425151741193.png" alt="image-20230425151741193" style="zoom:80%;" /></p><h3 id="adapter">9.2.1 Adapter</h3><blockquote><p>在模型中添加进一个Adapter层，微调时只改Adapter</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425151839155.png" alt="image-20230425151839155" style="zoom:80%;" /></p><h3 id="lora">9.2.2 LoRA</h3><blockquote><p>在旁路中添加一个残差部分</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425151914487.png" alt="image-20230425151914487" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425152226724.png" alt="image-20230425152226724" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425152244750.png" alt="image-20230425152244750" style="zoom:80%;" /></p><h3 id="prefixprompt-tuning">9.2.3 Prefix/Prompt Tuning</h3><p>Prompt Tuning：只修改输入的提示</p><p>Prefix Tuning：相当于模型的每一层都有一个提示需要被调</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425152604377.png" alt="image-20230425152604377" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425152622432.png" alt="image-20230425152622432" style="zoom:80%;" /></p><h3 id="不同方法的比较">9.2.4 不同方法的比较</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425152857242.png" alt="image-20230425152857242" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425153042641.png" alt="image-20230425153042641" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425153109739.png" alt="image-20230425153109739" style="zoom:80%;" /></p><h2 id="early-exit">9.3 Early Exit</h2><p>在每一层添加一个分类器，可以在中间就停止计算：在精度不变的情况下减小计算量</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425153303456.png" alt="image-20230425153303456" style="zoom:80%;" /></p><h2 id="训练策略">9.4 训练策略</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425153732016.png" alt="image-20230425153732016" style="zoom:80%;" /></p><h2 id="半监督学习">9.5 半监督学习</h2><p>有大量的数据，但是只有一部分有标签，让语言模型对数据打上标签</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425154105314.png" alt="image-20230425154105314" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425154119612.png" alt="image-20230425154119612" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425154131414.png" alt="image-20230425154131414" style="zoom:80%;" /></p><h2 id="如何选择策略">9.6 如何选择策略</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425154234931.png" alt="image-20230425154234931" style="zoom:80%;" /></p><h1 id="十深度强化学习-reinforcement-learning">十、深度强化学习Reinforcement Learning</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515211940385.png" alt="image-20230515211940385" style="zoom:80%;" /></p><p>Reinforcement：</p><ol type="1"><li>针对Decision Process</li><li>计算很长一段时间后，才能获得reward，根据reward反思decisionprocess</li></ol><h2 id="强化学习简介">10.1 强化学习简介</h2><p>个体在环境基于的奖励或惩罚的刺激<strong>Reward</strong>下，逐步形成对刺激的预期，产生能获得最大利益的习惯性为<strong>Actions</strong></p><ol type="1"><li>经验<strong>Experience</strong>：一系列的observation、action、reward，<spanclass="math inline">\(o_1,r_1,a_1,...,a_{t-1},o_t,r_t\)</span></li><li>状态<strong>State</strong>：experience的总结，<spanclass="math inline">\(s_t=f(o_1,r_1,a_1,...,a_{t-1},o_t,r_t)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515213533354.png" alt="image-20230515213533354" style="zoom:80%;" /></p><h2 id="value-based-rl">10.2 Value-based RL</h2><h3 id="q-learning">10.2.1 Q-Learning</h3><ol type="1"><li>策略<span class="math inline">\(\pi\)</span>：即Agent</li><li><spanclass="math inline">\(r_{t+i}\)</span>：经过i个时间后，期望得到的回报</li><li><spanclass="math inline">\(\gamma\)</span>：理性，用于控制未来的期望回报对当前价值判断的影响，一般取值为<spanclass="math inline">\([0,1]\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515213822800.png" alt="image-20230515213822800" style="zoom:80%;" /></p><blockquote><p>Value迭代：可以通过蒙特卡洛搜索的方式实现迭代</p><ol type="1"><li>随机生成一个策略</li><li>然后根据策略模拟对局，根据实际得到的Reward更新策略</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515215032973.png" alt="image-20230515215032973" style="zoom:80%;" /></p><h3 id="深度强化学习">10.2.2 深度强化学习</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515220641479.png" alt="image-20230515220641479" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515220655097.png" alt="image-20230515220655097" style="zoom:80%;" /></p><ol type="1"><li>反向传播算法失败：借鉴RNN的思想，修改hidden</li><li>图像差异小：ExperienceReply，每次随机传入几帧，而不是传入游戏的连续画面</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515221855303.png" alt="image-20230515221855303" style="zoom:80%;" /></p><h2 id="policy-based-rl">10.3 Policy-Based RL</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515222054847.png" alt="image-20230515222054847" style="zoom:80%;" /></p><h3 id="机器人走迷宫带来的启发">10.3.1 机器人走迷宫带来的启发</h3><p>以机器人走迷宫为例，图示为模型训练结束后，在该点的策略，得到的启发如下</p><ol type="1"><li>Environment对最优策略有很大的影响</li><li>Reward structure对最优策略有很大的影响</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515222345643.png" alt="image-20230515222345643" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515222354601.png" alt="image-20230515222354601" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515222401888.png" alt="image-20230515222401888" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515222409133.png" alt="image-20230515222409133" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515222423781.png" alt="image-20230515222423781" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515222436877.png" alt="image-20230515222436877" style="zoom:80%;" /></p></blockquote><h3 id="神经网络-actor">10.3.2 神经网络 =&gt; Actor</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515222702782.png" alt="image-20230515222702782" style="zoom:80%;" /></p><blockquote><p>每次选择时，按照已知概率进行选择，如果得到了Reward，则提升该选择的概率</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515223131660.png" alt="image-20230515223131660" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515223145827.png" alt="image-20230515223145827" style="zoom:80%;" /></p><h2 id="valuepolicy">10.4 Value+Policy</h2><blockquote><p>Asynchronous Advantage Actor-Critic (A3C)</p></blockquote><h3 id="critic">10.4.1 Critic</h3><p>Critic也是一个神经网络，给定一个actor <spanclass="math inline">\(\pi\)</span>，它会评价这个actor的表现如何</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515223244340.png" alt="image-20230515223244340" style="zoom:80%;" /></p><h3 id="如何计算vpis">10.4.2 如何计算<spanclass="math inline">\(V^\pi(s)\)</span></h3><blockquote><p>使用蒙特卡洛搜索算法：Monte-Carlo，MC</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515223441496.png" alt="image-20230515223441496" style="zoom:80%;" /></p><blockquote><p>直接评估两个状态的差值：Temporal-Difference，TD</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515223518986.png" alt="image-20230515223518986" style="zoom: 80%;" /></p><blockquote><p>示例：MC vs TD</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515223728204.png" alt="image-20230515223728204" style="zoom:80%;" /></p><h2 id="model-based-rl">10.5 Model-based RL</h2><p>输入：当前state</p><p>输出：预测下一时刻的state</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516011525612.png" alt="image-20230516011525612" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516011810247.png" alt="image-20230516011810247" style="zoom:80%;" /></p><p>Model-Based的优点：</p><ol type="1"><li>更容易收集reward</li><li>更容易迁移到其他任务</li><li>只需要很少的supervised data</li></ol><p>Model-Based的缺点：</p><ol type="1"><li>不能优化task的表示</li><li>有时比学习一个policy更难</li></ol><h2 id="imitation-learning">10.6 Imitation Learning</h2><p>有时候很难定义哪一种操作是更优的，如开车前往目的地，一个直接到达了目的地，另一个歪歪扭扭的到达了目的地，在到达目的地这个任务上，两者表现无法产生差异。因此需要一个第三方的标注/模型，告诉当前模型哪一种选择更优</p><h3 id="behavior-cloning">10.6.1 Behavior Cloning</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516012532489.png" alt="image-20230516012532489" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516012521521.png" alt="image-20230516012521521" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516012543337.png" alt="image-20230516012543337" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516012551225.png" alt="image-20230516012551225" style="zoom:80%;" /></p><h3 id="inverse-reinforcement-learning">10.6.2 Inverse ReinforcementLearning</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516012751872.png" alt="image-20230516012751872" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516012803851.png" alt="image-20230516012803851" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516012820233.png" alt="image-20230516012820233" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230516012827042.png" alt="image-20230516012827042" style="zoom:80%;" /></p><h1 id="十二图神经网络">十二、图神经网络</h1><h2 id="基础图论">12.1 基础图论</h2><h3 id="图的稀疏表达">12.1.1 图的稀疏表达</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523144447157.png" alt="image-20230523144447157" style="zoom:80%;" /></p><h3 id="图上的操作">12.1.2 图上的操作</h3><ol type="1"><li>Walk：从一个节点开始，走到另一个节点</li><li>Path：不存在回头路的Walk</li><li>Trail：存在回头路的Walk</li><li>Cycle：Path的头尾相同</li><li>Cricuit：多个Cycle的集合</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523144642059.png" alt="image-20230523144642059" style="zoom:80%;" /></p><h3 id="节点的度">12.1.3 节点的度</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523144857577.png" alt="image-20230523144857577" style="zoom:80%;" /></p><h3 id="邻接矩阵">12.1.4 邻接矩阵</h3><ol type="1"><li>对于无向图来说，邻接矩阵是对称的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523144956347.png" alt="image-20230523144956347" style="zoom:80%;" /></p><h3 id="二分图-bipartite-graph">12.1.5 二分图 Bipartite Graph</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523145127459.png" alt="image-20230523145127459" style="zoom:80%;" /></p><h2 id="图神经网络-gnn">12.2 图神经网络 GNN</h2><blockquote><p>Graph Neural Networks</p></blockquote><h3 id="node-embeddings">12.2.1 Node Embeddings</h3><p>学习一个映射函数，将图映射为向量表达</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523145551723.png" alt="image-20230523145551723" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523145845194.png" alt="image-20230523145845194" style="zoom:80%;" /></p><h3 id="naive-approach">12.2.2 Naive Approach</h3><ol type="1"><li>将邻接矩阵和节点的特征组合到一起</li><li>如果节点不存在特征，则通过编码设置节点的特征</li></ol><p>缺点：</p><ol type="1"><li>输入较大</li><li>限制输入的维度</li><li>顺序也被视为了一种特征</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523145952603.png" alt="image-20230523145952603" style="zoom:80%;" /></p><h2 id="图卷积网络-gcn">12.3 图卷积网络 GCN</h2><blockquote><p>Graph Convolutional Networks</p></blockquote><h3 id="图卷积操作">12.3.1 图卷积操作</h3><p>将邻居的信息加权，添加到自己的特征中</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523150503696.png" alt="image-20230523150503696" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523150516874.png" alt="image-20230523150516874" style="zoom:80%;" /></p><h3 id="相关定义">12.3.2 相关定义</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523150606540.png" alt="image-20230523150606540" style="zoom:80%;" /></p><h3 id="idea聚合邻居的信息">12.3.3 Idea：聚合邻居的信息</h3><ol type="1"><li>将邻居的信息，加权聚合到当前节点中</li><li>多次卷积时，相当于扩大了感受野<ol type="1"><li>如第二次卷积时，添加了邻居的邻居的信息</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523150733220.png" alt="image-20230523150733220" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523151105236.png" alt="image-20230523151105236" style="zoom:80%;" /></p><ol type="1"><li>每一个节点都要生成一个计算图</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523151116763.png" alt="image-20230523151116763" style="zoom:80%;" /></p><ol type="1"><li>计算方法：每次将邻居的信息加权，然后加上自己的信息，过一个激活函数，得到<spanclass="math inline">\(h_v^k\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523151238084.png" alt="image-20230523151238084" style="zoom:80%;" /></p><h3 id="无监督训练">12.3.4 无监督训练</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523151432938.png" alt="image-20230523151432938" style="zoom:80%;" /></p><h3 id="有监督训练">12.3.5 有监督训练</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523151514049.png" alt="image-20230523151514049" style="zoom:80%;" /></p><h3 id="模型的设计">12.3.6 模型的设计</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523151604714.png" alt="image-20230523151604714" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523151614379.png" alt="image-20230523151614379" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523151626219.png" alt="image-20230523151626219" style="zoom:80%;" /></p><ol type="1"><li>由于只学习了投影操作，因此可以很容易的新增一个节点，使用相同方式计算该节点的特征</li><li>由于参数变化会导致所有节点的特征变化，因此训练和推理的成本都很大</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523152100466.png" alt="image-20230523152100466" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523152112932.png" alt="image-20230523152112932" style="zoom:80%;" /></p><h2 id="spectral-based-gnn">12.4 Spectral-based GNN</h2><h3 id="变换编码">12.4.1 变换编码</h3><ol type="1"><li>将一个波形，分解为若干个已知波形的组合</li><li>只需要记录该波形在每个波形分量上的强度即可</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523152336938.png" alt="image-20230523152336938" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523152643876.png" alt="image-20230523152643876" style="zoom:80%;" /></p><h3 id="卷积定理">12.4.2 卷积定理</h3><ol type="1"><li>时域上的卷积 &lt;=&gt; 频域上的乘积(逐位相乘)</li><li>因此计算卷积时，可以将原图像和卷积核先进行FFT变换转换为频率空间，然后再将结果进行乘积，得到两者进行卷积操作后的频率空间表示</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523152736538.png" alt="image-20230523152736538" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523153314026.png" alt="image-20230523153314026" style="zoom:80%;" /></p><h3 id="spectral-based-convolution">12.4.3 Spectral-BasedConvolution</h3><ol type="1"><li>对图、卷积核分别进行傅里叶变换，然后相乘，最后再进行一次逆傅里叶变换，得到图和卷积核的卷积结果</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523153625210.png" alt="image-20230523153625210" style="zoom:80%;" /></p><h3 id="spectral-graph-theory">12.4.4 Spectral Graph Theory</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523153603529.png" alt="image-20230523153603529" style="zoom:80%;" /></p><ol type="1"><li><span class="math inline">\(D\)</span>：degreematrix，表示每个点的邻居个数</li><li><span class="math inline">\(A\)</span>：邻接矩阵</li><li><span class="math inline">\(L=D-A\)</span>：拉普拉斯矩阵</li><li>对<span class="math inline">\(L\)</span>进行分解，<spanclass="math inline">\(L=UΛU^T\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523153839689.png" alt="image-20230523153839689" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230523153852457.png" alt="image-20230523153852457" style="zoom:80%;" /></p><h2 id="gcn的缺点">12.5 GCN的缺点</h2><h3 id="图的同构问题">12.5.1 图的同构问题</h3><p>图结构 =&gt; 特征向量 的投影不是一一对应的</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530134439036.png" alt="image-20230530134439036" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530134407243.png" alt="image-20230530134407243" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530134450017.png" alt="image-20230530134450017" style="zoom:80%;" /></p><h3 id="gin做邻居节点的aggregation">12.5.2GIN：做邻居节点的aggregation</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530134527531.png" alt="image-20230530134527531" style="zoom:80%;" /></p><h3 id="图的同构判断-图着色问题">12.5.3 图的同构判断 &lt;=&gt;图着色问题</h3><p>K-WL算法：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530135358522.png" alt="image-20230530135358522" style="zoom:80%;" /></p><p>CW网络</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530135417371.png" alt="image-20230530135417371" style="zoom:80%;" /></p><h1 id="十三知识图谱">十三、知识图谱</h1><p>衡量一个知识图谱的好坏：</p><ol type="1"><li>正确性 correctness</li><li>覆盖性 coverage</li><li>新鲜度 freshness &amp; usage</li></ol><h2 id="什么是知识图谱">13.1 什么是知识图谱</h2><p>从数据到知识</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530140822050.png" alt="image-20230530140822050" style="zoom:80%;" /></p><p>什么是知识图谱：</p><ol type="1"><li>用图来表示知识<ol type="1"><li>可以发现邻居之间的关系</li><li>图是稀疏的，如果用数据库存，则会需要存一个邻接矩阵，有大量的浪费</li></ol></li><li>图的节点 =&gt; entities，表示当前知识关心的对象</li><li>图的边 =&gt; 表述不同对象之间的联系<ol type="1"><li>attributes：连接实体、属性</li><li>relationships：连接两个实体</li><li>Ontology(本体)：表述图的定义域，如节点都有哪些取值、关系有哪些类型</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530141510477.png" alt="image-20230530141510477" style="zoom:80%;" /></p><p>知识图谱与数据库类似，是一个架构，具体存什么东西，由定义决定</p><h2 id="如何构建一个知识图谱">13.2 如何构建一个知识图谱</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530143757069.png" alt="image-20230530143757069" style="zoom:80%;" /></p><h3 id="人工构建">13.2.1 人工构建</h3><ol type="1"><li>更新成本高</li><li>越到后期越难更新，因为需要检查与之前知识之间的关系</li></ol><h4 id="wordnet">13.2.1.1 WordNet</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530143740359.png" alt="image-20230530143740359" style="zoom:80%;" /></p><h4 id="babelnet">13.2.1.2 BabelNet</h4><blockquote><p>多语言</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530143831235.png" alt="image-20230530143831235" style="zoom:80%;" /></p><h4 id="cyc">13.2.1.3 Cyc</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530144055717.png" alt="image-20230530144055717" style="zoom:80%;" /></p><h3 id="从半结构化数据中抽取信息">13.2.2 从半结构化数据中抽取信息</h3><h4 id="dbpedia">13.2.2.1 DBPedia</h4><blockquote><p>直接使用维基百科的info，使用小程序将info的同义标签映射为一种表达</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530144224228.png" alt="image-20230530144224228" style="zoom:80%;" /></p><h4 id="freebase">13.2.2.2 Freebase</h4><blockquote><p>从Wikipedia中抽取 + 人工标注</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530144750201.png" alt="image-20230530144750201" style="zoom:80%;" /></p><h4 id="wikidata">13.2.2.3 WikiData</h4><blockquote><p>SPARQL：用于查询语义网的Query Language</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530144806815.png" alt="image-20230530144806815" style="zoom:80%;" /></p><h3 id="从非结构化数据中通过nlp技术得到结构化的知识图谱">13.2.3从非结构化数据中，通过NLP技术，得到结构化的知识图谱</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530145446852.png" alt="image-20230530145446852" style="zoom:80%;" /></p><h4 id="mention-detection提及检测">13.2.3.1 MentionDetection：提及检测</h4><p>NER：命名实体识别，用于识别一些专有名词</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530145747183.png" alt="image-20230530145747183" style="zoom:80%;" /></p><p>几种实现途径：</p><ol type="1"><li>基于规则<ol type="1"><li>不需要训练数据</li><li>但是需要由一些特定的知识</li></ol></li><li>非监督&amp;迭代方法<ol type="1"><li>先收集一些种子规则，然后标注一些数据，训练一个模型，提炼新的规则</li><li>然后再标注数据，训练模型，提炼规则......</li></ol></li><li>特征工程</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530150421541.png" alt="image-20230530150421541" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530151005436.png" alt="image-20230530151005436" style="zoom:80%;" /></p><p><strong>Deep Learning For NER</strong></p><ol type="1"><li>分类数：IBOE×PER/LOC：8类</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530152036919.png" alt="image-20230530152036919" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530152043801.png" alt="image-20230530152043801" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530152214365.png" alt="image-20230530152214365" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530152225092.png" alt="image-20230530152225092" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530152233536.png" alt="image-20230530152233536" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530152448093.png" alt="image-20230530152448093" style="zoom:80%;" /></p><h4 id="multi-task-learning-多任务学习">13.2.3.2 Multi-task Learning多任务学习</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530152513818.png" alt="image-20230530152513818" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530153223070.png" alt="image-20230530153223070" style="zoom:80%;" /></p><h4 id="knowledge-distillation-知识蒸馏">13.2.3.3 Knowledge Distillation知识蒸馏</h4><p>将大模型的知识，教给小模型</p><ol type="1"><li>可以收集很多未标注数据，交给大模型生成标签，然后交给小模型训练</li><li>小模型可以模仿大模型的输出，也可以模仿大模型的中间状态</li><li>小模型学习的是大模型的logists，即经过softmax之后的结果</li><li>在蒸馏的时候，要调整温度<spanclass="math inline">\(\tau\)</span>，温度越大，logist越平缓</li></ol><p>多实例学习MIL：抑制噪音</p><ol type="1"><li>假设一种化学式有ABC三种同分异构体，A是有效成分，但是生产的药品都是混合物。数据只能表示某个混合物是否有效，但我们的目标是找出有效成分。</li><li>假设当前的数据为：AB有效，AC有效，BC无效，在训练时，从包里随机挑选一种成分作为输入，给出对应的标签，让神经网络学习。</li><li>由于是随机采样，每个成分被选中的概率相同，但是药物是因为含有A而有效，从而模型会微微偏向A有效，然后在下一次采样中，模型会更加倾向于选A。</li><li>通过多轮迭代，强化这种倾向，最终模型会学习出来A是有效成分</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530153345099.png" alt="image-20230530153345099" style="zoom:80%;" /></p><h4 id="mention-disambiguation提及消歧">13.2.3.3 MentionDisambiguation：提及消歧</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530155007930.png" alt="image-20230530155007930" style="zoom:80%;" /></p><p><strong>Entity Linking</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530155115809.png" alt="image-20230530155115809" style="zoom:80%;" /></p><p>输入：文档</p><p>输出：mention及其对应的title</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230530155138393.png" alt="image-20230530155138393" style="zoom:80%;" /></p><ol type="1"><li>找到文档中的mention<ol type="1"><li>每个n元组都是可能的mention</li><li>基础过滤：删除chunk(固定词组)、stop word</li><li>基于统计的过滤</li><li>对mention进行扩展：词根化、将缩写变成全拼/全拼变成缩写</li></ol></li><li>尽可能全的找到与mention有关的title<ol type="1"><li>基于Name Dictionary：通过维基百科/数据挖掘<ol type="1"><li>Redirect pages：将不同的词重定向到同一个页面</li><li>Disambiguation pages：一词多义</li><li>Bold phrases from the first paragraphs,hyperlinks：第一段的粗体、超链接</li></ol></li><li>基于搜索引擎</li></ol></li><li>局部Inference</li><li>全局Inference</li><li>空聚类</li></ol><h4 id="实体链接任务">13.2.3.4 实体链接任务</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230606143431589.png" alt="image-20230606143431589" style="zoom:80%;" /></p><h4 id="entity-typing实体类别">13.2.3.5 Entity Typing：实体类别</h4>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2023/03/01/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/2023/03/01/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="一introduction">一、Introduction</h1><ol type="1"><li><p>编译器是一个程序，用于将一种语言翻译成另一种语言</p><ol type="1"><li>高级语言 =&gt; 高级语言/低级语言</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227102405818.png" alt="image-20230227102405818" style="zoom:80%;" /></p></li><li><p>编译器的特点：错误恢复，遇到error不是直接终止程序，而是会返回错误信息</p></li><li><p><strong>Phases</strong>：一个或多个模块，在编译过程中使用不同的抽象“语言”</p></li><li><p><strong>Interface</strong>：描述编译器模块之间交换的信息</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227104030169.png"alt="image-20230227104030169" /><figcaption aria-hidden="true">image-20230227104030169</figcaption></figure><h2 id="模块和接口">1.1 模块和接口</h2><table><colgroup><col style="width: 31%" /><col style="width: 68%" /></colgroup><thead><tr><th style="text-align: center;">阶段</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr><td style="text-align: center;">Lex：词法分析</td><td style="text-align: center;">将源代码分割为Tokens：正则语言</td></tr><tr><td style="text-align: center;">Parse：语法分析</td><td style="text-align: center;">分析程序的语法结构：上下文无关语言</td></tr><tr><td style="text-align: center;">Parsing Actions</td><td style="text-align: center;">根据每一个pharse，建立抽象语法树</td></tr><tr><td style="text-align: center;">Semantic Analysis：语义分析</td><tdstyle="text-align: center;">确定每个短语的含义<br>将变量的使用与其定义联系起来<br>检查表达式类型<br>请求翻译每个短语</td></tr><tr><td style="text-align: center;">Frame Layout</td><tdstyle="text-align: center;">将变量、函数参数等放入活动记录(栈帧)中</td></tr><tr><td style="text-align: center;">Translate</td><td style="text-align: center;">生成中间表示树(IRtrees)<br>不与任何具体语言相关联</td></tr><tr><td style="text-align: center;">Canonicalize</td><tdstyle="text-align: center;">提升表达式的副作用<br/>清理条件分支<br/>为了方便下一阶段</td></tr><tr><td style="text-align: center;">Instruction Selection</td><tdstyle="text-align: center;">将IR树节点分组为与目标机器指令的操作相对应的块</td></tr><tr><td style="text-align: center;">Control Flow Analysis</td><tdstyle="text-align: center;">将指令序列分析成控制流图，该图显示程序执行时可能遵循的所有可能的控制流</td></tr><tr><td style="text-align: center;">Dataflow Analysis</td><tdstyle="text-align: center;">通过程序变量收集有关信息流的信息<br/>例如，活跃度分析计算每个程序变量保持仍然需要的值（活跃）的位置</td></tr><tr><td style="text-align: center;">Register Allocation</td><tdstyle="text-align: center;">选择一个寄存器来保存程序使用的每个变量和临时值<br>不同时存在的变量可以共享同一个寄存器</td></tr><tr><td style="text-align: center;">Code Emission</td><tdstyle="text-align: center;">用机器寄存器替换每个机器指令中的临时名称</td></tr></tbody></table><ol type="1"><li>有些模块会被合并为一个模块：<ol type="1"><li>Parse，Semantic Analysis，Translate，Canonicalize</li><li>Instruction Selection，Code Emission</li></ol></li><li>简单的编译器可以省略：<ol type="1"><li>Control Flow Analysis，Data Flow Analysis，Register Allocationphases</li></ol></li><li>数据结构：抽象语法树、IR tree、汇编序列</li><li>函数：抽象接口<ol type="1"><li>Lex：每次产生一个Token</li><li>Parse：会调用Lex，获得一个Token，然后进行加工</li></ol></li></ol><h2 id="工具和软件">1.2 工具和软件</h2><ol type="1"><li>两种抽象：<ol type="1"><li>上下文无关语法：parsing</li><li>正则表达式：lexical analysis</li></ol></li><li>两个工具<ol type="1"><li>Yacc：将上下文无关语法，转化为paing程序</li><li>Lex：将正则表达式，转化为正则语言分析程序</li><li>Yacc和Lex均会生成C语言程序</li></ol></li></ol><h2 id="树形语言的数据结构">1.3 树形语言的数据结构</h2><ol type="1"><li><p>树形表示</p><ol type="1"><li>主要表现形式</li><li>具有不同属性的多个节点类型</li><li>用类似编程语言的语法描述</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227110233280.png" alt="image-20230227110233280" style="zoom:80%;" /></p></li><li><p>Concrete Tree：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227110445626.png" alt="image-20230227110445626" style="zoom:80%;" /></p></li><li><p>每个文法符号可以绑定一种类型，类型不固定</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227110554223.png" alt="image-20230227110554223" style="zoom:67%;" /></p></li><li><p>每一个语法规则：</p><ol type="1"><li>一个构造函数：<ol type="1"><li>属于左侧符号的联合</li></ol></li><li>构造函数名称<ol type="1"><li>显示在右侧–括号内</li></ol></li><li>右侧部件<ol type="1"><li>在数据结构中表示</li><li>CompoundStm：在右侧有两个Stm<ol type="1"><li>Stm→ Stm; Stm</li></ol></li><li>AssignStm：具有标识符和表达式<ol type="1"><li>id:=Exp</li></ol></li></ol></li><li>每个语法符号的结构：<ol type="1"><li>承载这些价值观的union，以及</li><li>一个种类字段，用于指示union的哪种表示是有效的</li></ol></li></ol></li></ol><h1 id="一introduction-1">一、Introduction</h1><ol type="1"><li><p>编译器是一个程序，用于将一种语言翻译成另一种语言</p><ol type="1"><li>高级语言 =&gt; 高级语言/低级语言</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227102405818.png" alt="image-20230227102405818" style="zoom:80%;" /></p></li><li><p>编译器的特点：错误恢复，遇到error不是直接终止程序，而是会返回错误信息</p></li><li><p><strong>Phases</strong>：一个或多个模块，在编译过程中使用不同的抽象“语言”</p></li><li><p><strong>Interface</strong>：描述编译器模块之间交换的信息</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227104030169.png"alt="image-20230227104030169" /><figcaption aria-hidden="true">image-20230227104030169</figcaption></figure><h2 id="模块和接口-1">1.1 模块和接口</h2><table><colgroup><col style="width: 31%" /><col style="width: 68%" /></colgroup><thead><tr><th style="text-align: center;">阶段</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr><td style="text-align: center;">Lex：词法分析</td><td style="text-align: center;">将源代码分割为Tokens：正则语言</td></tr><tr><td style="text-align: center;">Parse：语法分析</td><td style="text-align: center;">分析程序的语法结构：上下文无关语言</td></tr><tr><td style="text-align: center;">Parsing Actions</td><td style="text-align: center;">根据每一个pharse，建立抽象语法树</td></tr><tr><td style="text-align: center;">Semantic Analysis：语义分析</td><tdstyle="text-align: center;">确定每个短语的含义<br>将变量的使用与其定义联系起来<br>检查表达式类型<br>请求翻译每个短语</td></tr><tr><td style="text-align: center;">Frame Layout</td><tdstyle="text-align: center;">将变量、函数参数等放入活动记录(栈帧)中</td></tr><tr><td style="text-align: center;">Translate</td><td style="text-align: center;">生成中间表示树(IRtrees)<br>不与任何具体语言相关联</td></tr><tr><td style="text-align: center;">Canonicalize</td><tdstyle="text-align: center;">提升表达式的副作用<br/>清理条件分支<br/>为了方便下一阶段</td></tr><tr><td style="text-align: center;">Instruction Selection</td><tdstyle="text-align: center;">将IR树节点分组为与目标机器指令的操作相对应的块</td></tr><tr><td style="text-align: center;">Control Flow Analysis</td><tdstyle="text-align: center;">将指令序列分析成控制流图，该图显示程序执行时可能遵循的所有可能的控制流</td></tr><tr><td style="text-align: center;">Dataflow Analysis</td><tdstyle="text-align: center;">通过程序变量收集有关信息流的信息<br/>例如，活跃度分析计算每个程序变量保持仍然需要的值（活跃）的位置</td></tr><tr><td style="text-align: center;">Register Allocation</td><tdstyle="text-align: center;">选择一个寄存器来保存程序使用的每个变量和临时值<br>不同时存在的变量可以共享同一个寄存器</td></tr><tr><td style="text-align: center;">Code Emission</td><tdstyle="text-align: center;">用机器寄存器替换每个机器指令中的临时名称</td></tr></tbody></table><ol type="1"><li>有些模块会被合并为一个模块：<ol type="1"><li>Parse，Semantic Analysis，Translate，Canonicalize</li><li>Instruction Selection，Code Emission</li></ol></li><li>简单的编译器可以省略：<ol type="1"><li>Control Flow Analysis，Data Flow Analysis，Register Allocationphases</li></ol></li><li>数据结构：抽象语法树、IR tree、汇编序列</li><li>函数：抽象接口<ol type="1"><li>Lex：每次产生一个Token</li><li>Parse：会调用Lex，获得一个Token，然后进行加工</li></ol></li></ol><h2 id="工具和软件-1">1.2 工具和软件</h2><ol type="1"><li>两种抽象：<ol type="1"><li>上下文无关语法：parsing</li><li>正则表达式：lexical analysis</li></ol></li><li>两个工具<ol type="1"><li>Yacc：将上下文无关语法，转化为paing程序</li><li>Lex：将正则表达式，转化为正则语言分析程序</li><li>Yacc和Lex均会生成C语言程序</li></ol></li></ol><h2 id="树形语言的数据结构-1">1.3 树形语言的数据结构</h2><ol type="1"><li><p>树形表示</p><ol type="1"><li>主要表现形式</li><li>具有不同属性的多个节点类型</li><li>用类似编程语言的语法描述</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227110233280.png" alt="image-20230227110233280" style="zoom:80%;" /></p></li><li><p>Concrete Tree：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227110445626.png" alt="image-20230227110445626" style="zoom:80%;" /></p></li><li><p>每个文法符号可以绑定一种类型，类型不固定</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230227110554223.png" alt="image-20230227110554223" style="zoom:67%;" /></p></li><li><p>每一个语法规则：</p><ol type="1"><li>一个构造函数：<ol type="1"><li>属于左侧符号的联合</li></ol></li><li>构造函数名称<ol type="1"><li>显示在右侧–括号内</li></ol></li><li>右侧部件<ol type="1"><li>在数据结构中表示</li><li>CompoundStm：在右侧有两个Stm<ol type="1"><li>Stm→ Stm; Stm</li></ol></li><li>AssignStm：具有标识符和表达式<ol type="1"><li>id:=Exp</li></ol></li></ol></li><li>每个语法符号的结构：<ol type="1"><li>承载这些价值观的union，以及</li><li>一个种类字段，用于指示union的哪种表示是有效的</li></ol></li></ol></li></ol><h1 id="三语法分析-算法">三、语法分析 算法</h1><h2 id="ll1">3.1 LL(1)</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">S =&gt; uBDz</span><br><span class="line">B =&gt; Bv</span><br><span class="line">B =&gt; w</span><br><span class="line">D =&gt; EF</span><br><span class="line">E =&gt; y</span><br><span class="line">E =&gt; </span><br><span class="line">F =&gt; x</span><br><span class="line">F =&gt; </span><br></pre></td></tr></table></figure><h3 id="nullablefirstfollow表的构建">3.1.1nullable、First、Follow表的构建</h3><table><colgroup><col style="width: 7%" /><col style="width: 24%" /><col style="width: 24%" /><col style="width: 44%" /></colgroup><thead><tr><th style="text-align: center;">非终止字符</th><th style="text-align: center;">nullable</th><th style="text-align: center;">First</th><th style="text-align: center;">Follow</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>S</strong></td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "red"> u</font></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><strong>B</strong></td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "red"> w</font></td><td style="text-align: center;"><font color = "red"> v,z</font>，<font color = "blue"> y, x</font></td></tr><tr><td style="text-align: center;"><strong>D</strong></td><td style="text-align: center;"><font color = "blue"> true</font></td><td style="text-align: center;"><font color = "blue"> y, x</font></td><td style="text-align: center;"><font color = "red"> z</font></td></tr><tr><td style="text-align: center;"><strong>E</strong></td><td style="text-align: center;"><font color = "red"> true</font></td><td style="text-align: center;"><font color = "red"> y</font></td><td style="text-align: center;"><font color = "blue"> x, z</font></td></tr><tr><td style="text-align: center;"><strong>F</strong></td><td style="text-align: center;"><font color = "red"> true</font></td><td style="text-align: center;"><font color = "red"> x</font></td><td style="text-align: center;"><font color = "blue"> z</font></td></tr></tbody></table><blockquote><p>Follow()中，一定没有ε</p><p>First()中，可能有ε，对应nullable =true。有nullable时可以不写First()中的ε</p></blockquote><p><strong>nullable</strong>的计算方法：即该 non-terminal可以推导出空串</p><ol type="1"><li><font color = "red"> 表中红色</font>：先看能够直接推出<code>ε</code>的规则，将规则左边的<strong>nullable</strong>项置为<strong>true</strong><ol type="1"><li><code>E =&gt; ε</code>，将<code>E</code>的<strong>nullable</strong>项置为<strong>ture</strong></li><li><code>F =&gt; ε</code>，将<code>F</code>的<strong>nullable</strong>项置为<strong>ture</strong></li></ol></li><li><font color = "blue">表中蓝色</font>：然后判断剩余规则的右面，如果右面全为<strong>nullable</strong>，则左边的<strong>nullable</strong>项置为<strong>true</strong><ol type="1"><li><code>D =&gt; EF</code>，将<code>D</code>的<strong>nullable</strong>项置为<strong>ture</strong></li></ol></li></ol><p><strong>First</strong>的计算方法：即由该 non-terminal能够推出的所有字符串中，可能的起始字符为谁</p><ol type="1"><li><font color = "red"> 表中红色</font>：先看规则的右边以 terminal为起始的规则，则将该 terninal 添加进规则左边 non-terminal的<strong>First()</strong><ol type="1"><li><code>S =&gt; uBDz</code>，将<strong>u</strong>添加进<strong>First(S)</strong></li><li><code>B =&gt; w</code>，将<strong>w</strong>添加进<strong>First(B)</strong></li><li><code>E =&gt; y</code>，将<strong>y</strong>添加进<strong>First(E)</strong></li><li><code>F =&gt; x</code>，将<strong>x</strong>添加进<strong>First(F)</strong></li></ol></li><li><font color = "blue">表中蓝色</font>：然后看剩下的规则<code>A =&gt; BC</code>，则<code>First(A) += First(B)</code>；如果<code>B</code>可为空，则<code>First(A) += First(C)</code><ol type="1"><li><code>D =&gt; EF, E可为空</code>，则<strong>First(D) += First(E) ∪First(F)</strong></li></ol></li></ol><p><strong>Follow</strong>的计算方法：即在所有可能的字符串中，可以在该non-terminal 之后的第一个 terminal</p><ol type="1"><li><font color = "red"> 表中红色</font>：先看规则的右边，如果某个non-terminal 后面直接跟了一个 terminal，则将该 terminal 添加进该non-terminal 的<strong>Follow()</strong><ol type="1"><li><code>S =&gt; uBDz, D可为空</code>，将<strong>z</strong>添加进<strong>Follow(D)</strong>，将<strong>z</strong>添加进<strong>Follow(B)</strong></li><li><code>B =&gt; Bv</code>，将<strong>v</strong>添加进<strong>Follow(B)</strong></li></ol></li><li><font color = "blue">表中蓝色</font>：然后看剩下的规则<code>A =&gt; BC</code>，则<code>Follow(B) += First(C), Follow(C) += Follow(A)</code>；如果<code>C</code>可为空，则<code>Follow(B) += Follow(A)</code><ol type="1"><li><code>S =&gt; uBDz</code>，则<strong>Follow(B) +=First(D)</strong></li><li><code>D =&gt; EF, F可为空</code>，则<strong>Follow(F) +=Follow(D)</strong>，<strong>Follow(E) += Follow(D)</strong></li></ol></li></ol><h3 id="构建ll1-parsing-table">3.1.2 构建LL(1) Parsing Table</h3><blockquote><p>表的作用：给定当前状态、下一个读到的终止字符，可以判定使用哪一条规则继续递归</p></blockquote><table style="width:100%;"><colgroup><col style="width: 1%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 17%" /><col style="width: 16%" /><col style="width: 15%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">u</th><th style="text-align: center;">z</th><th style="text-align: center;">v</th><th style="text-align: center;">w</th><th style="text-align: center;">x</th><th style="text-align: center;">y</th></tr></thead><tbody><tr><td style="text-align: center;">S</td><td style="text-align: center;"><font color = "red">S=&gt;uBDz</font></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">B</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "red">B=&gt;Bv,B=&gt;w</font></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">D</td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "blue">D=&gt;EF</font></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "red">D=&gt;EF</font></td><td style="text-align: center;"><font color = "red">D=&gt;EF</font></td></tr><tr><td style="text-align: center;">E</td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "blue"> E=&gt;ε</font></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "blue">E=&gt; ε</font></td><td style="text-align: center;"><font color = "red"> E=&gt;y</font></td></tr><tr><td style="text-align: center;">F</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "blue"> F=&gt;ε</font></td><td style="text-align: center;"></td><td style="text-align: center;"><font color = "red"> F=&gt;x</font></td><td style="text-align: center;"></td></tr></tbody></table><p>对于所有的推导规则<code>A =&gt; α</code>：</p><ol type="1"><li><font color = "red">表中红色</font>：找出<code>First(α)</code>中包含的所有终止字符<code>t</code>，则<code>T[A,t] = (A=&gt;α)</code><ol type="1"><li><code>S =&gt; uBDz</code>：<code>First(uBDz) = u</code>，则<code>T[S,u] = (S=&gt;uBDz)</code></li><li><code>B =&gt; Bv</code>：<code>First(Bv) = w</code>，则<code>T[B,w] = (B=&gt;Bv)</code></li><li><code>B =&gt; w</code>：<code>First(w) = w</code>，则<code>T[B,w] = (B=&gt;w)</code></li><li><code>D =&gt; EF</code>：<code>First(EF) = x,y</code>，则<code>T[D,x] = T[D,y] = (D=&gt;EF)</code></li><li><code>E =&gt; y</code>：<code>First(y) = y</code>，则<code>T[E,y] = (E=&gt;y)</code></li><li><code>F =&gt; x</code>：<code>First(x) = x</code>，则<code>T[F,x] = (F=&gt;x)</code></li></ol></li><li><font color = "blue">表中蓝色</font>：如果<code>α可为空</code>，则找出<code>Follow(A)</code>中包含的所有终止字符<code>t</code>，则<code>T[A,t] = (A=&gt;α)</code><ol type="1"><li><code>D =&gt; EF</code>：<code>EF</code>可为空，<code>Follow(D) = z</code>，则<code>T[D,z] = (D=&gt;EF)</code></li><li><code>E =&gt;</code>：<code>Follow(E) = x,z</code>，则<code>T[E,x] = T[E,z] = (E=&gt;)</code></li><li><code>F =&gt;</code>：<code>Follow(F) = z</code>，则<code>T[F,z] = (F=&gt;)</code></li></ol></li></ol><h3 id="判断是否为ll1文法">3.1.3 判断是否为LL(1)文法</h3><p>核心思路：LL(1) Parsing Table中，某一个项对应多个值</p><ol type="1"><li><font color = "red">表中红色</font>：对于所有规则<code>A=&gt;α, A=&gt;β</code>，如果<spanclass="math inline">\(First(\alpha)\cap First(\beta) \neq\{\}\)</span>，则不是LL(1)<ol type="1"><li>不能存在左公因子</li></ol></li><li><font color = "blue">表中蓝色</font>：对于所有的<strong>可为空</strong>的非终止字符<code>A</code>，如果<spanclass="math inline">\(First(A)\cap Follow(A) \ne\{\}\)</span>，则不是LL(1)</li></ol><h3 id="将文法修改为ll1文法左递归消除">3.1.4将文法修改为LL(1)文法：左递归消除</h3><p>原来的文法：</p><ol type="1"><li><span class="math inline">\(S \rightarrow S\alpha_1|...|S\alpha_n\)</span></li><li><span class="math inline">\(S \rightarrow\beta_1|...|\beta_m\)</span></li></ol><p>更改为：</p><ol type="1"><li><span class="math inline">\(S \rightarrow \beta_1S&#39; |...|\beta_mS&#39;\)</span></li><li><span class="math inline">\(S&#39; \rightarrow \alpha_1S&#39; | ...| \alpha_nS&#39;|\epsilon\)</span></li></ol><h2 id="lr0-slr1">3.2 LR(0) &amp; SLR(1)</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">S =&gt; X<span class="built_in">$</span></span><br><span class="line">X =&gt; Ma</span><br><span class="line">X =&gt; bMc</span><br><span class="line">X =&gt; dc</span><br><span class="line">X =&gt; bda</span><br><span class="line">M =&gt; d</span><br></pre></td></tr></table></figure><h3 id="构造lr0状态机">3.2.1 构造LR(0)状态机</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230326220719577.png" alt="image-20230326220719577" style="zoom:80%;" /></p><blockquote><p>保证与起始字符相关的转移规则只有一条，如果不唯一，则新增一个起始字符</p></blockquote><ol type="1"><li>首先，构造起始字符的LR(0)Item，设为状态1<ol type="1"><li>先将<strong>起始字符</strong>的唯一一条转移规则，写到状态1里面<ol type="1"><li><code>S =&gt; .X$</code></li></ol></li><li>对于状态1中所有的<code>.</code>后面为非终止字符的情况，将终止字符展开，写入状态1里面<ol type="1"><li>展开X：<code>X =&gt; .Ma</code>、<code>X =&gt; .bMc</code>、<code>X =&gt; .dc</code>、<code>X =&gt; .bda</code></li><li>展开M：<code>M =&gt; .d</code></li></ol></li><li>如果有一条语句为<code>A =&gt; ε</code>，则在Item中的表示为：<code>A =&gt; .</code></li></ol></li><li>对于所有的状态，从上到下根据<code>.</code>后面的字符，接收该字符，转移到新的状态(没有则无法转移)<ol type="1"><li>如状态1可以接收<code>b</code>，转移到状态<code>2</code>，对应<code>.</code>向后移一位，即<code>X =&gt; b.Mc, X =&gt; b.da</code></li><li>对于新增的状态，类似状态1，进行展开<ol type="1"><li>如状态2原本是<code>X =&gt; b.Mc , X =&gt; b.da</code>，但是M为非终止符，需要展开为：<code>M =&gt; .d</code></li></ol></li></ol></li><li>直到没有新的状态产生</li></ol><h3 id="构造lr0-parsing-table">3.2.2 构造LR(0) Parsing Table</h3><p>表的内容</p><ol type="1"><li><strong>sk</strong>：将对应的<strong>终止</strong>字符压栈，然后转移到<strong>状态k</strong></li><li><strong>gk</strong>：将对应的<strong>非终止</strong>字符压栈，然后转移到<strong>状态k</strong></li><li><strong>rk</strong>：使用<strong>第k条规则</strong>规约</li><li><strong>accept</strong>：接受该字符串</li></ol><p>表的创建方式：</p><ol type="1"><li>对于DFA中的每一个<strong>S<sub>i</sub> 接受终止符t转移到S<sub>j</sub></strong>，令<strong>T[i, t] = sj</strong>（Input&amp; Shift表）</li><li>对于DFA中的每一个<strong>S<sub>i</sub> 接受非终止符X转移到S<sub>j</sub></strong>，令<strong>T[i, X] =gj</strong>（Goto表）</li><li>对于每一个<strong>可以规约的LR(0)Item</strong>，对于其所在所有状态<strong>i</strong>，每一个终止字符<strong>t</strong>，令<strong>T[i,t] = rk</strong>，k为对应规则的编号</li></ol><h3 id="构造slr-parsing-table">3.2.3 构造SLR Parsing Table</h3><p>首先，求出所有非终止字符的<strong>Follow()</strong></p><ol type="1"><li><code>Follow(S) = &#123;$&#125;</code></li><li><code>Follow(E) = &#123;=, $&#125;</code></li><li><code>Follow(V) = &#123;=, $&#125;</code></li></ol><p>构建SLR(1) Parsing Table：</p><ol type="1"><li>对于DFA中的每一个<strong>S<sub>i</sub> 接受终止符t转移到S<sub>j</sub></strong>，令<strong>T[i, t] = sj</strong>（Input&amp; Shift表）</li><li>对于DFA中的每一个<strong>S<sub>i</sub> 接受非终止符X转移到S<sub>j</sub></strong>，令<strong>T[i, X] =gj</strong>（Goto表）</li><li>对于每一个<strong>可以规约的LR(0) Item(假设为<code>A =&gt; α</code>)</strong>，对于其所在所有状态<strong>i</strong>，每一个终止字符<strong>t</strong>，如果<strong>t∈ Follow(A)</strong>，则令<strong>T[i, t] =rk</strong>，k为对应规则的编号</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230326223403239.png" alt="image-20230326223403239" style="zoom:80%;" /></p><h2 id="lr1-lalr1">3.3 LR(1) &amp; LALR(1)</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">S =&gt; X<span class="built_in">$</span></span><br><span class="line">X =&gt; Ma</span><br><span class="line">X =&gt; bMc</span><br><span class="line">X =&gt; dc</span><br><span class="line">X =&gt; bda</span><br><span class="line">M =&gt; d</span><br></pre></td></tr></table></figure><h3 id="构造lr1状态机">3.3.1 构造LR(1)状态机</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230326220621532.png" alt="image-20230326220621532" style="zoom:80%;" /></p><blockquote><p>保证与起始字符相关的转移规则只有一条，如果不唯一，则新增一个起始字符</p></blockquote><ol type="1"><li>首先，构造起始字符的LR(1)Item，设为状态1<ol type="1"><li>先将<strong>起始字符</strong>的唯一一条转移规则，写到状态1里面，并将<strong>向前看字符</strong>设置为<strong><code>$</code></strong><ol type="1"><li><code>S =&gt; .X$ ?</code></li></ol></li><li>对于状态1中所有的<code>.</code>后面为非终止字符的情况，将非终止字符展开，写入状态1里面，<strong>向前看字符</strong>为展开非终止字符时，后面的串的<strong>First()</strong><ol type="1"><li>根据<code>S =&gt; .X$ ?</code>展开X：<ol type="1"><li><code>X =&gt; .Ma $</code>、<code>X =&gt; .bMc $</code>、<code>X =&gt; .dc $</code>、<code>X =&gt; .bda $</code></li></ol></li><li>根据<code>X =&gt; .Ma $</code>展开M：<ol type="1"><li><code>M =&gt; .d a</code></li></ol></li></ol></li></ol></li><li>对于所有的状态，从上到下根据<code>.</code>后面的字符，接收该字符，转移到新的状态，且向前看字符不变(<code>.</code>没有字符则无法转移)<ol type="1"><li>如状态1可以接收<code>b</code>，转移到状态<code>2</code>，对应<code>.</code>向后移一位<ol type="1"><li>即<code>X =&gt; b.Mc $, X =&gt; b.da $</code></li></ol></li><li>对于新增的状态，类似状态1，进行展开<ol type="1"><li>如状态2原本是<code>X =&gt; b.Mc $, X =&gt; b.da $</code>，但是M为非终止符，需要展开为：<code>M =&gt; .d c</code></li></ol></li></ol></li><li>直到没有新的状态产生</li></ol><h3 id="构造lr1-parsing-table">3.3.2 构造LR(1) Parsing Table</h3><ol type="1"><li>对于DFA中的每一个<strong>S<sub>i</sub> 接受终止符t转移到S<sub>j</sub></strong>，令<strong>T[i, t] = sj</strong>（Input&amp; Shift表）</li><li>对于DFA中的每一个<strong>S<sub>i</sub> 接受非终止符X转移到S<sub>j</sub></strong>，令<strong>T[i, X] =gj</strong>（Goto表）</li><li>对于每一个<strong>可以规约的LR(1)Item</strong>，对于其所在所有状态<strong>i</strong>，每一个向前看字符<strong>t</strong>，令<strong>T[i,t] = rk</strong>，k为对应规则的编号</li></ol><h3 id="构造lalr1-parsing-table">3.3.3 构造LALR(1) Parsing Table</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230326223155255.png" alt="image-20230326223155255" style="zoom:80%;" /></p><ol type="1"><li>将LR(1)状态机中，LR(0)部分相同的状态合并，得到LALR(1)状态机</li><li>在根据LALR(1)状态机，仿照构造LR(1)的规则，构造LALR(1)分析表</li></ol><h2 id="将bnf转换为ebnf">3.4 将BNF转换为EBNF</h2><h3 id="表示循环">3.4.1 <code>&#123;&#125;</code>表示循环</h3><p>BNF：<code>exp =&gt; exp '+' term | term</code></p><p>EBNF：<code>exp =&gt; term &#123;'+' term&#125;</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">term</span>();</span><br><span class="line">    <span class="keyword">while</span>(token == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">eat</span>(token);</span><br><span class="line">        <span class="built_in">term</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表示选01次">3.4.2 <code>[]</code>表示选0/1次</h3><p>BNF：<code>IF =&gt; if ( exp ) statement | if ( exp ) statement else statement</code></p><p>EBNF：<code>IF =&gt; if ( exp ) statement [else statement]</code></p><h1 id="三parsing">三、Parsing</h1><h2 id="上下文无关语法-cfg">3.1 上下文无关语法 CFG</h2><h3 id="parser的任务">3.1.1 Parser的任务</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230306114328968.png" alt="image-20230306114328968" style="zoom:80%;" /></p><ol type="1"><li>输入：tokens流</li><li>输出：抽象语法树</li></ol><h3 id="cfg的表示">3.1.2 CFG的表示</h3><ol type="1"><li>符号：<ol type="1"><li>terminals：终止符</li><li>non-terminals：非终止符</li></ol></li><li>起始符号</li><li>规则：<code>符号 → 符号 符号 ... 符号</code><ol type="1"><li>左边：non-terminal</li><li>右边：termials 和 non-terminals 的连接</li><li>右边的符号可以视为左边符号的解释</li></ol></li></ol><h3 id="cfg的推导">3.1.3 CFG的推导</h3><ol type="1"><li>从起始符号开始</li><li>如果存在非终止符号，选择一个规则，用右边的符号替代左边的符号</li><li>重复2，直到只有终止符</li></ol><p>整个推导过程，可以形成一个<strong>抽象语法树 abstract syntaxtree</strong></p><blockquote><p><strong>示例</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230306115739759.png" alt="image-20230306115739759" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230306120038013.png" alt="image-20230306120038013" style="zoom:80%;" /></p><h3 id="parse-tree">3.1.4 Parse Tree</h3><ol type="1"><li>concrete syntax：即为Parse Tree，分析过程中的所有结果均会保留</li><li>abstract syntax：删除所有对分析结果没有影响的路径</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230306120406480.png" alt="image-20230306120406480" style="zoom:80%;" /></p><h3 id="ambiguous-grammar">3.1.5 Ambiguous Grammar</h3><ol type="1"><li>给定的某个tokens的序列，可以得到两个不同的parse tree</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230306121006118.png" alt="image-20230306121006118" style="zoom:80%;" /></p><h3 id="消除歧义">3.1.6 消除歧义</h3><ol type="1"><li>添加优先级：离根越远，优先级越高</li><li>改造文法</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230306121521468.png" alt="image-20230306121521468" style="zoom:80%;" /></p><h3 id="end-of-file标识符">3.1.7 End-of-File标识符：$</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230306121656796.png" alt="image-20230306121656796" style="zoom:80%;" /></p><ol type="1"><li>使用<code>$</code>表示文件结束</li><li>使用<code>S</code>表示表达式的起始状态</li></ol><h2 id="自顶向下分析predictive-parsing">3.2 自顶向下分析：PredictiveParsing</h2><p>LL(k)：</p><ol type="1"><li>Left-to-right parse：从左到右分析</li><li>Leftmost-derivation：最左推导</li><li>1 symbol lookahead：向前看1个符号</li></ol><h3 id="递归下降分析法llk">3.2.1 递归下降分析法：LL(k)</h3><ol type="1"><li>可以分析很多CFG，但不是所有的</li><li>关键思想<ol type="1"><li>每一个非终结符，视为一个递归函数</li><li>每一次推导，视为函数中的一个语句</li></ol></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313100635454.png" alt="image-20230313100635454" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313100648772.png" alt="image-20230313100648772" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313100700565.png" alt="image-20230313100700565" style="zoom:80%;" /></p></blockquote><h3 id="存在问题无法解决直接左递归的情况">3.2.2存在问题：无法解决直接左递归的情况</h3><ol type="1"><li>预测分析仅适用于：输入中的第一个终止符号提供足够的信息来选择要使用哪种生成的语法</li><li>在解析L时，如果tok=ID，解析器无法确定要使用哪个生成方式</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313100955345.png" alt="image-20230313100955345" style="zoom:80%;" /></p><h3 id="x是否可生成εnullablex">3.2.3 X是否可生成ε：Nullable(X)</h3><ol type="1"><li><span class="math inline">\((X:=\epsilon)\)</span>，则<spanclass="math inline">\(X\)</span>为<spanclass="math inline">\(Nullable\)</span></li><li><span class="math inline">\((X:=ABC...)\)</span>，且<spanclass="math inline">\(A,B,C...\)</span>均为<spanclass="math inline">\(Nullable\)</span>，则<spanclass="math inline">\(X\)</span>为<spanclass="math inline">\(Nullable\)</span></li></ol><h3 id="x可生成的第一个终结符firstx">3.2.4X可生成的第一个终结符：First(X)</h3><blockquote><p>看规则的左边</p></blockquote><ol type="1"><li>如果<span class="math inline">\(T\)</span>为终结符，则<spanclass="math inline">\(First(T)=\{T\}\)</span></li><li>如果<span class="math inline">\(X\)</span>为非终结符，且<spanclass="math inline">\((X:=ABC...)\)</span>，则<spanclass="math inline">\(First(X)=First(ABC...)\)</span><ol type="1"><li><span class="math inline">\(First(ABC...)=F1 \cup F2 \cup F3...\)</span></li><li><span class="math inline">\(F1 = Fisrt(A)\)</span></li><li>如果A为<span class="math inline">\(Nullable\)</span>，则<spanclass="math inline">\(F2=First(B)\)</span>；否则<spanclass="math inline">\(F2=\epsilon\)</span></li><li>如果A、B为<span class="math inline">\(Nullable\)</span>，则<spanclass="math inline">\(F3=First(C)\)</span>；否则<spanclass="math inline">\(F3=\epsilon\)</span></li></ol></li></ol><h3 id="x后面可以跟的第一个终结符followx">3.2.5X后面可以跟的第一个终结符：Follow(X)</h3><blockquote><p>看规则的右边</p><ol type="1"><li>给出语法的第一个规则的左边，默认为起始符号</li><li>对于起始符号，添加一个<code>$</code>进入Follow集合中，<code>$</code>表示输入的结束</li></ol></blockquote><ol type="1"><li>初始化：<span class="math inline">\(Follow(X):=\{\}\)</span></li><li>如果<span class="math inline">\((Y:=s1 X s2)\)</span>，则<spanclass="math inline">\(Follow(X)=First(s2)\)</span></li><li>如果<span class="math inline">\((Y:=s1Xs2)\)</span>，且<spanclass="math inline">\(s2\)</span>为<spanclass="math inline">\(Nullable\)</span>，则<spanclass="math inline">\(Follow(X)=Follow(Y)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313102750425.png" alt="image-20230313102750425" style="zoom:80%;" /></p><h3 id="分析表-parsing-table">3.2.6 分析表 Parsing Table</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313103442922.png" alt="image-20230313103442922" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313103514872.png" alt="image-20230313103514872" style="zoom:80%;" /></p><ol type="1"><li>构造分析表：对于规则<span class="math inline">\((X=&gt;s)\)</span><ol type="1"><li>如果<span class="math inline">\(T\in First(s)\)</span>，则在<spanclass="math inline">\(X\)</span>行<spanclass="math inline">\(T\)</span>列，填入<spanclass="math inline">\((X=&gt;s)\)</span></li><li>如果<span class="math inline">\(s\)</span>为<spanclass="math inline">\(Nullable\)</span>，且<spanclass="math inline">\(T\in Follow(X)\)</span>，则在<spanclass="math inline">\(X\)</span>行<spanclass="math inline">\(T\)</span>列，填入<spanclass="math inline">\((X=&gt;s)\)</span></li></ol></li><li>匹配文法：<ol type="1"><li>终结符：匹配</li><li>非终结符：查表<ol type="1"><li>如果当前的非终结符为<spanclass="math inline">\(Z\)</span>，读到的token为<spanclass="math inline">\(a\)</span>，则使用<spanclass="math inline">\(Z=&gt;XYZ\)</span>的规则</li><li>如果没有产生式，则输入有<strong>语法错误</strong></li><li>如果有多个产生式，则当前语法<strong>有歧义</strong></li></ol></li></ol></li></ol><h3 id="ll1-1">3.2.7 LL(1)</h3><ol type="1"><li><p>如果以这种方式构造的预测分析表不包含重复条目，则语法称为<strong>LL(1)</strong></p></li><li><p>判定语法是否为<strong>LL(1)</strong>：</p><ol type="1"><li>对于所有的<span class="math inline">\(A\)</span>，如果<spanclass="math inline">\(\epsilon \in First(A)\)</span>，如果<spanclass="math inline">\(First(A)\cap Follow(A) \ne\{\}\)</span>，则不是<strong>LL(1)</strong></li><li>对于所有的<strong>A=&gt;α，A=&gt;β</strong>，如果<spanclass="math inline">\(First(\alpha)\cap First(\beta) \neq\{\}\)</span>，则不是<strong>LL(1)</strong></li><li>否则，是<strong>LL(1)</strong></li></ol></li><li><p>LL(k)：即往前看k个符号</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313104247750.png" alt="image-20230313104247750" style="zoom:80%;" /></p></li><li><p>示例：</p><ol type="1"><li>注意替换后，右边的string要<strong>倒序进栈</strong></li><li>accept表示当前字符串，可以被接受</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313104432448.png" alt="image-20230313104432448" style="zoom:80%;" /></p></li></ol><h3 id="解决左递归问题">3.2.8 解决左递归问题</h3><h4 id="消除左递归">3.2.8.1 消除左递归</h4><ol type="1"><li><p>添加新的规则，消除左递归</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313104825289.png" alt="image-20230313104825289" style="zoom:80%;" /></p></li><li><p>示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313104711778.png" alt="image-20230313104711778" style="zoom:80%;" /></p></li></ol><h4 id="四则运算的语法">3.2.8.2 四则运算的语法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313104931063.png" alt="image-20230313104931063" style="zoom:80%;" /></p><h3 id="解决左公因子问题">3.2.9 解决左公因子问题</h3><ol type="1"><li>将判定推迟，在拿到ELSE时，才判断使用哪个规则<ol type="1"><li>原来为：<spanclass="math inline">\(A=&gt;\alpha\beta,A=&gt;\alpha\gamma,A=&gt;\alpha\)</span></li><li>改造为：<span class="math inline">\(A=&gt;\alpha A&#39;,A&#39;=&gt;\beta|\gamma|\epsilon\)</span></li></ol></li><li>示例：</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313105125827.png" alt="image-20230313105125827" style="zoom:80%;" /></p><h3 id="错误恢复">3.2.10 错误恢复</h3><ol type="1"><li><p>当产生错误时：</p><ol type="1"><li><p>产生异常，退出生成过程</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313105839095.png" alt="image-20230313105839095" style="zoom:80%;" /></p></li><li><p>输出错误信息，从错误中恢复：</p><ol type="1"><li><p>删除token：</p><ol type="1"><li>最安全的，因为避免了错误的放大</li><li>删除token，直到读到了<spanclass="math inline">\(Follow\)</span>集合中的token</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313105904507.png" alt="image-20230313105904507" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313110110363.png" alt="image-20230313110110363" style="zoom:80%;" /></p></li><li><p>替换token</p></li><li><p>增加token</p></li></ol></li></ol></li></ol><h2 id="自底向上分析bottom-upshift-reduce-parsing">3.3自底向上分析：Bottom-up(Shift-Reduce) Parsing</h2><ol type="1"><li>LL(k)：必须向前看k个符号，才能决定执行哪一步操作</li><li>LR(k)：不需要向前看，在k一定时分析能力更强<ol type="1"><li>Left-to-right parse：从左到右分析</li><li>Rightmost-derivation：最右推导</li><li>1 symbol lookahead：向前看1个符号</li></ol></li></ol><h3 id="lrk">3.3.1 LR(k)</h3><ol type="1"><li>语法器跟踪了：<ol type="1"><li>位于当前输入的哪个位置，即下一个要读入的input</li><li>一个包含终止符&amp;非终止符的栈，表示当前已经生成的语法</li></ol></li><li>四种操作：<ol type="1"><li><strong>shift</strong>：将下一个输入放到栈顶</li><li><strong>reduceR</strong>：栈顶匹配了规则的RHS，则将栈顶替换为LHS</li><li><strong>error</strong></li><li><strong>accept</strong>：栈里面只有开始符号时，生成成功</li></ol></li></ol><h3 id="lr生成表">3.3.2 LR生成表</h3><ol type="1"><li><strong>sn</strong>：shift，然后转为状态n</li><li><strong>gn</strong>：转为状态n</li><li><strong>rk</strong>：reduce，使用规则k</li><li><strong>a</strong>：accept，要保证唯一</li><li><strong>空</strong>：error</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313113747529.png" alt="image-20230313113747529" style="zoom:80%;" /></p><h3 id="shift-reduce-algorithm">3.3.3 Shift-Reduce Algorithm</h3><blockquote><p>使用一个整数，表示当前的生成状态</p><ol type="1"><li>整数表示FA的一个状态</li><li>可以通过在当前解析堆栈上运行自动机来计算当前解析状态</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313115149751.png" alt="image-20230313115149751" style="zoom:80%;" /></p><h3 id="lr0解析器">3.3.4 LR(0)解析器</h3><ol type="1"><li>LR(0) item：如果点号的右面为非终结符，则将其使用规则替换</li><li>completeitem：点号在最右面，只能进行reduce操作，如状态<code>2</code></li><li>shift item：点号不在最右面，需要进行shift操作</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313114753200.png" alt="image-20230313114753200" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313115118645.png" alt="image-20230313115118645" style="zoom:80%;" /></p><blockquote><p>LR(0)解析器无法解决的问题：SLR</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313115402787.png" alt="image-20230313115402787" style="zoom:80%;" /></p></blockquote><h3 id="slr解析器">3.3.5 SLR解析器</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313115707940.png" alt="image-20230313115707940" style="zoom:80%;" /></p><h3 id="lr1解析器">3.3.6 LR(1)解析器</h3><ol type="1"><li><p>LR(1) item：LR(0) item + lookahead symbol(一个终结符)</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313120317158.png" alt="image-20230313120317158" style="zoom:80%;" /></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230313120458869.png" alt="image-20230313120458869" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320101521894.png" alt="image-20230320101521894" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320101933691.png" alt="image-20230320101933691" style="zoom:80%;" /></p></blockquote></li><li><p>判断文法是否有冲突(歧义)</p><blockquote><p>Shift项：点号在中间</p><p>Reduce项：点号在最右边，也称为完整项</p></blockquote><ol type="1"><li>shift-reduce冲突：shift项和reduce项在同一个状态中</li><li>reduce-reduce冲突：向前看符号相同的reduce项和reduce项在同一个状态中</li><li>在LR(1) Parsing Table中，有某个表项中存在2个动作</li></ol></li></ol><h3 id="lalr1解析器">3.3.7 LALR(1)解析器</h3><ol type="1"><li>LR(0)的部分是相同的</li><li>前面一样但lookahead项不同的状态，合并起来</li><li>直接构造LALR(1)的算法不做要求</li><li>会使文法的表达能力下降：新增加了reduce-reduce冲突</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320102337824.png" alt="image-20230320102337824" style="zoom:80%;" /></p></blockquote><h3 id="不同语法的分析能力">3.3.8 不同语法的分析能力</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320102923215.png" alt="image-20230320102923215" style="zoom:80%;" /></p><h3 id="歧义文法">3.3.9 歧义文法</h3><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320103243931.png" alt="image-20230320103243931" style="zoom:80%;" /></p></blockquote><ol type="1"><li><p>改造文法：引入非终结符M</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320103410977.png" alt="image-20230320103410977" style="zoom:80%;" /></p></li><li><p>添加优先级</p></li></ol><h2 id="yacc">3.4 YACC</h2><blockquote><p>Yet Another Compiler Compiler</p></blockquote><ol type="1"><li><p>可以将动作放在中间</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320111844718.png" alt="image-20230320111844718" style="zoom:80%;" /></p></li><li><p>消除歧义的规则</p><ol type="1"><li><p>定义字符的结合方式：左结合<code>%left</code>，右结合<code>%right</code>，不结合<code>%nonassoc</code></p></li><li><p>优先级：定义的越后面，优先级越高</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">      <span class="comment">%left &#x27;+&#x27;&#x27;-&#x27;</span></span><br><span class="line">      <span class="comment">%left &#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line">   3. 规则的优先级，由产生式的最后一个符号决定</span><br><span class="line"></span><br><span class="line">   4. 当规则的优先级相同时，如果符号为左结合，则选择`reduce`，如果符号为右结合，则选择`shift`，如果符号为不结合，则报错`error`</span><br><span class="line"></span><br><span class="line">   5. 可以使用`<span class="comment">%prec`定义优先级</span></span><br><span class="line"></span><br><span class="line">   &lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320112549063.png&quot; alt=&quot;image-20230320112549063&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320112933865.png&quot; alt=&quot;image-20230320112933865&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">##</span> 3.5错误恢复</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> 3.5.1局部错误恢复</span><br><span class="line"></span><br><span class="line">1. 局部错误恢复机制：</span><br><span class="line"></span><br><span class="line">   1. 在检测到错误时调整解析堆栈和输入，以允许恢复解析</span><br><span class="line"></span><br><span class="line">2. yacc：使用`error`通配符，使得文法分析能够通配</span><br><span class="line"></span><br><span class="line">   &lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320113349913.png&quot; alt=&quot;image-20230320113349913&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">3. error的使用：</span><br><span class="line"></span><br><span class="line">   &lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320113559921.png&quot; alt=&quot;image-20230320113559921&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">   &gt; 示例：</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; &lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320113644205.png&quot; alt=&quot;image-20230320113644205&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line">   &gt;</span><br><span class="line">   &gt; &lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320113706224.png&quot; alt=&quot;image-20230320113706224&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line">   &gt;</span><br><span class="line">   &gt; &lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320113731521.png&quot; alt=&quot;image-20230320113731521&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">###</span> 3.5.2全局错误恢复</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320114142228.png&quot; alt=&quot;image-20230320114142228&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320114244565.png&quot; alt=&quot;image-20230320114244565&quot; style=&quot;zoom:80<span class="comment">%;&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">##</span> 3.6区分LR(0),SLR,LR(1)</span><br><span class="line"></span><br><span class="line">根据reduce操作区分</span><br><span class="line"></span><br><span class="line">1. `LR(0)`：同一行中有同一个reduce，且重复多次</span><br><span class="line">2. `LR(1)`：同一个reduce可能出现在不同行</span><br><span class="line">3. `SLR`：同一个reduce只能出现在一行</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="params">#</span> 四、抽象语法树 AST</span><br><span class="line"></span><br><span class="line">1. 降低语法树的存储开销</span><br><span class="line">2. 一定程度上过滤掉不同语法的差异</span><br><span class="line"></span><br><span class="line"><span class="params">##</span> 4.1语义动作 Semantic Actions</span><br><span class="line"></span><br><span class="line">所有的终结符和非终结符都会关联到它自己的语义属性</span><br><span class="line"></span><br><span class="line">1. 例如：`A =&gt; BCD`</span><br><span class="line">2. 语义操作必须返回一个值，该值的类型为与非终结符`A`关联的类型</span><br><span class="line">3. 它可以根据与匹配的终结符和非终结符`B、C、D`相关联的值来构建该值</span><br><span class="line">4. B的属性也可能依赖于CD</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> 4.1.1递归下降分析 Recursive Descent</span><br><span class="line"></span><br><span class="line">```tex</span><br><span class="line">S  =&gt; E<span class="built_in">$</span></span><br><span class="line">E  =&gt; TE&#x27;</span><br><span class="line">E&#x27; =&gt; +TE&#x27;</span><br><span class="line">E&#x27; =&gt; -TE&#x27;</span><br><span class="line">E&#x27; =&gt; </span><br><span class="line">T  =&gt; FT&#x27;</span><br><span class="line">T&#x27; =&gt; *FT&#x27;</span><br><span class="line">T&#x27; =&gt; /FT&#x27;</span><br><span class="line">T&#x27; =&gt; </span><br><span class="line">F  =&gt; id</span><br><span class="line">F  =&gt; num</span><br><span class="line">F  =&gt; (E)</span><br></pre></td></tr></table></figure></li></ol></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327102513916.png" alt="image-20230327102513916" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327102654495.png" alt="image-20230327102654495" style="zoom:80%;" /></p></blockquote><h3 id="yacc生成树">4.1.2 YACC生成树</h3><ol type="1"><li>Yacc生成的解析器通过维护两个栈（<strong>状态栈</strong>、<strong>value栈</strong>）并行来实现语义值</li><li>当解析器执行<strong>归约</strong>时，它必须执行C语言<strong>语义操作</strong></li><li>当解析器从<strong>状态栈</strong>中<strong>弹出前k个元素并压入非终结符时</strong>，它也从<strong>value栈</strong>中<strong>弹出k个元素并压入通过执行语义动作获得的值</strong></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327102803796.png" alt="image-20230327102803796" style="zoom:80%;" /></p></blockquote><h2 id="抽象语法树-abstact-parse-trees">4.2 抽象语法树 Abstact ParseTrees</h2><ol type="1"><li><strong>parse tree</strong>：编译器的后续阶段可以遍历的数据结构。<ol type="1"><li>输入的每个<strong>token</strong>正好有一个<strong>叶节点</strong></li><li>对于在解析过程中使用的<strong>每个语法规则</strong>有一个<strong>内部节点</strong></li></ol></li><li><strong>concrete parse tree</strong>：表示源语言的具体语法</li><li><strong>abstractsyntax</strong>：抽象语法树传达了源程序的短语结构，解决了所有解析问题，但没有任何语义解释</li><li><strong>abstract</strong>在解析器和编译器后面的短语之间建立了一个干净的接口</li><li><strong>解析器</strong>使用<strong>具体语法树</strong>为抽象语法构建<strong>抽象语法树</strong>。语义分析阶段采用这个抽象的语法树</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327104140072.png" alt="image-20230327104140072" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327104154280.png" alt="image-20230327104154280" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327104204667.png" alt="image-20230327104204667" style="zoom:80%;" /></p></blockquote><h3 id="positions">4.2.1 Positions</h3><ol type="1"><li>如果存在必须向用户报告的<strong>typeerror</strong>，则词法分析器的<strong>currentposition</strong>是错误源位置的合理近似值</li><li>对于<strong>one-pass</strong>编译器，词法分析器会保留一个全局变量<strong>currentposition</strong><ol type="1"><li><strong>one-pass</strong>：对代码、语法树等均只进行一次扫描</li></ol></li><li>使用抽象语法树数据结构的编译器需要准确地记住位置</li><li><strong>pos</strong>字段指示从中派生出这些抽象语法结构的字符的位置</li><li>使用Yacc时，一种解决方案是定义一个非终结符pos，其语义值是源位置（行号或行号和行内位置）</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327104917987.png" alt="image-20230327104917987" style="zoom:80%;" /></p><h2 id="ebnf扩展bnf">4.3 EBNF：扩展BNF</h2><blockquote><p>只要文法满足EBNF，则一定可以递归下降分析，一定没有左递归和左公因子</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327105501746.png" alt="image-20230327105501746" style="zoom:80%;" /></p><blockquote><p><code>&#123;&#125;</code>：表示循环</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327105513052.png" alt="image-20230327105513052" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327105523638.png" alt="image-20230327105523638" style="zoom:80%;" /></p><blockquote><p>在代码中处理左结合问题</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327105715790.png" alt="image-20230327105715790" style="zoom:80%;" /></p><blockquote><p><code>[]</code>：表示选0/1次</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327105751653.png" alt="image-20230327105751653" style="zoom:80%;" /></p><blockquote><p>其他问题</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327110035417.png" alt="image-20230327110035417" style="zoom:80%;" /></p><h1 id="五语义分析">五、语义分析</h1><ol type="1"><li>将变量的定义和使用联系起来</li><li>检查每一个表达式是否拥有正确的类型</li><li>将抽象语法树转化成一种更为简单的表示形态，用于后续生成机器代码</li></ol><h2 id="符号表-symbol-table">5.1 符号表 Symbol Table</h2><h3 id="符号表">5.1.1 符号表</h3><ol type="1"><li>符号表用于将<strong>标识符</strong>映射到其<strong>类型、位置</strong></li><li><strong>环境</strong>是一组绑定，使用<strong>↦</strong>表示<ol type="1"><li><strong>σ0</strong>：表示函数外的环境</li><li><strong>+</strong>：表示扩展符号表</li><li>符号表是动态的，每一条语句都有可能改变符号表</li></ol></li><li><strong>+</strong>：<code>X+Y</code>与<code>Y+X</code>不同，因为如果存在相同符号，<strong>+</strong>后面的符号表会覆盖前面的符号表<ol type="1"><li>函数式风格：当创建<code>σ2、σ3</code>时，不会更改<code>σ1</code>的值</li><li>命令式风格：修改<code>σ1</code>直到其变为<code>σ2</code>，当使用<code>σ2</code>时无法查看<code>σ1</code>，<code>σ2</code>失效时，需要通过<strong>undo</strong>操作将其更改为<code>σ1</code></li></ol></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327111828986.png" alt="image-20230327111828986" style="zoom:80%;" /></p></blockquote><h3 id="多个符号表">5.1.2 多个符号表</h3><p>有些语言可以同时有多个不同的符号表：</p><ol type="1"><li>如程序中的每个module、class、record均可有各自的符号表<code>σ</code></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327112550410.png" alt="image-20230327112550410" style="zoom:80%;" /></p><h3 id="符号表的构造">5.1.3 符号表的构造</h3><blockquote><p>使用<strong>Hash表+单链表</strong>构造符号表，每次将值插入<strong>表头</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327113230230.png" alt="image-20230327113230230" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327113540284.png" alt="image-20230327113540284" style="zoom:80%;" /></p><ol type="1"><li>如果<code>σ + &#123;a ↦ T2&#125;</code>，而<code>σ</code>已经包含了<code>&#123;a ↦ T1&#125;</code>，由于将<code>&#123;a ↦ T2&#125;</code>放到了表头<ol type="1"><li>当查询时，找到第一个<code>&#123;a ↦ T2&#125;</code>就返回了，不会查到之前的<code>&#123;a ↦ T1&#125;</code></li><li>删除时，也是找到第一个<code>&#123;a ↦ T2&#125;</code></li></ol></li></ol><h3 id="函数式符号表">5.1.4 函数式符号表</h3><ol type="1"><li>当计算<code>σ' = σ + &#123;a ↦ τ&#125;</code>时，我们只需要让<code>σ'</code>的指针指向<code>σ</code>的bucket即可</li><li>删除时，直接释放<code>σ'</code>中的指针</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327114249094.png" alt="image-20230327114249094" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327114315245.png" alt="image-20230327114315245" style="zoom:80%;" /></p><h3 id="tiger编译器中的符号表">5.1.5 Tiger编译器中的符号表</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327114550222.png" alt="image-20230327114550222" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327114731418.png" alt="image-20230327114731418" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327114806188.png" alt="image-20230327114806188" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230327114920302.png" alt="image-20230327114920302" style="zoom:80%;" /></p><h3 id="范围规则和块结构-scope-rules-and-block-structure">5.1.6范围规则和块结构 Scope rules and block structure</h3><p>两个规则：</p><ol type="1"><li>先定义，后使用</li><li>就近匹配原则</li></ol><p>具体要求：</p><ol type="1"><li>在分析时，就需要构建符号表</li><li>lookup时，选择尽可能近的符号定义</li><li>当lookup失败时：发生<code>声明前使用变量</code>的错误情况，编译器将发出适当的错误消息</li></ol><h2 id="tiger编译器的绑定">5.2 Tiger编译器的绑定</h2><p>类型等价：</p><ol type="1"><li>结构等价 structureequivalence：两个结构体包含的成员变量的类型、数量是相同的</li><li>命名等价 name equivalence：两个结构体完全相同</li><li>声明等价 declare equivalence：声明过两个结构体相同</li></ol><h3 id="环境">5.2.1 环境</h3><p>Tiger语言的编译器，将环境分为Type environment、Value environment</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403101725679.png" alt="image-20230403101725679" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403101715253.png" alt="image-20230403101715253" style="zoom:80%;" /></p><h2 id="type-checking-expression">5.3 Type-checking Expression</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403101953632.png" alt="image-20230403101953632" style="zoom:80%;" /></p><blockquote><p><strong>type-checker</strong>是抽象语法树的一个递归函数：transExp</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403102108865.png" alt="image-20230403102108865" style="zoom:80%;" /></p><blockquote><p>变量转换：transVar</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403102405598.png" alt="image-20230403102405598" style="zoom:80%;" /></p><h2 id="type-checking-declaration">5.4 Type-checking Declaration</h2><h3 id="变量声明">5.4.1 变量声明</h3><p>当出现声明语句时，Environment会发生改变</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403102910846.png" alt="image-20230403102910846" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403102751733.png" alt="image-20230403102751733" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403103054061.png" alt="image-20230403103054061" style="zoom:80%;" /></p><h3 id="类型声明">5.4.2 类型声明</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403103236744.png" alt="image-20230403103236744" style="zoom:80%;" /></p><h3 id="函数声明">5.4.3 函数声明</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403103557588.png" alt="image-20230403103557588" style="zoom:80%;" /></p><h3 id="递归声明">5.4.4 递归声明</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403104008862.png" alt="image-20230403104008862" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403104029522.png" alt="image-20230403104029522" style="zoom:80%;" /></p><h1 id="六活动记录">六、活动记录</h1><p>活动记录和函数调用相关</p><ol type="1"><li><p>函数的嵌套调用：使用栈传递函数的参数</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403104609213.png" alt="image-20230403104609213" style="zoom:80%;" /></p></li><li><p>函数的嵌套定义：子函数</p><ol type="1"><li>C语言不允许函数的嵌套定义</li><li>子函数可以调用父函数的变量：non-local and non-global</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403104618982.png" alt="image-20230403104618982" style="zoom:67%;" /></p></li></ol><h2 id="栈帧">6.1 栈帧</h2><ol type="1"><li>栈指针：指向某个位置<ol type="1"><li>堆栈通常只在函数的入口处增长，增量足够大，可以容纳该函数的所有局部变量</li><li>并且在函数退出之前保存这些变量</li></ol></li><li>函数的<strong>活动记录/栈帧</strong>：<ol type="1"><li>在栈中的一块空间，保存当前函数的局部变量、参数、返回值、临时变量</li><li>局部变量：用户定义的变量</li><li>临时变量：编译器在处理复杂表达式时产生的变量</li><li>保存寄存器：之前帧已经用到的寄存器</li></ol></li><li>Run-time stack通常从高地址开始，向低地址增长<ol type="1"><li>堆通常是从低地址开始，向高地址增长</li><li>尽可能共用中间部分的代码</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403112103765.png" alt="image-20230403112103765" style="zoom:80%;" /></p><h3 id="栈帧的各个部分">6.1.1 栈帧的各个部分</h3><p>caller：发起调用者</p><p>callee：被调用者</p><ol type="1"><li>输入参数：caller压栈</li><li>返回地址：由call指令创建，通常为当前地址+1</li><li>局部变量、临时变量：callee压栈，可能有的变量放入了寄存器中</li><li>输出参数：传递参数</li><li>static link：如果函数允许嵌套定义，则使用staticlink访问non-local-non-global变量</li></ol><h3 id="帧指针">6.1.2 帧指针</h3><ol type="1"><li>当<strong>g</strong>调用<strong>f</strong>时：<ol type="1"><li><strong>g</strong>压入参数，栈指针指向第一个参数的地址</li><li><strong>f</strong>申请一些栈空间，减小<strong>SP</strong>的值</li></ol></li><li>当进入<strong>f</strong>时：<ol type="1"><li>旧的<strong>FP</strong>保存到栈中</li><li>新的<strong>FP</strong>赋值为旧的<strong>SP</strong></li></ol></li><li>当退出<strong>f</strong>时：<ol type="1"><li>将<strong>SP</strong>赋值为<strong>FP</strong></li><li>从栈中读取<strong>FP</strong>的值</li></ol></li></ol><h3 id="寄存器">6.1.3 寄存器</h3><p>设<strong>f</strong>和<strong>g</strong>均使用了寄存器<strong>r</strong>，<strong>g</strong>调用<strong>f</strong></p><ol type="1"><li>如果<strong>r</strong>是<strong>caller-savedregister</strong>，则由<strong>g</strong>保存寄存器</li><li>如果<strong>r</strong>是<strong>callee-savedregister</strong>，则由<strong>f</strong>保存寄存器</li></ol><h3 id="参数传递">6.1.4 参数传递</h3><p>四种传递类型</p><ol type="1"><li>value 值传递：C只有值传递</li><li>reference 引用传递：只传地址，C可以通过传地址模拟该操作</li><li>value-result双向值传递：函数执行结束后，callee会向caller发起值传递</li><li>name 名字传递：只有用到变量是，才发生传递</li></ol><p>编译器可以选择将前k个参数放入寄存器</p><ol type="1"><li>通常k=4/6</li></ol><p>设函数<strong>f(a1, ... ,an)</strong>调用了函数<strong>h(z)</strong></p><ol type="1"><li>leaf procedures：不调用其他函数的函数<ol type="1"><li>叶子函数不需要将他们的输入参数写入内存</li></ol></li><li>interprocedural register allocation</li><li>dead variable：发生函数调用以后，变量不再使用<ol type="1"><li>则函数可以直接使用该变量对应的寄存器，而不用保存</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403114151248.png" alt="image-20230403114151248" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403114217292.png" alt="image-20230403114217292" style="zoom:80%;" /></p><h3 id="返回地址">6.1.5 返回地址</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403114236390.png" alt="image-20230403114236390" style="zoom:80%;" /></p><h3 id="放在frame中的变量">6.1.6 放在Frame中的变量</h3><ol type="1"><li>放在寄存器中的变量：<ol type="1"><li>参数、返回值、返回结果</li></ol></li><li>必须写入内存的原因：<ol type="1"><li>当前变量通过引用传递</li><li>当前变量会被嵌套在该函数中的函数使用</li><li>当前变量的值太大，寄存器存不下</li><li>当前变量是一个数组，因为需要通过下标计算地址访问</li><li>寄存器保存的变量需要被用于一个特定用途，如参数传递</li><li>寄存器不够用了</li></ol></li></ol><h3 id="静态链接-static-link">6.1.7 静态链接 Static Link</h3><p>在某些语言中，内部的函数会使用外部的函数，这种特性被称为blockstructure</p><ol type="1"><li>static link：当f被调用时，会传递一个指针，指向调用f的函数的栈帧</li><li>display表：维护函数调用的层次关系</li><li>lambdalifting：当g调用f时，f（或嵌套在f中的任何函数）实际访问的g的每个变量都作为额外的参数传递给f</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403115642643.png" alt="image-20230403115642643" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403115651944.png" alt="image-20230403115651944" style="zoom:80%;" /></p><h2 id="tiger编译器中的frame">6.2 Tiger编译器中的Frame</h2><p><strong>escape</strong>变量必须在内存中</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403120825953.png" alt="image-20230403120825953" style="zoom:80%;" /></p><p>抽象层次：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403121309546.png" alt="image-20230403121309546" style="zoom:80%;" /></p><p>静态链接管理：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230403121351400.png" alt="image-20230403121351400" style="zoom:80%;" /></p><h1 id="七翻译为中间代码">七、翻译为中间代码</h1><p>IR：Intermediate Representation，中间代码</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410100825954.png" alt="image-20230410100825954" style="zoom:80%;" /></p><p><strong>什么是中间代码</strong></p><ol type="1"><li>中间代码是一种抽象机器语言</li><li>特性：<ol type="1"><li>便于语义处理之后的生成</li><li>便于翻译为机器语言</li><li>便于优化</li></ol></li></ol><p><strong>三地址码</strong></p><ol type="1"><li><p>每条语句最多有三个地址</p><blockquote><p>如 x = y op z，给定表达式2*a+(b-3)，会将其转换为：</p><ol type="1"><li>T1 = 2 * a</li><li>T2 = b - 3</li><li>T3 = T1 + T2</li></ol></blockquote></li><li><p>一条语句有四个元素：(四元组 quadruple)</p><ol type="1"><li>一个表示operation</li><li>三个表示address，可为空</li></ol></li></ol><h2 id="中间表示树">7.1 中间表示树</h2><h3 id="表达式t_exp">7.1.1 表达式T_exp</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410103913293.png" alt="image-20230410103913293" style="zoom:80%;" /></p><h3 id="语句t_stm">7.1.2 语句T_stm</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410104258077.png" alt="image-20230410104258077" style="zoom:80%;" /></p><h2 id="翻译为树">7.2 翻译为树</h2><h3 id="表达式的结构定义">7.2.1 表达式的结构定义</h3><ol type="1"><li>有返回值的表达式：T_exp</li><li>没有返回值的表达式：T_stm</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tr_exp_</span> *<span class="title">Tr_exp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cx</span> &#123;</span> </span><br><span class="line">    patchList trues;  <span class="comment">// true时的标签</span></span><br><span class="line">    patchList falses; <span class="comment">// false时的标签</span></span><br><span class="line">    T_stm stm;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tr_exp_</span>&#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Tr_exp,Tr_nx,Tr_cx &#125; kind;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line">        T_exp ex; <span class="comment">// 表达式</span></span><br><span class="line">        T_stm nx; <span class="comment">// 语句</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Cx</span> <span class="title">cx</span>;</span> <span class="comment">// 包含的内容</span></span><br><span class="line">    &#125; u;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> Tr_exp <span class="title function_">Tr_Ex</span> <span class="params">( T_exp ex)</span>;</span><br><span class="line"><span class="type">static</span> Tr_exp <span class="title function_">Tr_Nx</span> <span class="params">( T_exp nx)</span>;</span><br><span class="line"><span class="type">static</span> Tr_exp <span class="title function_">Tr_Cx</span> <span class="params">( patchList trues, patchList falses,T_stm stm)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>a &gt; b | c &lt; d翻译为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Temp_label z = Temp_newlabel();<span class="comment">// 申请临时标签</span></span><br><span class="line">T_stm s1 = T_Seq(</span><br><span class="line">    T_Cjump(T_gt, a, b, NULLt, z),<span class="comment">// a&gt;b语句, 为真时跳到NULLt处(待后续补充), 为假时跳转到z处</span></span><br><span class="line">    T_Seq (T_Label (z), </span><br><span class="line">           T_Cjump (T_lt,c,d, NULLt, NULLf))); <span class="comment">// c&lt;d语句, 为真时跳到NULLt处(待后续补充), 为假时跳转到NULLf处(待后续补充)</span></span><br></pre></td></tr></table></figure><p>true和false的目标并不知道在哪里，但可以后续补充</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">patchList_</span> *<span class="title">patchList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">patchList_</span> &#123;</span> </span><br><span class="line">    Temp_label *head; </span><br><span class="line">    patchList tail; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> patchList <span class="title function_">PatchList</span><span class="params">(Temp_label *head, patchList tail)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">patchList trues = PatchList(</span><br><span class="line">    &amp;s1-&gt;u.SEQ.left-&gt; u.CJUMP.<span class="literal">true</span>,</span><br><span class="line">    PatchList(&amp;s1-&gt;u.SEQ.right-&gt;u.SEQ.right-&gt;u.CJUMP.<span class="literal">true</span>, <span class="literal">NULL</span>));</span><br><span class="line">patchList falses = PatchList(</span><br><span class="line">    &amp;s1-&gt;u.SEQ.right-&gt;u.SEQ.right-&gt;U.CJUMP.<span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">Tr_exp e1 = Tr_Cx (trues, falses, s1);</span><br></pre></td></tr></table></figure></blockquote><ol type="1"><li><p>将一个表达式转换为等价的另一种表达式</p><blockquote><p>如 flag := (a&gt;b | c&lt;d)</p></blockquote></li><li><p>三种类型转换函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> T_exp <span class="title function_">unEx</span><span class="params">(Tr_exp e)</span>;<span class="comment">// 表达式</span></span><br><span class="line"><span class="type">static</span> T_stm <span class="title function_">unNx</span><span class="params">(Tr_exp e)</span>;<span class="comment">// 语句</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> Cx <span class="title function_">unCx</span><span class="params">(Tr_exp e)</span>;<span class="comment">// 条件语句</span></span><br></pre></td></tr></table></figure><blockquote><p>如上述语句转换为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e = Tr_Cx (trues, falses, stm)</span><br><span class="line">MOVE (TEMP_flag, unEx(e))</span><br></pre></td></tr></table></figure></blockquote></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> T_exp <span class="title function_">unEx</span><span class="params">(Tr_exp e)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (e-&gt;kind) &#123;</span><br><span class="line">        <span class="comment">// 表达式</span></span><br><span class="line">    <span class="keyword">case</span> Tr_ex:</span><br><span class="line">    <span class="keyword">return</span> e-&gt;u.ex;</span><br><span class="line">        <span class="comment">// 条件语句</span></span><br><span class="line">    <span class="keyword">case</span> Tr_cx: &#123;</span><br><span class="line">            Temp_temp r= Temp_newtemp(); <span class="comment">// 申请临时变量</span></span><br><span class="line">            Temp_label t = Temp_newlabel(), f= Temp_newlabel(); <span class="comment">// 申请临时标签</span></span><br><span class="line">            doPatch(e-&gt;u.cx.trues, t);</span><br><span class="line">            doPatch(e-&gt;u.cx.falses, f);</span><br><span class="line">            <span class="keyword">return</span> T_Eseq(T_Move(T_Temp(r),T_Const(<span class="number">1</span>)), <span class="comment">// 临时变量r赋值为1</span></span><br><span class="line">            T_Eseq(e-&gt;u.cx.stm,  <span class="comment">//</span></span><br><span class="line">                        T_Eseq(T_Label(f), </span><br><span class="line">            T_Eseq(T_Move(T_Temp(r),T_Const(<span class="number">0</span>)),<span class="comment">// 将r赋值为0</span></span><br><span class="line">            T_Eseq(T_Label(t), T_Temp(r))))));  <span class="comment">// 运算结果为r</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 语句</span></span><br><span class="line">        <span class="keyword">case</span> Tr_nx:</span><br><span class="line">    <span class="keyword">return</span> T_Eseq(e-&gt;u.nx, T_Const(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    assert(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410105840570.png" alt="image-20230410105840570" style="zoom:80%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将标签放入标签列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doPatch</span> <span class="params">(patchList tList, Temp_label label)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; tList; tList = tList-&gt;tail)</span><br><span class="line">    *(tList-&gt;head) = label;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把两个列表连在一起</span></span><br><span class="line">PatchList <span class="title function_">joinPatch</span> <span class="params">(patchList first, patchList second)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span> second;</span><br><span class="line">    <span class="keyword">for</span> (; first-&gt;tail; first = first-&gt;tail);</span><br><span class="line">    first-&gt;tail = second;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单变量">7.2.2 简单变量</h3><ol type="1"><li><p>声明在当前活动记录栈帧中</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410111417606.png" alt="image-20230410111417606" style="zoom:80%;" /></p></li><li><p>在Semant和Translate之间的接口</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410111746902.png" alt="image-20230410111746902" style="zoom:80%;" /></p></li><li><p>使用<code>+(e1, e2)</code>代替<code>BINOP(PLUE, e1, e2)</code></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410111705506.png" alt="image-20230410111705506" style="zoom: 80%;" /></p></li><li><p>函数<code>F_Exp</code></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410111917539.png" alt="image-20230410111917539" style="zoom:80%;" /></p></li></ol><h3 id="数组变量">7.2.4 数组变量</h3><p>Pascal中两个数组的赋值操作：</p><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b : <span class="keyword">array</span>[<span class="number">1</span>..<span class="number">12</span>] <span class="keyword">of</span> integer</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">a:=b</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>C语言：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> a[<span class="number">12</span>], *b;</span><br><span class="line">    b=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tiger、Java、ML语言：数组变量的行为类似于指针操作</p><ol type="1"><li>没有C中的数组名常量</li><li>新建数组的操作：<code>ta[n] of i</code><ol type="1"><li><code>ta</code>：数组类型的名称</li><li><code>n</code>：元素个数</li><li><code>i</code>：每个元素的初始值</li></ol></li></ol><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">let</span><br><span class="line">    type intArray = array of int</span><br><span class="line">    var a:= intArray[12] of 0</span><br><span class="line">    var b:= intArray[12] of 7</span><br><span class="line">in a:= b// a指向了b, 原来的12个0就无法访问了</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="结构化左值">7.2.5 结构化左值</h3><ol type="1"><li>右值：表达式的右边</li><li>左值：表达式的左边</li><li>左值可以转换为右值，但右值不能转换为左值</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410112634010.png" alt="image-20230410112634010" style="zoom:80%;" /></p><ol type="1"><li><p>一个整数/指针，称为<strong>标量scalar</strong>：只包含一个元素</p><ol type="1"><li>Tiger中的所有左值均为标量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410112805166.png" alt="image-20230410112805166" style="zoom:80%;" /></p></li></ol><h3 id="subscripting-and-field-selection">7.2.6 Subscripting and FieldSelection</h3><ol type="1"><li><p>数组变量<code>a</code>是左值，<code>a[i]</code>也是</p><ol type="1"><li>从<code>a</code>计算左值<code>a[i]</code>，需要进行地址运算</li></ol></li><li><p><code>a[i]</code>的IR树：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410113043464.png" alt="image-20230410113043464" style="zoom:80%;" /></p></li></ol><h3 id="算术运算-arithmetic">7.2.8 算术运算 Arithmetic</h3><ol type="1"><li>树语言不能表示单目运算</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410113151479.png" alt="image-20230410113151479" style="zoom:80%;" /></p><h3 id="条件表达式-conditionals">7.2.9 条件表达式 Conditionals</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410113414602.png" alt="image-20230410113414602" style="zoom:80%;" /></p><blockquote><p>示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410113525054.png" alt="image-20230410113525054" style="zoom:80%;" /></p></blockquote><h3 id="while循环语句">7.2.12 while循环语句</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">test:</span><br><span class="line">if not(condition) goto done</span><br><span class="line">body</span><br><span class="line">goto test</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol type="1"><li>break语句：<ol type="1"><li>如果没有嵌套循环，则直接翻译为<code>goto done</code></li><li>如果有嵌套循环，则需要有一个标签，作为break跳转的地方</li></ol></li></ol><h3 id="for循环语句">7.2.13 For循环语句</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410113850656.png" alt="image-20230410113850656" style="zoom:80%;" /></p><h3 id="函数调用call">7.2.14 函数调用CALL</h3><ol type="1"><li>要将<code>static link</code>也作为参数传递进去</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410113931284.png" alt="image-20230410113931284" style="zoom:80%;" /></p><h2 id="定义-declaration">7.3 定义 Declaration</h2><ol type="1"><li>变量定义：<ol type="1"><li>保存在frame中</li></ol></li><li>函数定义：<ol type="1"><li>在Tree Code中会新增一个fragment，用于保存函数体的代码</li></ol></li></ol><h3 id="变量定义">7.3.1 变量定义</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410114200185.png" alt="image-20230410114200185" style="zoom:80%;" /></p><h3 id="函数定义">7.3.2 函数定义</h3><p>函数会被转化成：</p><ol type="1"><li>prologue<ol type="1"><li>伪指令：标记函数的开头</li><li>label：表示函数名</li><li>指令：调整栈指针</li><li>指令：将escape参数放入frame，nonescape放入寄存器中</li><li>store指令：保存callee-saved registers，包含return addressregister</li></ol></li><li>body</li><li>epilogue<ol type="1"><li>指令：将返回值保存到register中</li><li>load指令：恢复callee-saved registers</li><li>指令：恢复栈指针</li><li>return指令</li><li>伪指令：声明函数结束</li></ol></li></ol><h3 id="fragment">7.3.3 Fragment</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230410114615061.png" alt="image-20230410114615061" style="zoom:80%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* frame.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">F_frag_</span> * <span class="title">F_frag</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F_frag_</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>F_stringFrag, F_procFrag&#125; kind;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            Temp_label label;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        &#125; stringg;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            T_stm body; </span><br><span class="line">            F_frame frame;</span><br><span class="line">        &#125; proc;</span><br><span class="line">    &#125; u；</span><br><span class="line">&#125;；</span><br><span class="line">F_frag <span class="title function_">F_StringFrag</span><span class="params">(Temp_label label, <span class="built_in">string</span> str)</span>;</span><br><span class="line">F_frag <span class="title function_">F_ProcFrag</span><span class="params">(T_stm body, F_frame frame)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">F_fragList_</span> *<span class="title">F_fragList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F_fragList_</span> &#123;</span>F_frag head; F_fragList tail;&#125;;</span><br><span class="line">F_fragList <span class="title function_">F_FragList</span><span class="params">(F_frag head, F_fragList tail)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* translate.h */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tr_procEntryExit</span><span class="params">(Tr_level level, Tr_exp body, Tr_accessList formals)</span>;</span><br><span class="line">F_fragList <span class="title function_">Tr_getResult</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="八基本块和轨迹">八、基本块和轨迹</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417191225375.png" alt="image-20230417191225375" style="zoom:80%;" /></p><h2 id="overview">8.0 Overview</h2><p>现在生成的Tree Language与目标代码生成之间有一定的冲突</p><ol type="1"><li><strong>CJUMP(op, exp1, exp2, true_label,false_label)</strong>：条件分支跳转<ol type="1"><li>但是在机器码中，一条是默认分支，一条是要跳转的分支</li></ol></li><li><strong>ESEQ(stmt, exp)</strong>：表达式序列，结果是exp的值<ol type="1"><li>执行顺序会导致不同的结果</li></ol></li><li><strong>CALL(f, list)</strong>：调用函数<ol type="1"><li>在调用语句中含有表达式，如果表达式中含有其他节点的值，则会存在一定的问题</li></ol></li></ol><p>需要修改树的形态，使之避免上述问题</p><ol type="1"><li>没有<strong>SEQ、ESEQ</strong>节点</li><li>可以划分为一组<strong>basic blocks</strong>，每个<strong>basicblocks</strong>之内没有<strong>跳转/标签</strong></li><li>每个<strong>basicblocks</strong>按照顺序排列，形成<strong>traces</strong>的集合，其中每一个<strong>CJUMP</strong>之后均为其取false时的跳转目标</li></ol><h2 id="canonical-trees">8.1 Canonical Trees</h2><p>特点：</p><ol type="1"><li>没有<strong>SEQ</strong>和<strong>ESEQ</strong></li><li>每个<strong>CALL</strong>的父节点只能是<strong>EXP(...)</strong>或者<strong>MOVE(TEMPt, ...)</strong></li></ol><h3 id="eseq的转换">8.1.1 ESEQ的转换</h3><p>思想：将ESEQ往上提，直到其变为SEQ</p><h4 id="示例">8.1.1.1 示例</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417213623702.png" alt="image-20230417213623702" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417213745729.png" alt="image-20230417213745729" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417213950404.png" alt="image-20230417213950404" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417214501569.png" alt="image-20230417214501569" style="zoom:80%;" /></p><h4 id="commute判断一条语句和一个表达式能否交换">8.1.1.2commute：判断一条语句和一个表达式能否交换</h4><ol type="1"><li>exp为常量时，可以与任意语句交换</li><li>statement是空语句时，可以与任意exp交换</li><li>其他情况均不可交换</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417214601568.png" alt="image-20230417214601568" style="zoom:80%;" /></p><h4 id="改写规则的方法">8.1.1.3 改写规则的方法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417214903599.png" alt="image-20230417214903599" style="zoom:80%;" /></p><h4 id="算法">8.1.1.4 算法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417215018122.png" alt="image-20230417215018122" style="zoom:80%;" /></p><blockquote><p>reorder函数</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417215204624.png" alt="image-20230417215204624" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417215401514.png" alt="image-20230417215401514" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417215410650.png" alt="image-20230417215410650" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417215706135.png" alt="image-20230417215706135" style="zoom:80%;" /></p><h3 id="将call提升到最高层">8.1.2 将CALL提升到最高层</h3><p>对于<strong>BINOP(PLUS, CALL(), CALL())</strong></p><ol type="1"><li>CALL的结果会放到一个特定的寄存器中</li><li>而第二次CALL会将第一次CALL的结果覆盖</li></ol><p>因此，我们的需要：</p><ol type="1"><li>将CALL的结果放到一个临时变量中</li><li>即将<strong>CALL(fun, args)</strong>转化为<strong>ESEQ(MOVE(TEMP t,CALL(fun, args)), TEMP t)</strong></li></ol><h3 id="语句的线性链表">8.1.3 语句的线性链表</h3><ol type="1"><li>首先，<strong>SEQ(SEQ(a,b) c)</strong>与<strong>SEQ(a, SEQ(b,c)</strong>等价</li><li>因此，我们可以将其转化为一个语句的链表<strong>s1, s2, s3 ...sn</strong>，每个<strong>si</strong>中均不含<strong>SEQ</strong>或<strong>ESEQ</strong>节点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417220318817.png" alt="image-20230417220318817" style="zoom:80%;" /></p><h2 id="条件分支的转换">8.2 条件分支的转换</h2><ol type="1"><li>将Canonical Tree转化为Basic Block</li><li>将Basic Block按照顺序转化为trace</li></ol><h3 id="basic-block">8.2.1 Basic Block</h3><p>一个BasicBlock是一个语句的序列：始终在开头处进入，在结尾处退出，即</p><ol type="1"><li>第一条语句是<strong>LABEL</strong></li><li>最后一条语句是<strong>JUMP、CJUMP</strong></li><li>基本块之间没有其他<strong>LABEL、JUMP、CJUMP</strong></li></ol><h3 id="算法-1">8.2.2 算法</h3><ol type="1"><li>从头到尾扫描语句序列</li><li>如果发现一个<strong>LABEL</strong>，则创建一个新的block，之前的block结束</li><li>如果发现一个<strong>JUMP、CJUMP</strong>，则之前的block结束，下一个block开始</li><li>如果离开了一个block，但是这个block不已<strong>JUMP、CJUMP</strong>结尾，则在该block结尾添加一个<strong>JUMP</strong>，跳转至下一个block</li><li>如果一个block没有以<strong>LABEL</strong>开头，则添加一个新的<strong>LABEL</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417221606433.png" alt="image-20230417221606433" style="zoom:80%;" /></p><h2 id="traces">8.3 Traces</h2><p>Basic Block可以按任何顺序排列，执行程序的结果将是相同的</p><ol type="1"><li>我们可以利用这一点来选择一种顺序，满足：每个<strong>CJUMP</strong>后面跟着它的<strong>False_Label</strong>的块</li><li>我们还可以安排，每个<strong>JUMP</strong>后面紧跟着它们的<strong>目标Label</strong>。这将允许删除这些跳转，这将使编译后的程序运行得更快</li></ol><p>Trace：</p><ol type="1"><li>Trace是在程序执行过程中可以<strong>连续执行</strong>的一系列语句。它可以包括条件分支</li><li>我们想要制作一组包含整个程序的Traces：每个Block必须正好在一个Trace中</li><li>我们希望在我们的covering set中有尽可能少的Trace</li></ol><h3 id="算法-2">8.3.1 算法</h3><p>思想：从一些block开始，沿着某一条可能的执行路径，到达trace的终点</p><blockquote><p>设b1→b4→b6，则这个trace为：b1, b4, b6</p><p>设b6的结尾为条件跳转<strong>CJUMP(cond, b7,b3)</strong>，则将b3添加进trace中，b7会进入其他的trace</p></blockquote><p>算法：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">将程序的所有block添加进列表Q</span><br><span class="line">while (Q不为空) &#123;</span><br><span class="line">创建一个空的trace, 记为T</span><br><span class="line">删除Q中的第一个块b</span><br><span class="line">while (b没有被标记过) &#123;</span><br><span class="line">标记b</span><br><span class="line">将b添加到T的结尾</span><br><span class="line">检查b执行结束之后可能会进入的块c</span><br><span class="line">if (c没有被标记)&#123;</span><br><span class="line">b ← c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结束当前的trace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finishing-up">8.3.2 Finishing Up</h3><p>将有序的trace列表展开为一个语句的列表</p><ol type="1"><li><p>所有<strong>CJUMP</strong>后面为它的<strong>False_Label</strong>的，保留</p></li><li><p>所有<strong>CJUMP</strong>后面为它的<strong>True_Label</strong>的，将条件取反，并交换<strong>True_Label</strong>和<strong>False_Label</strong></p></li><li><p>所有<strong>CJUMP(cond, a, b, It,If)</strong>后面为其他标签的，创建一个新的<strong>Fals_LabelIf'</strong>，重写<strong>CJUMP</strong>使得其后面为它的<strong>False_Label</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CJUMP(cond, a, b, It, If_);</span><br><span class="line">LABEL If_;</span><br><span class="line">JUMP(NAME If);</span><br></pre></td></tr></table></figure></li></ol><h2 id="优化-trace">8.4 优化 Trace</h2><p>对于频繁执行的指令序列(如循环体)，应该具有自己的trace：</p><ol type="1"><li>这有助于最小化<strong>JUMP</strong>的数目</li><li>且有助于其他类型的优化，如寄存器分配、指令调度</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230417224345490.png" alt="image-20230417224345490" style="zoom:80%;" /></p><p>C最好，因为可以删除 JUMP(NAME test) 这句话</p></blockquote><h1 id="九指令选择">九、指令选择</h1><p>任务：将IR树转化为机器指令，暂时不考虑寄存器够不够的问题</p><h2 id="overview-1">Overview</h2><h3 id="jouette-architecture-指令集">9.0.1 Jouette architecture指令集</h3><ol type="1"><li>寄存器<code>r0</code>始终为0</li><li>TEMP节点也被视作一个寄存器</li><li>有些指令可能对应多个树模式</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508100735256.png" alt="image-20230508100735256" style="zoom:80%;" /></p><h3 id="将ir树转化为指令">9.0.2 将IR树转化为指令</h3><ol type="1"><li>基础思想：将已有的指令及其对应的树结构当作<strong>tile</strong>，用tile覆盖整个<strong>IR树</strong></li><li>注意，覆盖的方式可能不同，且覆盖有先后顺序</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508102001642.png" alt="image-20230508102001642" style="zoom:80%;" /></p><h3 id="最优覆盖">9.0.3 最优覆盖</h3><ol type="1"><li>产生的指令序列最短</li><li>或者使用成本最低的序列，因为不同指令的指令周期不同</li></ol><p>Optimal &amp; Optimum tiling：</p><ol type="1"><li>Optimum tiling：最优解，得到成本最低的tile覆盖</li><li>Optimaltiling：无法再优化的解，得到一个tile覆盖后，相邻的两个瓦片无法再合并为一个</li><li>Optimum一定是Optimal，但Optimal不一定是Optimum</li></ol><h2 id="指令选择的算法">9.1 指令选择的算法</h2><ol type="1"><li>对于CISC指令集来说，Optimum和Optimal的区别较大，因为这种指令粒度较大</li><li>对于RISC指令集来说，Optimum和Optimal的区别不大</li></ol><h3 id="maximal-munch算法">9.1.1 Maximal Munch算法</h3><p><strong>maximal munch</strong>主要思想：</p><ol type="1"><li>从树的根开始，找到最大的能匹配的tile，覆盖掉根节点以及几个子节点</li><li>将覆盖过的节点删除，会将树划分为几个子树</li><li>对剩下的子树重新执行1操作，直到所有节点都被覆盖</li></ol><p>算法解释：</p><ol type="1"><li>生成指令的顺序为逆序</li><li>如果有两个同样大小的tile覆盖根节点，则随意选择一个</li><li>有两个函数：munchStm、munchExp</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508104357860.png" alt="image-20230508104357860" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508104411883.png" alt="image-20230508104411883" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508104436671.png" alt="image-20230508104436671" style="zoom:80%;" /></p></blockquote><h3 id="动态规划算法">9.1.2 动态规划算法</h3><ol type="1"><li>可以找到Optimum最优解</li><li>算法是自底向上的</li><li>每次选择最小cost的match</li></ol><h4 id="算法描述">9.1.2.1 算法描述</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508104844190.png" alt="image-20230508104844190" style="zoom:80%;" /></p><p>一旦找到了根节点的cost，说明找到了整个树的cost，就会开始指令生成</p><ol type="1"><li>Emission(noden)：对于节点n选择的tile每个叶节点li，执行Emission(li)，然后再执行节点n的指令选择</li><li>Emission(n)不会在节点n的子节点上递归，而是在节点n处匹配的tile树上递归</li></ol><h4 id="对指令集的进一步划分">9.1.2.2 对指令集的进一步划分</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508105506270.png" alt="image-20230508105506270" style="zoom:80%;" /></p><p>使用CFG描述tiles：</p><ol type="1"><li>s：语句</li><li>a：将表达式的值赋值给一个地址寄存器</li><li>d：将表达式的值赋值给一个数据寄存器</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508105649097.png" alt="image-20230508105649097" style="zoom:80%;" /></p><h3 id="快速匹配">9.1.3 快速匹配</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508105755975.png" alt="image-20230508105755975" style="zoom:80%;" /></p><h3 id="tiling算法的效率">9.1.4 Tiling算法的效率</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508105836036.png" alt="image-20230508105836036" style="zoom:80%;" /></p><h2 id="cisc指令">9.2 CISC指令</h2><h3 id="risc指令集特点">9.2.1 RISC指令集特点</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508110855781.png" alt="image-20230508110855781" style="zoom:80%;" /></p><h3 id="cisc指令集特点">9.2.2 CISC指令集特点</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508110911242.png" alt="image-20230508110911242" style="zoom:80%;" /></p><h2 id="cisc的问题和解决方法">9.3 CISC的问题和解决方法</h2><ol type="1"><li><p>寄存器的分类：有些指令架构的指令要求特定寄存器才能使用</p><ol type="1"><li>解决方法：将operand和result进行move</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508111346077.png" alt="image-20230508111346077" style="zoom:80%;" /></p></li><li><p>二地址指令</p><ol type="1"><li>添加额外的指令</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508111412410.png" alt="image-20230508111412410" style="zoom:80%;" /></p></li><li><p>算术运算可能会访问内存：指令选择阶段将每个TEMP节点变成一个“寄存器”引用，这些“寄存器”中的许多实际上将成为内存位置</p><ol type="1"><li>在操作之前将所有操作数取入寄存器，然后将其存储回内存</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508111648518.png" alt="image-20230508111648518" style="zoom:80%;" /></p></li><li><p>几种寻址模式：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508111818397.png" alt="image-20230508111818397" style="zoom:80%;" /></p></li><li><p>可变长指令：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508111825572.png" alt="image-20230508111825572" style="zoom:80%;" /></p></li><li><p>有边缘效应的指令：有些机器有一个“自动递增”内存提取指令，其效果是</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230508111848319.png" alt="image-20230508111848319" style="zoom:80%;" /></p></li></ol><h1 id="十活性分析">十、活性分析</h1><p>目的：判断每个变量的活性，影响最后的寄存器分配</p><p>如何做：控制流、从未来推出过去</p><p>变量的活性：定义=&gt;使用，整个过程必须是活的</p><blockquote><p>粗线代表每个变量为liveness的周期</p><ol type="1"><li>从下图可知，a和b不会同时为livenes，因此a和b可以使用同一个寄存器</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515102016319.png" alt="image-20230515102016319" style="zoom:80%;" /></p></blockquote><h2 id="数据流方程的求解">10.1 数据流方程的求解</h2><h3 id="相关定义">10.1.1 相关定义</h3><p><strong>Flow-graph terminology</strong>：</p><ol type="1"><li>out-edge：指向后继节点的边，<strong>succ[n]</strong>表示当前节点的后继节点</li><li>in-edge：从前序节点指向当前节点，<strong>pred[n]</strong>表示当前节点的前序节点</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515102411421.png" alt="image-20230515102411421" style="zoom:80%;" /></p></blockquote><p><strong>Uses and defs</strong>：</p><ol type="1"><li>use：对变量的访问，即变量出现在赋值语句的右边，<strong>use[i]</strong>表示当前节点使用到的变量</li><li>def：对变量的定义，即变量出现在赋值语句的左边，<strong>def[i]</strong>表示当前节点定义的变量</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515102655658.png" alt="image-20230515102655658" style="zoom:80%;" /></p></blockquote><p><strong>Liveness</strong>：</p><ol type="1"><li>live-in：该变量在当前节点的in-edge上是活跃的</li><li>live-out：该变量在当前节点的out-edge上是活跃的</li></ol><h3 id="计算liveness">10.1.2 计算Liveness</h3><ol type="1"><li>如果变量在<strong>use[n]</strong>中，则它是<strong>节点n的live-in</strong></li><li>如果变量是<strong>节点n的live-in</strong>，则它是<strong>pred[n]</strong>中所有节点的<strong>live-out</strong></li><li>如果变量是<strong>节点n的live-out</strong>，且不在<strong>def[n]</strong>中，则它是<strong>节点n的live-in</strong></li></ol><h3 id="数据流方程">10.1.3 数据流方程</h3><p><span class="math display">\[\begin{aligned}in[n]   &amp;=use[n]\cup(out[n]-def[n])\\out[n]  &amp;=\cup_{s\in succ[n]}in[s]\end{aligned}\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515103250601.png" alt="image-20230515103250601" style="zoom:80%;" /></p><blockquote><p>示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515103600986.png" alt="image-20230515103600986" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515103550190.png" alt="image-20230515103550190" style="zoom:80%;" /></p><p>迭代次数多的原因：计算当前节点的out[n]时，需要先知道后继节点的in[n]</p><ol type="1"><li>倒过来计算的过程</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515104108315.png" alt="image-20230515104108315" style="zoom:80%;" /></p></blockquote><h3 id="与基本块结合">10.1.4 与基本块结合</h3><ol type="1"><li>Basic Block内的每个节点，均只有1个前序节点，1个后继节点</li><li>可以将Basic Block看作一整个node，他们的in[]、out[]合并到一起</li></ol><h3 id="表示inout集合">10.1.5 表示in、out集合</h3><ol type="1"><li><p>bit-array：</p><ol type="1"><li>设程序中有n个变量，则每个集合需要使用n-bit</li><li>计算两个set的并集，即将两个n-bit数做或运算</li></ol></li><li><p>Sorted List：</p><ol type="1"><li>按照变量名排序，记录当前节点的in、out集合</li><li>计算两个set的并集，即将两个链表合并</li></ol></li><li><p>计算的时间复杂度：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515104644473.png" alt="image-20230515104644473" style="zoom:80%;" /></p></li></ol><h3 id="最小不动点-least-fixed-point">10.1.6 最小不动点Least-Fixed-Point</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515104852113.png" alt="image-20230515104852113" style="zoom:80%;" /></p><ol type="1"><li>上述算法是<strong>conservative approximation保守近似</strong></li><li>在如上例子中，d是live-out的，但不意味着d一定会被用到</li></ol><h3 id="static-vs-dynamic-liveness">10.1.7 Static vs DynamicLiveness</h3><p>定理：不存在程序H(P,X)，返回如果P(X)可以停机就是true，否则为false</p><ol type="1"><li>P：任意一个程序</li><li>X：P的输入</li></ol><p>推论：不存在程序H'(P, L)，返回在P的计算中，L是否可以到达</p><ol type="1"><li>P：任意一个程序</li><li>L：P中的一个label</li></ol><p><strong>Dynamic Liveness</strong>：</p><ol type="1"><li>如果程序的某个执行从节点n到a的一个使用之间没有经过a的任何定义，那么变量a在节点n是动态活跃的</li></ol><p><strong>Static Liveness</strong>：</p><ol type="1"><li>如果存在一条从节点n到a的某个使用的控制流路径，且此路径上没有a的任何定值，那么变量a在节点n是静态活跃的</li></ol><p>如果a为动态活跃，则a也为静态活跃。因此编译器通常根据静态活跃信息来进行寄存器分配和其他优化</p><h3 id="干涉图-interference-graphs">10.1.8 干涉图 InterferenceGraphs</h3><ol type="1"><li>设变量集合为{a, b, c, ...}，寄存器集合为{r<sub>1</sub>, ...,r<sub>k</sub>}</li><li>阻止将a和b分配到同一个寄存器的条件称为interference</li></ol><p>interference的常见情况：</p><ol type="1"><li>活性周期有重合</li><li>如果生成a的指令无法寻址寄存器r1，则a和r1也是interfere的</li></ol><p>冲突信息可以用矩阵来表示，也可以用无向图来表示</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515112000976.png" alt="image-20230515112000976" style="zoom:80%;" /></p><p>MOVE指令的特殊处理：</p><ol type="1"><li>下列情况中，s和t的内容完全相同，因此不需要添加(s,t)的干涉边</li><li>当然，如果之后还有t的另一个定义，且该时刻s仍然是活跃的，则要创建(s,t)的干涉边</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515110515633.png" alt="image-20230515110515633" style="zoom:80%;" /></p><p>因此，为每一个新定义的值添加冲突边的方法为：</p><ol type="1"><li>对于任何定义变量a的非copy指令，以及在该指令处是live-out的变量{b1,... bj}，添加干涉边(a, b1)，...，(a, bj)</li><li>对于copy指令a←c，以及在该指令处是live-out的变量{b1, ...bj}，对每一个不同于c的bi添加干涉边(a, b1)，...，(a, bj)</li></ol><h1 id="十一寄存器分配">十一、寄存器分配</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230522100931468.png" alt="image-20230522100931468" style="zoom:80%;" /></p><p>寄存器分配的任务：</p><ol type="1"><li>将大量的临时变量分配到少量寄存器中</li><li>在可能的情况下，给一条MOVE指令的源地址和目的地址分配同一个寄存器，以便能删除该MOVE指令</li><li>在干涉图上执行<strong>着色算法</strong></li></ol><h2 id="通过简化进行着色">11.1 通过简化进行着色</h2><ol type="1"><li>寄存器分配是一个NP-Complete问题</li><li>可以使用一个线性近似算法得到一个较优解</li></ol><h3 id="build-构造">11.1.1 Build 构造</h3><p>构造冲突图</p><ol type="1"><li>利用数据流分析方法，计算在每隔程序点同时活跃的临时变量集合</li><li>由该集合中的每一对临时变量形成一条边。并将这些边加入冲突图中</li><li>对程序中的没一点重复这一过程</li></ol><h3 id="simplify-简化">11.1.2 Simplify 简化</h3><p>用一个简单的启发式方法，对图进行着色</p><ol type="1"><li>设图<span class="math inline">\(G\)</span>有一个节点<spanclass="math inline">\(m\)</span>，<strong>它的相邻节点小于<spanclass="math inline">\(K\)</span>个</strong>，<spanclass="math inline">\(K\)</span>是实际寄存器的个数</li><li>令<span class="math inline">\(G&#39;=G-\{m\}\)</span>，如果<spanclass="math inline">\(G&#39;\)</span>能够使用<spanclass="math inline">\(K\)</span>种颜色着色，那么<spanclass="math inline">\(G\)</span>也可以<ol type="1"><li>因为当将m添加到一着色的图<spanclass="math inline">\(G&#39;\)</span>时，<spanclass="math inline">\(m\)</span>的相邻节点至多使用了<spanclass="math inline">\(K-1\)</span>种颜色</li><li>所以总是能找到一种颜色作为<spanclass="math inline">\(m\)</span>的颜色</li></ol></li></ol><p>这很自然的导出了一种<strong>递归(stack-based orrecursive)</strong>的图着色算法：</p><ol type="1"><li>重复删除<span class="math inline">\(degree&lt;K\)</span>的节点，并将其压入栈中</li><li>每简化掉一个节点，都会减少其他节点的度数，从而产生更多的简化机会</li></ol><h3 id="spill-溢出">11.1.3 Spill 溢出</h3><p>在简化过程的某一点，图<spanclass="math inline">\(G\)</span>只包含<spanclass="math inline">\(degree\ge K\)</span>的节点</p><ol type="1"><li>在图中选择一个节点，并决定在程序执行期间，它存储在memory中</li><li>我们对这个溢出的效果做出乐观的估计，寄希望与这个被溢出的节点将来并不会与留在图中的其他节点发生冲突</li><li>因此可以将这个选中的节点从图中删除，并压入栈中，然后继续进行SImplify操作</li></ol><h3 id="select-选择">11.1.4 Select 选择</h3><p>将颜色指定给图中的节点</p><ol type="1"><li>从一个空的图开始，重复的将栈顶结点添加到图中，重建原来的冲突图</li><li>根据简化阶段的定义，每次往图中添加一个节点时，一定会由一种它可以使用的颜色</li></ol><p>当从栈中弹出一个用<strong>溢出</strong>启发式算法压入栈的<strong>潜在溢出</strong>节点<spanclass="math inline">\(n\)</span>时，并不能保证它是可着色的</p><ol type="1"><li>在图中，它的相邻节点可能已经使用了<spanclass="math inline">\(K\)</span>中不同的颜色</li><li>在这种情况下，我们就会有一个<strong>实际溢出</strong></li><li>此时，我们不知拍任何颜色，而是继续执行Select操作，来识别其他的实际溢出</li></ol><p>但是，潜在溢出节点<spanclass="math inline">\(n\)</span>的相邻节点，可能使用相同的颜色，导致总颜色种类数<spanclass="math inline">\(&lt;K\)</span></p><ol type="1"><li>此时，我们就可以给节点<spanclass="math inline">\(n\)</span>着色，并且它不会称为一个实际溢出</li><li>这种方法被称为<strong>优化着色 optimisitic coloring</strong></li></ol><h3 id="start-over-重新开始">11.1.5 Start Over 重新开始</h3><ol type="1"><li>如果Select阶段不能为某些节点找到颜色，则必须对程序进行改写，使得在每次使用这些节点之前，将它们从memory中读出，在每次对这些节点赋值之后，将它存回memory中</li><li>这样，一个被溢出的临时变量就会转变为几个具有较小活跃范围的新的临时变量。这些新的临时变量可能会与图中的其它临时变量发生冲突，因此对改写后的程序还要重新进行一次寄存器分配。</li><li>这种处理过程反复迭代，直到没有溢出而简化成功为止</li></ol><h2 id="合并-coalescing">11.2 合并 Coalescing</h2><p>如果一条MOVE指令对应的两个节点之间不存在边，则可以删除该MOVE指令，并且将两个节点合并为一个节点。</p><p>由于合并会导致节点的度数增加，从而可能使图无法进行K着色，因此存在两种合并策略：</p><h3 id="合并策略">11.2.1 合并策略</h3><ol type="1"><li><strong>Briggs</strong>：如果节点<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>合并产生的节点ab的高度数(<spanclass="math inline">\(\ge K\)</span>)相邻节点的个数少于<spanclass="math inline">\(K\)</span>个，则节点<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>可以合并</li><li><strong>George</strong>：如果对于<spanclass="math inline">\(a\)</span>的每一个邻居<spanclass="math inline">\(t\)</span>，<spanclass="math inline">\(t\)</span>要么与<spanclass="math inline">\(b\)</span>有冲突，要么是低度数(<spanclass="math inline">\(&lt;K\)</span>)的节点，则<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>可以合并</li></ol><h3 id="带有合并的着色算法">11.2.2 带有合并的着色算法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230522105241793.png" alt="image-20230522105241793" style="zoom:80%;" /></p><ol type="1"><li><strong>构造</strong>：<ol type="1"><li>构造冲突图</li><li>将每个节点分为<strong>move-related</strong> or<strong>non-move-related</strong><ol type="1"><li>move-related：该节点是一条MOVE指令的操作数</li></ol></li></ol></li><li><strong>简化</strong>：<ol type="1"><li>每次从图中删除<strong>低度数的且传递无关</strong>的节点</li></ol></li><li><strong>合并</strong>：<ol type="1"><li>对简化阶段得到的简化图，执行保守的合并</li></ol></li><li><strong>冻结</strong>：<ol type="1"><li>如果Simplify和Coalesce均不能操作，则找到一个<strong>度数较低的传递有关</strong>的节点，冻结该节点，然后重新开始Simplify和Coalesce操作</li><li>冻结：放弃对该MOVE指令进行合并的希望，将该节点视为传递无关的</li></ol></li><li><strong>溢出</strong>：<ol type="1"><li>如果没有低度数的节点，选择一个潜在可能溢出的高度数节点，并将其压入栈</li></ol></li><li><strong>选择</strong>：<ol type="1"><li>弹出整个栈，并给每个节点着色</li></ol></li></ol><h2 id="预着色的节点-precolored-node">11.3 预着色的节点 PrecoloredNode</h2><ol type="1"><li>有一些临时变量是<strong>预着色</strong>的，它们代表的是机器寄存器</li><li>对于每一个由专门用途的真实寄存器，算法应该使用与这些寄存器永久绑定的特殊临时变量</li><li>对于任一给定颜色(机器寄存器)，应该只有一种使用这种颜色的预着色节点</li><li>Select和Coalescing操作可以给普通临时变量分配与预着色寄存器相同的颜色，只要它们之间不发生冲突，即：<ol type="1"><li>一个调用约定的标准寄存器能够在过程中重新用于临时变量</li><li>预着色节点可以通过保守合并算法，与其他非预着色节点合并</li></ol></li><li>预着色节点有指定的颜色，且不能将其溢出到寄存器</li></ol><h3 id="机器寄存器的临时副本">11.3.1 机器寄存器的临时副本</h3><p><strong>着色算法通过不断执行Simplify、Coalescing、Spill操作，直到只剩下预着色节点，然后Select阶段才能开始向冲突图中加入其他节点，并且对它们进行着色</strong></p><ol type="1"><li>预着色节点不能被溢出，因此前端必须尽可能让它们的活跃范围较小</li><li>可以通过生成保存和恢复预着色节点值的MOVE指令来实现这一点</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230522115203138.png" alt="image-20230522115203138" style="zoom:80%;" /></p></blockquote><h3 id="caller-saved寄存器calllee-saved寄存器">11.3.2caller-saved寄存器、calllee-saved寄存器</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230522115231125.png" alt="image-20230522115231125" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-21：动画/模拟/仿真</title>
      <link href="/2023/02/22/GAMES101/21--%E5%8A%A8%E7%94%BB/"/>
      <url>/2023/02/22/GAMES101/21--%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="二十一动画模拟仿真">二十一、动画/模拟/仿真</h1><h2 id="关键帧动画">21.1 关键帧动画</h2><ol type="1"><li>给定一系列关键的帧，通过<strong>插值</strong>，将中间的帧补全</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406213305918.png" alt="image-20230406213305918" style="zoom:80%;" /></p><h2 id="物理模拟">21.2 物理模拟</h2><ol type="1"><li>建立物理模型，解某个时刻对应的方程</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406213618926.png" alt="image-20230406213618926" style="zoom:80%;" /></p><h3 id="质点弹簧系统-mass-spring-system">21.2.1 质点弹簧系统 Mass SpringSystem</h3><ol type="1"><li>是一系列相互连接的质点和弹簧</li></ol><h4 id="理想弹簧">21.2.1.1 理想弹簧</h4><ol type="1"><li>弹簧没有长度，弹簧的力只与其被拉伸的长度有关</li><li><span class="math inline">\(k_s\)</span>：劲度系数</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406214224321.png" alt="image-20230406214224321" style="zoom:80%;" /></p><h4 id="非零长度弹簧">21.2.1.2 非零长度弹簧</h4><ol type="1"><li>在理想弹簧的基础上，弹簧的初始长度为<spanclass="math inline">\(l\)</span></li><li>问题：由于动能和弹性势能的相互转换，弹簧会永远震动下去</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406214307106.png" alt="image-20230406214307106" style="zoom:80%;" /></p><h4 id="添加能量流失">21.2.1.3 添加能量流失</h4><ol type="1"><li>在非零长度弹簧的基础上，添加一个摩擦力<spanclass="math inline">\(f=-k_d\dot b\)</span>，使弹簧能够停下来</li><li><span class="math inline">\(k_d\)</span>：阻尼系数 dampingcoefficient</li><li>问题：只能表示弹簧整体的能量损耗，不能表示弹簧内部的能量损耗</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406215157003.png" alt="image-20230406215157003" style="zoom:80%;" /></p><h4 id="添加内部阻尼">21.2.1.4 添加内部阻尼</h4><ol type="1"><li>在上述弹簧的基础上，添加内部阻尼，以让弹簧能够恢复原样<ol type="1"><li>相对速度的投影：分解到沿着ab方向的速度，只有这个速度会让弹簧产生形变</li></ol></li><li>内部阻尼与弹簧的直接形变没有关系，只与ab的相对速度有关系</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406215514210.png" alt="image-20230406215514210" style="zoom:80%;" /></p><h4 id="弹簧的结构">21.2.1.5 弹簧的结构</h4><p>用网格结构的弹簧模拟布料</p><ol type="1"><li>无法抵抗切变的力：从</li><li>无法抵抗out-of-plane的力</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406215820111.png" alt="image-20230406215820111" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406220402457.png" alt="image-20230406220402457" style="zoom:80%;" /></p><blockquote><p>添加两个方向的对角线方向的弹簧，抵抗切变的力：</p><ol type="1"><li>当从两端拉弹簧时，对角线上的弹簧会被压缩，从而产生抵抗切变的力</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230406220645857.png" alt="image-20230406220645857" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-19：相机&amp;透镜&amp;光场</title>
      <link href="/2023/02/21/GAMES101/19--%E7%9B%B8%E6%9C%BA&amp;%E9%80%8F%E9%95%9C&amp;%E5%85%89%E5%9C%BA/"/>
      <url>/2023/02/21/GAMES101/19--%E7%9B%B8%E6%9C%BA&amp;%E9%80%8F%E9%95%9C&amp;%E5%85%89%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十九相机透镜光场">十九、相机&amp;透镜&amp;光场</h1><h2 id="相机">19.1 相机</h2><p>快门：控制光在某个极短时间内进入相机</p><p>传感器：将光的信息记录下来，只能记录Irradiance，不能记录radiance，因此需要小孔/棱镜成像</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331150921690.png" alt="image-20230331150921690" style="zoom:80%;" /></p><h3 id="针孔相机">19.1.1 针孔相机</h3><ol type="1"><li>没有景深的效果，不会模糊</li></ol><h3 id="基础概念">19.1.2 基础概念</h3><h4 id="视场-fov">19.1.2.1 视场 FOV</h4><p><strong>FOV</strong>：视场</p><ol type="1"><li>传感器高度：<strong>h</strong></li><li>传感器到小孔的距离：<strong>焦距f</strong></li><li>焦距越大，视场越大</li><li>传感器越小，视场越小</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331151043290.png" alt="image-20230331151043290" style="zoom:80%;" /></p><blockquote><p>以<strong>35mm格式</strong>的胶片为标准，通过更改<strong>焦距f</strong>，定义视场</p><ol type="1"><li>也就是确定了传感器高度<strong>h</strong></li><li>通常说的是等效到35mm格式，而不是传感器就是35mm</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331151357618.png" alt="image-20230331151357618" style="zoom:80%;" /></p><p>传感器sensor和胶片film可以不一样，但可以当作是一样的</p><ol type="1"><li>传感器：接收到了具体信息</li><li>胶片：最后呈现的效果</li></ol><blockquote><p>小的传感器 + 小焦距，可以得到相同的视场</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331151711271.png" alt="image-20230331151711271" style="zoom:80%;" /></p><h4 id="曝光度-exposure">19.1.2.2 曝光度 Exposure</h4><p><strong>Exposure = 时间(T) × Irradiance(E)</strong></p><ol type="1"><li>时间越长、单位时间内接收到的能量越多，最后的曝光度越大</li><li>曝光度记录的是energy，而不是power</li><li>时间：由快门控制</li><li>Irradiance：由很多因素决定，如光圈</li></ol><h4 id="影响曝光度的因素光圈快门iso">19.1.2.3影响曝光度的因素：光圈&amp;快门&amp;ISO</h4><ol type="1"><li>光圈<strong>ApertureSize</strong>：用<strong><code>FN</code>或<code>F/N</code></strong>表示<ol type="1"><li>模拟人的瞳孔，通过<strong>F-stop/F-number</strong>控制开关</li><li><strong>N</strong>对应光圈半径的倒数</li><li><strong>光圈越大，越亮，但是远的部分越模糊</strong></li><li>如果要考虑景深，光圈就应该小，图像就会暗，因此就需要更长的快门时间，从而无法考虑运动模糊的问题</li></ol></li><li>快门<strong>Shutter speed</strong>：用分数表示<ol type="1"><li>控制记录的时间</li><li><strong>时间越长，越模糊</strong></li><li>因为存在运动模糊效果：对快门时间内记录到的所有信息做了一个平均</li><li>相当于在时间上采样时，做了一个模糊效果</li><li><strong>Rollingshutter</strong>：对于高速运动的物体，可能会出现扭曲的现象</li></ol></li><li>感光度<strong>ISO gain</strong>：用ISOxx表示<ol type="1"><li>类似于后期处理，对接收到的光乘上某个数</li><li>可以发生在硬件上，也可以发生在软件上</li><li><strong>ISO越大，越亮，但是噪声也越大</strong></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331152235235.png" alt="image-20230331152235235" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331153511790.png" alt="image-20230331153511790" style="zoom:80%;" /></p><h4 id="高速低速摄影">19.1.2.4 高速/低速摄影</h4><p><strong>高速摄影</strong></p><ol type="1"><li>即每秒钟要拍更多的照片</li><li>快门时间变短，同时需要更大的光圈</li></ol><p><strong>低速摄影/延迟摄影</strong></p><ol type="1"><li>即每秒钟要拍更少的照片</li><li>快门时间变长，就是需要运动模糊</li></ol><h2 id="薄透镜近似">19.2 薄透镜近似</h2><h3 id="理想化薄透镜">19.2.1 理想化薄透镜</h3><ol type="1"><li>平行光可以汇聚到焦点上，过交点可以发散为平行光</li><li>过中心不改变光路</li><li>可以任意更改焦距：通过透镜组，动态改变焦距</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331154506466.png" alt="image-20230331154506466" style="zoom:80%;" /></p><h3 id="焦散模糊-defocus-blur">19.2.2 焦散模糊 Defocus Blur</h3><p><strong>CoC</strong>：Circle of Confusion</p><ol type="1"><li>当感光器在成像点后面时，会导致成像为一个圆</li><li>光圈越大，CoC越大</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331155356722.png" alt="image-20230331155356722" style="zoom:80%;" /></p><h3 id="f-number的定义">19.2.3 F-Number的定义</h3><ol type="1"><li>F-Number = 焦距 / 光圈直径</li><li>拍的更清楚 =&gt; 使用小光圈</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331155149689.png" alt="image-20230331155149689" style="zoom:80%;" /></p><h2 id="光线追踪模拟薄透镜">19.3 光线追踪模拟薄透镜</h2><h3 id="定义">19.3.1 定义</h3><ol type="1"><li>感光器的大小</li><li>焦距、光圈大小</li><li>物体与棱镜的距离，即物距<strong>z<sub>o</sub></strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331155614225.png" alt="image-20230331155614225" style="zoom:80%;" /></p><h3 id="渲染方式">19.3.2 渲染方式</h3><ol type="1"><li>在感光元件上选一个点<strong>x'</strong></li><li>在透镜上选另一个点<strong>x''</strong></li><li>连接<strong>x'</strong>和<strong>x''</strong>，可以得到通过该透镜后的光线<strong>x''→x'''</strong></li><li>考虑<strong>x''→x'''</strong>的Radiance，记录到<strong>x'</strong>上即可</li></ol><h2 id="景深-depth-of-fielddf-dn">19.4 景深 Depth ofField：D<sub>F</sub> ~ D<sub>N</sub></h2><ol type="1"><li>用不同的光圈，会影响模糊的范围</li><li>在<strong>实际场景</strong>中有<strong>一段深度(景深)</strong>，这段通过透镜，会在成像区域附近形成一个区域，我们认为这个区域内的CoC都是足够小的</li><li>这段深度内的像素，认为均是锐利的，即不模糊的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331160147996.png" alt="image-20230331160147996" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331161005848.png" alt="image-20230331161005848" style="zoom:80%;" /></p><h2 id="光场-light-field-lumigraph">19.5 光场 Light Field /Lumigraph</h2><h3 id="全光函数-plenoptic-function">19.5.1 全光函数 PlenopticFunction</h3><h4 id="grayscale-snapshotpθ-φ">19.5.1.1 Grayscale snapshot：P(θ,Φ)</h4><ol type="1"><li>定义了在一个固定地方，向任意一个<strong>方向(θ,Φ)</strong>看，能够看到的亮度值</li></ol><h4 id="color-snapshotpθ-φ-λ">19.5.1.2 Color snapshot：P(θ, Φ, λ)</h4><ol type="1"><li>定义了在一个固定地方，向任意一个<strong>方向(θ,Φ)</strong>看，能够看到的<strong>波长为λ</strong>的亮度值</li></ol><h4 id="moviepθ-φ-λ-t">19.5.1.3 Movie：P(θ, Φ, λ, t)</h4><ol type="1"><li>定义了在一个固定地方，在某个<strong>时间t</strong>，向任意一个<strong>方向(θ,Φ)</strong>看，能够看到的<strong>波长为λ</strong>的亮度值</li><li>即电影</li></ol><h4 id="holographic-moviepθ-φ-λ-t-vx-vy-vz">19.5.1.4 HolographicMovie：P(θ, Φ, λ, t, V<sub>X</sub>, V<sub>Y</sub>, V<sub>Z</sub>)</h4><ol type="1"><li>定义了在某个<strong>位置(V<sub>X</sub>, V<sub>Y</sub>,V<sub>Z</sub>)</strong>，在某个<strong>时间t</strong>，向任意一个<strong>方向(θ,Φ)</strong>看，能够看到的<strong>波长为λ</strong>的亮度值</li><li>即全息电影</li></ol><h4 id="plenoptic-functionpθ-φ-λ-t-vx-vy-vz">19.5.1.5 PlenopticFunction：P(θ, Φ, λ, t, V<sub>X</sub>, V<sub>Y</sub>,V<sub>Z</sub>)</h4><ol type="1"><li>在任何<strong>时间t</strong>、任何<strong>地点V</strong>、向任何<strong>方向(θ,Φ)</strong>看，所能看到的所有的<strong>光λ</strong></li><li>是一个七维函数</li></ol><h3 id="光线的定义">19.5.2 光线的定义</h3><p>5个维度：<strong>P(θ, Φ, V<sub>X</sub>, V<sub>Y</sub>,V<sub>Z</sub>)</strong></p><ol type="1"><li>3个维度的坐标</li><li>2个维度的方向</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331162624696.png" alt="image-20230331162624696" style="zoom:80%;" /></p><p>4个维度：</p><ol type="1"><li>2维的位置：<strong>(u, v)</strong></li><li>2维的方向：<strong>(θ, Φ)</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331162633863.png" alt="image-20230331162633863" style="zoom:80%;" /></p><h3 id="全光表面-plenoptic-surface">19.5.3 全光表面 PlenopticSurface</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331162812295.png" alt="image-20230331162812295" style="zoom:80%;" /></p><p>光场：任何一个位置，往任何一个方向去的光的强度</p><ol type="1"><li>在表面的位置：<strong>(u, v)</strong></li><li>方向：<strong>(θ, Φ)</strong></li><li>从任意一个位置，往任意一个方向看，都看到该光场的强度</li></ol><h3 id="光场">19.5.4 光场</h3><p>不需要直到物体具体是什么，只需要直到<strong>包围盒外</strong>的光场信息</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331163303962.png" alt="image-20230331163303962" style="zoom:80%;" /></p><h3 id="lumigraph-organization">19.5.5 Lumigraph-Organization</h3><p>取一个平面，只需要直到该平面上任何一个位置，往任何一个方向去的光的强度</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331163416657.png" alt="image-20230331163416657" style="zoom:80%;" /></p><p>也可以定义两个平面<strong>(u,v) &amp; (s,t)</strong>，定义该光线</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331163525401.png" alt="image-20230331163525401" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331164408327.png" alt="image-20230331164408327" style="zoom:80%;" /></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230331164514848.png" alt="image-20230331164514848" style="zoom:80%;" /></p></blockquote><h3 id="光场摄像机">19.5.6 光场摄像机</h3>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-18：高级渲染</title>
      <link href="/2023/02/20/GAMES101/18--%E9%AB%98%E7%BA%A7%E6%B8%B2%E6%9F%93/"/>
      <url>/2023/02/20/GAMES101/18--%E9%AB%98%E7%BA%A7%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十八高级渲染">十八、高级渲染</h1><h2 id="高级光线传播">18.1 高级光线传播</h2><h3 id="无偏-有偏-蒙特卡洛估计">18.1.1 无偏 &amp; 有偏 蒙特卡洛估计</h3><ol type="1"><li>无偏：不论样本数是多少，估计值的期望总是正确的</li><li>有偏：期望和正确值不一样；但是样本数足够多时，会收敛到正确值<strong>consistency</strong><ol type="1"><li>有偏 = 模糊</li><li>一致性 = 样本足够多时可以收敛到不模糊</li></ol></li></ol><h3 id="双向路径追踪-bdpt">18.1.2 双向路径追踪 BDPT</h3><ol type="1"><li>从光源、观察点开始，分别生成两个不同的半路径</li><li>将半路径的端点连起来</li><li>缺点：渲染速度慢</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330220720680.png" alt="image-20230330220720680" style="zoom:80%;" /></p><blockquote><p>对于间接光较多的场景，双向路径追踪效果更好</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330220814339.png" alt="image-20230330220814339" style="zoom:80%;" /></p><h3 id="metropolis光线传播-mlt">18.1.3 Metropolis光线传播 MLT</h3><ol type="1"><li>用马尔科夫链进行采样<ol type="1"><li>马尔科夫链：当前有一个样本，返回一个与之接近的样本</li><li>优点：可以生成一个样本分布与与任意函数形状一致的PDF</li></ol></li><li>给任意一个路径，可以生成与之相似的路径：是一个局部的方法</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330221257024.png" alt="image-20230330221257024" style="zoom:80%;" /></p><blockquote><p>适用于做困难的路径传播，因为可以由一条较好的路径开始，找到更多的路径</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330221447583.png" alt="image-20230330221447583" style="zoom:80%;" /></p><p>缺点：</p><ol type="1"><li>难以在理论上计算收敛的速度</li><li>所有操作都是局部的，有的像素快，有的像素满，会很"脏"</li><li>难以用于动画的渲染</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330222050918.png" alt="image-20230330222050918" style="zoom:80%;" /></p></blockquote><h3 id="光子映射-photon-mapping">18.1.4 光子映射 Photon Mapping</h3><ol type="1"><li><p>适用于渲染SDS(Specular-Diffuse-Specular)路径、生成caustics</p><ol type="1"><li>caustics：由于光线的聚焦产生的非常强的高亮图案</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330222033557.png" alt="image-20230330222033557" style="zoom:80%;" /></p></li><li><p>分为两步：</p><ol type="1"><li>从光源开始，辐射光子，直到光子打到diffuse表面，将结果记录下来</li><li>从摄像机开始，发射半路径，直到路径打到diffuse表面上</li><li>计算局部密度估计 local density estimation：<ol type="1"><li>对任何一个着色点，取最近的n个光子，计算这n个光子占据的面积，计算其密度</li><li>n较少时，噪声大；n较大时，会模糊</li></ol></li></ol></li><li><p>有偏估计：</p><ol type="1"><li>因为dN / dA != ΔN / ΔA，只有ΔA很小时才接近dA</li><li>光子越多，找n个光子占据的面积越小，就更接近正确结果</li><li>不能确定ΔA，增加光子，因为ΔA永远不会接近dA</li></ol></li></ol><h3 id="vertex-connection-and-merging">18.1.5 Vertex Connection andMerging</h3><ol type="1"><li>将BDPT和光子映射结合起来</li><li>使用BDPT生成两段sub-path</li><li>如果有两段sub-path的终点非常接近，则使用光子映射计算其贡献</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330223206732.png" alt="image-20230330223206732" style="zoom: 80%;" /></p><h3 id="实时辐射度-instant-radiosity">18.1.6 实时辐射度 InstantRadiosity</h3><ol type="1"><li>已经被照亮的地方，认为是光源，照亮别的地方<ol type="1"><li>从光源开始发射sub-path，停在某些地方，形成新的光源VPL(Virtual PointLight)</li><li>用新的光源照亮着色点</li></ol></li><li>优点：快，并且效果较好</li><li>缺点：<ol type="1"><li>在缝隙处会出现问题</li><li>不能做glossy物体</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330223358225.png" alt="image-20230330223358225" style="zoom:80%;" /></p><h2 id="高级外观建模">18.2 高级外观建模</h2><p>外观 == 材质 == BRDF</p><h3 id="非表面模型云-烟雾等">18.2.1 非表面模型：云、 烟、雾等</h3><p><strong>Participating Media</strong>：参与介质</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330224145788.png" alt="image-20230330224145788" style="zoom:80%;" /></p><p><strong>Phase Function</strong>：相位函数，规定光线如何散射</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330224250395.png" alt="image-20230330224250395" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330224330452.png" alt="image-20230330224330452" style="zoom:80%;" /></p><h3 id="头发表面">18.2.2 头发表面</h3><p>会有两种高光：有色、无色</p><p><strong>Kajiya-Kay模型</strong>：光线打到圆柱上，会反射为圆锥</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330224648071.png" alt="image-20230330224648071" style="zoom:80%;" /></p><p><strong>Marschner模型</strong>：光线打到圆柱上，一部分会反射为圆锥，一部分会穿进去</p><ol type="1"><li><strong>R</strong>：直接反射</li><li><strong>TT</strong>：穿进头发，然后再穿出来</li><li><strong>TRT</strong>：穿进头发，发生反射，然后再穿出来</li><li>定义光线和一根圆柱如何作用：R、TT、TRT</li><li>根据光线传播，计算和多个头发的作用</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330224739393.png" alt="image-20230330224739393" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330225204954.png" alt="image-20230330225204954" style="zoom:80%;" /></p><p><strong>Double Cylinder Model</strong>：增加一个圆柱，模拟髓质</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330225312464.png" alt="image-20230330225312464" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330225323075.png" alt="image-20230330225323075" style="zoom:80%;" /></p><h3 id="颗粒材质granular">18.2.3 颗粒材质：Granular</h3><ol type="1"><li><p>由很多小石子构成的模型</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330225609403.png" alt="image-20230330225609403" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330225635165.png" alt="image-20230330225635165" style="zoom:80%;" /></p></li></ol><h3 id="表面模型次表面散射-bssrdf">18.2.4 表面模型：次表面散射BSSRDF</h3><p><strong>Translucent</strong>：光线从一个点进入表面，在物体内发生了一系列散射，然后再从另一个点钻出表面</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330225827858.png" alt="image-20230330225827858" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330225950269.png" alt="image-20230330225950269" style="zoom:80%;" /></p><p><strong>Dipole</strong>近似：在物体上下添加两个光源，模拟次表面反射的效果</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330230124438.png" alt="image-20230330230124438" style="zoom:80%;" /></p><h3 id="布料">18.2.5 布料</h3><p>布料的定义</p><ol type="1"><li>纤维的集合 fiber</li><li>纤维缠绕，可以得到不同的股 Ply</li><li>股绕在一起，可以得到线 Yarn</li><li>线织成布 cloth</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330230502109.png" alt="image-20230330230502109" style="zoom:80%;" /></p><p>将布料当作物体表面，使用<strong>BRDF</strong>渲染</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330230747552.png" alt="image-20230330230747552" style="zoom:80%;" /></p><p>将布料划分为很小的块，作为<strong>散射介质</strong>渲染</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330230632698.png" alt="image-20230330230632698" style="zoom:80%;" /></p><p>将布料划分为很多个线，类似<strong>头发模型</strong>渲染</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330230810766.png" alt="image-20230330230810766" style="zoom:80%;" /></p><h2 id="通过修改微表面法线分布得到不同的效果">18.3通过修改微表面法线分布，得到不同的效果</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330231505492.png" alt="image-20230330231505492" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330231516015.png" alt="image-20230330231516015" style="zoom:80%;" /></p><h3 id="对一个区域内的微表面进行积分">18.3.1对一个区域内的微表面进行积分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330231534136.png" alt="image-20230330231534136" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330231544316.png" alt="image-20230330231544316" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330231601075.png" alt="image-20230330231601075" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330231611914.png" alt="image-20230330231611914" style="zoom:80%;" /></p><h3 id="波动光学与几何光学得到的ndf">18.3.2波动光学与几何光学得到的NDF</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330231719561.png" alt="image-20230330231719561" style="zoom:80%;" /></p><h2 id="程序化生成表面">18.4 程序化生成表面</h2><ol type="1"><li>定义在空间中的函数，可以在使用的时候，查询空间中的某个点的值，而不是将三维纹理存储下来，<strong>噪声函数</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330231937462.png" alt="image-20230330231937462" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-17：材质与外观</title>
      <link href="/2023/02/19/GAMES101/17--%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/"/>
      <url>/2023/02/19/GAMES101/17--%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十七材质与外观">十七、材质与外观</h1><h2 id="材质-brdf-btdf-bsdf">17.1 材质 == BRDF + BTDF= BSDF</h2><h3 id="漫反射材质-brdf">17.1.1 漫反射材质 BRDF</h3><ol type="1"><li>光线会被均匀的反射到每个方向</li><li>完全不吸收能量、不发光的漫反射材质：<spanclass="math inline">\(f_r=\frac{\rho}{\pi} \in[0,\frac{1}{\pi}]\)</span><ol type="1"><li>其中<span class="math inline">\(\rho \in[0,1]\)</span>，表示对光的反射率</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324152718150.png" alt="image-20230324152718150" style="zoom:80%;" /></p><h3 id="镜面反射-brdf">17.1.2 镜面反射 BRDF</h3><ol type="1"><li>将入射光、反射光、平面放到立体角中</li><li>立体角坐标轴的Z轴方向为法线方向，XY平面为物体表面</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322174804469.png" alt="image-20230322174804469" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324153808848.png" alt="image-20230324153808848" style="zoom:80%;" />-</p><h3 id="折射-btdf">17.1.3 折射 BTDF</h3><ol type="1"><li>使用折射定律，算出反射角对应的<spanclass="math inline">\(\theta\)</span></li><li>然后通过方位角，求解对应向量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324154159876.png" alt="image-20230324154159876" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324154758730.png" alt="image-20230324154758730" style="zoom:80%;" /></p><h3 id="菲涅尔项多少光反射多少光折射">17.1.4菲涅尔项：多少光反射，多少光折射</h3><ol type="1"><li><strong>反射率</strong>取决于<strong>入射角度</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324161453003.png" alt="image-20230324161453003" style="zoom:80%;" /></p><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324155034305.png" alt="image-20230324155034305" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324161318996.png" alt="image-20230324161318996" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324161350170.png" alt="image-20230324161350170" style="zoom:80%;" /></p></blockquote><h2 id="微表面模型-microfacet-material">17.2 微表面模型 MicrofacetMaterial</h2><ol type="1"><li>从近处看：看到几何</li><li>从远处看：看到材质、外观</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230324161736587.png" alt="image-20230324161736587" style="zoom:80%;" /></p><h3 id="微表面brdf">17.2.1 微表面BRDF</h3><ol type="1"><li>微表面都是完全的镜子，只有在镜面反射方向，才能看到反射光线</li><li>微表面的法线分布，可以表示表面的粗糙程度<ol type="1"><li>法线分布集中 &lt;=&gt; glossy</li><li>法线分布发散 &lt;=&gt; diffuse</li></ol></li><li>当光线接近平行射入表面时，微表面之间的相互遮挡较大<ol type="1"><li>称为grazing angle</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330212241199.png" alt="image-20230330212241199" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330212608972.png" alt="image-20230330212608972" style="zoom:80%;" /></p><h3 id="各向同性各向异性材质-isotropicanisotropic-materials">17.2.2各向同性/各向异性材质 Isotropic/Anisotropic Materials</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330213918232.png" alt="image-20230330213918232" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330214126623.png" alt="image-20230330214126623" style="zoom:80%;" /></p><h2 id="brdf的性质">17.3 BRDF的性质</h2><ol type="1"><li><p>值非负：<span class="math inline">\(f_r(\omega_i \rightarrow\omega_r) \ge 0\)</span></p></li><li><p>线性性质：<spanclass="math inline">\(L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i\rightarrow \omega_r)L_i(p, \omega_i)cos \theta_i\d\omega_i\)</span></p><ol type="1"><li>可以分成很多块，然后相加</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330214746731.png" alt="image-20230330214746731" style="zoom:80%;" /></p></li><li><p>可逆性：<span class="math inline">\(f_r(\omega_i \rightarrow\omega_r) = f_r(\omega_r \rightarrow \omega_i)\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330214759683.png" alt="image-20230330214759683" style="zoom:80%;" /></p></li><li><p>能量守恒：<span class="math inline">\(\forall \omega_r,\int_{H^2}f_r(\omega_i \rightarrow \omega_r)cos \theta_i\ d\omega_i \le1\)</span></p><ol type="1"><li>BRDF不可能让能量变多</li><li>因此，光线追踪经过很多次反射后，能量会收敛</li></ol></li><li><p>各向同性 &amp; 各向异性</p><ol type="1"><li>各向同性：<spanclass="math inline">\(f_r(\theta_i,\phi_i;\theta_r,\phi_r)=f_r(\theta_i,\theta_r,\phi_r-\phi_i)\)</span><ol type="1"><li>降低了一个维度的自由度</li></ol></li><li>考虑对称性，对于所有的BRDF：<spanclass="math inline">\(f_r(\theta_i,\theta_r,\phi_r-\phi_i)=f_r(\theta_r,\theta_i,\phi_i-\phi_r)=f_r(\theta_i,\theta_r,|\phi_r-\phi_i|)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330215347624.png" alt="image-20230330215347624" style="zoom:80%;" /></p></li></ol><h2 id="测量brdf">17.4 测量BRDF</h2><ol type="1"><li>给定一个光源(入射方向)、一个摄像机(出射方向)</li><li>更改这光源和摄像机的位置，测量对应的BRDF</li><li>优化：<ol type="1"><li>对于各向同性的物体，可以通过方位角，将4D转化为3D</li><li>可逆性：降低了一半的测量次数</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330215511604.png" alt="image-20230330215511604" style="zoom: 80%;" /></p><h2 id="保存brdf">17.5 保存BRDF</h2><p>MERL BRDF Database：</p><ol type="1"><li>测量了很多不同的材质</li><li>保存为三维数组</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230330220014005.png" alt="image-20230330220014005" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-16：光线追踪4：蒙特卡洛积分 &amp; 路径追踪</title>
      <link href="/2023/02/18/GAMES101/16--%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA4%EF%BC%9A%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%20&amp;%20%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"/>
      <url>/2023/02/18/GAMES101/16--%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA4%EF%BC%9A%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%20&amp;%20%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1id="十六光线追踪4蒙特卡洛积分-路径追踪">十六、光线追踪4：蒙特卡洛积分&amp; 路径追踪</h1><h2 id="复习">16.1 复习</h2><blockquote><p>渲染方程：描述了光线的传递</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323221310058.png" alt="image-20230323221310058" style="zoom:80%;" /></p><ol type="1"><li>存在积分</li><li>是一个递归的计算：因为入射光可能是其他面的反射光</li></ol><h2 id="蒙特卡洛积分采样求定积分">16.2 蒙特卡洛积分：采样求定积分</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323221704667.png" alt="image-20230323221704667" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323222122882.png" alt="image-20230323222122882" style="zoom:80%;" /></p><ol type="1"><li>在<spanclass="math inline">\([a,b]\)</span>中采样多次，设每次采样点为<spanclass="math inline">\(x_i\)</span>，对应的函数值为<spanclass="math inline">\(f(x_i)\)</span>，则使用<spanclass="math inline">\((b-a)*f(x_i)\)</span>，近似定积分的值</li><li>当采样次数足够多时，求平均值，即可得到实际的定积分的值</li><li>设随机采样点<span class="math inline">\(X_i\)</span> ~ <spanclass="math inline">\(p(x)\)</span>，要求<spanclass="math inline">\(\int_{a}^bp(x)=1\)</span>，则蒙特卡洛的积分值为：<spanclass="math inline">\(F_N=\frac{1}{N}\sum_{i=1}^{N}\frac{f(X_i)}{p(X_i)}\)</span></li></ol><blockquote><p>示例：用<span class="math inline">\(X_i\)</span> ~ <spanclass="math inline">\(p(x)\)</span> = C采样</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323222403543.png" alt="image-20230323222403543" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323222419854.png" alt="image-20230323222419854" style="zoom:80%;" /></p></blockquote><p>注意：</p><ol type="1"><li>采样次数越多，结果越精确</li><li>在x上采样，则就是在x上积分</li></ol><h2 id="路径追踪path-tracing">16.3 路径追踪：Path Tracing</h2><h3 id="whitted-style-ray-tracing-的做法存在的问题">16.3.1 Whitted-StyleRay Tracing 的做法存在的问题</h3><p>不断的弹射光线，在任意一个位置均弹射光线</p><ol type="1"><li>如果是光滑物体：则沿镜面方向反射、折射方向折射</li><li>如果是漫反射物体：停止弹射</li></ol><p>存在问题：</p><ol type="1"><li>对于glossy物体，不能按照specular那样的镜面反射处理</li><li>漫反射物体会将光线均匀的弹射到各个部分，而非不反射</li></ol><h3 id="使用蒙特卡洛积分实现渲染方程中的积分">16.3.2使用蒙特卡洛积分，实现渲染方程中的积分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323224040938.png" alt="image-20230323224040938" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323224120396.png" alt="image-20230323224120396" style="zoom:80%;" /></p><h4 id="直接光照">16.3.2.1 直接光照</h4><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li>随机选择<strong>N</strong>个方向，N的分布满足某一种PDF</li><li><strong>L<sub>o</sub></strong>初始化为0.0</li><li>对于每一个方向<strong>ω<sub>i</sub></strong><ol type="1"><li>追踪光线<strong>r(p, ω<sub>i</sub>)</strong></li><li>如果光线<strong>r</strong>击中了光源<ol type="1"><li><strong>L<sub>o</sub> += (1/N) * L<sub>i</sub> * f<sub>r</sub> * cosθ / PDF(ω<sub>i</sub>)</strong></li></ol></li></ol></li><li>返回<strong>L<sub>o</sub></strong></li></ol><h4 id="间接光照">16.3.2.2 间接光照</h4><blockquote><p>相当于从P点看Q点的直接光照</p></blockquote><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li>随机选择<strong>N</strong>个方向，N的分布满足某一种PDF</li><li><strong>L<sub>o</sub></strong>初始化为0.0</li><li>对于每一个方向<strong>ω<sub>i</sub></strong><ol type="1"><li>追踪光线<strong>r(p,ω<sub>i</sub>)</strong>（p点发出，方向为ω<sub>i</sub>）</li><li>如果光线<strong>r</strong>击中了光源<ol type="1"><li><strong>L<sub>o</sub> += (1/N) * L<sub>i</sub> * f<sub>r</sub> * cosθ / PDF(ω<sub>i</sub>)</strong></li></ol></li><li>如果光线<strong>r</strong>击中了物体，且物体位于<strong>q</strong><ol type="1"><li><strong>L<sub>o</sub> += (1/N) * shade(q, -ω<sub>i</sub>) *f<sub>r</sub> * cos θ / PDF(ω<sub>i</sub>)</strong></li></ol></li></ol></li><li>返回<strong>L<sub>o</sub></strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323224729779.png" alt="image-20230323224729779" style="zoom:80%;" /></p><h2 id="路径追踪解决光线数量爆炸">16.4 路径追踪：解决光线数量爆炸</h2><blockquote><p>问题：光线的数量会爆炸：光线数量 = N <sup>反射次数</sup>，只有当N =1时，才不会指数爆炸 ==&gt; 路径追踪</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323225058558.png" alt="image-20230323225058558" style="zoom:80%;" /></p><h3 id="每一个着色点只使用1根光线进行追踪">16.4.1每一个着色点，只使用1根光线进行追踪</h3><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li>随机选择<strong>1</strong>个方向<strong>ω<sub>i</sub></strong>，ω<sub>i</sub>的分布满足某一种PDF</li><li>追踪光线<strong>r(p,ω<sub>i</sub>)</strong>（p点发出，方向为ω<sub>i</sub>）</li><li>如果光线<strong>r</strong>击中了光源<ol type="1"><li>返回 <strong>L<sub>o</sub> = L<sub>i</sub> * f<sub>r</sub> * cos θ /PDF(ω<sub>i</sub>)</strong></li></ol></li><li>如果光线<strong>r</strong>击中了物体，且物体位于<strong>q</strong><ol type="1"><li>返回 <strong>L<sub>o</sub> = shade(q, -ω<sub>i</sub>) *f<sub>r</sub> * cos θ / PDF(ω<sub>i</sub>)</strong></li></ol></li></ol><h3 id="解决噪声问题选择多个穿过该着色点的路径每个路径1条光线">16.4.2解决噪声问题：选择多个穿过该着色点的路径，每个路径1条光线</h3><p><strong>ray_generation(camPos, pixel)</strong></p><ol type="1"><li>在该像素中，随机选择<strong>N</strong>个采样位置</li><li><strong>pixel_radiance = 0.0</strong></li><li>对于每一个采样位置<ol type="1"><li>追踪光线<strong>r(camPos, cam_to_sample)</strong></li><li>如果光线<strong>r</strong>在<strong>p</strong>点击中场景<ol type="1"><li><strong>pixel_radiance += (1/N) * shade(p,sample_to_cam)</strong></li></ol></li></ol></li><li>返回<strong>pixel_radiance</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323225611788.png" alt="image-20230323225611788" style="zoom:80%;" /></p><h3 id="解决递归无法停下问题runssian-roulette">16.4.3解决递归无法停下问题：Runssian Roulette</h3><blockquote><p>问题：<strong>shade(p,ω<sub>o</sub>)</strong>是递归定义的，可能无法停下 ==&gt;RR，一定概率停止追踪</p></blockquote><ol type="1"><li>定义一个概率<strong>P</strong></li><li><strong>P</strong>的概率，发射一个光线，并且返回<strong>L<sub>o</sub>/ P</strong></li><li><strong>1-P</strong>的概率，不发射光线，返回<strong>0</strong></li><li>最后的期望依旧为<strong>L<sub>o</sub></strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323230308526.png" alt="image-20230323230308526" style="zoom:80%;" /></p><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li>定义概率<strong>P_RR</strong></li><li>随机生成一个在<strong>[0,1]</strong>的实数<strong>dist</strong>，如果<strong>dist&gt;P_RR</strong>，则返回<strong>0.0</strong></li><li>随机选择<strong>1</strong>个方向<strong>ω<sub>i</sub></strong>，ω<sub>i</sub>的分布满足某一种PDF</li><li>追踪光线<strong>r(p,ω<sub>i</sub>)</strong>（p点发出，方向为ω<sub>i</sub>）</li><li>如果光线<strong>r</strong>击中了光源<ol type="1"><li>返回 <strong>L<sub>o</sub> = L<sub>i</sub> * f<sub>r</sub> * cos θ /PDF(ω<sub>i</sub>) / P_RR</strong></li></ol></li><li>如果光线<strong>r</strong>击中了物体，且物体位于<strong>q</strong><ol type="1"><li>返回 <strong>L<sub>o</sub> = shade(q, -ω<sub>i</sub>) *f<sub>r</sub> * cos θ / PDF(ω<sub>i</sub>) / P_RR</strong></li></ol></li></ol><h3 id="让路径追踪变得高效对光源采样">16.4.4让路径追踪变得高效：对光源采样</h3><blockquote><p>均匀采样，导致很多光线无法打到小的光源，导致浪费计算力</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323231200753.png" alt="image-20230323231200753" style="zoom:80%;" /></p><blockquote><p>对光源进行采样，然后将渲染方程修改为对光源的积分：即找到<strong>dω</strong> 与 <strong>dA</strong> 的关系</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323231551425.png" alt="image-20230323231551425" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323231600802.png" alt="image-20230323231600802" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323231643529.png" alt="image-20230323231643529" style="zoom:80%;" /></p><blockquote><p>优化算法</p></blockquote><p>将radiance分为两个部分：</p><ol type="1"><li>来自光源的radiance：直接采样光源</li><li>其他反射光：使用RR的方法</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323231831265.png" alt="image-20230323231831265" style="zoom:80%;" /></p><p><strong>shade(p, ω<sub>o</sub>)</strong></p><ol type="1"><li><blockquote><p>光源的贡献</p></blockquote><ol type="1"><li>均匀的对位于<strong>x'</strong>的光源进行采样，<strong>PDF_light = 1/ A</strong></li><li>从<strong>p</strong>向<strong>x'</strong>发射一条光线，如果光线不会被阻挡，则<ol type="1"><li><strong>L_dir = L<sub>i</sub> * f<sub>r</sub> * cos θ * cos θ‘ / |x'- p|<sup>2</sup> / PDF_light</strong></li></ol></li></ol></li><li><blockquote><p>其他反射光的贡献</p></blockquote><ol type="1"><li><strong>L_indir = 0.0</strong></li><li>判断是否需要采样，RR的概率为<strong>P_RR</strong></li><li>均匀的对半球进行采样，方位角为<strong>ω<sub>i</sub></strong>，<strong>PDF_hemi= 1 / 2Π</strong></li><li>追踪光线<strong>r(p,ω<sub>i</sub>)</strong>（p点发出，方向为ω<sub>i</sub>）</li><li>如果光线<strong>r</strong>击中了<strong>非发光体</strong>，且物体位于<strong>q</strong><ol type="1"><li><strong>L_indir = shade(q, -ω<sub>i</sub>) * f<sub>r</sub> * cos θ /PDF_hemi / P_RR</strong></li></ol></li></ol></li><li>返回<strong>L_dir + L_indir</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-15：光线追踪3：BRDF &amp; 渲染方程</title>
      <link href="/2023/02/17/GAMES101/15--%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA3%EF%BC%9ABRDF%20&amp;%20%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"/>
      <url>/2023/02/17/GAMES101/15--%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA3%EF%BC%9ABRDF%20&amp;%20%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十五光线追踪3brdf-渲染方程">十五、光线追踪3：BRDF &amp;渲染方程</h1><h2 id="辐射度量学-basic-radiometry">15.1 辐射度量学 Basicradiometry</h2><ol type="1"><li>如何描述光照：定义了一系列的方法和单位</li><li>给光赋予了一系列空间上的属性（依旧是基于几何光学）<ol type="1"><li>Radiant flux：辐射通量</li><li>intensity：强度</li><li>irradiance：辐射通量密度</li><li>radiance：辐射</li></ol></li><li>在物理上准确定义光照的方法</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322174129089.png" alt="image-20230322174129089" style="zoom:80%;" /></p><h3 id="radiant-fluxpower单位时间的能量">15.1.1 RadiantFlux/Power：单位时间的能量</h3><ol type="1"><li>Radiant <strong>Energy</strong>：光源辐射出来的能量，<spanclass="math inline">\(Q\)</span>，单位为<strong>焦耳J</strong>，在CG中基本不使用</li><li>Radiant <strong>Flux/Power</strong>：单位时间内发射的能量，<spanclass="math inline">\(\Phi=\frac{dQ}{dt}\)</span>，单位为<strong>瓦特W</strong>/<strong>流明lm=lumen</strong></li></ol><h3 id="radiant-intensity单位立体角的能量">15.1.2 RadiantIntensity：单位立体角的能量</h3><ol type="1"><li>Radiant <strong>Intensity</strong>：单位立体角上的power，<spanclass="math inline">\(I(\omega)=\frac{d\Phi}{d\omega}\)</span>，单位为<strong>坎德拉cd</strong><ol type="1"><li>也就是光源在某个方向上的亮度</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322174233794.png" alt="image-20230322174233794" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322175039042.png" alt="image-20230322175039042" style="zoom:80%;" /></p><h4 id="立体角-solid-angles">15.1.2.1 立体角 Solid Angles</h4><ol type="1"><li>角度：<spanclass="math inline">\(\theta=\frac{l}{r}\)</span>，单位为<strong>rad</strong></li><li>立体角：<spanclass="math inline">\(\Omega=\frac{A}{r^2}\)</span>，单位为<strong>sr</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322174554385.png" alt="image-20230322174554385" style="zoom:80%;" /></p><h4 id="单位立体角-differential-solid-angles">15.1.2.2 单位立体角Differential Solid Angles</h4><ol type="1"><li>单位面积：<span class="math inline">\(dA=r^2sin\theta\ d\theta\d\phi\)</span></li><li>单位立体角：<span class="math inline">\(d\omega=sin\theta\ d\theta\d\phi\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322174804469.png" alt="image-20230322174804469" style="zoom:80%;" /></p><h3 id="irradiance单位面积的能量">15.1.4 Irradiance：单位面积的能量</h3><ol type="1"><li><p>Irradiance：表面上<strong>与光线垂直</strong>的单位面积接收到的能量，<spanclass="math inline">\(E(x)=\frac{d\phi(x)}{dA}\)</span>，单位<strong><spanclass="math inline">\(\frac{W}{m^2}\)</span>，<spanclass="math inline">\(\frac{lm}{m^2}\)</span>=lux</strong></p><ol type="1"><li>如果表面与光线<strong>不垂直</strong>，则需要投影到垂直方向：<spanclass="math inline">\(E(x)=\frac{d\phi(x)}{dA}\ \cos\theta\)</span>，<spanclass="math inline">\(\theta\)</span>为光线与法线的夹角</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323202218229.png" alt="image-20230323202218229" style="zoom:80%;" /></p></li><li><p>光在传播的过程中，Intensity没有变，而Irradiate变小了，因为面积变大了</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323202709508.png" alt="image-20230323202709508" style="zoom:80%;" /></p></li></ol><h3 id="radiance单位立体角单位面积的能量">15.1.5Radiance：单位立体角&amp;单位面积的能量</h3><ol type="1"><li>Radiance：表面上<strong>与光线垂直</strong>的单位面积接收到的能量，<spanclass="math inline">\(L(p,\omega)=\frac{d^2\phi(p,\omega)}{d\omega dAcos \theta}\)</span>，单位<strong><span class="math inline">\(\frac{cd}{m^2}\)</span>，<span class="math inline">\(\frac{lm}{sr\m^2}=\frac{lm}{sr\ m^2}\)</span>=nit</strong><ol type="1"><li>单位面积的Intensity：<spanclass="math inline">\(L(p,\omega)=\frac{dI(p,\omega)}{dA cos\theta}\)</span></li><li>单位立体角的Irradiance：<spanclass="math inline">\(L(p,\omega)=\frac{dE(p)}{d\omega cos\theta}\)</span></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323203046905.png" alt="image-20230323203046905" style="zoom:80%;" /></p><h3 id="irradiance-vs-radiance">15.1.6 Irradiance vs Radiance</h3><ol type="1"><li><strong>Irradiance</strong>：单位面积<strong>dA</strong>接收到的所有能量，<spanclass="math inline">\(E(p)\)</span></li><li><strong>Radiance</strong>：单位面积<strong>dA</strong>在单位方向<strong>dω</strong>处接收到的所有能量，<spanclass="math inline">\(L(p,\omega)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323203503761.png" alt="image-20230323203503761" style="zoom:80%;" /></p><h2 id="brdf双向反射分布函数">15.2 BRDF：双向反射分布函数</h2><blockquote><p><strong>Bidirectional Reflectance Distribution Function</strong></p></blockquote><h3 id="某个点的反射">15.2.1 某个点的反射</h3><ol type="1"><li>单位面积<strong>dA</strong>，在某个单位立体角<strong>ω<sub>i</sub></strong>处吸收能量<strong>dE(ω<sub>i</sub>)</strong></li><li>会反射到另一个单位立体角<strong>ω<sub>r</sub></strong>、单位面积的能量<strong>dL<sub>r</sub>(x,ω<sub>r</sub>)</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323204145095.png" alt="image-20230323204145095" style="zoom:80%;" /></p><h3 id="brdf">15.2.2 BRDF</h3><ol type="1"><li>入射光的Radiance：<strong>dE<sub>i</sub>(ω<sub>i</sub>)</strong></li><li>反射光的Irradiance：<strong>dL<sub>r</sub>(ω<sub>r</sub>)</strong></li><li>入射光在反射方向的能量分布比例<strong>f<sub>r</sub>(ω<sub>i</sub> →ω<sub>r</sub>)</strong>为：<ol type="1"><li>入射光的Radiance / 反射光的Irradiance</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323204215288.png" alt="image-20230323204215288" style="zoom:80%;" /></p><h3 id="反射方程-reflection-equation">15.2.3 反射方程 ReflectionEquation</h3><ol type="1"><li>某个着色点<strong>p</strong>，当反射方向为<strong>ω<sub>r</sub></strong>是，反射的光<strong>L<sub>r</sub>(p,ω<sub>r</sub>)</strong>为：<ol type="1"><li>在每个入射方向<strong>ω<sub>i</sub></strong>的反射的能量<strong>f<sub>r</sub>(p,ω<sub>i</sub> → ω<sub>r</sub>) L<sub>i</sub>(p, ω<sub>i</sub>) cosθ<sub>i</sub></strong>，对入射方向立体角<strong>dω<sub>i</sub></strong>的积分</li><li>只考虑半球<strong>H<sup>2</sup> / Ω+</strong></li></ol></li><li>问题：任何出射的radiance，都可能作为其他着色点的入射的radiance，因此存在递归定义</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323204816473.png" alt="image-20230323204816473" style="zoom:80%;" /></p><h2 id="渲染方程-rendering-equation">15.3 渲染方程 RenderingEquation</h2><p>某个点<strong>p</strong>向某个方向<strong>ω<sub>o</sub></strong>出射的光<strong>L<sub>o</sub>(p,ω<sub>o</sub>)</strong>由两部分构成</p><ol type="1"><li>自己产生的光：<span class="math inline">\(L_e(p, ω_o)\)</span></li><li>反射的光：<spanclass="math inline">\(\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n·\omega_i)d\omega_i\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323205330782.png" alt="image-20230323205330782" style="zoom:80%;" /></p><h3 id="一个点光源">15.3.1 一个点光源</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323211001791.png" alt="image-20230323211001791" style="zoom:80%;" /></p><h3 id="很多个点光源加和">15.3.2 很多个点光源：加和</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323211106534.png" alt="image-20230323211106534" style="zoom:80%;" /></p><h3 id="面光源很多个点光源的集合-积分">15.3.3 面光源：很多个点光源的集合=&gt; 积分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323211423936.png" alt="image-20230323211423936" style="zoom:80%;" /></p><h3 id="其他表面的反射当成面光源使用">15.3.4其他表面的反射：当成面光源使用</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323211407432.png" alt="image-20230323211407432" style="zoom:80%;" /></p><h3 id="渲染方程的简化表示">15.3.5 渲染方程的简化表示</h3><blockquote><p>积分方程</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323211552304.png" alt="image-20230323211552304" style="zoom:80%;" /></p><blockquote><p>线性算子等式</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323211712567.png" alt="image-20230323211712567" style="zoom:80%;" /></p><h3 id="光线弹射n次的光线追踪-全局光照">15.3.6 光线弹射n次的光线追踪=&gt; 全局光照</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323212038657.png" alt="image-20230323212038657" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323212529890.png" alt="image-20230323212529890" style="zoom:80%;" /></p><h2 id="概率论">15.4 概率论</h2><h3 id="pdf概率分布函数x-px">15.4.1 PDF：概率分布函数，X ~ p(x)</h3><blockquote><p><strong>Probability Distribution Function</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323213850665.png" alt="image-20230323213850665" style="zoom:80%;" /></p><h3 id="随机变量函数的期望">15.4.2 随机变量函数的期望</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230323214009047.png" alt="image-20230323214009047" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-14：光线追踪2：使用AABB包围盒加速光线追踪</title>
      <link href="/2023/02/16/GAMES101/14--%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA2%EF%BC%9A%E4%BD%BF%E7%94%A8AABB%E5%8C%85%E5%9B%B4%E7%9B%92%E5%8A%A0%E9%80%9F%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
      <url>/2023/02/16/GAMES101/14--%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA2%EF%BC%9A%E4%BD%BF%E7%94%A8AABB%E5%8C%85%E5%9B%B4%E7%9B%92%E5%8A%A0%E9%80%9F%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1id="十四光线追踪2使用aabb包围盒加速光线追踪">十四、光线追踪2：使用AABB包围盒加速光线追踪</h1><h2 id="直接使用aabb包围盒">14.1 直接使用AABB包围盒</h2><ol type="1"><li><p>找到包围盒</p></li><li><p>将包围盒分为格子<code>Grid</code></p></li><li><p>如果某个格子与物体的表面相交，则标记该格子</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321222357738.png" alt="image-20230321222357738" style="zoom:80%;" /></p></li><li><p>将光线与格子求交</p><ol type="1"><li>如果光线与格子相交，且格子内有物体，则将光线与对应物体求交</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321222609290.png" alt="image-20230321222609290" style="zoom:80%;" /></p></li><li><p>格子过于稀疏 or 过于密集，均会使效率变低</p></li><li><p>通常，格子的数量是场景中的物体数目的整数倍：<code>#cells = C * #objs</code></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321222827253.png" alt="image-20230321222827253" style="zoom:80%;" /></p></li></ol><h2 id="空间划分-spatial-partitions">14.2 空间划分 SpatialPartitions</h2><p>将空间划分为大小不同的盒子</p><p>缺点：</p><ol type="1"><li>难以判断哪些三角形属于当前格子</li><li>一个三角形可能会处在多个格子中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321225126054.png" alt="image-20230321225126054" style="zoom:80%;" /></p><h3 id="kd-tree-预处理">14.2.1 KD-Tree 预处理</h3><ol type="1"><li>注意，每一个部分都要划分，按照水平、竖直的顺序交替分割</li><li>中间节点：<ol type="1"><li>分割轴：x、y、z</li><li>分割位置：在分割轴上的分割点的坐标</li><li>子节点：指向子节点的指针，有2个子节点</li></ol></li><li>叶节点：<ol type="1"><li>记录和该格子相交的物体</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322164639853.png" alt="image-20230322164639853" style="zoom:80%;" /></p><h3 id="kd-tree加速光线追踪">14.2.2 KD-Tree加速光线追踪</h3><ol type="1"><li>如果光线和格子没有交点，则不做操作</li><li>如果光线和格子有交点<ol type="1"><li>如果格子为叶节点，则光线与叶节点中的所有物体求交</li><li>否则与格子的两个子节点求交</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322170220976.png" alt="image-20230322170220976" style="zoom:80%;" /></p><h2 id="物体划分-object-partitions">14.3 物体划分 Object Partitions</h2><ol type="1"><li>将物体分为两堆，然后再求包围盒</li><li>包围盒之间可能有相交，但可以保证一个三角形最多只在一个包围盒中</li></ol><h3 id="层次包围盒-bvhbounding-volume-hierarchy">14.3.1 层次包围盒BVH：Bounding Volume Hierarchy</h3><ol type="1"><li>找到一个包围盒</li><li>递归的将包围盒中的物体划分为两个部分</li><li>重新计算包围盒</li><li>重复23，直到每个包围和中的物体数量足够少</li><li>将物体存在每个叶节点中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322171211451.png" alt="image-20230322171211451" style="zoom:80%;" /></p><h3 id="划分方法">14.3.2 划分方法</h3><ol type="1"><li>每次找最长的轴进行划分</li><li>每次找第n/2个三角形，进行划分，保证两边的三角形个数相差不多<ol type="1"><li>根据重心坐标，划分三角形的位置</li><li>可以类似于找第k大数，通过快排，在O(n)时间内找到</li></ol></li><li>如果场景中的物体移动了，就需要重新建立BVH树</li></ol><h3 id="bvh加速光线追踪">14.3.3 BVH加速光线追踪</h3><ol type="1"><li>如果光线和包围盒没有交点，则不做操作</li><li>如果光线和包围盒有交点<ol type="1"><li>如果包围盒为叶节点，则光线与叶节点中的所有物体求交</li><li>否则与包围盒的两个子节点求交</li></ol></li></ol><h3 id="空间划分-vs-物体划分">14.3.4 空间划分 vs 物体划分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322172055257.png" alt="image-20230322172055257" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-13：光线追踪1：Whitted-Style Ray Tracing</title>
      <link href="/2023/02/15/GAMES101/13--%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA1%EF%BC%9AWhitted-Style/"/>
      <url>/2023/02/15/GAMES101/13--%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA1%EF%BC%9AWhitted-Style/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1id="十三光线追踪1whitted-style-ray-tracing">十三、光线追踪1：Whitted-StyleRay Tracing</h1><h2 id="为什么要使用光线追踪">13.1 为什么要使用光线追踪</h2><ol type="1"><li><p>光栅化不能很好解决全局效果</p><ol type="1"><li>软阴影</li><li>Glossy反射</li><li>间接光照</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321172627995.png" alt="image-20230321172627995" style="zoom:80%;" /></p></li><li><p>光栅化的速度很快，但是质量较低，通常用于实时渲染</p></li><li><p>光线追踪质量高，但是非常慢，通常用于离线制作</p></li></ol><h2 id="基础光线追踪算法">13.2 基础光线追踪算法</h2><h3 id="光线是什么">13.2.1 光线是什么</h3><ol type="1"><li>光线沿直线传播</li><li>光线和光线不会发生碰撞</li><li>光线从光源发出，经过反射、折射等过程，进入人的眼睛：<strong>光路可逆性</strong></li></ol><h3 id="光线投射">13.2.2 光线投射</h3><ol type="1"><li>eyeray：从<strong>眼睛</strong>到屏幕上的<strong>像素</strong>，连接的而成的射线，只记录最近的<strong>交点</strong></li><li>shadowray：从某个<strong>点</strong>到<strong>光源</strong>的连线</li><li>根据两条线的关系，判断着色</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321173554636.png" alt="image-20230321173554636" style="zoom:80%;" /></p><h3 id="递归光线追踪">13.2.3 递归光线追踪</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321173940996.png" alt="image-20230321173940996" style="zoom:80%;" /></p><ol type="1"><li>primary ray：即eye ray</li><li>secondary ray：经过折射/反射后的光线</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321174050214.png" alt="image-20230321174050214" style="zoom:80%;" /></p><h2 id="光线和表面的交点">13.3 光线和表面的交点</h2><h3 id="光线的数学定义">13.3.1 光线的数学定义</h3><ol type="1"><li>起点<code>o</code>，方向<code>d</code></li><li>射线定义：<code>r(t) = o + td</code></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321174353486.png" alt="image-20230321174353486" style="zoom:80%;" /></p><h3 id="光线-与-球-求交点">13.3.2 光线 与 球 求交点</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321174429897.png" alt="image-20230321174429897" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321174531995.png" alt="image-20230321174531995" style="zoom:80%;" /></p><h3 id="光线-与-隐式表面-求交点">13.3.3 光线 与 隐式表面 求交点</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321174700426.png" alt="image-20230321174700426" style="zoom:80%;" /></p><h3 id="光线-与-三角形-求交点">13.3.4 光线 与 三角形 求交点</h3><blockquote><p>如果射线与物体的交点数量为<strong>奇数</strong>，则点在<strong>物体内</strong>；如果是<strong>偶数</strong>，则在<strong>物体外</strong></p></blockquote><ol type="1"><li>光线和平面求交</li><li>判断点是否在三角形内</li></ol><h4 id="平面的数学定义">13.3.4.1 平面的数学定义</h4><ol type="1"><li>给一个点<span class="math inline">\(p_0\)</span>，一条法线<spanclass="math inline">\(\vec{N}\)</span></li><li>则平面为：<span class="math inline">\((p-p_0)·\vec{N} =0\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321175203939.png" alt="image-20230321175203939" style="zoom:80%;" /></p><h4 id="光线和平面的交点">13.3.4.2 光线和平面的交点</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321203414616.png" alt="image-20230321203414616" style="zoom:80%;" /></p><h4 id="moller-trumbore算法">13.3.4.3 Moller Trumbore算法</h4><ol type="1"><li>用重心坐标表示平面：<span class="math inline">\((1-b_1-b_2)\vec{P_0}+ b_1\vec{P_1} + b_2\vec{P_2}\)</span></li><li>判定点在射线上：<span class="math inline">\(t\ge 0\)</span></li><li>判定点在三角形内：<span class="math inline">\(b_1 \ge 0,b_2 \ge0\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321203545908.png" alt="image-20230321203545908" style="zoom:80%;" /></p><h2 id="加速-光线-与-三角形表面-求交">13.4 加速 光线 与 三角形表面求交</h2><h3 id="包围盒-bounding-volumes">13.4.1 包围盒 Bounding Volumes</h3><ol type="1"><li>用一个简单的形状，将物体包围起来，如果不能与包围盒相交，则一定不会与物体相交</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321215130003.png" alt="image-20230321215130003" style="zoom:80%;" /></p><h3 id="轴对齐包围盒aabbaxis-aligned-bounding-box">13.4.2轴对齐包围盒AABB：Axis-Aligned Bounding Box</h3><ol type="1"><li><p>空间中的长方体，可以理解为3对表面的交集</p></li><li><p>轴对齐包围盒：长方体的每一个边，均与坐标轴平行</p></li><li><p>二维空间，光线与长方形求交</p><ol type="1"><li>对于竖着的情况，可以得到在<spanclass="math inline">\(t=t_{x-min}\)</span>时，与<spanclass="math inline">\(x=x_0\)</span>相交；在<spanclass="math inline">\(t=t_{x-max}\)</span>时，与<spanclass="math inline">\(x=x_1\)</span>相交</li><li>对于横着的情况，可以得到在<spanclass="math inline">\(t=t_{y-min}\)</span>时，与<spanclass="math inline">\(y=y_0\)</span>相交；在<spanclass="math inline">\(t=t_{y-max}\)</span>时，与<spanclass="math inline">\(y=y_1\)</span>相交</li><li>由于长方形可以看作四条线的交集，因此光线在长方形中的部分，也可以看作<spanclass="math inline">\([t_{x-min},t_{x-max}]\)</span>和<spanclass="math inline">\([t_{y-min},t_{y-max}]\)</span>的交集</li><li>从而可以得到光线与长方形的交点对应的时间<spanclass="math inline">\(t_{enter} =\max(t_{x-min},t_{y-min})\)</span>，<spanclass="math inline">\(t_{exit}=\min(t_{x-max},t_{y-max})\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321220625451.png" alt="image-20230321220625451" style="zoom:80%;" /></p></li><li><p>三维空间，光线与长方体求交</p><ol type="1"><li>只有当光线同时进入了3对表面，才能说光线进入了长方体</li><li>光线只要离开了1对表面，就说钢线离开了长方体</li><li>对于每一对表面，计算一次<spanclass="math inline">\([t_{min},t_{max}]\)</span></li><li>则对于长方体来说，<span class="math inline">\(t_{enter} =\max(t_{min})\)</span>，<spanclass="math inline">\(t_{exit}=\min(t_{max})\)</span></li></ol></li><li><p>如果<spanclass="math inline">\(t_{exit}&lt;0\)</span>，则说明盒子在光线的背后，不可能有交点</p></li><li><p>如果<span class="math inline">\(t_{exit}\ge0,t_{enter}&lt;0\)</span>，则说明光线的起点在盒子里面，肯定有交点</p></li></ol><p><strong>因此，光线与AABB有交点，当且仅当：<spanclass="math inline">\(t_{enter}&lt;t_{exit}\)</span> 并且 <spanclass="math inline">\(t_{exit} \ge 0\)</span></strong></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-12：阴影 Shadow Mapping</title>
      <link href="/2023/02/14/GAMES101/12--%E9%98%B4%E5%BD%B1%EF%BC%9AShadow%20Map/"/>
      <url>/2023/02/14/GAMES101/12--%E9%98%B4%E5%BD%B1%EF%BC%9AShadow%20Map/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十二阴影-shadow-mapping">十二、阴影 Shadow Mapping</h1><ol type="1"><li>本质上是一个<strong>图像空间</strong>的算法<ol type="1"><li>不需要知道场景的几何信息</li><li>会存在<strong>走样</strong>现象</li></ol></li><li>核心思想：<ol type="1"><li>点不在阴影里 &lt;=&gt; 摄像机&amp;光源均可以看到该点</li></ol></li><li>ShadowMapping只能处理点光源的阴影，且会有明显的边界，即<strong>硬阴影</strong></li></ol><h2 id="第一步render-from-light">12.1 第一步：Render from Light</h2><p>从光源看向场景，记录看到的任何点的深度，即获取Z-Buffer</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321170213274.png" alt="image-20230321170213274" style="zoom:80%;" /></p><h2 id="第二步render-from-eye">12.2 第二步：Render from Eye</h2><ol type="1"><li><p>从摄像机看向场景，记录看到的点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321170427126.png" alt="image-20230321170427126" style="zoom:80%;" /></p></li><li><p>将看到的点，投影回光源，判断该位置对应的光源看到的深度</p><ol type="1"><li>如果深度相同，则可以看到</li><li>如果深度不相同，则不可以看到</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321170510434.png" alt="image-20230321170510434" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321170625379.png" alt="image-20230321170625379" style="zoom:80%;" /></p></li></ol><h2 id="示例">12.3 示例</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321170932574.png" alt="image-20230321170932574" style="zoom:80%;" /></p><ol type="1"><li><p>从光源看向场景，记录深度图</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321170818410.png" alt="image-20230321170818410" style="zoom:80%;" /></p></li><li><p>从相机看向场景，将每一个像素投影回光源看到的图像，对比两个深度</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321170902602.png" alt="image-20230321170902602" style="zoom:80%;" /></p></li><li><p>由于存在浮点精度、shadowmap的分辨率与场景的分辨率等问题，会导致阴影的各种问题</p></li></ol><h2 id="硬阴影与软阴影">12.4 硬阴影与软阴影</h2><ol type="1"><li>Umbra 本影：完全看不到光源</li><li>Penumbra 半影：看到部分光源</li><li>软阴影一定是因为光源存在大小</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321171532601.png" alt="image-20230321171532601" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-12：几何3：网格体</title>
      <link href="/2023/02/13/GAMES101/12--%E5%87%A0%E4%BD%953%EF%BC%9A%E7%BD%91%E6%A0%BC%E4%BD%93/"/>
      <url>/2023/02/13/GAMES101/12--%E5%87%A0%E4%BD%953%EF%BC%9A%E7%BD%91%E6%A0%BC%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十二几何3网格体">十二、几何3：网格体</h1><h2 id="网格体的细分-subdivision">12.1 网格体的细分 Subdivision</h2><ol type="1"><li>引入更多三角形</li><li>调整顶点的位置，让网格体更加接近原样</li></ol><h3 id="loop细分三角形网格体">12.1.1 Loop细分：三角形网格体</h3><ol type="1"><li><p>连接三角形三条边的中点，可以将一个三角形划分为四个三角形</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321162509372.png" alt="image-20230321162509372" style="zoom:80%;" /></p></li><li><p>计算新的顶点的位置</p><ol type="1"><li>设新增的顶点为图中的白点，白点被原来的两个三角形<code>ABC、ABD</code>共享</li><li>则可以计算新的顶点的坐标值：<code>3/8 * (A+B) + 1/8 * (C+D)</code></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321162618650.png" alt="image-20230321162618650" style="zoom:80%;" /></p></li><li><p>更改旧的顶点的位置</p><ol type="1"><li>设顶点的度为<code>n</code>，与<code>n</code>相关的一个数<code>u</code></li><li>则更改顶点的位置为：<code>(1-n*u) * 当前顶点原来的位置 + u * 相邻节点的位置之和</code></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321162914642.png" alt="image-20230321162914642" style="zoom:80%;" /></p></li></ol><h3 id="catmull-clark细分一般的网格体">12.1.2Catmull-Clark细分：一般的网格体</h3><ol type="1"><li>quad face：四边形面</li><li>non-quad face：非四边形面</li><li>Extraordinary vertex：奇异点，度数不为4的点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321163537134.png" alt="image-20230321163537134" style="zoom:80%;" /></p><p>细分方法：</p><ol type="1"><li><p>增加新的点：每一条线取中点，每一个面取中点，然后将边上的中点与面中心的点连起来</p><ol type="1"><li>新出现了2个奇异点，度数均为2</li><li>每个原来的非四边形面均会引入一个奇异点，且一次操作后会消失</li></ol><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321163943647.png" alt="image-20230321163943647" style="zoom:80%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321164016513.png" alt="image-20230321164016513" style="zoom:80%;" /></th><th><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321163957959.png" alt="image-20230321163957959" style="zoom:80%;" /></th></tr></thead><tbody></tbody></table></li><li><p>修改点的坐标</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321164236099.png" alt="image-20230321164236099" style="zoom:80%;" /></p></li></ol><h2 id="网格体简化-simplification">12.2 网格体简化 Simplification</h2><h3 id="边坍缩-collapsing-an-edge">12.2.1 边坍缩 Collapsing An Edge</h3><ol type="1"><li>选中一条边，将两个端点合并为一个顶点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321164735232.png" alt="image-20230321164735232" style="zoom:80%;" /></p><h3 id="二次度量误差-quadric-error-metrics">12.2.2 二次度量误差 QuadricError Metrics</h3><ol type="1"><li>将点放到某一个位置，使得其到原本与它关联面的距离平方和最小</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321165037373.png" alt="image-20230321165037373" style="zoom:80%;" /></p><h3 id="边坍缩的二次误差">12.2.3 边坍缩的二次误差</h3><ol type="1"><li>假设坍缩该边，并且将坍缩后的点放到最佳位置，计算其二次度量误差</li><li>从误差小的边开始坍缩</li><li>但是每一次坍缩后，需要更新其他受影响边的二次度量误差：用堆维护</li><li>本质上是一个贪心算法，用局部最优，组成全局最优</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230321165529353.png" alt="image-20230321165529353" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-11：几何2：曲线和曲面</title>
      <link href="/2023/02/12/GAMES101/11--%E5%87%A0%E4%BD%952%EF%BC%9A%E6%9B%B2%E7%BA%BF%E5%92%8C%E6%9B%B2%E9%9D%A2/"/>
      <url>/2023/02/12/GAMES101/11--%E5%87%A0%E4%BD%952%EF%BC%9A%E6%9B%B2%E7%BA%BF%E5%92%8C%E6%9B%B2%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十一几何2曲线和曲面">十一、几何2：曲线和曲面</h1><h2 id="贝塞尔曲线-bezier-curve">11.1 贝塞尔曲线 Bezier Curve</h2><ol type="1"><li>定义四个控制点<code>p0,p1,p2,p3</code>，要求曲线的起始切线方向为<code>p1-p0</code>，终止切线方向为<code>p3-p2</code></li><li>曲线不一定经过控制点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320213504658.png" alt="image-20230320213504658" style="zoom:80%;" /></p><h3 id="de-casteljau算法">11.1.1 de Casteljau算法</h3><h4 id="二次贝塞尔曲线三个控制点">11.1.1.1二次贝塞尔曲线：三个控制点</h4><ol type="1"><li><code>b0</code>为起点，<code>b2</code>为终点，<code>b1</code>控制曲线弯曲</li><li>实际上是：对于每一个时间<code>t</code>，找到当前时刻对应的点的坐标<ol type="1"><li>第一步：<ol type="1"><li>在<span class="math inline">\(b_0b_1\)</span>上，设<spanclass="math inline">\(b_0\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^1\)</span></li><li>在<span class="math inline">\(b_1b_2\)</span>上，设<spanclass="math inline">\(b_1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_2\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_1^1\)</span></li></ol></li><li>第二步：<ol type="1"><li>在<span class="math inline">\(b_0^1b_1^1\)</span>上，设<spanclass="math inline">\(b_0^1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1^1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^2\)</span></li></ol></li><li>则<spanclass="math inline">\(b_0^2\)</span>记为贝塞尔曲线，在时间<code>t</code>所在的位置</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320214216113.png" alt="image-20230320214216113" style="zoom:80%;" /></p><h4 id="四个控制点">11.1.1.2 四个控制点</h4><ol type="1"><li><code>b0</code>为起点，<code>b3</code>为终点，<code>b1,b2</code>控制曲线弯曲</li><li>实际上是：对于每一个时间<code>t</code>，找到当前时刻对应的点的坐标<ol type="1"><li>第一步：<ol type="1"><li>在<span class="math inline">\(b_0b_1\)</span>上，设<spanclass="math inline">\(b_0\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^1\)</span></li><li>在<span class="math inline">\(b_1b_2\)</span>上，设<spanclass="math inline">\(b_1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_2\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_1^1\)</span></li><li>在<span class="math inline">\(b_2b_3\)</span>上，设<spanclass="math inline">\(b_2\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_3\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_2^1\)</span></li></ol></li><li>第二步：<ol type="1"><li>在<span class="math inline">\(b_0^1b_1^1\)</span>上，设<spanclass="math inline">\(b_0^1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1^1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^2\)</span></li><li>在<span class="math inline">\(b_1^1b_2^1\)</span>上，设<spanclass="math inline">\(b_1^1\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_2^1\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_1^2\)</span></li></ol></li><li>第三步：<ol type="1"><li>在<span class="math inline">\(b_0^2b_1^2\)</span>上，设<spanclass="math inline">\(b_0^2\)</span>为时间<code>0</code>，<spanclass="math inline">\(b_1^2\)</span>为时间<code>1</code>，线性插值找到<spanclass="math inline">\(b_0^3\)</span></li></ol></li><li>则<spanclass="math inline">\(b_0^3\)</span>记为贝塞尔曲线，在时间<code>t</code>所在的位置<code>x(t)</code></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320214234859.png" alt="image-20230320214234859" style="zoom:80%;" /></p><h4 id="贝塞尔曲线的代数形式">11.1.1.3 贝塞尔曲线的代数形式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320214621950.png" alt="image-20230320214621950" style="zoom:80%;" /></p><blockquote><p>2阶贝塞尔曲线</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320214734581.png" alt="image-20230320214734581" style="zoom:80%;" /></p><h3 id="n阶贝塞尔曲线的代数表示">11.1.2 n阶贝塞尔曲线的代数表示</h3><blockquote><p>参数为 <strong>(1-t+t)<sup>n</sup></strong> 的多项式展开</p></blockquote><p><span class="math display">\[b^n(t) = \sum_{j=0}^n b_j B_j^n(t)\]</span></p><ol type="1"><li><spanclass="math inline">\(b^n(t)\)</span>：n阶贝塞尔曲线的表达式</li><li><spanclass="math inline">\(b_j\)</span>：第j个控制点，可以为三维空间中的点</li><li><spanclass="math inline">\(B_j^n(t)\)</span>：Bernstein多项式，此处为<spanclass="math inline">\(C_{n}^i\ t^i\ (1-t)^{n-i}\)</span></li></ol><h3 id="贝塞尔曲线的性质">11.1.3 贝塞尔曲线的性质</h3><ol type="1"><li><p>必须过起点和终点：<spanclass="math inline">\(b(0)=b_0,b(1)=b_n\)</span></p></li><li><p>对于三阶贝塞尔曲线：<spanclass="math inline">\(b&#39;(0)=3(b_1-b_0),b&#39;(1)=3(b_3-b_2)\)</span></p></li><li><p>在仿射变换中：<strong>对贝塞尔曲线的仿射变换 &lt;=&gt;对控制点做仿射变换然后再计算贝塞尔曲线</strong></p><ol type="1"><li>但是对投影变换不行</li></ol></li><li><p>凸包性质：<strong>贝塞尔曲线一定在控制点形成的凸包内</strong></p><ol type="1"><li><p>凸包：包围某些顶点的最小凸多边形</p><blockquote><p>可以将顶点想象为钉子，用橡皮筋包裹住所有顶点，然后松手，橡皮筋最后的形状记为这些顶点的凸包</p></blockquote></li><li><p>如果控制点在同一条直线上，则贝塞尔曲线就是这条直线</p></li></ol></li></ol><h3 id="分段贝塞尔曲线-picewise-bezier-curves">11.1.4 分段贝塞尔曲线Picewise Bezier Curves</h3><ol type="1"><li><p>通常为4个控制点，控制一段贝塞尔曲线</p></li><li><p>PS中的钢笔工具，就应用了分段贝塞尔曲线</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320220627770.png" alt="image-20230320220627770" style="zoom:80%;" /></p></li><li><p>保证<strong>连续</strong>（<strong>C<sup>0</sup>连续</strong>）：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320221118919.png" alt="image-20230320221118919" style="zoom:80%;" /></p></li><li><p>保证<strong>光滑/切线连续</strong>（<strong>C<sup>1</sup>连续</strong>）：相邻的两端贝塞尔曲线中，上一段曲线的最后两个控制点，与下一段曲线的最初两个控制点，共线且距离相同</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320221132408.png" alt="image-20230320221132408" style="zoom:80%;" /></p></li></ol><h2 id="样条曲线-spline">11.2 样条曲线 Spline</h2><p>样条：一个可控的曲线</p><h3 id="b样条-basis-spline">11.2.1 B样条 Basis-Spline</h3><p>基函数样条</p><ol type="1"><li>贝塞尔曲线，既可以理解为用Bernstein多项式，对控制点加权求和；也可以理解为用控制点，对Bernstein多项式进行加权求和。则Bernstein多项式，即为基函数</li><li>相当于由不同的函数，通过某一种方式结合起来，得到另一个函数</li><li>B样条是对贝塞尔曲线的扩展，可以保证<strong>修改的局部性</strong>，改变一个点，至多影响曲线的某个部分</li></ol><h2 id="贝塞尔曲面-bezier-surfaces">11.3 贝塞尔曲面 Bezier Surfaces</h2><h3 id="个控制点">11.3.1 4×4个控制点</h3><ol type="1"><li><p>对于每一行的4个控制点，计算每一行的贝塞尔曲线</p></li><li><p>对于每一个时间<code>t1</code>，对应的4行贝塞尔曲线上的点，认为是4个控制点，可以得到另一个贝塞尔曲线，其时间为<code>t2</code></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320222831716.png" alt="image-20230320222831716" style="zoom:80%;" /></p></li><li><p>在<code>t1,t2</code>的变换过程中，即可得到贝塞尔曲面</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320222940089.png" alt="image-20230320222940089" style="zoom:80%;" /></p></li></ol><h3 id="计算贝塞尔曲面">11.3.2 计算贝塞尔曲面</h3><blockquote><p>可以将参数<code>(u,v)</code>，映射到曲面上的对应点，因此贝塞尔曲面是显示表示</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320223338990.png" alt="image-20230320223338990" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320223409877.png" alt="image-20230320223409877" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320223417719.png" alt="image-20230320223417719" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-10：几何1：介绍</title>
      <link href="/2023/02/11/GAMES101/10--%E5%87%A0%E4%BD%951%EF%BC%9A%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/02/11/GAMES101/10--%E5%87%A0%E4%BD%951%EF%BC%9A%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="十几何1介绍">十、几何1：介绍</h1><h2 id="隐式表示-implicit">10.1 隐式表示 Implicit</h2><ol type="1"><li><p><strong>f(x,y,z) =0</strong>：表示一定的关系，并不直接给出实际点</p></li><li><p>优点：便于判断某个<strong>点与面</strong>的关系</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320210121129.png" alt="image-20230320210121129" style="zoom:80%;" /></p></li><li><p>缺点：无法直接判断出<strong>形状</strong>/找到所有在这个面上的点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320210022919.png" alt="image-20230320210022919" style="zoom:80%;" /></p></li></ol><h2 id="显示表示-explicit">10.2 显示表示 Explicit</h2><ol type="1"><li><p>显示表示：直接用三角形表示 / 通过参数映射给出</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320210219640.png" alt="image-20230320210219640" style="zoom:80%;" /></p></li><li><p>优点：便于<strong>取样</strong>，判断形状</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320210302100.png" alt="image-20230320210302100" style="zoom:80%;" /></p></li><li><p>缺点：难以判断某个<strong>点和面</strong>的关系</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320210417478.png" alt="image-20230320210417478" style="zoom:80%;" /></p></li></ol><h2 id="cg中的隐式几何表示">10.3 CG中的隐式几何表示</h2><h3 id="数学公式表述">10.3.1 数学公式表述</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320210536832.png" alt="image-20230320210536832" style="zoom:80%;" /></p><h3 id="构造几何csgconstructive-solid-geometry">10.3.2构造几何CSG：Constructive Solid Geometry</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320210649720.png" alt="image-20230320210649720" style="zoom:80%;" /></p><h3 id="距离函数-distance-functions">10.3.3 距离函数 DistanceFunctions</h3><ol type="1"><li>描述空间中的任何一个点，到该表面的最近距离<ol type="1"><li>如果在物体外，则为正数</li><li>如果在物体内，则为负数</li><li>SDF：有向距离函数</li></ol></li><li>优点：便于做两个物体的<strong>边界融合</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320210931112.png" alt="image-20230320210931112" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320211414373.png" alt="image-20230320211414373" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320211444830.png" alt="image-20230320211444830" style="zoom:80%;" /></p><h3 id="水平集函数">10.3.4 水平集函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320211928804.png" alt="image-20230320211928804" style="zoom:80%;" /></p><h3 id="分形-fractal">10.3.5 分形 Fractal</h3><p><strong>分形 &lt;=&gt; 自相似</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320212054041.png" alt="image-20230320212054041" style="zoom:80%;" /></p><h2 id="cg中的显示几何表示">10.4 CG中的显示几何表示</h2><h3 id="点云">10.4.1 点云</h3><ol type="1"><li>通过特别多的点，表示一个模型</li><li>通常为三维扫描的输出</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320212656886.png" alt="image-20230320212656886" style="zoom:80%;" /></p><h3 id="多边形面">10.4.2 多边形面</h3><ol type="1"><li>通常为三角形 &amp; 四边形</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320212736997.png" alt="image-20230320212736997" style="zoom:80%;" /></p><h3 id="the-wavefront-object-file-format">10.4.3 The Wavefront ObjectFile Format</h3><ol type="1"><li><code>v</code>：点的坐标</li><li><code>vt</code>：纹理坐标</li><li><code>vn</code>：法向</li><li><code>f</code>：连接关系，同一行内为三角形的三个点，每个点的格式为<code>v/vt/vn</code>，表示该点的坐标/纹理坐标/法向</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320212854657.png" alt="image-20230320212854657" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-09：着色3：纹理的应用</title>
      <link href="/2023/02/10/GAMES101/9--%E7%9D%80%E8%89%B23%EF%BC%9A%E7%BA%B9%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/02/10/GAMES101/9--%E7%9D%80%E8%89%B23%EF%BC%9A%E7%BA%B9%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="九着色3纹理的应用">九、着色3：纹理的应用</h1><h2 id="重心坐标-barycentric-coordinates">9.1 重心坐标 BarycentricCoordinates</h2><p>为什么需要插值</p><ol type="1"><li>我们的很多操作是定义在<strong>顶点</strong>上的</li><li>我们需要在<strong>三角形</strong>内获得平滑的值</li></ol><p>插值什么内容</p><ol type="1"><li>纹理坐标、颜色、法线</li></ol><p>怎么做插值</p><ol type="1"><li>重心坐标</li></ol><h3 id="重心坐标是什么">9.1.1 重心坐标是什么</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320181655673.png" alt="image-20230320181655673" style="zoom:80%;" /></p><ol type="1"><li><p>定义在三角形上：三角形<strong>所在平面</strong>的任意一个点的坐标，都可以用三个顶点坐标的线性组合表示，且<spanclass="math inline">\(\alpha+\beta+\gamma=1\)</span></p><ol type="1"><li><span class="math inline">\((x,y)=\alpha A+ \beta B + \gammaC\)</span>，可以得到一个坐标<spanclass="math inline">\((\alpha,\beta,\gamma)\)</span></li><li>如果在<strong>三角形内</strong>，则<spanclass="math inline">\(\alpha,\beta,\gamma\)</span>均为<strong>非负</strong>的</li></ol></li><li><p>求<spanclass="math inline">\(\alpha,\beta,\gamma\)</span>：通过面积计算</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320182149277.png" alt="image-20230320182149277" style="zoom:80%;" /></p></li><li><p>三角形的<strong>重心</strong>：分成的三个三角形面积相等</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320182314078.png" alt="image-20230320182314078" style="zoom:80%;" /></p></li><li><p>使用公式计算：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320182412696.png" alt="image-20230320182412696" style="zoom:80%;" /></p></li></ol><h3 id="重心坐标插值">9.1.2 重心坐标插值</h3><p><strong>注意：投影后，重心坐标可能会改变，因此插值三维属性，应该使用三维坐标</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320182502273.png" alt="image-20230320182502273" style="zoom:80%;" /></p><h2 id="纹理的基础应用">9.2 纹理的基础应用</h2><h3 id="简单纹理映射漫反射颜色">9.2.1 简单纹理映射：漫反射颜色</h3><p>对每一个屏幕中的采样点<spanclass="math inline">\((x,y)\)</span>：</p><ol type="1"><li>通过重心坐标插值，计算<spanclass="math inline">\((x,y)\)</span>对应的纹理坐标<spanclass="math inline">\((u,v)\)</span></li><li>得到纹理中，<spanclass="math inline">\((u,v)\)</span>所在点的颜色，记为<code>texcolor = texture.sample(u,v)</code></li><li>将该采样点的颜色，设置为<code>texcolor</code></li></ol><h3 id="纹理放大双线性插值-bilinear-interpolation">9.2.2纹理放大：双线性插值 Bilinear interpolation</h3><blockquote><p>像素<strong>pixel</strong> &lt;=&gt;纹理元素<strong>texel</strong>，纹理需要放大时，多个pixel会对应到同一个texel上</p></blockquote><blockquote><p>纹理过小：失真</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320184241753.png" alt="image-20230320184241753" style="zoom:80%;" /></p></blockquote><ol type="1"><li>找到临近的四个点</li><li>计算水平距离<code>s</code>和垂直距离<code>t</code>，均为<code>[0,1]</code>之间的值</li><li>定义线性插值操作：<spanclass="math inline">\(lerp(x,v_0,v_1)=v_0+x(v_1-v_0)\)</span>，<spanclass="math inline">\(x\)</span>为<code>[0,1]</code>之间的值</li><li>进行<strong>两次线性插值</strong>操作：<ol type="1"><li>水平方向：<spanclass="math inline">\(u_0=lerp(s,u_{00},u_{10}),u_1=lerp(s,u_{01},u_{11})\)</span></li><li>垂直方向：<spanclass="math inline">\(f(x,y)=lerp(t,u_0,u_1)\)</span></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320183957812.png" alt="image-20230320183957812" style="zoom:80%;" /></p><h3 id="纹理缩小">9.2.3 纹理缩小</h3><blockquote><p>纹理过大：远处摩尔纹，近处锯齿</p><ol type="1"><li>远处，一个像素覆盖了纹理上的很大一块区域，因此会存在走样</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320184320810.png" alt="image-20230320184320810" style="zoom:80%;" /></p></blockquote><h4 id="mipmap">9.2.3.1 Mipmap</h4><p><strong>Mipmap</strong>：允许做<strong>快速、近似、正方形</strong>的范围查询</p><ol type="1"><li><p>每一层均将上一层缩小到原来的一半</p><ol type="1"><li>预处理纹理</li><li>多了1/3的存储量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320185053505.png" alt="image-20230320185053505" style="zoom:80%;" /></p></li><li><p>计算某个像素对应到纹理的正方形区域</p><ol type="1"><li>将屏幕上的某个像素点<code>p1</code>及其两个邻居<code>p2,p3</code>对应到纹理上的三个点<code>t1,t2,t3</code></li><li>在屏幕上，<code>p1</code>与<code>p2</code>的距离为<code>1</code>，<code>p1</code>与<code>p3</code>的距离为<code>1</code></li><li>在纹理中，<code>t1</code>与<code>t2</code>的距离为<code>L1</code>，<code>t1</code>与<code>t2</code>的距离为<code>L2</code></li><li>取<code>L=max(L1,L2)</code>，则该像素在纹理空间上对应的正方形区域为，以<code>t1</code>为中心的<code>L×L</code>的区域</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320185714401.png" alt="image-20230320185714401" style="zoom:80%;" /></p></li><li><p>计算正方形区域的平均值</p><ol type="1"><li>假设正方形为<code>1×1</code>，则可以直接在<code>0</code>层中获得该区域的平均值</li><li>假设正方形为<code>4×4</code>，则可以直接在<code>1</code>层中获得该区域的平均值</li><li>因此，我们可以在第<spanclass="math inline">\(D=log_2L\)</span>层中获取该区域的平均值</li><li>如果<spanclass="math inline">\(log_2L\)</span>不是整数，则可以通过<strong>线性插值</strong>，获得该区域的平均值</li><li>每一层的查询，使用了一次<strong>双线性插值</strong>，最后又进行了一次<strong>线性插值</strong>，因此称为<strong>三线性插值</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320190152780.png" alt="image-20230320190152780" style="zoom:80%;" /></p></li><li><p>缺点：在远处会完全模糊<strong>overblur</strong></p></li></ol><h4 id="各向异性过滤">9.2.3.2 各向异性过滤</h4><p><strong>AnisotropicFiltering</strong>：各向异性过滤，对矩形的区域快速查询平均值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320190538811.png" alt="image-20230320190538811" style="zoom:80%;" /></p><ol type="1"><li>各向异性过滤：水平、竖直压扁，开销为原本的3倍</li><li>EWA过滤：将图像分为一个个的椭圆</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320190625611.png" alt="image-20230320190625611" style="zoom:80%;" /></p><h2 id="纹理的其他应用">9.3 纹理的其他应用</h2><p>现代GPU中，纹理的本质：是一块内存区域，且可以进行范围查询</p><h3 id="环境贴图-environment-map">9.3.1 环境贴图 Environment Map</h3><ol type="1"><li>环境贴图：即为空间中的某个点，向上下左右前后六个方向，所能接收到的光</li><li>可以通过环境贴图，进行光照计算，进而实现环境光渲染</li><li>基本假设：环境光来自无限远处，只记录环境光的方向信息</li><li>可以使用<strong>Spherical Map</strong>或者<strong>CubeMap</strong>表示</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320203116579.png" alt="image-20230320203116579" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320203423125.png" alt="image-20230320203423125" style="zoom:80%;" /></p><blockquote><p>由于立方体的<strong>各个面都是均匀</strong>的，因此能很好的避免天空球的<strong>极点消失</strong>现象</p><ol type="1"><li>天空盒只记录方向信息</li><li>需要先判断某个方向是属于哪一个面上的</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320203303350.png" alt="image-20230320203303350" style="zoom:80%;" /></p><h3 id="凹凸贴图-法线贴图">9.3.2 凹凸贴图 &amp; 法线贴图</h3><ol type="1"><li>凹凸贴图：定义某个点的相对高度(沿法线移动的距离)，从而改变周围像素的法线方向</li><li>法线贴图：定义某个点的法线</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320203552597.png" alt="image-20230320203552597" style="zoom:80%;" /></p><blockquote><p>计算修改后的法线</p></blockquote><ol type="1"><li><p>一维贴图，修改像素的法线：<strong>flatland</strong></p><ol type="1"><li>设原来的表面法线<code>n(p)=(0, 1)</code></li><li>计算梯度：<code>dp=c*[h(p+1)-h(p)]</code></li><li>则切线为：<code>(1,dp)</code></li><li>因此更改后的法线为：<code>n(p)=(-dp, 1).normalized()</code></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320203941915.png" alt="image-20230320203941915" style="zoom:80%;" /></p></li><li><p>二维贴图，修改像素的法线：<strong>局部坐标系下</strong></p><ol type="1"><li>设原来的表面法线<code>n(p)=(0, 0, 1)</code></li><li>计算梯度：<code>dp/du=c1*[h(u+1)-h(u)]</code>，<code>dp/dv=c2*[h(v+1)-h(v)]</code></li><li>因此更改后的法线为：<code>n(p)=(-dp/du, -dp/dv ,1).normalized()</code></li></ol></li></ol><h3 id="位移贴图-displacement-mapping">9.3.3 位移贴图 DisplacementMapping</h3><ol type="1"><li>与凹凸贴图类似，但是会直接<strong>更改三角形顶点的位置</strong></li><li>要求原有模型的三角形比较细，要求模型的三角形顶点之间的间隔，比纹理之间的间隔小</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320204818983.png" alt="image-20230320204818983" style="zoom:80%;" /></p><h3 id="三维纹理">9.3.4 三维纹理</h3><ol type="1"><li>定义一个三维空间的噪声函数，可以得到三维空间中，任意一个点的属性</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320205137485.png" alt="image-20230320205137485" style="zoom:80%;" /></p><h3 id="保存预处理的数据">9.3.5 保存预处理的数据</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320205230388.png" alt="image-20230320205230388" style="zoom:80%;" /></p><h3 id="三维纹理-体积渲染">9.3.6 三维纹理 &amp; 体积渲染</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230320205313633.png" alt="image-20230320205313633" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-08：着色2：着色频率&amp;实时渲染管线</title>
      <link href="/2023/02/09/GAMES101/8--%E7%9D%80%E8%89%B22%EF%BC%9A%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87&amp;%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2023/02/09/GAMES101/8--%E7%9D%80%E8%89%B22%EF%BC%9A%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87&amp;%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1id="八着色2着色频率实时渲染管线">八、着色2：着色频率&amp;实时渲染管线</h1><h2 id="着色频率">8.1 着色频率</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316221140250.png" alt="image-20230316221140250" style="zoom:80%;" /></p><ol type="1"><li>着色频率即为：将结果应用到哪些平面上<ol type="1"><li>左1：应用到每个三角面上，<strong>Flat Shading</strong></li><li>左2：应用到每个顶点上，<strong>Gouraud Shading</strong></li><li>左3：应用到每个像素上，<strong>Phong Shading</strong></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316221604284.png" alt="image-20230316221604284" style="zoom:80%;" /></p><h3 id="计算顶点法线">8.1.1 计算顶点法线</h3><blockquote><p>将与该顶点相关的所有面的法线，做加权平均，权重为三角形面积</p></blockquote><p><span class="math display">\[N_v=\frac{\sum_i N_i}{|\sum_i N_i|}\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316221815730.png" alt="image-20230316221815730" style="zoom:80%;" /></p><h3 id="计算像素法线">8.1.2 计算像素法线</h3><blockquote><p>使用重心坐标，对相邻两个顶点的法线进行插值</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316222038138.png" alt="image-20230316222038138" style="zoom:80%;" /></p><h2 id="实时渲染管线">8.2 实时渲染管线</h2><ol type="1"><li>输入：3维空间中的若干个点</li><li><strong>Vertex Processing</strong>：将3维空间的点，投影到屏幕空间上<ol type="1"><li>Model, View Projection变换</li><li>着色、纹理映射</li></ol></li><li><strong>Triangle Processing</strong>：形成屏幕空间上的三角形</li><li><strong>Rasterization</strong>：通过光栅化，将三角形绘制到屏幕上<ol type="1"><li>对三角形是否覆盖进行采样</li></ol></li><li><strong>Fragment Processing</strong>：对像素进行着色<ol type="1"><li>Z-Buffer</li><li>着色、纹理映射</li></ol></li><li><strong>Framebuffer Opreations</strong>：将三角形拼装成图像</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316222331676.png" alt="image-20230316222331676" style="zoom:80%;" /></p><h2 id="shader程序">8.3 Shader程序</h2><ol type="1"><li>对每一个顶点/像素，Shader均会执行一次</li><li>顶点着色器：对顶点操作</li><li>片段着色器、像素着色器：对像素操作，确定当前像素是什么颜色</li></ol><h2 id="gpu">8.4 GPU</h2><ol type="1"><li>是整个图形管线的硬件实现：如光栅化、投影</li><li>有一部分是可编程的：即着色器</li><li>GPGPU：通用GPU计算，可以完成各种各样的GPU计算</li><li>是一个高度并行化的多核处理器</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316225348436.png" alt="image-20230316225348436" style="zoom:80%;" /></p><h2 id="纹理映射">8.5 纹理映射</h2><ol type="1"><li><p>根本作用：定义3维物体上任何一个点的属性</p></li><li><p><strong>纹理</strong>：任何一个3维物体的表面都是2维的，因此可以和一张图有一个一一对应的关系，这张图即为纹理</p><ol type="1"><li>将3维物体上的每一个三角形的顶点，映射到纹理图像上<ol type="1"><li>由美工完成</li><li>自动化：参数化模型</li></ol></li></ol></li><li><p>UV坐标系：即纹理坐标的坐标系，通常范围为[0~1] × [0~1]</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316230121429.png" alt="image-20230316230121429" style="zoom:80%;" /></p></li><li><p>不同的位置可以映射到同一个位置上</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316230208252.png" alt="image-20230316230208252" style="zoom:80%;" /></p></li><li><p>好的纹理：纹理的上下左右可以无缝衔接，称为<strong>tiledtextures</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316230252605.png" alt="image-20230316230252605" style="zoom:80%;" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-07：着色1：Blinn-Phong反射模型</title>
      <link href="/2023/02/08/GAMES101/7--%E7%9D%80%E8%89%B21%EF%BC%9ABlinn-Phong%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/02/08/GAMES101/7--%E7%9D%80%E8%89%B21%EF%BC%9ABlinn-Phong%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="七着色1blinn-phong反射模型">七、着色1：Blinn-Phong反射模型</h1><blockquote><p><strong>Shading</strong>：着色</p><ol type="1"><li>对不同物体，定义不同材质，从而与光线产生不同作用</li></ol><p>局部性：</p><ol type="1"><li>只考虑自己的属性，不考虑与其他物体的存在</li><li>因此，没有阴影</li></ol></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316203039767.png"alt="image-20230316203039767" /><figcaption aria-hidden="true">image-20230316203039767</figcaption></figure><h2 id="反射模型的输入">7.1 反射模型的输入</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316203536809.png" alt="image-20230316203536809" style="zoom:80%;" /></p><h2 id="光照的能量传递关系">7.2 光照的能量传递关系</h2><ol type="1"><li><p>余弦定理：单位面积接收到的光的能量占比为<code>cos θ</code>，<code>θ</code>为光照方向与平面法线的夹角</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316204159302.png" alt="image-20230316204159302" style="zoom:80%;" /></p></li><li><p>设光源的能量为<code>I</code>，光源与表面的距离为<code>r</code>，则到达表面的能量为<spanclass="math inline">\(\frac{I}{r^2}\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316204518794.png" alt="image-20230316204518794" style="zoom:80%;" /></p></li></ol><h2 id="漫反射-diffuse-reflection">7.3 漫反射 Diffuse Reflection</h2><p><span class="math display">\[L_d=k_d\frac{I}{r^2}max(0,\vec{n}·\vec{l})\]</span></p><ol type="1"><li><span class="math inline">\(L_d\)</span>：漫反射光照</li><li><spanclass="math inline">\(k_d\)</span>：漫反射系数，通常为物体的颜色</li><li><span class="math inline">\(I/r^2\)</span>：到达该点的能量</li><li><spanclass="math inline">\(max(0,\vec{n}·\vec{l})\)</span>：该点接收到的能量</li><li>由于漫反射到四面八方的能量均相同，因此没有<spanclass="math inline">\(\vec{v}\)</span>的事情</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316204556352.png" alt="image-20230316204556352" style="zoom:80%;" /></p><h2 id="镜面反射高光项-specular-reflection">7.4 镜面反射&amp;高光项Specular Reflection</h2><blockquote><p>接近镜面反射时，会出现高光</p></blockquote><p><span class="math display">\[L_s=k_s\frac{I}{r^2}max(0,\vec{n}·\vec{h})^p\]</span></p><ol type="1"><li><span class="math inline">\(L_s\)</span>：镜面反射光照</li><li><spanclass="math inline">\(k_s\)</span>：镜面反射系数，通常为白色</li><li><span class="math inline">\(I/r^2\)</span>：到达该点的能量</li><li><spanclass="math inline">\(max(0,\vec{n}·\vec{l})\)</span>：该点接收到的能量</li><li><spanclass="math inline">\(p\)</span>：为了让高光的区域足够小，需要将夹角余弦进行幂操作</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316205631263.png" alt="image-20230316205631263" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316220333380.png" alt="image-20230316220333380" style="zoom:80%;" /></p><h2 id="环境光-ambient-term">7.5 环境光 Ambient Term</h2><blockquote><p>假设所有点接收到的环境光均相同</p></blockquote><p><span class="math display">\[L_a=k_aI_a\]</span></p><ol type="1"><li><span class="math inline">\(L_a\)</span>：环境光</li><li><spanclass="math inline">\(k_a\)</span>：环境光系数，通常为物体颜色</li><li>环境光通常为一个常量，保证没有地方是黑的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316220425251.png" alt="image-20230316220425251" style="zoom:80%;" /></p><h2 id="blinn-phong反射模型">7.6 Blinn-Phong反射模型</h2><p><span class="math display">\[\begin{aligned}L &amp;= L_a+L_d+L_s\\  &amp;= k_aI_a+k_d\frac{I}{r^2}max(0,n·l)+k_s\frac{I}{r^2}max(0,n·h)^p\end{aligned}\]</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316220636330.png" alt="image-20230316220636330" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-06：光栅化2：反走样&amp;深度缓冲</title>
      <link href="/2023/02/07/GAMES101/6--%E5%85%89%E6%A0%85%E5%8C%962%EF%BC%9A%E5%8F%8D%E8%B5%B0%E6%A0%B7&amp;%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/"/>
      <url>/2023/02/07/GAMES101/6--%E5%85%89%E6%A0%85%E5%8C%962%EF%BC%9A%E5%8F%8D%E8%B5%B0%E6%A0%B7&amp;%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="六光栅化2反走样深度缓冲">六、光栅化2：反走样&amp;深度缓冲</h1><blockquote><p><strong>Antialiasing and Z-Buffering</strong></p></blockquote><ol type="1"><li><p><strong>Artifacts</strong>：瑕疵，指一切看上去不太对的地方</p></li><li><p>采样可能产生的瑕疵：</p><ol type="1"><li><p>锯齿</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226185128331.png" alt="image-20230226185128331" style="zoom: 50%;" /></p></li><li><p>摩尔纹：将左图的奇数行和奇数列删除，会产生右面的效果</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226185149464.png" alt="image-20230226185149464" style="zoom:80%;" /></p></li></ol></li><li><p>车轮效应：车轮高速逆时针旋转时，看上去好像是在顺时针旋转</p></li></ol><table><thead><tr><th style="text-align: center;">现象</th><th style="text-align: center;">原因</th></tr></thead><tbody><tr><td style="text-align: center;">锯齿 Jaggies</td><td style="text-align: center;">在空间上的采样率不足</td></tr><tr><td style="text-align: center;">摩尔纹 Moire</td><td style="text-align: center;">对一个图像降低采样率</td></tr><tr><td style="text-align: center;">车轮效应 Wagon wheel effect</td><td style="text-align: center;">在时间上的采样率不足</td></tr></tbody></table><h2 id="反走样方法在采样之前进行过滤模糊处理">6.1反走样方法：在采样之前进行过滤/模糊处理</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226185816066.png" alt="image-20230226185816066" style="zoom:80%;" /></p><h3 id="先滤波后采样aliasing">6.1.1 先滤波，后采样：Aliasing</h3><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><th style="text-align: center;">原始图片</th><th style="text-align: center;">点采样</th><th style="text-align: center;">模糊处理抗锯齿</th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226185933649.png" alt="image-20230226185933649" style="zoom:80%;" /></td><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226185944079.png" alt="image-20230226185944079" style="zoom:80%;" /></td><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226185951932.png" alt="image-20230226185951932" style="zoom:80%;" /></td></tr></tbody></table><h3 id="先采样后滤波blurred-aliasing">6.1.2 先采样，后滤波：BlurredAliasing</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226190155171.png" alt="image-20230226190155171" style="zoom:80%;" /></p><h2 id="频率域">6.2 频率域</h2><h3 id="空间域-与-频率域的转换傅里叶变换">6.2.1 空间域 与频率域的转换：傅里叶变换</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226191158596.png" alt="image-20230226191158596" style="zoom:80%;" /></p><ol type="1"><li>任何一个函数，均可以展开为多个三角函数的和</li><li>傅里叶变换，实际上就是将函数在不同频率域上展开</li></ol><h3 id="函数的频率越高需要的采样频率越高">6.2.2函数的频率越高，需要的采样频率越高</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226191506715.png" alt="image-20230226191506715" style="zoom:80%;" /></p><h3 id="从频率角度理解走样">6.2.3 从频率角度理解走样</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226191902811.png" alt="image-20230226191902811" style="zoom:80%;" /></p><ol type="1"><li>在采样频率一定时，采样两个频率不同的函数，我们无法区分这两个函数，因此会产生锯齿</li></ol><h2 id="滤波删除一些频率的内容">6.3 滤波：删除一些频率的内容</h2><h3 id="通过傅里叶变换将图像变为频率图">6.3.1通过傅里叶变换，将图像变为频率图</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226192200644.png" alt="image-20230226192200644" style="zoom:80%;" /></p><ol type="1"><li>中心是低频区，四周是高频区</li><li>亮度表示当前频率包含的信息数量</li><li>上图的信息主要集中在低频区</li><li>出现两条线的原因<ol type="1"><li>一般情况下，傅里叶变换会将图像视为周期函数</li><li>对于图片来说，相当于在图像的右边再复制一份图像</li><li>通常情况下，图片的左右边界不会相同，因此在边界处会有剧烈的变换</li><li>分析图像内部的内容时，一般忽略这两条线</li></ol></li></ol><h3 id="高通滤波">6.3.2 高通滤波</h3><blockquote><p><strong>高通滤波 ==&gt; 只保留图像的高频部分 ==&gt;图像内容的边界</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226192757970.png" alt="image-20230226192757970" style="zoom:80%;" /></p><h3 id="低通滤波">6.3.3 低通滤波</h3><blockquote><p><strong>低通滤波 ==&gt; 只保留图像的低频部分 ==&gt;对图像的模糊处理</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226192911384.png" alt="image-20230226192911384" style="zoom:80%;" /></p><h3 id="过滤高频和低频部分">6.3.4 过滤高频和低频部分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226193200309.png" alt="image-20230226193200309" style="zoom:80%;" /></p><h2 id="滤波-平均-卷积">6.4 滤波 = 平均 = 卷积</h2><blockquote><p><strong>Filter = Averaging = Convolution</strong></p><ol type="1"><li>滤波器覆盖信号的某些部分时，将对应位做点乘：卷积操作</li><li>实际上也是一个平均操作</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226193458236.png" alt="image-20230226193458236" style="zoom:80%;" /></p><h3 id="卷积定理时域的卷积-频域的乘积">6.4.1 卷积定理：时域的卷积&lt;=&gt; 频域的乘积</h3><p><strong>卷积定理</strong>：在时域上的卷积，等价于在频域上的乘积，即以下两个操作等价</p><ol type="1"><li>在时域上，通过卷积进行滤波</li><li>先通过傅里叶变换，将函数与滤波器转换到频域上；然后把两者相乘；最后再进行逆傅里叶变换，变换到时域上</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226194122537.png" alt="image-20230226194122537" style="zoom:80%;" /></p><h3 id="滤波器的时域与频域的关系">6.4.2 滤波器的时域与频域的关系</h3><blockquote><p>时域上变大了，频域上反而变低了：Box越大，得出的结果越模糊</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226194605360.png" alt="image-20230226194605360" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226194506188.png" alt="image-20230226194506188" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226194514473.png" alt="image-20230226194514473" style="zoom:80%;" /></p><h2 id="频率角度理解采样">6.5 频率角度理解采样</h2><h3 id="采样-重复原始信号的频谱">6.5.1 采样 = 重复原始信号的频谱</h3><blockquote><p>采样频率越快，频谱复制越稀疏</p><p>采样频率越满，频谱复制越密集</p></blockquote><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><th style="text-align: center;">时域上采样 &lt;=&gt; 两个函数相乘</th><th style="text-align: center;">频域上的卷积 &lt;=&gt;重复原始信号的频谱</th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226194857621.png" alt="image-20230226194857621" style="zoom:80%;" /></td><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226194911883.png" alt="image-20230226194911883" style="zoom:80%;" /></td></tr></tbody></table><h3 id="走样-频谱的内容出现重叠">6.5.2 走样 = 频谱的内容出现重叠</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226195426029.png" alt="image-20230226195426029" style="zoom:80%;" /></p><h3 id="反走样-先删除高频信息在采样">6.5.3 反走样 =先删除高频信息，在采样</h3><ol type="1"><li>先模糊，后采样：先删除一个信号的高频信息，然后在进行采样</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226195656888.png" alt="image-20230226195656888" style="zoom:80%;" /></p><h2 id="反走样的实际做法">6.6 反走样的实际做法</h2><ol type="1"><li>对每个像素，根据三角形覆盖的面积，做平均值</li><li>然后再进行采样</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226200044458.png" alt="image-20230226200044458" style="zoom:80%;" /></p><h3 id="msaamultisample-antialiasing">6.6.1 MSAA：MultisampleAntialiasing</h3><ol type="1"><li><strong>超采样SuperSampling</strong>：将每个像素划分为多个小的采样点，然后该像素的颜色为多个采样点的平均</li><li>MSAA近似的是抗锯齿的第一步操作，即<strong>模糊处理</strong></li><li>MSAA无法提高屏幕的分辨率，只是通过多个采样点得到近似的三角形覆盖</li><li>MSAA是通过增大计算量，得到抗锯齿效果</li><li>在实际使用中，会将采样点按特殊的方法排列，有些采样点还会被多个像素复用</li></ol><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226201008321.png" alt="image-20230226201008321" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226201027928.png" alt="image-20230226201027928" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226201036128.png" alt="image-20230226201036128" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226201053512.png" alt="image-20230226201053512" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226201100860.png" alt="image-20230226201100860" style="zoom:80%;" /></p></blockquote><h3 id="fxaafast-approximate-antialiasing">6.6.2 FXAA：Fast ApproximateAntialiasing</h3><ol type="1"><li>快速近似抗锯齿</li><li>通过图像的后期处理，先将有锯齿的图像得出来，然后通过图像匹配找到边界，将这些像素换为边界上的颜色</li></ol><h3 id="taatemporal-antialiasing">6.6.3 TAA：Temporal Antialiasing</h3><ol type="1"><li>通过找上一帧的信息，进行抗锯齿操作</li><li>假设是静止画面，在相邻两帧同一个像素用不同的点感知是否在一个三角形内</li><li>复用上一帧感知到的值，相当于将MSAA的采样点分布在时间上，对于具体的某一帧没有额外操作</li></ol><h2 id="超分辨率超采样">6.7 超分辨率/超采样</h2><ol type="1"><li>采样率不够，而分辨率较大时，会使用这种技术</li><li>DLSS：Deep Learning SuperSampling，通过深度学习，猜测丢失的信息</li></ol><h2 id="深度缓冲解决可见性">6.8 深度缓冲：解决可见性</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230316201036427.png" alt="image-20230316201036427" style="zoom:80%;" /></p><ol type="1"><li>Z-Buffer：存储<strong>每一个像素</strong>，所看到的几何物体的最浅距离<ol type="1"><li>设Z始终为整数，且Z越小离相机越近</li></ol></li><li>具体算法：<ol type="1"><li>初始化深度缓存为<code>∞</code></li><li>对于每一个三角形<code>T</code><ol type="1"><li>对于<code>T</code>中的每一个采样点<code>(x,y,z)</code>：</li><li>如果<code>Z &lt; z-buffer[x,y]</code>：更新<code>frame-buffer、z-buffer</code></li><li>否则，跳过该采样点</li></ol></li></ol></li><li>复杂度<ol type="1"><li>有<code>n</code>个三角形，则复杂度为<code>O(n)</code></li><li>此处并没有排序，而是对每一个像素，维护了一个最小值</li></ol></li><li>画出来的结果，与画三角形的顺序无关</li><li><strong>深度缓存无法处理透明物体</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-05：光栅化1：三角形</title>
      <link href="/2023/02/06/GAMES101/5--%E5%85%89%E6%A0%85%E5%8C%961%EF%BC%9A%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2023/02/06/GAMES101/5--%E5%85%89%E6%A0%85%E5%8C%961%EF%BC%9A%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="五光栅化1三角形">五、光栅化1：三角形</h1><blockquote><p>规范立方体 =&gt; 屏幕：<strong>Canonical Cube to Screen</strong></p></blockquote><h2 id="屏幕的定义">5.1 屏幕的定义</h2><ol type="1"><li><p>像素点形成的二维数组</p><ol type="1"><li>数组的大小：分辨率<strong>Resolution</strong></li></ol></li><li><p>屏幕是一个典型的光栅成像设备：<strong>Raster Display</strong></p><ol type="1"><li>在德语中，raster == screen</li><li>rasterize == drawing onto the screen</li></ol></li><li><p>像素<strong>Pixel</strong>：FYL，picture element的缩写</p><ol type="1"><li>在本节课中，一个像素就是一个小的立方体，有着一个固定的颜色</li><li>颜色是红、绿、蓝的组合</li></ol></li><li><p>屏幕空间<strong>Screen Space</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813114126068.png" alt="image-20220813114126068" style="zoom:67%;" /></p></li><li><p>像素的坐标</p><ol type="1"><li>由一个整数坐标<strong>(x,y)</strong>表示，范围为<strong>(0,0) ~(width-1, height-1)</strong></li><li>像素的中心在<strong>(x+0.5, y+0.5)</strong></li><li>屏幕的范围为<strong>(0, 0) ~ (width, height)</strong></li></ol></li></ol><h2 id="视口变换-113-rightarrow-0width0height">5.2 视口变换：<spanclass="math inline">\([-1,1]^3 \rightarrow[0,width]×[0,height]\)</span></h2><blockquote><p><strong>Viewport Transform</strong>，思想：</p><ol type="1"><li>忽略Z</li><li>变换XY坐标：<span class="math inline">\([-1,1]^2 \rightarrow[0,width]×[0,height]\)</span></li></ol><p>此时，三维空间中的多种物体，已经变成了二维空间上的多个多边形</p></blockquote><p><span class="math display">\[M_{viewport}=\left(\begin{matrix}\frac{width}{2} &amp; 0                 &amp; 0 &amp; \frac{width}{2} \\0               &amp; \frac{height}{2}  &amp; 0 &amp; \frac{height}{2}\\0               &amp; 0                 &amp; 1 &amp; 0 \\0               &amp; 0                 &amp; 0 &amp; 1\end{matrix}\right)\]</span></p><h2 id="现代显示原理">5.3 现代显示原理</h2><ol type="1"><li><p>帧缓冲<strong>FrameBuffer</strong>：将内存中的一块区域映射到屏幕上，内存中的数据即为要显示的数据</p></li><li><p>液晶显示器<strong>LCD</strong>：Liquid Crystal Display，通过液晶将光翻转</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226081745766.png" alt="image-20230226081745766" style="zoom:80%;" /></p></li><li><p>发光二极管阵列LED：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226081945181.png" alt="image-20230226081945181" style="zoom:80%;" /></p></li><li><p>电子墨水屏：通过通电，控制每个像素的黑色/白色</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226082024437.png" alt="image-20230226082024437" style="zoom:80%;" /></p></li></ol><h2 id="三角形的性质">5.4 三角形的性质</h2><ol type="1"><li>最基础的多边形，任何多边形都可以拆分成多个三角形</li><li>三角形三个顶点一定共面</li><li>可以很好的定义内部外部</li><li>定义三个顶点的属性后，可以轻易定义三角形内部的每个点的属性插值：重心插值</li></ol><h2 id="光栅化三角形-像素">5.5 光栅化：三角形 =&gt; 像素</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813121135954.png" alt="image-20220813121135954" style="zoom: 67%;" /></p><h3 id="采样法-确定像素颜色">5.5.1 采样法 确定像素颜色</h3><blockquote><p><strong>Sampling</strong>：对于每一个采样点，查询函数的值</p></blockquote><ol type="1"><li><p>也就是函数离散化的过程</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; x++)</span><br><span class="line">    output[x] = <span class="built_in">f</span>(x);</span><br></pre></td></tr></table></figure></li><li><p>定义一个函数：<strong>inside(t, x, y)</strong> <spanclass="math display">\[inside(t,x,y)=\left\{\begin{matrix}1 &amp; (x,y)在三角形t内\\0 &amp; (x,y)不在三角形t内\end{matrix}\right.\]</span></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; y++)</span><br><span class="line">        image[x][y] = <span class="built_in">inside</span>(tri, x+<span class="number">0.5</span>, y+<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813121848377.png" alt="image-20220813121848377" style="zoom: 67%;" /></p></li><li><p><strong>inside(t, x,y)</strong>函数的实现方法：<strong>叉乘</strong></p><ol type="1"><li><p>已知点与三角形共面，如何判断一个点是否在三角形内</p></li><li><p>按照<spanclass="math inline">\(P_0,P_1,P_2\)</span>的顺序进行叉乘<spanclass="math inline">\(\vec{P_0P_1}×\vec{P_0Q}、\vec{P_1P_2}×\vec{P_1Q}、\vec{P_2P_0}×\vec{P_2Q}\)</span>，三者的<spanclass="math inline">\(Z\)</span>的正负性相同则说明<spanclass="math inline">\(Q\)</span>在三角形内</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813122230668.png" alt="image-20220813122230668" style="zoom: 50%;" /></p></li><li><p>边界情况：可以不做处理 or 特殊处理，在本课中，均不做处理</p></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813122354867.png" alt="image-20220813122354867" style="zoom: 50%;" /></p></li></ol><h3 id="三角形的包围盒">5.5.2 三角形的包围盒</h3><ol type="1"><li><p>三角形的包围盒<strong>BoundingBox</strong>：只需要考虑包围盒内的像素</p><ol type="1"><li><p>这里是轴向的<strong>AABB</strong>包围盒，因为只有XY平面的</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813122501707.png" alt="image-20220813122501707" style="zoom:50%;" /></p></li></ol></li><li><p>也可以对每行计算 最左像素 和 最右像素</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813122658221.png" alt="image-20220813122658221" style="zoom:50%;" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-04：变换2：三维变换</title>
      <link href="/2023/02/05/GAMES101/4--%E5%8F%98%E6%8D%A22%EF%BC%9A%E4%B8%89%E7%BB%B4%E5%8F%98%E6%8D%A2/"/>
      <url>/2023/02/05/GAMES101/4--%E5%8F%98%E6%8D%A22%EF%BC%9A%E4%B8%89%E7%BB%B4%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="四变换2三维变换">四、变换2：三维变换</h1><h2 id="有关旋转的补充">4.0 有关旋转的补充</h2><strong>旋转矩阵的逆 == 旋转矩阵的转置</strong> ==&gt;<strong>旋转矩阵为正交矩阵</strong> $$ R_{}= (<span class="math display">\[\begin{matrix}\cos\theta &amp; -\sin\theta \\\sin\theta &amp; \cos\theta\end{matrix}\]</span><p>) \</p>R_{-}= (<span class="math display">\[\begin{matrix}\cos\theta &amp; \sin\theta \\-\sin\theta &amp; \cos\theta\end{matrix}\]</span><p>) =R_{}^T \</p><p>R_{-}=R_^{-1} $$</p><p>正交矩阵：<span class="math inline">\(R^T=R^{-1}\)</span></p><h2 id="d-transformations">4.1 3D Transformations</h2><h3 id="齐次坐标">4.4.1 齐次坐标</h3><ol type="1"><li>3维点：<span class="math inline">\((x,y,z,1)^T\)</span></li><li>3维点的补充形式：<spanclass="math inline">\((x,y,z,w)^T\)</span>与<spanclass="math inline">\((\frac{x}{w},\frac{y}{w},\frac{z}{w},1)^T\)</span>等价</li><li>3维向量：<span class="math inline">\((x,y,z,0)^T\)</span></li></ol><h3 id="仿射变换">4.4.2 仿射变换</h3><blockquote><p><strong>Affine Transform</strong>：</p></blockquote><ol type="1"><li>变换的顺序：先<strong>线性变换</strong>，后加<strong>平移</strong>量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812113815122.png" alt="image-20220812113815122" style="zoom:80%;" /></p><h4 id="缩放">4.4.2.1 缩放</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812113919856.png" alt="image-20220812113919856" style="zoom:80%;" /></p><h4 id="平移">4.4.2.2 平移</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812113927686.png" alt="image-20220812113927686" style="zoom:80%;" /></p><h4 id="旋转">4.4.2.3 旋转</h4><h5 id="绕坐标轴旋转">4.4.2.3.1 绕坐标轴旋转</h5><ol type="1"><li><p>绕X轴：X不变，YZ旋转</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812114205936.png" alt="image-20220812114205936" style="zoom:80%;" /></p></li><li><p>绕Y轴：Y不变，ZX旋转</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812114238231.png" alt="image-20220812114238231" style="zoom:80%;" /></p></li><li><p>绕Z轴：Z不变，XY旋转</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812114220868.png" alt="image-20220812114220868" style="zoom:80%;" /></p></li></ol><h5 id="绕任意过原点的轴旋转">4.4.2.3.2 绕任意过原点的轴旋转</h5><blockquote><p>有两种形式：欧拉角、四元数</p><ol type="1"><li>四元数：多应用于旋转的插值操作</li></ol></blockquote><ol type="1"><li><p>绕任意轴旋转：分解为<strong>欧拉角</strong></p><ol type="1"><li>将任意轴方向的旋转，分解为绕X、Y、Z轴的旋转：<spanclass="math inline">\(R_{x,y,z}(\alpha,\beta,\gamma)\)</span></li><li><spanclass="math inline">\(\alpha,\beta,\gamma\)</span>也被称为欧拉角</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226070451531.png" alt="image-20230226070451531" style="zoom: 80%;" /></p></li><li><p><strong>Rodrigues’ Rotation Formula 罗德里格旋转公式</strong></p><ol type="1"><li>向量<strong>v</strong>绕过原点的轴<strong>n</strong>旋转<strong><spanclass="math inline">\(\alpha\)</span></strong>角</li><li>向量<strong>I</strong>为向量<strong>v</strong>方向的单位向量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226070549341.png" alt="image-20230226070549341" style="zoom:80%;" /></p></li></ol><blockquote><p>推导思路：</p><ol type="1"><li><p><strong>v</strong>与<strong>n</strong>垂直时，<spanclass="math inline">\(\vec{v&#39;}=\cos\alpha*\vec{v}+\sin\alpha*(\vec{n}×\vec{I})\)</span></p></li><li><p><strong>v</strong>与<strong>n</strong>不垂直时，将<strong>v</strong>分解为垂直于<strong>n</strong>的向量<strong>v<sub>⊥</sub></strong>和平行于<strong>n</strong>的向量<strong>v<sub>∥</sub></strong></p><ol type="1"><li><spanclass="math inline">\(\vec{v_∥&#39;}=\vec{v_∥}=|\vec{v}|*cos&lt;\vec{v},\vec{n}&gt;=\vec{v}·\vec{n}·\vec{n}\)</span></li><li><spanclass="math inline">\(\vec{v_⊥}=\vec{v}-\vec{v_∥}=\vec{v}-\vec{v}·\vec{n}·\vec{n}\)</span></li><li><spanclass="math inline">\(\vec{v_⊥&#39;}=\cos\alpha*\vec{v_⊥}+\sin\alpha*(\vec{n}×\vec{v_⊥})\)</span></li><li>综上可得：<spanclass="math inline">\(\vec{v&#39;}=\vec{v_∥&#39;}+\vec{v_⊥&#39;}=\cos\alpha*\vec{v}+(1-\cos\alpha)*\vec{v}·\vec{n}·\vec{n}+\sin\alpha*(\vec{n}×\vec{v})\)</span></li></ol></li><li><p>矩阵形式：<spanclass="math inline">\(\vec{v&#39;}=\cos\alpha*\vec{v}+(1-\cos\alpha)*\vec{v}·\vec{n}·\vec{n}+\sin\alpha*(\vec{n}×\vec{v})\)</span>$</p><p>​ <spanclass="math inline">\(=[\cos\alpha*\vec{I}+(1-\cos\alpha)*\vec{n}·\vec{n}^T+\sin\alpha*(\vec{n}×\vec{I})]·\vec{v}\)</span></p></li></ol></blockquote><h5 id="绕过任意点的任意轴旋转">4.4.2.3.2 绕过任意点的任意轴旋转</h5><p>绕过任意轴<strong>n</strong>旋转<strong><spanclass="math inline">\(\alpha\)</span></strong>角</p><ol type="1"><li>先将轴平移至过原点</li><li>然后旋转</li><li>最后平移回去</li></ol><h2 id="model-view-transformation">4.2 Model &amp; ViewTransformation</h2><h3 id="什么是视图变换">4.2.1 什么是视图变换</h3><ol type="1"><li>与照相类比：<strong>MVP</strong>变换</li></ol><table><colgroup><col style="width: 42%" /><col style="width: 57%" /></colgroup><thead><tr><th style="text-align: center;">照相</th><th style="text-align: center;">对应变换</th></tr></thead><tbody><tr><td style="text-align: center;">找一个好的地方、人物排列</td><td style="text-align: center;">模型变换 <strong>model</strong>transformation</td></tr><tr><td style="text-align: center;">找一个好的角度放置摄像机</td><td style="text-align: center;">视图变换 <strong>view</strong>transformation</td></tr><tr><td style="text-align: center;">拍照，三维空间投影到二维平面</td><td style="text-align: center;">投影变换 <strong>projection</strong>transformation</td></tr></tbody></table><h3 id="定义camera">4.2.2 定义Camera</h3><ol type="1"><li>位置<strong>Position</strong>：<spanclass="math inline">\(\vec{e}\)</span></li><li>往哪看<strong>Look-at/gaze direction</strong>：<spanclass="math inline">\(\vec{g}\)</span></li><li>向上方向<strong>Up direction</strong>：<spanclass="math inline">\(\vec{t}\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812123220752.png" alt="image-20220812123220752" style="zoom:80%;" /></p><h3 id="关键点相机与物体的相对位置决定看到的图像">4.2.3关键点：相机与物体的相对位置决定看到的图像</h3><ol type="1"><li><p>只要<strong>摄像机</strong>与<strong>物体</strong>的相对位置一样，所看到的图形就是一样的</p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812123524813.png"alt="image-20220812123524813" /><figcaption aria-hidden="true">image-20220812123524813</figcaption></figure></li><li><p>将摄像机永远放在一个标准的位置</p><ol type="1"><li><strong>Position</strong>：原点</li><li><strong>Up direction</strong>：Y轴</li><li><strong>Look-at direction</strong>：-Z轴</li></ol></li><li><p>当相机变换时，将物体随着相机变换</p></li></ol><h3 id="将相机移动到标准位置">4.2.4 将相机移动到标准位置</h3><ol type="1"><li><p>方法</p><ol type="1"><li>将<spanclass="math inline">\(\vec{e}\)</span>平移到<strong>原点</strong></li><li>旋转 <span class="math inline">\(\vec{g}\)</span>到<strong>-Z</strong>的方向</li><li>旋转 <span class="math inline">\(\vec{t}\)</span>到<strong>Y</strong>的方向</li><li>旋转 <span class="math inline">\(\vec{g}×\vec{t}\)</span>到<strong>X</strong>方向</li></ol></li><li><p>矩阵表示：设<spanclass="math inline">\(M_{view}=R_{view}T_{view}\)</span></p><ol type="1"><li><p>将<span class="math inline">\(\vec{e}\)</span>平移到原点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812164249448.png" alt="image-20220812164249448" style="zoom:80%;" /></p></li><li><p>旋转 <span class="math inline">\(\vec{g}\)</span>到<strong>-Z</strong>、 <span class="math inline">\(\vec{t}\)</span>到<strong>Y</strong>、<spanclass="math inline">\(\vec{g}×\vec{t}\)</span>到<strong>X</strong>：考虑逆矩阵</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812164531901.png" alt="image-20220812164531901" style="zoom:80%;" /></p></li></ol></li></ol><h3 id="总结">4.2.5 总结</h3><ol type="1"><li>将物体与相机一起旋转：<strong>Model Transformation ==&gt; <spanclass="math inline">\(M_{model}\)</span></strong></li><li>将相机变换到标准位置：<strong>View Transformation ==&gt; <spanclass="math inline">\(M_{view}\)</span></strong><ol type="1"><li>Position：原点</li><li>Up direction：Y轴</li><li>Look-at direction：-Z轴</li></ol></li></ol><h2 id="projection-transformation">4.3 Projection Transformation</h2><ol type="1"><li>正交投影 <strong>OrthographicProjection</strong>：不存在近大远小</li><li>透视投影 <strong>PerspectiveProjection</strong>：存在近大远小，平行线不再平行</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812165450522.png" alt="image-20220812165450522" style="zoom:80%;" /></p><h3 id="正交投影">4.3.1 正交投影</h3><blockquote><p><strong>Orthographic Projection</strong>：</p><ol type="1"><li>思想：直接扔掉物体的Z坐标，然后将其移动到[-1,1]的标准范围内</li></ol></blockquote><ol type="1"><li><p>实际做法：将一个立方体<span class="math inline">\([l, r]×[b,t]×[f, n]\)</span>映射到标准立方体<span class="math inline">\([-1,1]^3\)</span>上</p><ol type="1"><li>首先，通过<strong>平移</strong>操作，将立方体的中心移到原点</li><li>然后，通过<strong>缩放</strong>操作，将立方体缩放为标准立方体</li><li>立方体的定义：X轴<spanclass="math inline">\([l,r]\)</span>；Y轴<spanclass="math inline">\([b,t]\)</span>；Z轴<spanclass="math inline">\([f,n]\)</span></li><li>变换之后，物体一定会有拉伸</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812170410007.png" alt="image-20220812170410007" style="zoom:80%;" /></p></li><li><p>变换矩阵：先平移到原点，再将<spanclass="math inline">\(x,y,z\)</span>缩放到<spanclass="math inline">\(2\)</span></p><p>$$ M_{ortho}= (</p><span class="math display">\[\begin{matrix}\frac{2}{r-l} &amp; 0              &amp; 0             &amp; 0 \\0              &amp; \frac{2}{t-b} &amp; 0             &amp; 0 \\0              &amp; 0             &amp; \frac{2}{n-f} &amp; 0 \\0              &amp; 0             &amp; 0             &amp; 1 \\\end{matrix}\]</span><p>)</p><p>(</p><span class="math display">\[\begin{matrix}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\]</span><p>)</p><p>= (</p><span class="math display">\[\begin{matrix}\frac{2}{r-l} &amp; 0              &amp; 0             &amp;-\frac{r+l}{r-l} \\0              &amp; \frac{2}{t-b} &amp; 0             &amp;-\frac{t+b}{t-b} \\0              &amp; 0             &amp; \frac{2}{n-f} &amp;-\frac{n+f}{n-f} \\0              &amp; 0             &amp; 0             &amp; 1 \\\end{matrix}\]</span><p>) $$</p></li></ol><h3 id="透视投影">4.3.2 透视投影</h3><blockquote><p><strong>Perspective Projection</strong></p><ol type="1"><li>基础知识：<span class="math inline">\((x,y,z,1)\)</span>与<spanclass="math inline">\((kx,ky,kz,k)\)</span>表示同一个点，因此<spanclass="math inline">\((xz,yz,z^2,z)\)</span>表示的也是这个点</li><li>思想：将透视投影转化为正交投影<spanclass="math inline">\(M_{persp-&gt;ortho}\)</span>，然后再进行正交投影变换<spanclass="math inline">\(M_{ortho}\)</span></li></ol></blockquote><h4 id="如何进行透视投影">4.3.2.1 如何进行透视投影</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812171751431.png" alt="image-20220812171751431" style="zoom:80%;" /></p><ol type="1"><li>首先，定义从相机点向外的两个平面<strong>n、f</strong>，<strong>f</strong>平面要比<strong>n</strong>平面大</li><li>此时就相当于<strong>f</strong>平面上的点全部投影到<strong>n</strong>平面上</li><li>透视投影的做法<ol type="1"><li>先将<strong>Frustum</strong>挤成<strong>Cuboid</strong>(<spanclass="math inline">\(n \rightarrow n，f \rightarrowf&#39;\)</span>)，满足如下三个定义：<spanclass="math inline">\(M_{persp-&gt;ortho}\)</span><ol type="1"><li>近平面<span class="math inline">\(n\)</span>永远不变</li><li>远平面<span class="math inline">\(f\)</span>的Z值永远不变</li><li>远平面<span class="math inline">\(f\)</span>的中心点<spanclass="math inline">\((0,0,f)\)</span>永远不变</li></ol></li><li>再进行一次正交投影：<spanclass="math inline">\(M_{ortho}\)</span></li></ol></li></ol><h4 id="计算矩阵m_persp-ortho">4.3.2.2 计算矩阵<spanclass="math inline">\(M_{persp-&gt;ortho}\)</span></h4><ol type="1"><li><p>思路：找到变换后的点<spanclass="math inline">\((x&#39;,y&#39;,z&#39;)\)</span>与原来的点<spanclass="math inline">\((x,y,z)\)</span>的对应关系</p></li><li><p>从YZ平面上看，挤压前后存在相似三角形，从而可得到<spanclass="math inline">\(y&#39;=\frac{n}{z}*y\)</span></p><ol type="1"><li>同理，<span class="math inline">\(x&#39;=\frac{n}{z}*x\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812172142284.png" alt="image-20220812172142284" style="zoom:80%;" /></p></li><li><p>齐次坐标表示</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812172516140.png" alt="image-20220812172516140" style="zoom:80%;" /></p></li><li><p>矩阵表示</p><table><colgroup><col style="width: 11%" /><col style="width: 88%" /></colgroup><thead><tr><th style="text-align: center;">由3得</th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812172528972.png" alt="image-20220812172528972" style="zoom:80%;" /></th></tr></thead><tbody><tr><td style="text-align: center;"><strong>因此</strong></td><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812172545755.png" alt="image-20220812172545755" style="zoom:80%;" /></td></tr></tbody></table></li><li><p>对于矩阵的第三行(对于Z值)，有以下性质</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><th style="text-align: center;">在近平面上的点，坐标不变</th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812173013770.png" alt="image-20220812173013770" style="zoom:80%;" /></td></tr><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812173047212.png" alt="image-20220812173047212" style="zoom:80%;" /></td></tr><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812173249005.png" alt="image-20220812173249005" style="zoom:80%;" /></td></tr></tbody></table><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><th style="text-align: center;">在远平面上的中心点<spanclass="math inline">\((0,0,f)\)</span>，坐标不变</th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812173205858.png" alt="image-20220812173205858" style="zoom:80%;" /></td></tr></tbody></table><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><th style="text-align: center;">根据两个等式，可以解出<spanclass="math inline">\(A,B\)</span></th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812173341348.png" alt="image-20220812173341348" style="zoom:80%;" /></td></tr></tbody></table></li><li><p>综上 <span class="math display">\[M_{persp \rightarrow ortho}=\left(\begin{matrix}n &amp; 0 &amp; 0   &amp; 0 \\0 &amp; n &amp; 0   &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1   &amp; 0 \\\end{matrix}\right)\]</span></p></li><li><p>最后，再进行正交投影：<spanclass="math inline">\(M_{persp}=M_{ortho}M_{persp-&gt;ortho}\)</span></p></li></ol>$$ M_{persp}= (<span class="math display">\[\begin{matrix}\frac{2}{r-l} &amp; 0             &amp; 0             &amp;-\frac{r+l}{r-l} \\0             &amp; \frac{2}{t-b} &amp; 0             &amp;-\frac{t+b}{t-b} \\0             &amp; 0             &amp; \frac{2}{n-f} &amp;-\frac{n+f}{n-f} \\0             &amp; 0             &amp; 0             &amp; 1 \\\end{matrix}\]</span><p>)</p>(<span class="math display">\[\begin{matrix}n &amp; 0 &amp; 0   &amp; 0 \\0 &amp; n &amp; 0   &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1   &amp; 0 \\\end{matrix}\]</span><p>)</p><p>=</p>(<span class="math display">\[\begin{matrix}\frac{2n}{r-l}  &amp; 0              &amp; -\frac{r+l}{r-l} &amp; 0 \\0               &amp; \frac{2n}{t-b} &amp; -\frac{t+b}{t-b} &amp; 0  \\0               &amp; 0              &amp; \frac{n+f}{n-f}  &amp;-\frac{2nf}{n-f} \\0               &amp; 0              &amp; 1                &amp; 0 \\\end{matrix}\]</span><p>) $$</p><h4 id="对于不在近远平面上的点">4.3.3.3 对于不在近/远平面上的点</h4>$$ (<span class="math display">\[\begin{matrix}n &amp; 0 &amp; 0   &amp; 0 \\0 &amp; n &amp; 0   &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1   &amp; 0 \\\end{matrix}\]</span><p>)</p>(<span class="math display">\[\begin{matrix}x \\y \\z \\1 \\\end{matrix}\]</span><h1 id="section">)</h1>(<span class="math display">\[\begin{matrix}nx \\ny \\(n+f)z-nf \\z \\\end{matrix}\]</span><p>)</p>==&gt; (<span class="math display">\[\begin{matrix}\frac{n}{z}x \\\frac{n}{z}y \\(n+f)-\frac{nf}{z} \\1 \\\end{matrix}\]</span><p>) $$</p><ol type="1"><li>近平面上的点<span class="math inline">\((z=n)\)</span><ol type="1"><li><spanclass="math inline">\(z&#39;=(n+f)-\frac{nf}{n}=n\)</span></li><li><span class="math inline">\(z&#39;=z\)</span></li></ol></li><li>远平面上的点<span class="math inline">\((z=f)\)</span><ol type="1"><li><spanclass="math inline">\(z&#39;=(n+f)-\frac{nf}{f}=f\)</span></li><li><span class="math inline">\(z&#39;=z\)</span></li></ol></li><li>不在近/远平面上的点<spanclass="math inline">\((f&lt;z&lt;n)\)</span><ol type="1"><li><span class="math inline">\(z&#39;=(n+f)-\frac{nf}{z}\)</span><ol type="1"><li>设<span class="math inline">\(n=1,f=-1,z=0.5\)</span>，则<spanclass="math inline">\(z&#39;=2\)</span></li><li>设<span class="math inline">\(n=1,f=-1,z=-0.5\)</span>，则<spanclass="math inline">\(z&#39;=-2\)</span></li></ol></li><li>可得：若<span class="math inline">\(z&lt;0\)</span>，则<spanclass="math inline">\(z&#39;\)</span>更靠近<strong>远平面<spanclass="math inline">\(f\)</span></strong>；若<spanclass="math inline">\(z&gt;0\)</span>，则<spanclass="math inline">\(z&#39;\)</span>更靠近<strong>近平面<spanclass="math inline">\(n\)</span></strong></li></ol></li></ol><h4 id="定义视锥">4.3.3.4 定义视锥</h4><blockquote><p>定义一个视锥，需要</p><ol type="1"><li>宽高比：<strong>Aspect ratio</strong></li><li>垂直的可视角度：<strong>Vertical Field of View</strong></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813112938428.png" alt="image-20220813112938428" style="zoom:80%;" /></p><ol type="1"><li><p><strong>Aspect ratio 纵横比</strong>：<spanclass="math inline">\(\frac{width}{height}\)</span></p></li><li><p><strong>field-of-view(fovY)视野</strong>：从摄像机所在位置出发，连接屏幕宽的两个中点，两条线所夹的角度</p></li><li><p>从<strong>fovY</strong>和<strong>Aspect</strong>推出<strong>l, r,b, t</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220813113243520.png" alt="image-20220813113243520" style="zoom:80%;" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-03：变换1：2维变换</title>
      <link href="/2023/02/04/GAMES101/3--%E5%8F%98%E6%8D%A21%EF%BC%9A%E4%BA%8C%E7%BB%B4%E5%8F%98%E6%8D%A2/"/>
      <url>/2023/02/04/GAMES101/3--%E5%8F%98%E6%8D%A21%EF%BC%9A%E4%BA%8C%E7%BB%B4%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="三变换12维变换">三、变换1：2维变换</h1><p>变换：</p><ol type="1"><li>Modeling：模型变换，物体在3D空间中的运动</li><li>Viewing：视图变换，3D到2D的投影</li></ol><h2 id="d-transform">3.1 2D Transform</h2><h3 id="scale缩放变换">3.1.1 Scale缩放变换</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811125108799.png" alt="image-20220811125108799" style="zoom:80%;" /></p><h3 id="reflectin翻转">3.1.2 Reflectin翻转</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811125051816.png" alt="image-20220811125051816" style="zoom:80%;" /></p><h3 id="shear切变">3.1.3 Shear切变</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811125253629.png" alt="image-20220811125253629" style="zoom:80%;" /></p><h3 id="rotate旋转默认-绕原点-逆时针-旋转">3.1.4 Rotate旋转(默认 绕原点逆时针 旋转)</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811125758262.png" alt="image-20220811125758262" style="zoom:80%;" /></p><h3 id="linear-transform线性变换矩阵">3.1.5 LinearTransform线性变换=矩阵</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811130400053.png" alt="image-20220811130400053" style="zoom:80%;" /></p><h2 id="homogeneous-coordinates齐次坐标">3.2 Homogeneouscoordinates齐次坐标</h2><h3 id="translation平移变换notin线性变换">3.2.1 Translation平移变换<spanclass="math inline">\(\notin\)</span>线性变换</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811130553973.png" alt="image-20220811130553973" style="zoom:80%;" /></p><p>矩阵表示：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811130633298.png" alt="image-20220811130633298" style="zoom:80%;" /></p><h3 id="齐次坐标">3.2.2 齐次坐标</h3><p>添加一个维度</p><ol type="1"><li>2维点：<span class="math inline">\((x,y,1)^T\)</span></li><li>2维点的补充形式：<spanclass="math inline">\((x,y,w)^T\)</span>与<spanclass="math inline">\((\frac{x}{w},\frac{y}{w},1)^T\)</span>等价</li><li>2维向量：<span class="math inline">\((x,y,0)^T\)</span></li></ol><p>对于两者第3个坐标的解释：</p><ol type="1"><li>点的第三维为0，向量的第三维为1，可以满足向量的平移不变性</li><li>且可以满足以下性质<ol type="1"><li>vector + vector = vector</li><li>point - point = vector</li><li>point + vector = point</li><li>point + point = 两个point的中点</li></ol></li></ol><h3 id="affine-transformation仿射变换-线性变换-平移变换">3.2.3 AffineTransformation仿射变换 = 线性变换 + 平移变换</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811131633578.png" alt="image-20220811131633578" style="zoom:80%;" /></p><h3 id="d-transformation">3.2.4 2D Transformation</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811131725685.png" alt="image-20220811131725685" style="zoom:80%;" /></p><h3 id="inverse-transform逆变换">3.2.5 Inverse Transform逆变换</h3><p>逆变换 &lt;==&gt; 乘变换矩阵的逆矩阵</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811155155659.png" alt="image-20220811155155659" style="zoom:80%;" /></p><h2 id="composing-transforms变换的组合">3.3 ComposingTransforms变换的组合</h2><h3 id="举例">3.3.1 举例</h3><ol type="1"><li>复杂变换可以有简单变换组合而成</li><li>简单变换的顺序是很有必要的 &lt;==&gt; 矩阵乘法不满足交换律</li></ol><p>变换的目标：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811155307566.png" alt="image-20220811155307566" style="zoom:80%;" /></p><p>变换的方法：先平移后旋转 or 先旋转后平移</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811155434542.png" alt="image-20220811155434542" style="zoom:80%;" /></p><p>矩阵表示：<strong>从右到左</strong>进行矩阵乘法，顺序为：<strong>缩放=&gt; 旋转 =&gt; 平移</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811155453930.png" alt="image-20220811155453930" style="zoom:80%;" /></p><h3 id="多个变换">3.3.2 多个变换</h3><p>假设有一系列仿射变换<spanclass="math inline">\(A_1,A_2,A_3...\)</span></p><ol type="1"><li><p>可以用矩阵乘法表示：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811155912416.png" alt="image-20220811155912416" style="zoom:80%;" /></p></li><li><p>可以先计算<spanclass="math inline">\(A_n...A_2·A_1\)</span>，再与列向量相乘</p><ol type="1"><li>一个3*3的矩阵可以表示任意的变换</li></ol></li></ol><h3 id="变换的分解">3.3.3 变换的分解</h3><p>以C点为中心进行旋转<spanclass="math inline">\(\alpha\)</span>度：<spanclass="math inline">\(T(\vec{c})·R(\alpha)·T(\vec{-c})\)</span></p><ol type="1"><li>先将图形按照<spanclass="math inline">\(\vec{-c}\)</span>的方向进行平移：<spanclass="math inline">\(T(\vec{-c})\)</span></li><li>然后绕原点旋转<span class="math inline">\(\alpha\)</span>度：<spanclass="math inline">\(R(\alpha)\)</span></li><li>然后将图形按照<spanclass="math inline">\(\vec{c}\)</span>的方向进行平移：<spanclass="math inline">\(T(\vec{c})\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220811160035313.png" alt="image-20220811160035313" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-02：线性代数复习</title>
      <link href="/2023/02/03/GAMES101/2--%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/02/03/GAMES101/2--%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="二线性代数复习">二、线性代数复习</h1><h2 id="向量点乘">2.1 向量点乘</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230223163818522.png" alt="image-20230223163818522" style="zoom:80%;" /></p><h3 id="定义">2.1.1 定义</h3><p><span class="math display">\[\begin{aligned}\vec{a}·\vec{b}&amp;=||\vec{a}||*||\vec{b}||*\cos\theta \\               &amp;=x_a*x_b+y_a*y_b+z_a*z_b\\\end{aligned}\]</span></p><h3 id="性质">2.1.2 性质</h3><ol type="1"><li><spanclass="math inline">\(\vec{a}·\vec{b}=\vec{b}·\vec{a}\)</span></li><li><spanclass="math inline">\(\vec{a}·(\vec{b}+\vec{c})=\vec{a}·\vec{b}+\vec{a}·\vec{c}\)</span></li><li><spanclass="math inline">\((k\vec{a})·\vec{b}=\vec{a}·(k\vec{b})=k(\vec{a}·\vec{b})\)</span></li></ol><h3 id="应用">2.1.3 应用</h3><ol type="1"><li><p>计算夹角：<spanclass="math inline">\(\cos\theta=\frac{\vec{a}·\vec{b}}{||\vec{a}||*||\vec{b}||}\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810170049692.png" alt="image-20220810170049692" style="zoom: 67%;" /></p></li><li><p>计算投影：<spanclass="math inline">\(||\vec{b}_⊥||=||\vec{b}||\cos\theta\)</span>，<spanclass="math inline">\(\vec{b}_⊥=(||\vec{b}||\cos\theta)\ \hata\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810170106422.png" alt="image-20220810170106422" style="zoom: 67%;" /></p></li><li><p>将<span class="math inline">\(\vec{b}\)</span>在<spanclass="math inline">\(\vec{a}\)</span>方向分解：<spanclass="math inline">\(\vec{b}=\vec{b}_⊥+(\vec{b}-\vec{b}_⊥)\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810170343996.png" alt="image-20220810170343996" style="zoom: 67%;" /></p></li><li><p>向量之间的方向</p><ol type="1"><li><span class="math inline">\(\vec{a}\)</span>与<spanclass="math inline">\(\vec{b}\)</span>方向基本一致：<spanclass="math inline">\(\hat{a}·\hat{b} &gt;0\)</span>，越接近1，夹角越接近0°</li><li><span class="math inline">\(\vec{a}\)</span>与<spanclass="math inline">\(\vec{b}\)</span>方向基本相反：<spanclass="math inline">\(\hat{a}·\hat{b} &lt;0\)</span>，越接近-1，夹角越接近180°</li><li><span class="math inline">\(\vec{a}\)</span>与<spanclass="math inline">\(\vec{b}\)</span>垂直：<spanclass="math inline">\(\hat{a}·\hat{b}=0\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810170534209.png" alt="image-20220810170534209" style="zoom: 67%;" /></p></li></ol><h2 id="向量叉乘">2.2 向量叉乘</h2><h3 id="定义-1">2.2.1 定义</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810171343721.png" alt="image-20220810171343721" style="zoom: 67%;" /></p><p>大小：<spanclass="math inline">\(||\vec{a}×\vec{b}||=||\vec{a}||*||\vec{b}||*\sin\theta\)</span></p><p>方向：右手螺旋定则，四指方向为<spanclass="math inline">\(\vec{a}\)</span>旋转到<spanclass="math inline">\(\vec{b}\)</span>，拇指方向为<spanclass="math inline">\(\vec{a}×\vec{b}\)</span>的方向</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810172156875.png" alt="image-20220810172156875" style="zoom: 67%;" /></p><h3 id="性质-1">2.2.2 性质</h3><p>性质：<spanclass="math inline">\(\vec{a}×\vec{b}=-\vec{b}×\vec{a}\)</span>，可以用于建立空间直角坐标系：</p><ol type="1"><li>右手坐标系：<spanclass="math inline">\(\vec{x}×\vec{y}=\vec{z}\)</span></li><li>左手坐标系：<spanclass="math inline">\(\vec{x}×\vec{y}=-\vec{z}\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810171901046.png" alt="image-20220810171901046" style="zoom: 67%;" /></p><h3 id="应用-1">2.2.3 应用</h3><ol type="1"><li><p>判断左右：假设<spanclass="math inline">\(\vec{a}、\vec{b}\)</span>均在XY平面上</p><ol type="1"><li><span class="math inline">\(\vec{b}\)</span>在<spanclass="math inline">\(\vec{a}\)</span>的左侧：<spanclass="math inline">\(Z_{\vec{a}×\vec{b}}&gt;0\)</span></li><li><span class="math inline">\(\vec{b}\)</span>在<spanclass="math inline">\(\vec{a}\)</span>的右侧：<spanclass="math inline">\(Z_{\vec{a}×\vec{b}}&lt;0\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810172421848.png" alt="image-20220810172421848" style="zoom: 67%;" /></p></li><li><p>判断内外：假设ABCP四点共面</p><ol type="1"><li>P在▲ABC的内部：若ABC逆时针排列，则都在左面；若ABC顺时针排列，则都在右面<ol type="1"><li><span class="math inline">\(\vec{AP}\)</span>在<spanclass="math inline">\(\vec{AB}\)</span>的左面</li><li><span class="math inline">\(\vec{BP}\)</span>在<spanclass="math inline">\(\vec{BC}\)</span>的左面</li><li><span class="math inline">\(\vec{CP}\)</span>在<spanclass="math inline">\(\vec{CA}\)</span>的左面</li></ol></li><li>P在▲ABC的外部：上述三个条件有一个不符合</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810172608646.png" alt="image-20220810172608646" style="zoom: 67%;" /></p></li></ol><h2 id="正交基坐标系">2.3 正交基/坐标系</h2><p>正交基：Orthonormal Bases</p><p>坐标系：Coordinate Frames</p><h3 id="定义-2">2.3.1 定义</h3><ol type="1"><li><spanclass="math inline">\(\vec{u}、\vec{v}、\vec{w}\)</span>均为单位向量</li><li><spanclass="math inline">\(\vec{u}、\vec{v}、\vec{w}\)</span>两两垂直</li><li><span class="math inline">\(\vec{w}=\vec{u}×\vec{v}\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220810173601736.png" alt="image-20220810173601736" style="zoom: 67%;" /></p><h2 id="矩阵">2.4 矩阵</h2><h3 id="矩阵乘法">2.4.1 矩阵乘法</h3><ol type="1"><li>定义：设<spanclass="math inline">\(A[m][n]*B[n][p]=C[m][p]\)</span>，则<spanclass="math inline">\(C[i][j]=\sum_{k=1}^nA[i][k]*B[k][j]=\{A的第i行\}·\{B的第j列\}\)</span></li><li>性质：<ol type="1"><li>没有交换律</li><li>有结合律：<span class="math inline">\((AB)C=A(BC)\)</span></li><li>有分配律：<span class="math inline">\(A(B+C)=AB+AC\)</span>，<spanclass="math inline">\((A+B)C=AC+BC\)</span></li></ol></li></ol><h3 id="矩阵转置">2.4.2 矩阵转置</h3><ol type="1"><li><p>定义：将行列互换</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812181413411.png" alt="image-20220812181413411" style="zoom: 67%;" /></p></li><li><p>性质：<span class="math inline">\((AB)^T=B^TA^T\)</span></p></li></ol><h3 id="单位矩阵矩阵的逆">2.4.3 单位矩阵&amp;矩阵的逆</h3><ol type="1"><li><p>单位矩阵：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220812181521742.png" alt="image-20220812181521742" style="zoom:67%;" /></p></li><li><p>逆矩阵的定义：<spanclass="math inline">\(AA^{-1}=A^{-1}A=I\)</span></p></li><li><p>逆矩阵的性质：<spanclass="math inline">\((AB)^{-1}=B^{-1}A^{-1}\)</span></p></li></ol><h3 id="矩阵向量点乘叉乘">2.4.4 矩阵&amp;向量点乘/叉乘</h3><ol type="1"><li><p>向量的对偶矩阵：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230223174941145.png" alt="image-20230223174941145" style="zoom:80%;" /></p></li><li><p>矩阵&amp;向量点乘/叉乘：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230223175008749.png" alt="image-20230223175008749" style="zoom:80%;" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-01：计算机图形学概览</title>
      <link href="/2023/02/02/GAMES101/1--%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%A7%88/"/>
      <url>/2023/02/02/GAMES101/1--%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="virtualbox挂载">VirtualBox挂载</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t vboxsf Share share_dir</span><br></pre></td></tr></table></figure><h1 id="一计算机图形学概览">一、计算机图形学概览</h1><ol type="1"><li><p><strong>光栅化</strong>：将三维空间的几何形体显示在屏幕上</p></li><li><p><strong>实时</strong>：每秒钟能够生成30幅画面/30帧/30fps；否则称为离线</p></li><li><p><strong>计算机图形学</strong> 与 <strong>计算机视觉</strong>的区别：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230223153108705.png" alt="image-20230223153108705" style="zoom:80%;" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101-00：环境配置</title>
      <link href="/2023/02/01/GAMES101/0--%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/01/GAMES101/0--%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="库文件的安装">库文件的安装</h1><p><ahref="https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.zip"><strong>Eigen库下载</strong></a>：解压路径如下</p><blockquote><p>D:.0</p></blockquote><p><strong>opencv库下载</strong>：解压路径如下</p><blockquote><p>D:</p></blockquote><h1 id="将opencv添加到环境变量中">将opencv添加到环境变量中</h1><p>在<strong>Path</strong>中添加：</p><blockquote><p>D:</p><p>D:</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230226182328400.png" alt="image-20230226182328400" style="zoom:80%;" /></p><h1 id="修改vs的项目设置">修改VS的项目设置</h1><ol type="1"><li><p>【VC++目录】</p><ol type="1"><li><p>【包含目录】：添加如下项</p><blockquote><p>D:.0</p>D:</blockquote></li><li><p>【库目录】：添加如下项</p><blockquote><p>D:</p></blockquote></li></ol></li><li><p>【C/C++】【常规】【附加包含目录】：添加如下项</p><blockquote>D:</blockquote></li><li><p>【链接器】【输入】【附加依赖项】：添加如下项</p><ol type="1"><li>带d的为Debug环境，不带d的为Release环境</li></ol><blockquote><p>opencv_world460d.lib</p></blockquote></li><li><p>将所有代码中，有关Eigen库的引用，修改为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>【配置属性】【调试】【命令参数】中，可以输入传递给main函数的参数</p><ol type="1"><li>如作业3中，需要输入的是<code>./Rasterizer output.png phong</code></li><li>那么我们就可以在此输入<code>output.png phong</code></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/2ccaa721e75c48ebb38a0a55662c518d.png#pic_center" alt="img" style="zoom:80%;" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GAMES系列课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学</title>
      <link href="/2022/09/15/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
      <url>/2022/09/15/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="chanpter-0introduction">Chanpter 0：Introduction</h1><p>三个重要的属性：</p><ol type="1"><li>形状</li><li>外表</li><li>动态行为的属性（如粗糙度、移动）</li></ol><p>三个基础任务：</p><ol type="1"><li>建模</li><li>模拟物体的行为</li><li>渲染Rendering</li></ol><p>Visual Computer：</p><ol type="1"><li>Image Processing：Image=&gt;Image</li><li>Computer Vision：Image=&gt;3D</li><li>Computer Graphics：3D=&gt;3D，3D=&gt;Image</li></ol><h1 id="chapter-1-2d-graphics">Chapter 1 2D Graphics</h1><h2 id="rasterization光栅化">1.1 Rasterization光栅化</h2><ol type="1"><li>将二维基本体(<strong>primitives</strong>，如直线、多边形)转换为光栅图像</li><li><strong>PWM</strong>：控制元件一段时间亮，一段时间不亮，以得到不同光强的光</li></ol><h3 id="坐标系">1.1.1 坐标系</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922081856989.png" alt="image-20220922081856989" style="zoom:80%;" /></p><ol type="1"><li>坐标系：以像素的中心作为整数坐标</li></ol><h2 id="线段">1.2 线段</h2><h3 id="线段的定义">1.2.1 线段的定义</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922082519056.png" alt="image-20220922082519056" style="zoom:80%;" /></p><ol type="1"><li>线段：给定起点、终点、以及各自的颜色、线段的颜色<ol type="1"><li>一般来说，起点和终点均为整数坐标</li></ol></li></ol><h3 id="线段的光栅化">1.2.2 线段的光栅化</h3><ol type="1"><li><p>将线段光栅化到屏幕的要求：</p><ol type="1"><li>选中的像素尽可能接近理想线段</li><li>像素的序列尽可能直</li><li>像素的亮度尽可能一样</li><li>像素的起始和结束尽可能精确</li><li>画的足够快</li><li>可以画不同宽度的线段</li></ol></li><li><p>将线段光栅化到屏幕的方法：</p><ol type="1"><li>计算线段的表达式</li><li>枚举x，计算y，判断计算出的(x,y)属于哪一个像素(Rounding)</li><li>给对应的像素上色</li></ol></li><li><p>优化掉Rounding：</p><ol type="1"><li>Rounding的任务：四舍五入，本质是做一个比较</li><li>斜率：x每增加一个单位，y变化相应的单位</li></ol></li><li><p>DDA：Digital Differential Analyzer，数字微分分析</p></li><li><p>线段的象限：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922090026618.png" alt="image-20220922090026618" style="zoom:80%;" /></p></li></ol><h3 id="bresenham画线算法">1.2.3 Bresenham画线算法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922084258568.png" alt="image-20220922084258568" style="zoom:80%;" /></p><p><spanclass="math inline">\(y_i=m·x_i+c,其中m=\frac{y_2-y_1}{x_2-x_1}\)</span></p><p>思路：</p><ol type="1"><li>对于相邻的两个像素，当x++时，y’只有两种可能：y或y+1</li><li>y’是否+1，取决于<spanclass="math inline">\(y_{actual}\)</span>与y+1近，还是y近</li></ol><p><strong>Bresenham画线算法</strong>：假设线段在第一象限(x增加时y也增加)</p><ol type="1"><li><p>定义：<spanclass="math inline">\(dx=x_2-x_1,dy=y_2-y_1,m=\frac{dy}{dx}\)</span></p></li><li><p>定义：<spanclass="math inline">\(y=m(x_i+1)+b,d_1=y-y_i,d2=y_i+1-y\)</span></p></li><li><p>若<span class="math inline">\(d_1-d_2&gt;0\)</span>，则<spanclass="math inline">\(y_{i+1}=y_i+1\)</span>；若<spanclass="math inline">\(d_1-d_2&lt;0\)</span>，则<spanclass="math inline">\(y_{i+1}=y_i\)</span></p></li><li><p>定义：<spanclass="math inline">\(P_i=(d_1-d_2)*dx=2x_idy-2y_idx+2dy+(2b-1)dx\)</span></p><ol type="1"><li>由于线在第一象限上，因此<spanclass="math inline">\(P_i\)</span>与<spanclass="math inline">\(d_1-d_2\)</span>的符号相同</li><li>因此：若<span class="math inline">\(P_i&gt;0\)</span>，则<spanclass="math inline">\(y_{i+1}=y_i+1\)</span>；若<spanclass="math inline">\(P_i&lt;0\)</span>，则<spanclass="math inline">\(y_{i+1}=y_i\)</span></li></ol></li><li><p>可以计算出，<spanclass="math inline">\(P_{i+1}=P_i+2dy-2(y_{i+1}-y_i)dx\)</span></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922084619794.png" alt="image-20220922084619794" style="zoom:80%;" /></p></li><li><p>伪码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x1,y1);</span><br><span class="line">dx = x2 - x1; dy = y2 - y1; P[<span class="number">1</span>] = <span class="number">2</span>*dy - dx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; x2+<span class="number">1</span>; i++)&#123;</span><br><span class="line">    x[i+<span class="number">1</span>] = x[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P[i] &gt; <span class="number">0</span>) y[i+<span class="number">1</span>] = y[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> y[i+<span class="number">1</span>] = y[i];</span><br><span class="line">    <span class="built_in">plot</span>(x[i+<span class="number">1</span>], y[i+<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(P[i] &gt; <span class="number">0</span>) P[i+<span class="number">1</span>] = P[i] + <span class="number">2</span>*dy - <span class="number">2</span>*dx;</span><br><span class="line">    <span class="keyword">else</span> P[i+<span class="number">1</span>] = P[i] + <span class="number">2</span>*dy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="圆">1.3 圆</h2><h3 id="圆的定义使用极坐标定义">1.3.1 圆的定义(使用极坐标定义)</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922090614503.png"alt="image-20220922090614503" /><figcaption aria-hidden="true">image-20220922090614503</figcaption></figure><p><spanclass="math inline">\(x_{i+1}=x_i\cos\Delta\theta-y_i\sin\Delta\theta\)</span></p><ol type="1"><li>存在累加误差</li><li>一般情况下，浮点加法的误差比浮点乘法的定义大，误差出现在大数加小数上</li></ol><h3 id="bresenham画圆算法">1.3.2 Bresenham画圆算法</h3><p><strong>理论推导</strong>：</p><ol type="1"><li><p>采用八分法画圆：由于圆的对称性，只需要计算出<spanclass="math inline">\(\frac{1}{8}\)</span>圆弧的像素点即可</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzk3MjM=,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:50%;" /></p></li><li><p>只考虑第一象限的上半部分，x每次增加1，y减少1或不变</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzk3MjM=,size_16,color_FFFFFF,t_70-16639873054602.png" alt="img" style="zoom:80%;" /></p></li><li><p>将中点<spanclass="math inline">\(M(x_i+1,y_i-0.5)\)</span>带入圆的隐式方程，得到：<spanclass="math inline">\(d[i]=F(M)=(x[i]+1)^2+(y[i]-0.5)^2-R^2\)</span>，如上图所示</p><ol type="1"><li>如果<span class="math inline">\(d\le0\)</span>，则M在圆内，<spanclass="math inline">\(p[i+1]=(x[i]+1,y[i])\)</span></li><li>如果<span class="math inline">\(d&gt;0\)</span>，则M在圆外，<spanclass="math inline">\(p[i+1]=(x[i]+1,y[i]-1)\)</span></li></ol></li><li><p>进行递推计算</p><ol type="1"><li>如果<span class="math inline">\(d[i]\le 0\)</span>，得到<ol type="1"><li><spanclass="math inline">\(d[i]=(x[i]+1)^2+(y[i]-0.5)^2-R^2\)</span></li><li><spanclass="math inline">\(d[i+1]=(x[i]+2)^2+(y[i]-0.5)^2-R^2\)</span></li><li><span class="math inline">\(\Delta d = 2x[i]+3\)</span></li></ol></li><li>如果<span class="math inline">\(d[i] &gt; 0\)</span>，得到<ol type="1"><li><spanclass="math inline">\(d[i]=(x[i]+1)^2+(y[i]-0.5)^2-R^2\)</span></li><li><spanclass="math inline">\(d[i+1]=(x[i]+2)^2+(y[i]-1.5)^2-R^2\)</span></li><li><span class="math inline">\(\Delta d = 2(x[i]-y[i])+5\)</span></li></ol></li></ol></li></ol><p><strong>画圆步骤</strong>：</p><ol type="1"><li>画上半部分：<ol type="1"><li>输入圆的半径，计算初始值<spanclass="math inline">\((x[0],y[0])=(0,R)\)</span></li><li>判断<span class="math inline">\(d[i]\)</span>的符号，计算<spanclass="math inline">\((x[i+1],y[i+1])\)</span>的坐标</li><li><span class="math inline">\(d[i+1]\)</span>根据<spanclass="math inline">\(d[i]\)</span>递推</li><li>当<spanclass="math inline">\(x&lt;y\)</span>时，重复2~3步，否则结束</li></ol></li><li>根据对称性，画出完整的圆</li></ol><h3 id="椭圆的中点画法">1.3.3 椭圆的中点画法</h3><p><strong>理论推导</strong>：</p><ol type="1"><li><p>椭圆需要画出<spanclass="math inline">\(\frac{1}{4}\)</span>，而且我们需要找到分界点，如下图。</p><ol type="1"><li>分界点上，x为主增量</li><li>分界点下，y为主增量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzk3MjM=,size_16,color_FFFFFF,t_70-16639880829154.png" alt="img" style="zoom:80%;" /></p></li><li><p>考虑上半部分：</p></li></ol><pre><code> 1.   将中点$M(x[i]+1,y[i]-0.5)$带入椭圆的隐式方程，得到$d[i]=F(M)=a^2(y[i]-0.5)^2+b^2(x[i]+1)^2-a^2b^2$      1.   如果$d\le0$，则M在椭圆内，$p[i+1]=(x[i]+1,y[i])$      2.   如果$d&gt;0$，则M在椭圆外，$p[i+1]=(x[i]+1,y[i]-1)$ 2.   进行递推计算      1.   如果$d[i]\le 0$，得到           1.   $d[i]=a^2(y[i]-0.5)^2+b^2(x[i]+1)^2-a^2b^2$           2.   $d[i+1]=a^2(y[i]-0.5)^2+b^2(x[i]+2)^2-a^2b^2$           3.   $\Delta d = b^2(2x[i]+3)$      2.   如果$d[i] &gt; 0$，得到           1.   $d[i]=a^2(y[i]-0.5)^2+b^2(x[i]+1)^2-a^2b^2$           2.   $d[i+1]=a^2(y[i]-1.5)^2+b^2(x[i]+2)^2-a^2b^2$           3.   $\Delta d = b^2(2x[i]+3)+2a^2(-y[i]+1)$</code></pre><ol start="3" type="1"><li><p>对于下半部分：</p><ol type="1"><li>将中点<spanclass="math inline">\(M(x[i]-0.5,y[i]+1)\)</span>带入椭圆的隐式方程，得到<spanclass="math inline">\(d[i]=F(M)=a^2(y[i]+1)^2+b^2(x[i]-0.5)^2-a^2b^2\)</span><ol type="1"><li>如果<span class="math inline">\(d\le0\)</span>，则M在椭圆内，<spanclass="math inline">\(p[i+1]=(x[i],y[i]+1)\)</span></li><li>如果<span class="math inline">\(d&gt;0\)</span>，则M在椭圆外，<spanclass="math inline">\(p[i+1]=(x[i]-1,y[i]+1)\)</span></li></ol></li><li>进行递推计算<ol type="1"><li>如果<span class="math inline">\(d[i]\le 0\)</span>，得到<ol type="1"><li><spanclass="math inline">\(d[i]=a^2(y[i]+1)^2+b^2(x[i]-0.5)^2-a^2b^2\)</span></li><li><spanclass="math inline">\(d[i+1]=a^2(y[i]+2)^2+b^2(x[i]-0.5)^2-a^2b^2\)</span></li><li><span class="math inline">\(\Delta d = a^2(2y[i]+3)\)</span></li></ol></li><li>如果<span class="math inline">\(d[i] &gt; 0\)</span>，得到<ol type="1"><li><spanclass="math inline">\(d[i]=a^2(y[i]+1)^2+b^2(x[i]-0.5)^2-a^2b^2\)</span></li><li><spanclass="math inline">\(d[i+1]=a^2(y[i]+2)^2+b^2(x[i]-1.5)^2-a^2b^2\)</span></li><li><span class="math inline">\(\Delta d = a^2(2y[i]+3) +2b^2(-x[i]+1)\)</span></li></ol></li></ol></li></ol></li></ol><p><strong>画圆步骤</strong>：</p><ol type="1"><li>画上半部分：<ol type="1"><li>输入椭圆的半径，计算初始值<ol type="1"><li><span class="math inline">\((x[0],y[0])=(0,b)\)</span></li><li><spanclass="math inline">\(d[0]=a^2(b-0.5)^2+b^2-a^2b^2\)</span></li></ol></li><li>判断<span class="math inline">\(d[i]\)</span>的符号，计算<spanclass="math inline">\((x[i+1],y[i+1])\)</span>的坐标<ol type="1"><li>如果<span class="math inline">\(d\le0\)</span>，则M在椭圆内，<spanclass="math inline">\(p[i+1]=(x[i]+1,y[i])\)</span></li><li>如果<span class="math inline">\(d&gt;0\)</span>，则M在椭圆外，<spanclass="math inline">\(p[i+1]=(x[i]+1,y[i]-1)\)</span></li></ol></li><li><span class="math inline">\(d[i+1]\)</span>根据<spanclass="math inline">\(d[i]\)</span>递推<ol type="1"><li>如果<span class="math inline">\(d[i]\le 0\)</span>，得到<spanclass="math inline">\(d[i+1] = d[i] + b^2(2x[i]+3)\)</span></li><li>如果<span class="math inline">\(d[i] &gt; 0\)</span>，得到<spanclass="math inline">\(d[i+1] = d[i] +b^2(2x[i]+3)+2a^2(-y[i]+1)\)</span></li></ol></li><li>当<spanclass="math inline">\(2a^2(y[i]-0.5)&gt;2b^2(x[i]+1)\)</span>时，重复2~3步，否则结束</li></ol></li><li>画下半部分：<ol type="1"><li>输入椭圆的半径，计算初始值<ol type="1"><li><span class="math inline">\((x[0],y[0])=(a,0)\)</span></li><li><spanclass="math inline">\(d[0]=a^2+b^2(a-0.5)^2-a^2b^2\)</span></li></ol></li><li>判断<span class="math inline">\(d[i]\)</span>的符号，计算<spanclass="math inline">\((x[i+1],y[i+1])\)</span>的坐标<ol type="1"><li>如果<span class="math inline">\(d\le0\)</span>，则M在椭圆内，<spanclass="math inline">\(p[i+1]=(x[i],y[i]+1)\)</span></li><li>如果<span class="math inline">\(d&gt;0\)</span>，则M在椭圆外，<spanclass="math inline">\(p[i+1]=(x[i]-1,y[i]+1)\)</span></li></ol></li><li><span class="math inline">\(d[i+1]\)</span>根据<spanclass="math inline">\(d[i]\)</span>递推<ol type="1"><li>如果<span class="math inline">\(d[i]\le 0\)</span>，得到<spanclass="math inline">\(d[i+1] = d[i] + a^2(2y[i]+3)\)</span></li><li>如果<span class="math inline">\(d[i] &gt; 0\)</span>，得到<spanclass="math inline">\(d[i+1] = d[i] + a^2(2y[i]+3) +2b^2(-x[i]+1)\)</span></li></ol></li><li>当<span class="math inline">\(2a^2(y[i]-0.5) \le2b^2(x[i]+1)\)</span>时，重复2~3步，否则结束</li></ol></li><li>根据对称性，画出完整的椭圆</li></ol><h2 id="多边形填充">1.4 多边形填充</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922091245511.png" alt="image-20220922091245511" style="zoom:80%;" /></p><h3 id="判断一个点是否在多边形之中">1.4.1判断一个点是否在多边形之中</h3><ol type="1"><li><p>奇偶测试：画水平线，与多边形相交，奇数点和偶数点之间的像素在多边形之中</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922091757368.png" alt="image-20220922091757368" style="zoom:80%;" /></p></li><li><p>Winding Numbertest：从选定的点开始，计算与多边形的所有相邻顶点之间的夹角，如果在内部，则夹角和为360°</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922091850038.png" alt="image-20220922091850038" style="zoom:80%;" /></p></li></ol><h3 id="scan-line-method">1.4.2 Scan-line Method</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922092116274.png" alt="image-20220922092116274" style="zoom:80%;" /></p><ol type="1"><li><p>从上到下，从左到右，进行扫描</p></li><li><p>计算每一根扫描线与多边形的交点，奇数点与偶数点之间填充颜色</p></li><li><p>计算交点：假设交点数不发生变化，则这就是画线算法的一步</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922092542517.png" alt="image-20220922092542517" style="zoom:80%;" /></p></li></ol><h3 id="seed-fill-algorithm种子填充算法">1.4.3 Seed FillAlgorithm种子填充算法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922092634034.png" alt="image-20220922092634034" style="zoom:80%;" /></p><h3 id="clipping">1.4.4 Clipping</h3><ol type="1"><li><p>Clipping：将不在屏幕中的对象裁剪掉</p><ol type="1"><li>在光栅化之前进行，对primitive进行操作</li></ol><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922093506903.png"alt="image-20220922093506903" /><figcaption aria-hidden="true">image-20220922093506903</figcaption></figure></li></ol><h1 id="chapter-2introduction-to-opengl">Chapter 2：Introduction toOpenGL</h1><h2 id="opengl的功能">2.1 OpenGL的功能</h2><ol type="1"><li>定义物体的形状、材质的属性、光照<ol type="1"><li>根据简单的点、线、多边形构建一个复杂的图形</li></ol></li><li>将物体放到场景中，且投射到摄像机中</li><li>将物体的数学表达式转化为像素：<strong>Rasterization</strong></li><li>计算物体的每个点的颜色：<strong>Shading</strong></li></ol><h2 id="opengl工具链">2.2 OpenGL工具链</h2><ol type="1"><li>OpenGL <strong>&lt; GL/gl.h &gt;</strong>：跨平台的核心库</li><li>GLU <strong>&lt; GL/glu.h &gt;</strong>：实现了一系列的图形函数</li><li>GLUT <strong>&lt; GL/glut.h&gt;</strong>：实现了窗口创建、操作系统调用(如鼠标、键盘)</li><li>GLUI：用户界面</li></ol><h2 id="opengl中的三个阶段">2.3 OpenGL中的三个阶段</h2><ol type="1"><li>在世界坐标中定义一个物体</li><li>设置Modeling &amp; Viewing变换</li><li>渲染场景</li></ol><h2 id="opengl的工作方式">2.4 OpenGL的工作方式</h2><ol type="1"><li>OpenGL是一个状态机</li><li>OpenGL会给定一个起始状态，有一些初始值</li><li>除非显式设置一些值，否则当前状态不会改变<ol type="1"><li>比如设置当前颜色是红色，在下一次显式更改颜色之前，所有的图形均会化成红色</li><li>所有的状态均有一个默认值</li></ol></li></ol><h2 id="opengl的元素">2.5 OpenGL的元素</h2><ol type="1"><li><p>GL_POINTS：点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085246455.png" alt="image-20220929085246455" style="zoom:80%;" /></p></li><li><p>GL_LINES：线</p><ol type="1"><li>给定一个点的数组，两两之间画线</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085347331.png" alt="image-20220929085347331" style="zoom:80%;" /></p></li><li><p>GL_LINE_STRIP：线</p><ol type="1"><li>给定一个数组，每一根线段的起点是前一根的终点，中点是后一根的起点</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085403212.png" alt="image-20220929085403212" style="zoom:80%;" /></p></li><li><p>GL_LINE_LOOP</p><ol type="1"><li>线，给定一个数组，每一根线段的起点是前一根的终点，中点是后一根的起点</li><li>首尾相连</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085414235.png" alt="image-20220929085414235" style="zoom:80%;" /></p></li><li><p>GL_TRIANGLES：三角形</p><ol type="1"><li>给定一个点的数组，以三个为一组画三角形</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085449285.png" alt="image-20220929085449285" style="zoom:80%;" /></p></li><li><p>GL_TRANGLE_FAN：三角形</p><ol type="1"><li>给定一个点的数组，第0个点为扇形的圆心，剩下的逆时针排列</li></ol></li><li><p>GL_TRANGLE_STRIP：三角形</p><ol type="1"><li>给定一个点的数组，相邻两个三角形共边</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085504670.png" alt="image-20220929085504670" style="zoom:80%;" /></p></li><li><p>GL_POLYGON：多边形</p><ol type="1"><li>多边形默认是共面、凸多边形</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085255853.png" alt="image-20220929085255853" style="zoom:80%;" /></p></li><li><p>GL_QUADS：四边形</p></li><li><p>GL_QUAD_STRIP：四边形</p></li></ol><h2 id="opengl的基础格式">2.6 OpenGL的基础格式</h2><h3 id="opengl的函数">2.6.1 OpenGL的函数</h3><ol type="1"><li><p>所有的函数名以<strong>gl</strong>开始</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure></li><li><p>常量均为大写</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">     GL_COLOR_BUFFER_BIT</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>   数据类型以**GL**开始：为了跨平台</span><br><span class="line"></span><br><span class="line">     ```c++</span><br><span class="line">     GLfloat onevertex[<span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>大多数函数名的结尾表示参数的数据类型及个数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertex3f</span>(...); <span class="comment">//3个GLfoat的参数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>glVertex</strong>：所有的对象都是由顶点定义的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertex2f</span>(x, y);</span><br><span class="line"><span class="built_in">glVertex3f</span>(x, y, z);</span><br><span class="line"><span class="built_in">glVertex4f</span>(x, y, z, w);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(a);<span class="comment">// with a[0], a[1], a[2]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="根据顶点创建物体">2.6.2 根据顶点创建物体</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">3.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090505040.png" alt="image-20220929090505040" style="zoom:80%;" /></p><h3 id="颜色">2.6.3 颜色</h3><ol type="1"><li>根据RGB三个分量，float类型，范围为[0.0, 1.0]</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背景颜色</span></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"><span class="comment">// 物体颜色</span></span><br><span class="line"><span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h3 id="其它可以放在glbeginglend中的函数">2.6.4其它可以放在glBegin/glEnd中的函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090841289.png" alt="image-20220929090841289" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090901328.png" alt="image-20220929090901328" style="zoom:80%;" /></p><h3 id="多边形的显示模型">2.6.5 多边形的显示模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090924589.png" alt="image-20220929090924589" style="zoom:80%;" /></p><h3 id="编译opengl程序">2.6.6 编译OpenGL程序</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090945521.png" alt="image-20220929090945521" style="zoom:80%;" /></p><h3 id="glut-based程序的结构">2.6.7 GLUT-based程序的结构</h3><ol type="1"><li><p>GLUT基于用户定义的回调函数，在每一个事件发生时调用</p><ol type="1"><li><p>用户显示屏幕的函数</p></li><li><p>用于重新设置viewport的大小的函数</p></li><li><p>用于处理键盘/鼠标输入的函数</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091042541.png" alt="image-20220929091042541" style="zoom:80%;" /></p></li></ol></li><li><p>例：画一个多边形</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_RGBA | GLUT_DOUBLE);</span><br><span class="line">    <span class="type">int</span> windowHandle = <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;Simple GLUT App&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(redraw);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glutMainLoop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readraw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glBegin</span>(GL_QUADS);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertex3f</span>(<span class="number">-0.5</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">glVertex3f</span>( <span class="number">0.5</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">glVertex3f</span>( <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">glVertex3f</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">   <span class="built_in">glEnd</span>();</span><br><span class="line">    <span class="built_in">glutSwapBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Doublebuffer：画在一个buffer中，显示另一个buffer，然后进行切换</p><ol type="1"><li>可以防止显示绘画的过程</li></ol></li><li><p>其它GLUT</p></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091653690.png" alt="image-20220929091653690" style="zoom:80%;" /></p><h3 id="回调">2.6.8 回调</h3><ol type="1"><li><p>Reshape Callback</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091743114.png" alt="image-20220929091743114" style="zoom:80%;" /></p></li><li><p>鼠标回调</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091758018.png" alt="image-20220929091758018" style="zoom:80%;" /></p></li><li><p>键盘回调</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091819083.png" alt="image-20220929091819083" style="zoom:80%;" /></p></li><li><p>静止回调</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091835079.png" alt="image-20220929091835079" style="zoom:80%;" /></p></li><li><p>菜单回调</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091846842.png" alt="image-20220929091846842" style="zoom:80%;" /></p></li></ol><h3 id="动画">2.6.9 动画</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929092157021.png" alt="image-20220929092157021" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929092207632.png" alt="image-20220929092207632" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929092217364.png" alt="image-20220929092217364" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929092227042.png" alt="image-20220929092227042" style="zoom:80%;" /></p><h1 id="chapter-3basic-math">Chapter 3：Basic Math</h1><h2 id="向量">3.1 向量</h2><h3 id="点乘">3.1.1 点乘</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008081644667.png" alt="image-20221008081644667" style="zoom:80%;" /></p><p><spanclass="math inline">\(\vec{a}·\vec{b}=|\vec{a}||\vec{b}|\cos\theta=x_a*x_b+y_a*y_b+z_a*z_b\)</span></p><ol type="1"><li><p>本质是：投影操作</p><ol type="1"><li>函数可以看作是一个无限维的向量</li><li>FFT本质上是将函数换了一个坐标轴(不同的余弦函数)，进行投影操作</li></ol></li><li><p>转换坐标：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082012976.png" alt="image-20221008082012976" style="zoom:80%;" /></p></li></ol><h3 id="差积">3.1.2 差积</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082221936.png" alt="image-20221008082221936" style="zoom:80%;" /></p><ol type="1"><li>方向：右手法则（从<spanclass="math inline">\(\vec{a}\)</span>转到<spanclass="math inline">\(\vec{b}\)</span>）</li></ol><h3 id="点的操作">3.1.3 点的操作</h3><ol type="1"><li>点 - 点 = 向量</li><li>点 + 向量 = 点</li></ol><h2 id="直线">3.2 直线</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082546772.png" alt="image-20221008082546772" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082742925.png" alt="image-20221008082742925" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082820347.png" alt="image-20221008082820347" style="zoom:80%;" /></p><ol type="1"><li>直线方程：<span class="math inline">\((p-p_0)·\vec{n}=0 \rightarrowax+by+c = 0\)</span><ol type="1"><li><span class="math inline">\(\vec{t} =p-p_0=(x_1-x_0,y_1-y_0)\)</span></li><li><spanclass="math inline">\(\vec{n}=Prep(\vec{t})=(y_0-y_1,x_1-x_0)\)</span></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LineEquation</span><span class="params">(vertex &amp;v0, vertex &amp;v1, line &amp;l)</span></span>&#123;</span><br><span class="line">    l.a = v1.y - v0.y;</span><br><span class="line">    l.b = v0.x - v1.x;</span><br><span class="line">    l.c = -(l.a * v0.x + l.b * v0.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变换transform">3.3 变换Transform</h2><h3 id="平移translation">3.3.1 平移Translation</h3><p><span class="math display">\[x\rightarrow x+T_x \\y\rightarrow y+T_y \\z\rightarrow z+T_z \\\]</span></p><ol type="1"><li>刚体变换：不会改变物体的形状</li></ol><h3 id="缩放scaling">3.3.2 缩放Scaling</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008083332443.png" alt="image-20221008083332443" style="zoom:80%;" /><span class="math display">\[x\rightarrow x*S_x \\y\rightarrow y*S_y \\z\rightarrow z*S_z \\\]</span></p><ol type="1"><li>以<strong>原点</strong>为中心进行缩放：直接对xyz乘上对应的缩放因子</li><li>以<strong>某个点</strong>为中心进行缩放：先平移到原点，然后缩放，然后再平移回去</li></ol><h3 id="旋转rotation">3.3.3 旋转Rotation</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008083723743.png" alt="image-20221008083723743" style="zoom:80%;" /><span class="math display">\[x&#39;=x*\cos\theta-y*\sin\theta \\y&#39;=x*\sin\theta+y*\cos\theta \\\]</span></p><ol type="1"><li>刚体变换：不会改变物体的形状</li><li>2维：绕原点旋转；3维：绕旋转轴旋转</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008084010992.png" alt="image-20221008084010992" style="zoom:80%;" /><span class="math display">\[x&#39;=x_r+(x-x_r)\cos\theta-(y-y_r)\sin\theta \\y&#39;=y_r+(y-y_r)\cos\theta+(x-x_r)\sin\theta \\\]</span></p><ol type="1"><li>绕某一个点旋转：<ol type="1"><li>将要旋转的点平移到原点上</li><li>进行旋转</li><li>然后再平移回去</li></ol></li></ol><h3 id="剪切shearing">3.3.4 剪切Shearing</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008084226181.png" alt="image-20221008084226181" style="zoom:80%;" /></p><h2 id="齐次坐标">3.4 齐次坐标</h2><h3 id="点向量的对应关系">3.4.1 点/向量的对应关系</h3><ol type="1"><li>点：<spanclass="math inline">\([x,y]\rightarrow[x,y,1]\)</span></li><li>向量：<spanclass="math inline">\([x,y]\rightarrow[x,y,0]\)</span></li><li><span class="math inline">\([x,y,w]==[x/w,y/w,z/w]\)</span></li></ol><h3 id="线性变换与矩阵的对应关系">3.4.2 线性变换与矩阵的对应关系</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008085728747.png" alt="image-20221008085728747" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090046598.png" alt="image-20221008090046598" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008085901606.png" alt="image-20221008085901606" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090012572.png" alt="image-20221008090012572" style="zoom:80%;" /></p><h3 id="复合变换">3.4.3 复合变换</h3><ol type="1"><li>每乘一个矩阵，就相当于进行了一次变换</li><li>由于矩阵乘法具有结合律，因此可以先将变换矩阵相乘，再和向量相乘</li><li>也就是说，可以用一个矩阵，表示任意的齐次变换</li><li>先进行的变换，其变换矩阵写在后面</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090542957.png" alt="image-20221008090542957" style="zoom:80%;" /></p><h3 id="矩阵形式表示关于某个点p的变换">3.4.4矩阵形式表示关于某个点P的变换</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090552802.png" alt="image-20221008090552802" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090707899.png" alt="image-20221008090707899" style="zoom:80%;" /></p><h3 id="绕任意轴旋转">3.4.5 绕任意轴旋转</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008091039215.png" alt="image-20221008091039215" style="zoom:80%;" /></p><ol type="1"><li><p>将旋转轴旋转到Z轴</p><ol type="1"><li><span class="math inline">\(T\)</span>：将轴平移至过原点</li><li><spanclass="math inline">\(R_x(\alpha)\)</span>：绕X轴旋转，让旋转轴处于yz平面</li><li><spanclass="math inline">\(R_y(\beta)\)</span>：绕Y轴旋转，让旋转轴处于xz平面</li><li><spanclass="math inline">\(R_z(\theta)\)</span>：绕Z轴旋转，让旋转轴与z轴重合</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008091343729.png" alt="image-20221008091343729" style="zoom:80%;" /></p></li><li><p>绕Z轴旋转角度</p></li><li><p>进行第1步的逆变换</p></li></ol><h2 id="opengl中的变换">3.5 OpenGL中的变换</h2><h3 id="ctm">3.5.1 CTM</h3><ol type="1"><li>Current Transform Matrix：当前变换矩阵</li></ol><h3 id="修改ctm">3.5.2 修改CTM</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008091844590.png" alt="image-20221008091844590" style="zoom:80%;" /></p><h3 id="绕某个轴轴旋转">3.5.3 绕某个轴轴旋转</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008092006187.png" alt="image-20221008092006187" style="zoom:80%;" /></p><ol type="1"><li>最后写的操作会最先执行，按照前面写矩阵的顺序写代码即可</li></ol><h3 id="matrix-stack">3.5.4 Matrix Stack</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008092229650.png" alt="image-20221008092229650" style="zoom:80%;" /></p><h2 id="向量的进一步应用">3.6 向量的进一步应用</h2><h3 id="计算两个线段的交点">3.6.1 计算两个线段的交点</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/v2-23d0f051422fe205ad6ce24b9c41b96a_720w.webp" alt="img" style="zoom: 67%;" /></p><ol type="1"><li><p>判断两个线段相交</p><ol type="1"><li>判断依据：点c和点d在直线ab的两侧，且点a和点b在直线cd的两侧</li><li>判断方法：使用向量叉乘求abd,abc的“面积”，当两线段相交时，abc与abd面积正负号相反</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以ab为三角形公共边，求三角形abc, abd的面积，并判断是否不相交</span></span><br><span class="line"><span class="type">double</span> area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);</span><br><span class="line"><span class="type">double</span> area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);</span><br><span class="line"><span class="keyword">if</span> (area_abc * area_abd &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以cd为三角形公共边，求三角形abc, abd的面积，并判断是否不相交</span></span><br><span class="line"><span class="type">double</span> area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);</span><br><span class="line"><span class="type">double</span> area_cdb = area_cda + area_abc - area_abd ;</span><br><span class="line"><span class="keyword">if</span> (area_cda * area_cdb &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>计算交点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> t = area_cda / ( area_abd - area_abc );</span><br><span class="line"><span class="type">double</span> dx = t * (b.x - a.x),</span><br><span class="line"><span class="type">double</span> dy = t * (b.y - a.y);</span><br><span class="line">intersect_p.x = a.x + dx;</span><br><span class="line">intersect_p.y = a.y + dy;</span><br></pre></td></tr></table></figure></li></ol><h1 id="chapter-4viewing-in-2d-3d">Chapter 4：Viewing in 2D &amp;3D</h1><h2 id="d中的viewing">4.1 2D中的Viewing</h2><h3 id="window">4.1.1 Window</h3><ol type="1"><li><strong>Window</strong>：一个2D世界中的矩形区域<ol type="1"><li>中心：(xCenter, yCenter)</li><li>大小：windowSize</li></ol></li><li><strong>Screen / Viewport</strong>：一个像素点的矩阵<ol type="1"><li>大小：screenSize，以像素为单位</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082538881.png" alt="image-20221013082538881" style="zoom:80%;" /></p><h3 id="d-viewing-transformation">4.1.2 2D Viewing Transformation</h3><ol type="1"><li>将2D世界中能够看到的部分<strong>window</strong>映射到屏幕<strong>viewport</strong>上</li><li>也成为：<strong>window-to-viewport transformation</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082315825.png" alt="image-20221013082315825" style="zoom:80%;" /></p><h3 id="derivation推导">4.1.3 Derivation推导</h3><table><colgroup><col style="width: 36%" /><col style="width: 63%" /></colgroup><thead><tr><th>先平移到坐标原点，并且进行相应缩放</th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082614575.png" alt="image-20221013082614575" style="zoom:80%;" /></th></tr></thead><tbody><tr><td><strong>然后将坐标轴转化为屏幕的坐标</strong></td><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082646008.png" alt="image-20221013082646008" style="zoom:80%;" /></td></tr></tbody></table><h3 id="aspect-ratio纵横比">4.1.4 Aspect Ratio纵横比</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082921300.png" alt="image-20221013082921300" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082941369.png" alt="image-20221013082941369" style="zoom:80%;" /></p><h3 id="opengl中的命令">4.1.5 OpenGL中的命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置视口: 最终图像映射到的像素矩阵</span></span><br><span class="line"><span class="comment">// (x,y): 定义视口的左下角</span></span><br><span class="line"><span class="comment">// (width, height): 定义视口矩阵的大小</span></span><br><span class="line"><span class="built_in">glViewport</span>(x, y, width, height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二维正交投影矩阵</span></span><br><span class="line"><span class="built_in">gluOrtho2D</span>(left, right, bottom, top); </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013083056196.png" alt="image-20221013083056196" style="zoom:80%;" /></p><h3 id="modeling-vs-viewing">4.1.6 Modeling vs Viewing</h3><ol type="1"><li>Modeling Transformation：修改场景</li><li>Viewing Transformation：修改视窗位置，不会修改场景</li></ol><h2 id="d中的viewing-1">4.2 3D中的Viewing</h2><h3 id="透视投影-perspective-projection">4.2.1 透视投影 PerspectiveProjection</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013084148797.png" alt="image-20221013084148797" style="zoom:80%;" /></p><ol type="1"><li>所有点的延长线交于一点<ol type="1"><li><strong>PRP</strong>：Projection Reference Point，投影参考点</li><li>也就是眼睛所在位置</li></ol></li><li>投影大小 与 距离、朝向 都有关系</li></ol><h3 id="平行投影-parallel-projection">4.2.2 平行投影 ParallelProjection</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013085546793.png" alt="image-20221013085546793" style="zoom:80%;" /></p><ol type="1"><li><p>对应点连线相互平行</p><ol type="1"><li><strong>DOP</strong>：Direction of Projection，投影方向</li><li>相当于眼睛在无穷远的位置</li></ol></li><li><p>投影大小 只与 朝向 有关系</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013090314403.png" alt="image-20221013090314403" style="zoom:80%;" /></p></li><li><p>斜平行投影</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013090608146.png" alt="image-20221013090608146" style="zoom:80%;" /></p><ol type="1"><li>最一般的平行投影</li><li>平行与投影平面的角度、大小不变</li><li>不平行投影平面的会被拉伸</li></ol></li></ol><h2 id="view-specification">4.3 View Specification</h2><h3 id="定义一个相机">4.3.1 定义一个相机</h3><ol type="1"><li><p><strong>Reference</strong>：相机的位置</p></li><li><p><strong>view-direction</strong>(vrp)：相机的朝向</p></li><li><p><strong>up-direction</strong>(upVector)：相机的向上方向</p><ol type="1"><li>保证与<strong>view-direction</strong>垂直</li><li>一般是指定一个朝天的方向<strong>sky-vector</strong></li><li>然后找最接近朝天方向的垂直于相机朝向的向量</li><li>计算方法：<ol type="1"><li><strong>sky-vector ×view-direction</strong>，得到<strong>right-vector</strong></li><li><strong>right-vector ×view-direction</strong>，得到<strong>up-vector</strong></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013091629822.png" alt="image-20221013091629822" style="zoom:80%;" /></p></li></ol><h3 id="world-to-view-transformation">4.3.2 World-to-ViewTransformation</h3><ol type="1"><li>先将相机的坐标轴 平移到 原点</li><li>然后将相机的坐标轴 投影到 原坐标轴</li></ol><h3 id="平行投影">4.3.3 平行投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013091949516.png" alt="image-20221013091949516" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092045138.png" alt="image-20221013092045138" style="zoom:80%;" /></p><ol type="1"><li>先进行<strong>World-to-View Transformation</strong></li><li>然后进行平行投影：直接舍弃Z轴</li><li>最后进行<strong>2D viewing transformation</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092451427.png" alt="image-20221013092451427" style="zoom:80%;" /></p><h3 id="透视投影">4.3.4 透视投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092109964.png" alt="image-20221013092109964" style="zoom:80%;" /></p><ol type="1"><li>先进行<strong>World-to-View Transformation</strong></li><li>然后进行透视投影：乘投影矩阵</li><li>最后进行<strong>2D viewing transformation</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092416523.png" alt="image-20221013092416523" style="zoom:80%;" /></p><h3 id="view-window">4.3.5 View Window</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092157331.png" alt="image-20221013092157331" style="zoom:80%;" /></p><h3 id="view-volume">4.3.6 View Volume</h3><ol type="1"><li><p>只有<strong>front plane</strong>和<strong>backplane</strong>之间的物体才能被看见</p></li><li><p>透视投影：金字塔型</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092557909.png" alt="image-20221013092557909" style="zoom:80%;" /></p></li><li><p>平行投影：长方体型</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092758810.png" alt="image-20221013092758810" style="zoom:80%;" /></p></li></ol><h3 id="完整的view-specification">4.3.7 完整的View Specification</h3><ol type="1"><li>定义世界坐标系<ol type="1"><li>position of viewing：<strong>vrp</strong></li><li>direction of viewing：<strong>-n</strong></li><li>up direction for viewing：<strong>upVector</strong></li></ol></li><li>定义视角坐标系<ol type="1"><li>view window：<strong>center(cx, cy), width, height</strong></li><li><strong>prp</strong>：distance from the view plane</li><li><strong>front clipping plane</strong>：distance from view plane</li><li><strong>back clipping plane</strong>：distance from view plane</li></ol></li></ol><h2 id="opengl编程">4.4 OpenGL编程</h2><p>问题：如何处理Back-face Culling无法解决的面</p><p>回答：将相机所在的顶点与面上的点连线，与相机朝向向量点乘，判断向量的模</p><h1 id="chapter-5hidden-surface-removal-antialiasing">Chapter 5：HiddenSurface Removal &amp; Antialiasing</h1><h2 id="获得真实的渲染效果">5.1 获得真实的渲染效果</h2><h3 id="要求">5.1.1 要求</h3><ol type="1"><li>透视投影的视图</li><li>适当剪裁的视场</li><li>隐藏看不到的部分</li><li>表面细节，如纹理等</li><li>光照细节，如阴影等</li><li>体积效应，如透过水、蒸汽、烟等分离介质的透明度和半透明性</li><li>动态效果，如运动等</li></ol><h3 id="相关opengl函数">5.1.2 相关OpenGL函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glEnable / <span class="built_in">glDisable</span>(GL_CULL_FACE);</span><br><span class="line"><span class="built_in">glCullFace</span>(mode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glutInitDisplayMode</span>(... | GLUT_DEPTH);</span><br><span class="line"><span class="built_in">glEnalbe</span>(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><h3 id="view流水线">5.1.3 View流水线</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020080854655.png" alt="image-20221020080854655" style="zoom:80%;" /></p><h2 id="可视表面确定">5.2 可视表面确定</h2><p>目标：</p><ol type="1"><li>给定一组3D对象和视图规范，</li><li>确定当沿投影方向观看时，对象的那些部分是可见的</li><li>或者，等价地，消除隐藏部分(隐藏线和表面)</li><li>可见部分将用适当的阴影绘制/显示</li></ol><p>方法：</p><ol type="1"><li>对象空间算法<ol type="1"><li>对象精度</li></ol></li><li>图像空间算法<ol type="1"><li>图像精度</li><li>Z-缓冲区</li></ol></li></ol><h3 id="back-face-culling">5.3 Back-face Culling</h3><ol type="1"><li><p>在一个封闭的多边形表面，如多面体或实心多面体的表面，</p><ol type="1"><li>其法线点远离观察者的面是不可见的，</li><li>这样的背面可以在进一步的处理中消除</li></ol></li><li><p>这种方法被称为Back-face Culling</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020081910444.png" alt="image-20221020081910444" style="zoom:80%;" /></p></li><li><p>Back Face：</p><ol type="1"><li>物体表面的一部分背对眼睛</li><li>即法线指向远离眼睛的表面</li></ol></li><li><p>计算方法：</p><ol type="1"><li>面的法向量 与 观察方向向量 点乘</li><li>负数表示朝向观察者</li><li>正数表示远离观察者</li></ol></li><li><p>Back-face Culling的不足</p><ol type="1"><li>无法判断物体之间的遮挡关系</li><li>背面一定看不到，前面不一定能看到</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020082413694.png" alt="image-20221020082413694" style="zoom:67%;" /></p></li><li><p>Back-face Culling结果成立的情况：</p><ol type="1"><li>单个、闭合的、凸多边形</li></ol></li></ol><h2 id="painters-algorithm">5.4 Painter’s Algorithm</h2><h3 id="算法">5.4.1 算法</h3><ol type="1"><li>物体从远到近排序，先画远的，后画近的，自动形成遮挡</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020083137512.png" alt="image-20221020083137512" style="zoom:80%;" /></p><p>缺点：</p><ol type="1"><li><p>有的图形不可被排序</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020083229134.png" alt="image-20221020083229134" style="zoom:80%;" /></p></li></ol><p>解决方法：</p><ol type="1"><li>将物体进行切割，然后进行排序</li></ol><h3 id="warnocks-area-subdivision">5.4.2 Warnock’s Area Subdivision</h3><ol type="1"><li>从整个图像开始</li><li>如果满足以下情况之一，则直接进行绘制<ol type="1"><li>在前面的多边形覆盖整个窗口</li><li>有最多一个多边形在窗口</li></ol></li><li>否则将窗口分为4个部分，并且重复这两步</li><li>如果区域是单像素的，选择深度最小的表面</li><li>优点：<ol type="1"><li>不过度渲染，抗锯齿性好</li><li>进一步获取亚像素信息</li></ol></li><li>缺点：<ol type="1"><li>测试相当复杂和缓慢</li><li>不适合硬件实现</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020083812927.png" alt="image-20221020083812927" style="zoom:80%;" /></p><h3 id="bsp树">5.4.3 BSP树</h3><p>BSP：Binary Space Partitioning Trees</p><ol type="1"><li><p>构建BSP树</p><ol type="1"><li>选择一个切割面，将空间分为两部分<ol type="1"><li>切割面为根节点，靠近观察者的是左子结点，远离观察者的是右子结点</li></ol></li><li>所有与切割面相交的三角形，会被分解为两个多边形<ol type="1"><li>判断需要切割：三个顶点带入平面方程，符号不一样</li><li>切割方法：二分三角形，每一步舍去在平面同一方向的多边形</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020091257604.png" alt="image-20221020091257604" style="zoom:80%;" /></p></li><li><p>绘制</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020091527689.png" alt="image-20221020091527689" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020091535653.png" alt="image-20221020091535653" style="zoom:80%;" /></p></li></ol><h2 id="z-buffer-algorithm">5.5 Z-buffer Algorithm</h2><h3 id="算法-1">5.5.1 算法</h3><ol type="1"><li>在记录颜色信息的F-Buffer之外，添加一个大小相同的Z-Buffer，存储深度(Z)信息<ol type="1"><li>深度的计算：相机朝向向量 与 面 交点的Z值</li></ol></li><li>优点：绘画的顺序不影响最后的结果</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020084355203.png" alt="image-20221020084355203" style="zoom:80%;" /></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(j = 0; j &lt; SCREEN_HEIGHT; j++)</span><br><span class="line">    for(i = 0; i &lt; SCREEN_WIDTH; i++)&#123;</span><br><span class="line">        WriteToFrameBuffer(i, j, BackgroundColor);</span><br><span class="line">        WriteToZBuffer(i, j, MAX);</span><br><span class="line">    &#125;</span><br><span class="line">for(each polygon)</span><br><span class="line">    for(each pixel in polygon&#x27;s projection)&#123;</span><br><span class="line">        z = polygon&#x27;s z value at (i,j);</span><br><span class="line">        if(z &lt; ReadFromZBuffer(i, j))&#123;</span><br><span class="line">            WriteToFrameBuffer(i, j, polygon&#x27;s color at (i, j));</span><br><span class="line">            WriteToZBuffer(i, j, z);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="示例">5.5.2 示例</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020085640214.png" alt="image-20221020085640214" style="zoom:80%;" /></p><h3 id="相关opengl函数-1">5.5.3 相关OpenGL函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020085912366.png" alt="image-20221020085912366" style="zoom:80%;" /></p><h2 id="ray-casting">5.6 Ray Casting</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020092149931.png" alt="image-20221020092149931" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020092156619.png" alt="image-20221020092156619" style="zoom:80%;" /></p><h2 id="aliasing-锯齿混叠">5.7 Aliasing 锯齿/混叠</h2><ol type="1"><li><p>Aliasing是由于显示设备的离散特性造成的</p></li><li><p>栅格化就像用一组有限的值对连续信号进行采样</p></li><li><p>如果采样率不充分，信号就会丢失，这种抽样误差称为Aliasing</p></li><li><p>Aliasing的效果：</p><ol type="1"><li>锯齿状边缘</li><li>渲染不正确的细节</li><li>可能会漏掉小物件</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020092750083.png" alt="image-20221020092750083" style="zoom:80%;" /></p></li></ol><h3 id="super-sampling">5.7.1 Super-sampling</h3><ol type="1"><li>每一个像素，采样多个点，进行平均，作为当前像素的颜色</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020092949911.png" alt="image-20221020092949911" style="zoom:80%;" /></p><h3 id="area-sampling">5.7.2 Area-sampling</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020093204838.png" alt="image-20221020093204838" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020093215071.png" alt="image-20221020093215071" style="zoom:80%;" /></p><p>http://www.pbrt.org/chapters/pbrt_chapter7.pdf</p><h1 id="chapter-6color-theory-programmable-pipeline">Chapter 6：ColorTheory &amp; Programmable Pipeline</h1><h2 id="什么是颜色">6.1 什么是颜色</h2><ol type="1"><li><strong>Color</strong>是大脑对特定视觉刺激的反应</li><li>知觉：观察者锁经历的主观感受，没有观察者就没有颜色</li><li>颜色取决于：<ol type="1"><li>光的物理特性</li><li>光与物理材料的相互作用</li><li>人类的视觉系统和大脑对由此产生的现象的解释</li></ol></li></ol><h2 id="光的物理特性">6.2 光的物理特性</h2><ol type="1"><li>光是一种难以观测的动态现象</li><li>现在的研究正在试图对光进行建模</li><li>目前，物理学家提出了两种模型来解释光的行为<ol type="1"><li>波模型，将光视为水波</li><li>粒子模型，该模型假设光是由微小的、不可见的振动粒子—光子构成的</li></ol></li></ol><h3 id="光的粒子模型">6.2.1 光的粒子模型</h3><ol type="1"><li><p>从颜色的角度来看，采用了粒子模型</p></li><li><p>当光子沿着直线运动时，它们会以特定的频率振动</p></li><li><p>假设光子携带一定的能量，能量与它们的振动频率成正比，<spanclass="math inline">\(E = h f\)</span></p><ol type="1"><li><span class="math inline">\(h\)</span>是普朗克常数</li><li><span class="math inline">\(f\)</span>是振动的频率</li></ol></li><li><p>光子的行为是循环的，有一个重复的模式</p></li><li><p>光子从一个周期开始到下一个周期开始所经过的距离称为波长，<spanclass="math inline">\(\lambda=\frac{c}{f}\)</span></p><ol type="1"><li><span class="math inline">\(c\)</span>是光速</li><li><span class="math inline">\(f\)</span>是频率</li></ol></li><li><p>每个光子都有一个与其相关的波长，<strong>光的颜色</strong>取决于这个<strong>波长</strong></p></li><li><p><strong>光的强度</strong>取决于存在的<strong>光子的数量</strong></p></li><li><p>光是一种连续的电磁光谱</p><ol type="1"><li>粒子数在波长上的分布</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027081651698.png" alt="image-20221027081651698" style="zoom: 80%;" /></p></li></ol><h3 id="计算光在脑中产生的电信号">6.2.2 计算光在脑中产生的电信号</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027082504687.png" alt="image-20221027082504687" style="zoom:80%;" /></p><p><span class="math inline">\(r=\int f(x)s(x)dx\)</span></p><ol type="1"><li><spanclass="math inline">\(f(x)\)</span>：光强沿波长分布函数(右图)</li><li><spanclass="math inline">\(s(x)\)</span>：人眼细胞敏感度沿波长分布函数(左图)</li><li>两个函数乘积再积分 ==&gt; 卷积 ==&gt; 离散化之后，变为向量的点乘==&gt; <span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(s(x)\)</span>上的投影</li></ol><h2 id="颜色模型">6.3 颜色模型</h2><ol type="1"><li><p>RGB：加色模型，从黑色开始添加颜色</p><ol type="1"><li>Red / Green / Blue</li></ol></li><li><p>CMYK：减色模型，从白色出发开始减去颜色</p><ol type="1"><li>Cyan / Magenta/ Yellow / Black</li></ol></li><li><p>HSV：</p><ol type="1"><li>Hue(颜色) / Saturation(饱和度) / Value</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027083424996.png" alt="image-20221027083424996" style="zoom:50%;" /></p></li><li><p>Lab：概念颜色空间</p></li></ol><h2 id="可编程流水线">6.4 可编程流水线</h2><h3 id="可编程图形学流水线">6.4.1 可编程图形学流水线</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027085338876.png" alt="image-20221027085338876" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027085417058.png" alt="image-20221027085417058" style="zoom:80%;" /></p><h3 id="着色器程序结构">6.4.2 着色器程序结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027085530923.png" alt="image-20221027085530923" style="zoom:80%;" /></p><h3 id="gpu的结构">6.4.3 GPU的结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027085627360.png" alt="image-20221027085627360" style="zoom:80%;" /></p><h2 id="glsl">6.5 GLSL</h2><h3 id="变量">6.5.1 变量</h3><ol type="1"><li><p>uniform：可以在程序中改变，但在shader中是常量</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenGL中预先定义的变量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> <span class="built_in">gl_ModelViewMatrix</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> <span class="built_in">gl_ProjectionMatrix</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> <span class="built_in">gl_NormalMatrix</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户定义</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br></pre></td></tr></table></figure></li><li><p>attribute：顶点属性的输入</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> <span class="built_in">gl_Color</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> <span class="built_in">gl_FrontColor</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> <span class="built_in">gl_BackColor</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="built_in">gl_FrontColor</span> = <span class="built_in">gl_Color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>varying：顶点属性的输出</p></li></ol><h3 id="向量-1">6.5.2 向量</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="type">vec3</span> v3 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line"><span class="type">vec4</span> v4 = <span class="type">vec4</span>(v3, <span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swizzling</span></span><br><span class="line"><span class="type">vec2</span> v2 = v4.xy;</span><br><span class="line"><span class="type">vec4</span> v2Reverse = v4.wzyx;</span><br><span class="line"><span class="type">vec4</span> result = v4.xyzw + v4.xxxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量运算</span></span><br><span class="line"><span class="type">float</span> result = <span class="built_in">dot</span>(v4, v4Reverse);</span><br><span class="line"><span class="type">vec3</span> result = <span class="built_in">cross</span>(v3, <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure><h3 id="纹理">6.5.3 纹理</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> someTexture;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec4</span> someTexture = <span class="built_in">texture2D</span>(someTexture, <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序与glsl沟通">6.5.4 程序与GLSL沟通</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027090918716.png"alt="image-20221027090918716" /><figcaption aria-hidden="true">image-20221027090918716</figcaption></figure><h3 id="顶点着色器">6.5.5 顶点着色器</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027090936750.png"alt="image-20221027090936750" /><figcaption aria-hidden="true">image-20221027090936750</figcaption></figure><h3 id="片段着色器">6.5.6 片段着色器</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027090954131.png"alt="image-20221027090954131" /><figcaption aria-hidden="true">image-20221027090954131</figcaption></figure><h3 id="示例-1">6.5.7 示例</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027091258602.png"alt="image-20221027091258602" /><figcaption aria-hidden="true">image-20221027091258602</figcaption></figure><h1 id="chapter-7curves">Chapter 7：Curves</h1><h2 id="曲线的表达形式">7.1 曲线的表达形式</h2><ol type="1"><li>显式曲线：<span class="math inline">\(y=f(x)\)</span></li><li>隐式曲线：<span class="math inline">\(g(x,y)=0\)</span></li><li>参数曲线：<span class="math inline">\(x=x(t),y=y(t)\)</span></li></ol><h2 id="隐式曲线-implicit-curves">7.2 隐式曲线 Implicit Curves</h2><ol type="1"><li><p>优点：很容易判断一个点是在曲线上/里/外</p></li><li><p>缺点：难以找到所有的点</p></li><li><p>找点的方法：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110081551865.png" alt="image-20221110081551865" style="zoom:80%;" /></p></li></ol><h2 id="参数化曲线-parametric-curves">7.3 参数化曲线 ParametricCurves</h2><ol type="1"><li><span class="math inline">\(C = C(u) =[x(u),y(u),z(u)]\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082316876.png" alt="image-20221110082316876" style="zoom:80%;" /></p><h3 id="插值">7.3.1 插值</h3><ol type="1"><li><p>Nearest Neighbor插值</p><ol type="1"><li>缺点：值不连续</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082517408.png" alt="image-20221110082517408" style="zoom:67%;" /></p></li><li><p>线性插值</p><ol type="1"><li>缺点：导数不连续</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082607117.png" alt="image-20221110082607117" style="zoom:80%;" /></p></li><li><p>平滑插值</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082707969.png" alt="image-20221110082707969" style="zoom:80%;" /></p></li></ol><h3 id="cubic-hermite插值">7.3.2 Cubic Hermite插值</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082735897.png" alt="image-20221110082735897" style="zoom:80%;" /></p><ol type="1"><li><p>已知：两个值，两个导数</p></li><li><p>假设一个三次多项式：<spanclass="math inline">\(P(t)=at^3+bt^2+ct+d,P&#39;(t)=3at^2+2bt+c\)</span></p><ol type="1"><li><spanclass="math inline">\(P(0)=d,P(1)=a+b+c+d,P&#39;(0)=c,P&#39;(1)=3a+2b+c\)</span></li></ol><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083005175.png" alt="image-20221110083005175" style="zoom:80%;" /></th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083030111.png" alt="image-20221110083030111" style="zoom:80%;" /></td></tr><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083212613.png" alt="image-20221110083212613" style="zoom:80%;" /></td></tr><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083226736.png" alt="image-20221110083226736" style="zoom:80%;" /></td></tr><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083515950.png" alt="image-20221110083515950" style="zoom:80%;" /></td></tr><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083536773.png" alt="image-20221110083536773" style="zoom:80%;" /></td></tr><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083616368.png" alt="image-20221110083616368" style="zoom:80%;" /></td></tr><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083640575.png" alt="image-20221110083640575" style="zoom:80%;" /></td></tr></tbody></table></li><li><p>本质上是从以<spanclass="math inline">\([t^3,t^2,t,1]\)</span>为基，变成了以<spanclass="math inline">\([H_0(t),H_1(t),H_2(t),H_3(t)]\)</span>为基</p></li><li><p>Hermite Basic Function</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110084048248.png" alt="image-20221110084048248" style="zoom:80%;" /></p><ol type="1"><li><p><spanclass="math inline">\(H_1(t)\)</span>函数可以用作动画，开始和停止都会比较慢</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110084102539.png" alt="image-20221110084102539" style="zoom:80%;" /></p></li></ol></li><li><p>多个点的插值：相邻的两个点做一次三次插值</p><ol type="1"><li>由于插值保证所有点的导数不变，因此曲线一定连续</li></ol></li></ol><h3 id="catmull-rom-插值">7.3.3 Catmull-Rom 插值</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110084349963.png" alt="image-20221110084349963" style="zoom:80%;" /></p><ol type="1"><li><p>找每个点的斜率：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085220297.png" alt="image-20221110085220297" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085816174.png" alt="image-20221110085816174" style="zoom:80%;" /></p></li><li><p>要找两个邻居，而不是找一个邻居：</p><ol type="1"><li>一个邻居的偏差为<spanclass="math inline">\(O(n)\)</span>，两个邻居的偏差为<spanclass="math inline">\(O(n^2)\)</span></li><li>通过泰勒展开证明</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085841836.png" alt="image-20221110085841836" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085851775.png" alt="image-20221110085851775" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085902001.png" alt="image-20221110085902001" style="zoom:80%;" /></p></li></ol><h2 id="bezier-curve-贝塞尔曲线">7.4 Bezier Curve 贝塞尔曲线</h2><h2 id="计算方式">7.4.1 计算方式</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110090123212.png" alt="image-20221110090123212" style="zoom:80%;" /></p><h3 id="性质">7.4.2 性质</h3><ol type="1"><li><p>每个点的权重<span class="math inline">\(\ge 0\)</span></p></li><li><p>所有点的权重和为<span class="math inline">\(1\)</span></p></li><li><p>权重有对称性</p></li><li><p>穿过第一个点、最后一个点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110090211889.png" alt="image-20221110090211889" style="zoom:80%;" /></p></li><li><p><span class="math inline">\(P_0P_1,P_{n-1}P_n\)</span>为<spanclass="math inline">\(P_0,P_n\)</span>处的曲率</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110090352978.png" alt="image-20221110090352978" style="zoom:80%;" /></p></li><li><p>仿射不变性：先变换后采样的结果 == 先采样后变换的结果</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110090716384.png" alt="image-20221110090716384" style="zoom:80%;" /></p></li><li><p>贝塞尔曲线一定在所有控制点的凸包内</p></li><li><p>贝塞尔曲线一定不会比直接连线更陡</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091015792.png" alt="image-20221110091015792" style="zoom:80%;" /></p></li></ol><h3 id="示例-2">7.4.3 示例</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091056918.png" alt="image-20221110091056918" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091106122.png" alt="image-20221110091106122" style="zoom:80%;" /></p><h3 id="opengl中的贝塞尔曲线">7.4.4 OpenGL中的贝塞尔曲线</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110092037061.png" alt="image-20221110092037061" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091001577.png" alt="image-20221110091001577" style="zoom:80%;" /></p><h3 id="rational-bezier-curve-有理贝塞尔曲线">7.4.5 Rational BezierCurve 有理贝塞尔曲线</h3><ol type="1"><li>每一个点对最后曲线的权重可以调节</li><li><span class="math inline">\(P_i\)</span>的权重设为<spanclass="math inline">\(w_i\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091331795.png" alt="image-20221110091331795" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091410787.png" alt="image-20221110091410787" style="zoom:80%;" /></p><h3 id="贝塞尔曲线的缺点">7.4.6 贝塞尔曲线的缺点</h3><ol type="1"><li>控制点个数对应表达式的阶数，点过多时阶数过大</li><li>每一个控制点对全局均有影响</li></ol><h2 id="b-spline">7.5 B-spline</h2><ol type="1"><li>阶数与控制点个数无关</li><li>局部控制</li><li>本质上是成片的相接的多项式</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091648614.png" alt="image-20221110091648614" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091728674.png" alt="image-20221110091728674" style="zoom:80%;" /></p><h3 id="nurbs">7.5.1 NURBS</h3><p>Non-Uniform Rational B-Spline：区间段的长度可以由人工控制</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091926951.png" alt="image-20221110091926951" style="zoom:80%;" /></p><h3 id="opengl中的nurbs">7.5.2 OpenGL中的NURBS</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110092019603.png" alt="image-20221110092019603" style="zoom:80%;" /></p><h2 id="总结">7.6 总结</h2><ol type="1"><li>从顶点上来看：曲线本质上是对控制点的加权平均，权重由basisfunction决定</li><li>从函数上来看：曲线是由不同的函数线性组合而来，权重由控制点决定，basisfunction固定不变。相当于将<spanclass="math inline">\(P(t)\)</span>投影到了<spanclass="math inline">\(B_0(t),...,B_n(t)\)</span>的坐标轴上</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110092101504.png" alt="image-20221110092101504" style="zoom:80%;" /></p><h1 id="chapter-8-surface">Chapter 8 Surface</h1><h2 id="参数化曲线">8.1 参数化曲线</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117082250344.png" alt="image-20221117082250344" style="zoom:80%;" /></p><h2 id="参数化曲面">8.2 参数化曲面</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117082414258.png" alt="image-20221117082414258" style="zoom:80%;" /></p><h3 id="n阶贝塞尔曲面">8.2.1 n阶贝塞尔曲面</h3><h4 id="曲面的表达式">8.2.1.1 曲面的表达式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117082505623.png" alt="image-20221117082505623" style="zoom:80%;" /></p><h4 id="贝塞尔曲线与贝塞尔曲面的联系">8.2.1.2贝塞尔曲线与贝塞尔曲面的联系</h4><ol type="1"><li><spanclass="math inline">\(B_{j,m}(v)\)</span>为参数的贝塞尔曲线，计算当<spanclass="math inline">\(t=v\)</span>时对应的点，共<spanclass="math inline">\(n+1\)</span>个</li><li>作为控制点，再次计算以<spanclass="math inline">\(B_{i,n}(u)\)</span>为参数的贝塞尔曲线</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117082730133.png" alt="image-20221117082730133" style="zoom:80%;" /></p><h4 id="贝塞尔曲面的法向量">8.2.1.3 贝塞尔曲面的法向量</h4><ol type="1"><li>计算对于<spanclass="math inline">\(u,v\)</span>的偏导，然后进行叉积</li><li><span class="math inline">\(N(u,v)=\frac{\partial S(u,v)}{\partialu} × \frac{\partial S(u,v)}{\partial v}\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083228947.png" alt="image-20221117083228947" style="zoom:80%;" /></p><h4 id="opengl中的使用">8.2.1.4 OpenGL中的使用</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083400530.png" alt="image-20221117083400530" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083459717.png" alt="image-20221117083459717" style="zoom:80%;" /></p><h3 id="b-spline曲面">8.2.2 B-spline曲面</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083543462.png" alt="image-20221117083543462" style="zoom:80%;" /></p><h3 id="nurbs曲面">8.2.3 NURBS曲面</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083554216.png" alt="image-20221117083554216" style="zoom:80%;" /></p><h2 id="多边形网格">8.3 多边形网格</h2><h3 id="什么是多边形网格">8.3.1 什么是多边形网格</h3><ol type="1"><li>在三维计算机图形学和实体建模中，定义一个多面体物体形状的顶点、边和面的集合</li><li>可以用许多平面近似地表示一个曲线形状</li><li>在游戏中呈现几何体的实际标准</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117084031574.png" alt="image-20221117084031574" style="zoom:80%;" /></p><h3 id="多边形网格的表示">8.3.2 多边形网格的表示</h3><p>顶点信息 + 拓扑信息</p><ol type="1"><li><p>Vertex-Vertex Meshes(VV)</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117084141008.png" alt="image-20221117084141008" style="zoom:80%;" /></p></li><li><p>Face-Vertex Meshes</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117084204664.png" alt="image-20221117084204664" style="zoom:80%;" /></p></li></ol><h3 id="obj格式">8.3.3 obj格式</h3><h4 id="示例-3">8.3.3.1 示例</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117085237119.png" alt="image-20221117085237119" style="zoom:80%;" /></p><h4 id="含义">8.3.3.2 含义</h4><ol type="1"><li>mtllib：导入.mtl文件</li><li>usemtl：从该句开始后面的面，使用该.mtl文件</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117085252584.png" alt="image-20221117085252584" style="zoom: 80%;" /></p><h4 id="wavefront-.obj-file">8.3.3.3 Wavefront .obj file</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117085801279.png" alt="image-20221117085801279" style="zoom:80%;" /></p><h3 id="constructive-solid-geometry-构造实体几何">8.3.4 ConstructiveSolid Geometry 构造实体几何</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117085919901.png" alt="image-20221117085919901" style="zoom:80%;" /></p><h3 id="l-systemformal-grammar">8.3.5 L-system：Formal grammar</h3><ol type="1"><li><p>Formal grammar</p><ol type="1"><li>Alphabet：字母表</li><li>Production rules：推导规则</li><li>An initial axiom：公理</li></ol></li><li><p>最后的字符串对应一个图像</p></li><li><p>应用</p><ol type="1"><li>植物</li><li>分形</li></ol></li><li><p>示例：</p><ol type="1"><li><p>生成字符串</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117090339348.png" alt="image-20221117090339348" style="zoom:80%;" /></p></li><li><p>解释这个字符串</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117090453258.png" alt="image-20221117090453258" style="zoom:80%;" /></p></li></ol></li></ol><h3 id="shape-grammar">8.3.6 Shape Grammar</h3><ol type="1"><li><p>将推导规则定义在形状上</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117091357675.png" alt="image-20221117091357675" style="zoom:80%;" /></p></li><li><p>例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117091456789.png" alt="image-20221117091456789" style="zoom:80%;" /></p></li></ol><h3 id="subdivision-curvessurface">8.3.7 Subdivision Curves/Surface</h3><ol type="1"><li>从一些顶点开始</li><li>根据规则，生成新顶点，替换旧顶点：Geometric rule</li><li>根据规则，将新顶点连起来：Topological rule</li><li>重复若干次，直到收敛</li></ol><h3 id="使用生成方法的优点">8.3.8 使用生成方法的优点</h3><ol type="1"><li>可以构造复杂图形</li><li>容易生成</li><li>容易通过控制初始点，控制网格</li><li>LOD</li><li>可以由GPU通过geometry shader原生支持</li></ol><h2 id="sweeping">8.4 Sweeping</h2><ol type="1"><li><p>由一个图形+轨迹生成网格</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117092534929.png" alt="image-20221117092534929" style="zoom:80%;" /></p></li></ol><h2 id="总结-1">8.5 总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117092612893.png" alt="image-20221117092612893" style="zoom:80%;" /></p><p>问题：观察者如何看到光源？回答：反射光源必须经过人眼，即人眼与反射点的连线与法向量<strong>n</strong>的夹角，与<strong>i</strong>与<strong>n</strong>的夹角相同，且三者共面</p><h1 id="chapter-9digital-material-appearance">Chapter 9：DigitalMaterial Appearance</h1><h2 id="introduction">9.1 Introduction</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124081816705.png" alt="image-20221124081816705" style="zoom:80%;" /></p><p>光与物体的交互：</p><ol type="1"><li>吸收</li><li>反射：颜色、光泽</li><li>穿透</li></ol><h2 id="reflection-models">9.2 Reflection Models</h2><h3 id="brdf">9.2.1 BRDF</h3><p>Bidirectional Reflectance Distribution Function f(i,o)</p><ol type="1"><li>i：入射方向</li><li>o：出射方向</li><li>是一个4D函数：因为是单位向量，消去了一个自由度<ol type="1"><li>一个单位球上确定一个向量，只需要2个自由度(经度、纬度)</li></ol></li><li>固定i，一个出方向的二维函数描述了入射光如何沿不同方向反射</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124082727824.png" alt="image-20221124082727824" style="zoom:80%;" /></p><h3 id="完美镜面反射">9.2.2 完美镜面反射</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124083131813.png" alt="image-20221124083131813" style="zoom:80%;" /></p><ol type="1"><li>观察者如何看到光源：<spanclass="math inline">\(\vec{o}\)</span>与<spanclass="math inline">\(\vec{i}\)</span>关于法向量<spanclass="math inline">\(\vec{n}\)</span>的夹角相等，且三者共面</li><li>判断夹角是否相等：<spanclass="math inline">\(\vec{h}=\frac{\vec{i}+\vec{o}}{||\vec{i}+\vec{o}||}\)</span>与<spanclass="math inline">\(\vec{n}\)</span>的方向相同</li></ol><h3 id="fresnel-reflectance-term">9.2.3 Fresnel Reflectance Term</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><th style="text-align: center;">绝缘体</th><th style="text-align: center;">导体</th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124083608406.png" alt="image-20221124083608406" style="zoom:80%;" /></td><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124083615758.png" alt="image-20221124083615758" style="zoom:80%;" /></td></tr></tbody></table><p>计算镜面反射率：<spanclass="math inline">\(n_1,n_2\)</span>为两者的反射率，<spanclass="math inline">\(\theta\)</span>为<spanclass="math inline">\(\vec{i}\)</span>和<spanclass="math inline">\(\vec{n}\)</span>的夹角 <spanclass="math display">\[R(\theta)=R_0+(1-R_0)(1-cos\theta)^5 \\R_0=(\frac{n_1-n_2}{n_1+n_2})^2\]</span></p><h3 id="microfacet-based-models">9.2.4 Microfacet-Based Models</h3><blockquote><ol type="1"><li>当平面非常小时，均为镜面反射</li><li>微面的反射只与微面的方向有关系</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124084056057.png" alt="image-20221124084056057" style="zoom:80%;" /></p><blockquote><p>Microfacet-Based Models的计算公式</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124085703236.png" alt="image-20221124085703236" style="zoom:80%;" /></p><ol type="1"><li><p><spanclass="math inline">\(D(h)\)</span>：有百分之多少的微面，法向量=<spanclass="math inline">\(\vec{h}\)</span></p><ol type="1"><li>如果微面的法向量≠<spanclass="math inline">\(\vec{h}\)</span>，则在当前的<spanclass="math inline">\(\vec{i},\vec{o}\)</span>的情况下，不可能发生镜面反射，如下图所示</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124084512790.png" alt="image-20221124084512790" style="zoom:80%;" /></p></li><li><p><span class="math inline">\(G(i,o,h)\)</span>：计算遮挡的情况</p><ol type="1"><li>微面的法向量=<spanclass="math inline">\(\vec{h}\)</span>，可能发生镜面反射，但由于阴影/遮罩，也可能无法发生镜面反射</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124085320197.png" alt="image-20221124085320197" style="zoom:80%;" /></p></li><li><p><span class="math inline">\(F(i,h)\)</span>：镜面反射率</p></li></ol><blockquote><p>Microfacet-Based Models的一个具体的计算方式：Cook-Torrance Model</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124085635846.png" alt="image-20221124085635846" style="zoom:80%;" /></p><h3 id="anisotropic-brdf-各向异性">9.2.5 Anisotropic BRDF 各向异性</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124090022557.png" alt="image-20221124090022557" style="zoom:80%;" /></p><h2 id="diffuse-reflection-漫反射">9.3 Diffuse Reflection 漫反射</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124090201135.png" alt="image-20221124090201135" style="zoom:80%;" /></p><ol type="1"><li>一束光打过来，沿每一个可能的出射方向的反射率是相同的：<spanclass="math inline">\(f(i,o)=constant\)</span><ol type="1"><li>这只是观察到的情况，物理上不是这样的</li><li>物理上是先吸收，后反射</li></ol></li></ol><h2 id="两种反射结合">9.4 两种反射结合</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124090412086.png" alt="image-20221124090412086" style="zoom:80%;" /></p><ol type="1"><li>金属的高光颜色为表面颜色，塑料的高光颜色为白色</li><li>额外的一个cos(i, n)表示光实际打到表面的能量占比</li></ol><h2 id="brdf模型在glsl中的实现">9.5 BRDF模型在GLSL中的实现</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091214190.png" alt="image-20221124091214190" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091225385.png" alt="image-20221124091225385" style="zoom:80%;" /></p><h2 id="实用工具">9.6 实用工具</h2><p>https://www.disneyanimation.com/technology/brdf.html</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091402285.png" alt="image-20221124091402285" style="zoom:80%;" /></p><h2 id="reflectance-capture">9.7 Reflectance Capture</h2><h3 id="直接采样">9.7.1 直接采样</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091619340.png" alt="image-20221124091619340" style="zoom:80%;" /></p><h3 id="光照多路复用">9.7.2 光照多路复用</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091806057.png" alt="image-20221124091806057" style="zoom:80%;" /></p><p>灯光舞台</p><ol type="1"><li>同时使用数百个光源</li><li>只有一个或几个摄像头</li><li>投射特定的模式并使用查找表恢复反射率</li><li>效率更高</li><li>广泛用于电影制作</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124092000943.png" alt="image-20221124092000943" style="zoom:80%;" /></p><h2 id="总结-2">9.8 总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124093411345.png" alt="image-20221124093411345" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124093420018.png" alt="image-20221124093420018" style="zoom:80%;" /></p><h1 id="chapter-10texture">Chapter 10：Texture</h1><h2 id="什么是texture-mapping">10.1 什么是Texture Mapping</h2><ol type="1"><li>Surface存在在3D世界空间中</li><li>每个3D表面点在2D图像和2D纹理中也有一个位置</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201081320444.png" alt="image-20221201081320444" style="zoom:80%;" /></p><h2 id="texture-coordinates">10.2 Texture Coordinates</h2><ol type="1"><li>纹理坐标也叫UV坐标</li><li>UV坐标系左下角为(0,0)，右上角为(1,1)</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201081724694.png" alt="image-20221201081724694" style="zoom:80%;" /></p><h2 id="sponza-palace-model">10.3 Sponza Palace Model</h2><ol type="1"><li>一个小的纹理贴图，可以通过重复，将其映射到一个大的物体上</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082117840.png" alt="image-20221201082117840" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082126464.png" alt="image-20221201082126464" style="zoom:80%;" /></p><h2 id="如何生成纹理坐标">10.4 如何生成纹理坐标</h2><h3 id="参数化曲面-1">10.4.1 参数化曲面</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082247584.png" alt="image-20221201082247584" style="zoom:80%;" /></p><h3 id="平面投影">10.4.2 平面投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082441068.png" alt="image-20221201082441068" style="zoom:80%;" /></p><h3 id="球面投影">10.4.3 球面投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082645574.png" alt="image-20221201082645574" style="zoom:80%;" /></p><h3 id="立方体投影">10.4.4 立方体投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082705189.png" alt="image-20221201082705189" style="zoom:80%;" /></p><h3 id="复杂表面">10.4.5 复杂表面</h3><ol type="1"><li>将物体分为不同的部分，分别使用不同的投影方法</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082825156.png" alt="image-20221201082825156" style="zoom:80%;" /></p><h3 id="实际上的操作">10.4.6 实际上的操作</h3><ol type="1"><li>切分 cut</li><li>摊平 flatten</li><li>打包 pack</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082928756.png" alt="image-20221201082928756" style="zoom:80%;" /></p><h2 id="texture-mapping实质是重采样">10.5 TextureMapping实质是重采样</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201083733711.png" alt="image-20221201083733711" style="zoom:80%;" /></p><h2 id="屏幕坐标-vs-纹理坐标">10.6 屏幕坐标 vs 纹理坐标</h2><p>在最佳观看尺寸下</p><ol type="1"><li>一个像素样本 &lt;==&gt; 一个纹理样本</li><li>取决于纹理分辨率，例如512x512</li></ol><p>当放大时(离我们越近)：</p><ol type="1"><li>多个像素样本 &lt;==&gt; 一个纹理样本</li></ol><p>当缩小时(离我们越远)：</p><ol type="1"><li>一个像素样本 &lt;==&gt; 多个纹理样本</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201084620522.png" alt="image-20221201084620522" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201084737849.png" alt="image-20221201084737849" style="zoom:80%;" /></p><p>计算具体的对应关系：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201085641752.png" alt="image-20221201085641752" style="zoom:80%;" /></p><h2 id="texture-filtering">10.7 Texture Filtering</h2><ol type="1"><li>采样率不匹配可能导致混叠效应</li><li>Idea：去掉超出采样率的“坏”高频部分</li></ol><h3 id="纹理放大bilinear-filtering-双线性滤波">10.7.1 纹理放大：BilinearFiltering 双线性滤波</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201085957359.png" alt="image-20221201085957359" style="zoom:80%;" /></p><ol type="1"><li>想要计算红点的值</li><li>找4个临近的节点，进行两次线性插值</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090021141.png" alt="image-20221201090021141" style="zoom: 50%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090109836.png" alt="image-20221201090109836" style="zoom: 50%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090137799.png" alt="image-20221201090137799" style="zoom: 50%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090440048.png" alt="image-20221201090440048" style="zoom:50%;" /></p><h3 id="纹理缩小mipmap-trilinear-filtering">10.7.2 纹理缩小：Mipmap=&gt; Trilinear Filtering</h3><ol type="1"><li>Challenge<ol type="1"><li>许多texels会增加像素占用</li><li>pixel footprint的形状可能很复杂</li></ol></li><li>Idea<ol type="1"><li>低通过滤器、降低采样率</li><li>使用与屏幕采样率匹配的分辨率</li></ol></li></ol><blockquote><p>Mipmap：将</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090959726.png" alt="image-20221201090959726" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091110918.png" alt="image-20221201091110918" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091203711.png" alt="image-20221201091203711" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091245274.png" alt="image-20221201091245274" style="zoom:80%;" /></p><blockquote><p>Trilinear Filtering</p><ol type="1"><li>在每个Mipmap Level中进行一次Bilinear</li><li>在Mipmap Level之间进行一次线性插值</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091334182.png" alt="image-20221201091334182" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091433151.png" alt="image-20221201091433151" style="zoom:80%;" /></p><blockquote><p>OpenGL中的设置：</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091528820.png" alt="image-20221201091528820" style="zoom:80%;" /></p><blockquote><p>Mipmap的局限：</p><ol type="1"><li>远处的地方，应该是对应一个椭圆，但mip level认为是一个圆形</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091649957.png" alt="image-20221201091649957" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091752287.png" alt="image-20221201091752287" style="zoom:80%;" /></p><h2 id="高级纹理映射">10.8 高级纹理映射</h2><p>纹理 = 内存 + 滤波</p><ol type="1"><li>为分段计算提供数据的一般方法</li></ol><p>应用程序</p><ol type="1"><li><p>环境照明</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201092006954.png" alt="image-20221201092006954" style="zoom:67%;" /></p></li><li><p>Micro-geometry映射</p></li><li><p>程序上的纹理</p></li><li><p>双向体绘制</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093031432.png" alt="image-20221201093031432" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093103715.png" alt="image-20221201093103715" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093115728.png" alt="image-20221201093115728" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093242373.png" alt="image-20221201093242373" style="zoom:80%;" /></p></li><li><p>结构函数</p></li></ol><h2 id="总结-3">10.9 总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093415899.png" alt="image-20221201093415899" style="zoom:80%;" /></p><h1 id="chapter-12advanced-real-time-rendering">Chapter 12：AdvancedReal-time Rendering</h1><h2 id="阴影贴图">12.1 阴影贴图</h2><ol type="1"><li><p>阴影对真实感非常重要</p><ol type="1"><li>可以显示物体之间的位置关系</li><li>光源的位置</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215080952113.png" alt="image-20221215080952113" style="zoom:80%;" /></p></li><li><p>如何判断点是否在阴影里面：点在灯的视角中被物体遮挡了(深度测试)</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215081326987.png" alt="image-20221215081326987" style="zoom:80%;" /></p></li><li><p>单个点光源的阴影计算：</p><ol type="1"><li>将光源作为眼睛，只渲染深度，相关的深度缓冲存储为<strong>阴影贴图</strong></li><li>对每一个被渲染的点，将其更改到光源的视角，用阴影贴图中的z-value进行测试<ol type="1"><li>如果不包含，则不使用阴影渲染</li><li>否则，渲染阴影</li></ol></li></ol></li><li><p>多个点光源的阴影计算：</p><ol type="1"><li>计算每个点光源的阴影贴图，然后做线性相加</li></ol></li><li><p>面光源的阴影计算：</p><ol type="1"><li>将面光源采样为多个点光源</li></ol></li><li><p>常见问题</p><ol type="1"><li><p>在Z的判断上精度不够：添加一个offset，而不是完全判断相等</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215082319338.png" alt="image-20221215082319338" style="zoom:80%;" /></p></li><li><p>当分辨率不高时，相机与光源的采样率区别很大：Perspective ShadowMap</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215082639109.png" alt="image-20221215082639109" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215082733361.png" alt="image-20221215082733361" style="zoom:80%;" /></p></li></ol></li></ol><h2 id="precomputed-radiance-transfer">12.2 Precomputed RadianceTransfer</h2><ol type="1"><li><p>反射的公式：</p><ol type="1"><li>L<sub>i</sub>(i, p)：入射光为i时，点p的能量</li><li>V(i, p)：入射光为i时，点p的可视性</li><li>(n,i)：一个cos&lt;n, i&gt;值</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215083258036.png" alt="image-20221215083258036" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215083550112.png" alt="image-20221215083550112" style="zoom:80%;" /></p></li><li><p>如何计算积分：随机采样</p></li><li><p>如何高效计算：预先计算好结果</p></li><li><p>预计算，假设：</p><ol type="1"><li><p>光源很远：表示光L<sub>i</sub>(i)</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215083946872.png" alt="image-20221215083946872" style="zoom:80%;" /></p></li><li><p>静态场景：可见性函数V(i, p)可以提前计算</p></li><li><p>Lambertian材质：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215084044453.png" alt="image-20221215084044453" style="zoom:80%;" /></p></li></ol></li><li><p>预计算：可以将积分改变为两重循环的积分</p></li><li><p>卷积定理：</p><ol type="1"><li>一个域下的卷积，是它对偶域上的点积</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215084439503.png" alt="image-20221215084439503" style="zoom:80%;" /></p></li><li><p>使用什么Base Function？</p><ol type="1"><li>Spherical Harmonics：球面谐波</li><li>Haar Wabelets：哈尔</li><li>Gaussian Mixtures：高斯混合</li></ol></li><li><p>如何计算参数？</p><ol type="1"><li>卷积，即F(i)和B<sub>k</sub>(i)的卷积</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215085846018.png" alt="image-20221215085846018" style="zoom:80%;" /></p></li><li><p>SH Lighting：通常用16个参数即可</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215085713134.png" alt="image-20221215085713134" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215085940724.png" alt="image-20221215085940724" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215085958543.png" alt="image-20221215085958543" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215090220502.png" alt="image-20221215090220502" style="zoom:80%;" /></p></li><li><p>Haar Wabelet：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215090251352.png" alt="image-20221215090251352" style="zoom:80%;" /></p></li><li><p>Gaussian Mixtures</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215090431734.png" alt="image-20221215090431734" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215090531558.png" alt="image-20221215090531558" style="zoom:80%;" /></p></li></ol><h2 id="screen-space-ambient-oocclusionssao">12.3 Screen-Space AmbientOocclusion(SSAO)</h2><ol type="1"><li>软阴影</li><li>是后处理，天然计算动态计算</li><li>利用了标准z-buffer</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091058690.png" alt="image-20221215091058690" style="zoom:80%;" /></p><h3 id="ssao对反射公式的近似">12.3.1 SSAO对反射公式的近似</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091202715.png" alt="image-20221215091202715" style="zoom:80%;" /></p><h3 id="为什么要用屏幕空间">12.3.2 为什么要用屏幕空间</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091302748.png" alt="image-20221215091302748" style="zoom:80%;" /></p><h3 id="horizon-split-ao">12.3.3 Horizon Split AO</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091520998.png" alt="image-20221215091520998" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091527831.png" alt="image-20221215091527831" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091640866.png" alt="image-20221215091640866" style="zoom:80%;" /></p><h3 id="ssao-demo">12.3.4 SSAO Demo</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091725119.png" alt="image-20221215091725119" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机体系结构</title>
      <link href="/2022/09/14/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2022/09/14/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="chapter-1introduction">Chapter 1：Introduction</h1><h2 id="current-computer">1.1 Current computer</h2><ol type="1"><li><p>什么是<strong>CA</strong>(Computer Architecture)</p><ol type="1"><li><p>计算机架构是：<strong>选择</strong>和连接硬件组件以创建满足<strong>功能</strong>、<strong>性能</strong>、<strong>成本</strong>和<strong>功率</strong>目标的计算机的科学和艺术</p></li><li><p>它是计算机各个部分的需求和设计实现的<strong>蓝图</strong>和功能描述，主要关注中央处理单元（CPU）内部执行和访问内存地址的方式</p></li><li><p><strong>Tradeoff</strong>取舍</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220918160513641.png" alt="image-20220918160513641" style="zoom:80%;" /></p></li></ol></li><li><p><strong>Computer Architecture</strong>包含了三个主要的方面</p><ol type="1"><li><strong>ISA</strong>，七个维度如下：<ol type="1"><li>Class of ISA</li><li>Memory addressing</li><li>Addressing modes</li><li>Types and sizes of operands</li><li>Operations</li><li>Control flow instructions</li><li>Encoding an ISA</li></ol></li><li><strong>Microarchitecture</strong>：也叫Computerorganization，是对系统的较低层次、更具体和更详细的描述，涉及系统的组成部分如何互连以及它们如何互操作以实现ISA</li><li><strong>SystemDesign</strong>：包括计算系统中所有其他硬件组件的系统设计，如：逻辑实现</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220918161931403.png" alt="image-20220918161931403" style="zoom:80%;" /></p></li><li><p>处理器芯片的发展趋势</p><ol type="1"><li>工艺、主频遇到瓶颈后，开始通过增加核数的方式来提升性能；</li><li>芯片的物理尺寸有限制，不能无限制的增加；</li><li>ARM的众核横向扩展空间优势明显</li></ol></li><li><p><strong>SoC</strong>：System of Chips，芯片上的系统</p></li><li><p>CPU发展的三个挑战</p><ol type="1"><li><strong>ILP</strong>：指令集之间的并行</li><li><strong>Memory</strong>：内存到CPU之间的时间开销</li><li><strong>Power</strong>：功耗</li></ol></li><li><p>Bandwidth和Latency</p><ol type="1"><li><strong>Bandwidth带宽/throughput吞吐率</strong>：单位时间内能够完成的任务</li><li><strong>Latency延迟/responsetime反应时间</strong>：完成单个任务所需的时间</li><li>有时候不一定Latency降低，Bandwidth就提高了</li></ol></li><li><p>降低能耗：</p><ol type="1"><li>休眠：在没有core运行时就休眠</li><li>动态调压：降低电压/频率<ol type="1"><li>频率：开关晶体管的次数</li></ol></li><li>为典型的情况做设计</li><li>超频Overlocking</li><li>尽快将所有的任务完成Race-to-halt</li></ol></li><li><p>功耗</p><ol type="1"><li>动态功耗Dynamic power：由于开关晶体管导致的功耗<ol type="1"><li><spanclass="math inline">\(Power_{dynamic}=\frac{1}{2}*电容负载*电压^2\)</span></li><li><spanclass="math inline">\(Energy_{dynamic}=电容负载*电压^2\)</span></li></ol></li><li>静态功耗Static power：即便不导通，晶体管也会有电压泄露<ol type="1"><li><spanclass="math inline">\(Power_{dynamic}=静态电流*电压\)</span></li></ol></li><li>一般来说，电压降低10%，功率降低30%</li></ol></li></ol><h2 id="dependability需要计算">1.2 Dependability(需要计算)</h2><ol type="1"><li><p><strong>Availability</strong>：可用性，一定时间内有多长时间是可以正常工作的</p><ol type="1"><li>也是某个时间，不可用的几率</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926193308993.png" alt="image-20220926193308993" style="zoom:80%;" /></p></li><li><p><strong>Reliability</strong>：可靠性</p><ol type="1"><li>指一个人或系统在日常环境以及敌对或意外环境中执行和维护其功能的能力</li><li>IEEE将其定义为：“某个系统或组件在规定条件下，在规定时间内执行其所需功能的能力。”</li></ol></li><li><p><strong>Maintainability</strong>：可维护性</p></li><li><p><strong>Dependability</strong>：可信性，所提供服务的质量，以便可以合理地依赖此服务</p><ol type="1"><li><strong>MTTF</strong>：Mean Time ToFailure，从开始工作到失效的平均时间</li><li><strong>MTTR</strong>：Mean Time ToRepair，从失效到再次重新工作的平均时间</li><li><strong>MTBF</strong>：Mean Time BetweenFailure，两次失效之间的平均时间<ol type="1"><li><strong>MTBF = MTTF + MTTR</strong></li></ol></li><li><strong>FIT</strong>：Failure In Time，失败出现的机会<ol type="1"><li><strong>FIT = 1 / MTTF</strong></li></ol></li><li><strong>Module Availability</strong>：模块可用的时间<ol type="1"><li><strong><spanclass="math inline">\(\frac{MTTF}{MTTF+MTTR}=\frac{MTTF}{MTBF}\)</span></strong></li></ol></li></ol></li><li><p><strong>已知每个部分的MTTF，求整个系统的MTTF</strong>：</p><ol type="1"><li>求出各个部分的<strong>FIT<sub>i</sub> = 1 /MTTF<sub>i</sub></strong></li><li>求出整个系统的<strong>FIT =FIT<sub>1</sub>+FIT<sub>2</sub>+…+FIT<sub>n</sub></strong></li><li>求出整个系统的<strong>MTTF = 1 / FIT</strong></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926195354943.png" alt="image-20220926195354943" style="zoom:80%;" /></p></li><li><p>应对failure：<strong>Redundancy冗余</strong></p><ol type="1"><li><strong>Time Redundancy</strong>：重复做一遍</li><li><strong>ResourceRedundancy</strong>：用另一个部件替换坏掉的部件</li></ol></li></ol><h2 id="测量报告总结-性能需要计算">1.3 测量/报告/总结性能(需要计算)</h2><ol type="1"><li><p>比较两个计算机的性能</p><ol type="1"><li><strong>Execution time</strong>：计算的速度</li><li><strong>Throught</strong>：吞吐率</li><li><strong>MIPS</strong>：millions of instructions persecond每秒多少百万条指令</li><li>使用<strong>Benchmark</strong>进行测量</li></ol></li><li><p><strong>Wall-clockTime</strong>：一个程序从开始到结束所需时间(包含中间停顿所需的时间)</p></li><li><p><strong>CPU Time</strong>：一个程序实际在CPU上所需的时间</p><ol type="1"><li><strong>User Time</strong>：在user mode下使用的时间</li><li><strong>System Time</strong>：在operating system中使用的时间</li></ol></li><li><p><strong>MIPS</strong>：每秒钟计算的多少百万条指令</p><ol type="1"><li><strong>MIPS = benchmark中的指令数 / (benchmark运行的时间 *1,000,000)</strong></li><li>指令集中的每条指令，权重不一定一样，且已经包含在了<strong>benchmark</strong>中</li></ol></li><li><p><strong>Benchmark</strong>的种类</p><ol type="1"><li>Real applications：一个真实的程序</li><li>Modified (or scripted)applications：对程序进行一些修改，关注于其中的一些点</li><li>Kernels：程序的最主要的部分</li><li>Toy：只关注一些部分</li><li>Synthetic：创建来表示程序的某些方面</li></ol></li><li><p><strong>计算A比B快多少</strong>：<strong>A所需的时间 /B所需的时间，得到一个&gt;1的数字</strong></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926211157177.png" alt="image-20220926211157177" style="zoom:80%;" /></p></li></ol><h1 id="chapter-3memory-hierarchy">Chapter 3：Memory hierarchy</h1><h2 id="introduction">3.1 Introduction</h2><ol type="1"><li><p><strong>DRAM</strong>：Dynamic Random Access Memory</p><ol type="1"><li>高密度、低功耗、便宜、速度慢</li><li>不能放在CPU里面，因为有电容，有充放电(交流信号)，会影响CPU的计算</li><li>Dynamic动态：需要定期“刷新”，刷新时不能进行读写</li></ol></li><li><p><strong>SRAM</strong>：Static Random Access Memory</p><ol type="1"><li>低密度、高功率、昂贵、快速</li><li>唯一可以放在CPU里面的，因为没有电容</li><li>Static静态：内容将“永远”保存（直到失去动力）</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926213915597.png" alt="image-20220926213915597" style="zoom:80%;" /></p></li></ol><h2 id="cache">3.2 Cache</h2><h3 id="组相联计算">3.2.1 组相联计算</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207100226371.png" alt="image-20221207100226371" style="zoom:80%;" /></p><ol type="1"><li>4G：地址为32位</li><li>Cache 8K，Block-offset为5位：共2<sup>8</sup>个block</li><li>2-way组相联：index= 8-1=7位</li></ol><h3 id="block的替换策略">3.2.2 block的替换策略</h3><blockquote><p>只有在全关联/组关联的时候，会有替换策略</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207101045729.png" alt="image-20221207101045729" style="zoom:67%;" /></p></blockquote><ol type="1"><li><p>Random replacement：随机选择一个块替换</p><ol type="1"><li>随机数的硬件实现：<ol type="1"><li>设计一个专门的组件</li><li>用一根电线什么也不接，然后读取这个引脚的电压，理论上是白噪声，电压是随机分布的</li></ol></li></ol></li><li><p>LRU：选择最近最少访问的块替换</p><ol type="1"><li>伪LRU算法(体系不考察LRU)</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207101613432.png" alt="image-20221207101613432" style="zoom:80%;" /></p></li><li><p>FIFO：选择第一个进入cache的块替换</p></li></ol><h3 id="写策略">3.2.3 写策略</h3><ol type="1"><li><strong>write-through</strong>：同时修改cache和memory<ol type="1"><li>cache的控制位：valid bit</li><li>始终保证memory中的数据是最新的</li><li>通常会写入buffer，从而让cache不用等待memory</li></ol></li><li><strong>write-back</strong>：只修改cache，block被替换时写入memory<ol type="1"><li>cache的控制位：valid bit，dirty bit</li><li>带宽更小，因为重复访问时不需要写memory</li></ol></li></ol><p>选择<strong>write-through</strong>时，会有两种更新策略</p><ol type="1"><li><strong>write-stall</strong>：CPU等待write-through完成</li><li><strong>write-buffer</strong>：写入buffer，CPU不用等待write-through完成<ol type="1"><li>buffer的大小不是无限的，buffer满时需要stall</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207102327940.png" alt="image-20221207102327940" style="zoom:80%;" /></p><p><strong>miss</strong>时的写策略：(读策略肯定是将block放入cache)</p><ol type="1"><li><strong>write-allocate</strong>：将对应的block放入cache（通常是write-back对应的策略，write-through也可以用）</li><li><strong>write-around</strong>：直接写memory，不取对应的cache（通常是write-through对应的策略）</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207103235415.png" alt="image-20221207103235415" style="zoom:80%;" /></p><h3 id="数据和指令的cache是否分离">3.2.4 数据和指令的cache是否分离</h3><ol type="1"><li><strong>average miss rate = 指令占比% × 指令的miss rate + 数据占比%× 数据的miss rate</strong></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207104617121.png" alt="image-20221207104617121" style="zoom:80%;" /></p><h3 id="supervisor-cache-user-cache">3.2.5 Supervisor cache / Usercache</h3><ol type="1"><li>Supervisor 和 User所要访问的空间肯定有很大的区别，可以将它们两个分别赋予一个cache</li><li>指令cache</li><li>Supervisor / User Space Bit<ol type="1"><li>1：Supervisor access only</li><li>0：Supervisor / User access</li></ol></li></ol><h3 id="cache-performance-计算">3.2.6 Cache Performance(<strong>计算</strong>)</h3><h4 id="cpu-time">3.2.6.1 CPU Time</h4><ol type="1"><li><strong>CPU时间 = (CPU时钟周期 + Memory-Stall周期) ×一个周期的时间</strong></li><li><strong>Memory-Stall周期 = 指令数量IC × 平均每条指令访问内存的次数 ×Miss-Rate × Miss惩罚</strong></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207105355773.png" alt="image-20221207105355773" style="zoom:80%;" /></p><h4 id="amat平均内存访问时间">3.2.6.2 AMAT：平均内存访问时间</h4><ol type="1"><li><p><strong>AMAT = 命中时间 + Miss率 × Miss惩罚</strong></p><p>​ <strong>= (命中时间<sub>指令</sub> + Miss率<sub>指令</sub> ×Miss惩罚<sub>指令</sub>) + 命中时间<sub>数据</sub> +Miss率<sub>数据</sub> × Miss惩罚<sub>数据</sub>)</strong></p></li><li></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207105609421.png" alt="image-20221207105609421" style="zoom:80%;" /></p><h4 id="cache性能的测试指标">3.2.6.3 Cache性能的测试指标</h4><ol type="1"><li>Miss Rate<ol type="1"><li>与硬件的速度无关</li></ol></li><li>Average Memory Access Time<ol type="1"><li>是性能的间接表现</li></ol></li><li>CPU time</li></ol><h4 id="示例">3.2.6.4 示例</h4><ol type="1"><li><p>例1：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207110058159.png" alt="image-20221207110058159" style="zoom:80%;" /></p></li><li><p>例2：</p><ol type="1"><li><strong>1 + 0.5</strong>：每条指令在取指令的时候都可能miss(1) +这些指令中的50%是访问数据，也会miss(0.5)</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207110555774.png" alt="image-20221207110555774" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207110723683.png" alt="image-20221207110723683" style="zoom:80%;" /></p></li><li><p>例3：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207111108659.png" alt="image-20221207111108659" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207111432070.png" alt="image-20221207111432070" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207111233382.png" alt="image-20221207111233382" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207111245213.png" alt="image-20221207111245213" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207111301770.png" alt="image-20221207111301770" style="zoom:80%;" /></p></li><li><p>例4：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207111805960.png" alt="image-20221207111805960" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207111817521.png" alt="image-20221207111817521" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207111828369.png" alt="image-20221207111828369" style="zoom:80%;" /></p></li><li><p>例5：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207112106592.png" alt="image-20221207112106592" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207112118603.png" alt="image-20221207112118603" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207112125809.png" alt="image-20221207112125809" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207112134237.png" alt="image-20221207112134237" style="zoom:80%;" /></p></li></ol><h1 id="chapter-4how-to-improve-memory-performance">Chapter 4：How toimprove memory performance</h1><p><span class="math display">\[AMAT = hit\_time + miss\_rate × miss\_penalty\]</span></p><ol type="1"><li>降低hit time<ol type="1"><li>更小的一级cache，路径预测</li><li>避免地址转换，Trace cache</li></ol></li><li>增加bandwidth<ol type="1"><li>流水线cache，multibanked cache，non-blocking caches</li></ol></li><li>降低miss penalty<ol type="1"><li>多级cache</li><li>读miss优先于写miss</li><li>Critical word first，merging write buffers，victim caches</li></ol></li><li>降低miss rate<ol type="1"><li>更大的block size，更大的cache size，更高的关联度(2路组相联 =&gt;4路组相联)</li><li>编译器优化</li></ol></li><li>通过并行，降低miss_penalty 或 miss_rate<ol type="1"><li>硬件/编译器预取</li></ol></li></ol><h2 id="降低hit-time">4.1 降低hit time</h2><h3 id="小而简单的cache">4.1.1 小而简单的cache</h3><p>使用小型，直接映射cache</p><ol type="1"><li>实现缓存所需的硬件越少，通过硬件的关键路径就越短</li><li>无论是读还是写，直接映射都比组关联快</li><li>将cache安装进CPU芯片上，也可以提高访问速度</li></ol><blockquote><p>一级cache和关联度对性能的影响</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207194810330.png" alt="image-20221207194810330" style="zoom:80%;" /></p></blockquote><h3 id="way-prediction">4.1.2 Way Prediction</h3><ol type="1"><li>额外的位保存在缓存中以预测下一次缓存访问的方式或块</li><li>如果预测是正确的，指令缓存延迟是1个时钟周期</li><li>如果不是，它尝试另一个块，改变方式预测，并有一个额外的1个时钟周期的延迟</li><li>使用SPEC95进行仿真表明，集预测精度超过85%，因此预测方式节省了流水线阶段85%以上的指令读取</li></ol><h3 id="在cache上做索引时避免address-translation">4.1.3在cache上做索引时避免Address Translation</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207195323138.png" alt="image-20221207195323138" style="zoom:80%;" /></p><ol type="1"><li>每个进程都有一个页表</li><li>页表是内存中的一个巨大的数据结构</li><li>每次load/store/instruction_fetch都需要2次内存访问</li><li>解决方法：<ol type="1"><li>方法1：如果cache中的index+offset均在页表中的page-offset中，那么可以先将页表中的page-offset送入cache进行搜索，然后再将MMU翻译出的tag送入cache进行比对</li><li>方法2：cache中的内容可以是虚地址，但是换进程/进内核的时候需要清空cache</li><li>方法3：对页表建立一个cache</li></ol></li></ol><h4 id="tlbtranslation-lookat-buffer">4.1.3.1 TLB：Translation LookatBuffer</h4><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207200143731.png" alt="image-20221207200143731" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207200404505.png" alt="image-20221207200404505" style="zoom:80%;" /></p><ol type="1"><li>实际上就是将页表放入cache</li><li>TLB的大小通常是128~256个entry，通常使用全相联</li></ol><blockquote><p>Fast hits by Avoiding Address Translation</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207200515798.png" alt="image-20221207200515798" style="zoom:80%;" /></p></blockquote><h4 id="virtual-cache">4.1.3.2 Virtual Cache</h4><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207200644869.png" alt="image-20221207200644869" style="zoom:80%;" /></p><ol type="1"><li>cache中的内容可以是虚地址</li><li>但是换进程/进内核的时候需要清空cache，因为不同的进程使用的虚页号可能相同，但对应的物理地址是不同的地址</li></ol><h3 id="trace-caches">4.1.4 Trace Caches</h3><ol type="1"><li><p>找到一个动态序列的指令，序列包含采取分支加载到缓存块</p></li><li><p>由CPU而不是内存布局决定block的边界</p><ol type="1"><li>例如有一个循环跨越了两个block，可以将这个循环访问到的数据放到tracecache中的一个block</li></ol></li><li><p>需要复杂的地址映射机制</p></li><li><p>使用trace cache后，如果每个循环有N个指令</p><ol type="1"><li>没有 I-cache miss</li><li>没有 prediction miss</li><li>没有 packet breaks</li></ol></li><li><p>Trace：dynamic instruction sequence</p><ol type="1"><li>当指令(操作)退出管道时，将指令段打包到trace中，并将它们存储在tracecache中，包括分支指令</li><li>虽然分支指令可能会去不同的目标，但大多数情况下，下一个操作顺序将与上一个顺序相同(locality)</li></ol></li><li><p>优点：引入一个额外的cache，可以突破block的边界</p></li><li><p>Trace in CPU：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207202135321.png" alt="image-20221207202135321" style="zoom: 67%;" /></p></li><li><p>Instruction segment：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207202257646.png" alt="image-20221207202257646" style="zoom:67%;" /></p></li></ol><h2 id="增加bandwidth">4.2 增加bandwidth</h2><h3 id="pipelined-cache">4.2.1 Pipelined Cache</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207202853389.png" alt="image-20221207202853389" style="zoom:80%;" /></p><h3 id="nonblocking-caches">4.2.2 Nonblocking Caches</h3><ol type="1"><li>一个Nonblocking(Lookup-free) Caches，允许cache在处理readmiss时继续提供hit<ol type="1"><li>“Hit under miss” ， “Hit under multiple miss”</li></ol></li><li>复杂的cache甚至可能有多个未执行的miss(miss under miss)</li><li>Nonblocking与乱序执行相结合，可以让CPU在数据cachemiss后继续执行之后的指令<ol type="1"><li>之后的指令与当前指令不能有依赖关系</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207203839462.png" alt="image-20221207203839462" style="zoom:80%;" /></p><h3 id="multibanked-caches">4.2.3 Multibanked Caches</h3><ol type="1"><li>将cache分成几个独立的bank，它们可以同时被访问</li><li>可以让多条指令同时进cache，但是WB阶段还是要排队</li><li>需要编译器的支持，实现对内存的交错访问</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207203800593.png" alt="image-20221207203800593" style="zoom:80%;" /></p><h2 id="降低miss-penalty">4.3 降低miss penalty</h2><h3 id="multilevel-caches">4.3.1 Multilevel Caches</h3><ol type="1"><li>一级cache较小，二级cache较大</li><li>如果一级cache miss，二级cache hit，此时会降低miss penalty</li><li><strong>AMAT = Hit_Time<sub>L1</sub> + Miss_Rate<sub>L1</sub> ×(Hit_Time<sub>L2</sub> + Miss_Rate<sub>L2</sub> ×Miss_Penalty<sub>L2</sub>)</strong></li><li>两个概念：<ol type="1"><li><strong>Local miss rate</strong>：当前cache miss的次数 /访问当前cache的指令数</li><li><strong>Global miss rate</strong>：当前cache miss的次数 /总指令数</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207204044541.png" alt="image-20221207204044541" style="zoom:80%;" /></p><h3 id="critical-word-first-early-restart">4.3.2 Critical Word First&amp; Early Restart</h3><ol type="1"><li><p>不要等到加载满块后才重新启动CPU：</p><ol type="1"><li>Critical WordFirst：一旦发生miss，立即将请求的word从内存中取出并发送给CPU，让CPU继续执行，之后再慢慢填充block。也叫wrappedfetch / requested word first</li><li>Earlyrestart：还是从内存中取出一个block，但是一旦当请求的word到达，就把它发送给CPU，让CPU继续执行</li></ol></li><li><p>通常在block比较大的时候比较有用</p></li><li><p>示例：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207205240171.png" alt="image-20221207205240171" style="zoom:80%;" /></p></li></ol><h3 id="giving-priority-to-read-misses-over-writes">4.3.3 GivingPriority to Read Misses over Writes</h3><ol type="1"><li><p>读miss优先于写miss执行</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207205426405.png" alt="image-20221207205426405" style="zoom:80%;" /></p></li></ol><h3 id="merging-write-buffer">4.3.4 Merging write Buffer</h3><ol type="1"><li>用 multiword writes 替代 one word writes</li><li>在write-througe策略中：<ol type="1"><li>当写入失败时，如果缓冲区包含其他修改的块，则可以检查地址，以查看这个新数据的地址是否与有效的写入缓冲区项的地址匹配</li><li>如果是，则将新数据与该条目合并</li></ol></li><li>降低了同一个地址被多次写时的开销，也可以降低write bufferfull的次数</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207205924147.png" alt="image-20221207205924147" style="zoom:80%;" /></p><h3 id="victim-caches">4.3.5 Victim Caches</h3><ol type="1"><li>Victim Caches：是一个小的、全关联的cache</li><li>当cache中的块被替换时，可以将其先放入 Victim Caches<ol type="1"><li>如果下一次的miss仍在该块中，可以直接将其拿回来 / 直接修改 VictimCaches 中的块</li></ol></li></ol><h2 id="降低miss-rate">4.4 降低miss rate</h2><p>miss的来源：</p><ol type="1"><li>Compulsory：由于cache为空而导致的miss<ol type="1"><li>Misses in even an Infinite Cache</li></ol></li><li>Capacity：由于cache容量已满而导致的miss<ol type="1"><li>Misses in Fully Associative Size X Cache</li></ol></li><li>Conflict：由于当前block应当放到的cache中的位置已经有block而导致的miss<ol type="1"><li>Misses in N-way Associative, Size X Cache</li></ol></li><li>Coherence：由于cache一致性问题导致的miss</li></ol><blockquote><p>以下策略均在cache size不变的情况下讨论</p></blockquote><h3 id="更大的block-size">4.4.1 更大的Block Size</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207211509692.png" alt="image-20221207211509692" style="zoom:67%;" /></p><ol type="1"><li><p>优点：</p><ol type="1"><li>利用空间局部性降低了compulsory miss rate</li></ol></li><li><p>缺点：</p><ol type="1"><li>会提高miss penalty：因为每次miss需要取更多的数据</li><li>会提高conflict miss rate：因为cache中的块数降低了</li><li>会提高capacity missrate：因为小的cache中包含的块数变少了，就更容易满了</li></ol></li><li><p>权衡：</p><ol type="1"><li>尽可能最小化 miss rate 和 miss penalty</li><li>block size的选择取决于memory的延迟和带宽</li></ol></li><li><p>示例：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207211544779.png" alt="image-20221207211544779" style="zoom:80%;" /></p></li></ol><h3 id="更大的cache">4.4.2 更大的cache</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207211623532.png" alt="image-20221207211623532" style="zoom: 67%;" /></p><ol type="1"><li>thumb定律：2倍的size =&gt; miss rate降低25%</li><li>优点：<ol type="1"><li>降低了capacity miss rate</li></ol></li><li>缺点：<ol type="1"><li>会提高hit time</li><li>会提高cost</li><li>AMAT曲线是U型的</li></ol></li></ol><h3 id="更高的associativity">4.4.3 更高的Associativity</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207212125595.png" alt="image-20221207212125595" style="zoom:67%;" /></p><ol type="1"><li><p>2:1 rule of thumb：</p><ol type="1"><li>大小为N的直接映射的cache 与 大小为N/2的2-way组相联的cache 的missrate相同</li><li>8-way组相联在降低miss rate方面，与提高8倍的cache size效果相同</li></ol></li><li><p>优点：</p><ol type="1"><li>降低了conflict miss rate</li></ol></li><li><p>缺点：</p><ol type="1"><li>会提高hit time</li></ol></li><li><p>AMAT vs. Miss Rate</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221207212317832.png" alt="image-20221207212317832" style="zoom:80%;" /></p></li></ol><h3 id="编译器优化">4.4.4 编译器优化</h3><ol type="1"><li>指令<ol type="1"><li>重新排列内存中的程序，以减少冲突、未命中</li><li>分析冲突（使用他们开发的工具）</li></ol></li><li>数据<ol type="1"><li>合并数组Merging Arrays：通过单个数组提高空间局部性</li><li>循环交换Loop Interchange：修改循环访问数据的嵌套次序</li><li>循环融合Loop Fusion：将两个有相同循环、类似变量的循环合并为一个</li><li>阻塞Blocking：重复数据与向下移动整列或整行</li></ol></li></ol><h4 id="merging-arrays">4.4.4.1 Merging Arrays</h4><ol type="1"><li>将两个独立的数组合并到一起</li><li>这样使用的时候，可以在一个block中读取到</li><li>提高空间局部性</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214102128193.png" alt="image-20221214102128193" style="zoom:80%;" /></p><h4 id="loop-interchange">4.4.4.2 Loop Interchange</h4><ol type="1"><li>遍历矩阵时，修改遍历的顺序，保证内层循环在列上</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214102823363.png" alt="image-20221214102823363" style="zoom:80%;" /></p><h4 id="loop-fusion">4.4.4.3 Loop fusion</h4><ol type="1"><li>将两个独立的循环合并为一个</li><li>两个循环中使用了相同的变量，合并之后可以减少miss</li></ol><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214113143734.png"alt="image-20221214113143734" /><figcaption aria-hidden="true">image-20221214113143734</figcaption></figure><h4 id="blocking-optimized-matrix-multiplication">4.4.4.4 Blockingoptimized Matrix Multiplication</h4><ol type="1"><li>将大矩阵分为小矩阵，使得小矩阵的每一列可以存进cache中</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214122238575.png" alt="image-20221214122238575" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214122530845.png" alt="image-20221214122530845" style="zoom:80%;" /></p><h4 id="示例-1">4.4.4.5 示例</h4><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214123001322.png" alt="image-20221214123001322" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214123218445.png" alt="image-20221214123218445" style="zoom:80%;" /></p><h2 id="硬件相关知识">4.5 硬件相关知识</h2><h3 id="dram-sram">4.5.1 DRAM &amp; SRAM</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214123602777.png" alt="image-20221214123602777" style="zoom:80%;" /></p><p>SRAM：</p><ol type="1"><li>6个晶体管，表示1个bit</li><li>不需要刷新</li></ol><p>DRAM：</p><ol type="1"><li><p>1个电容，表示1个bit</p></li><li><p>电容越大，积累的电荷越多，自放电越慢，刷新的频率越低；但每一次写入的时间越长，单位面积存放的电容越少，存储容量越少</p></li><li><p>DRAM的周期性刷新，会产生一个大的交流信号，导致DRAM不能与CPU做在一起</p></li><li><p>通常会做成矩阵形式</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214124159094.png" alt="image-20221214124159094" style="zoom:80%;" /></p></li></ol><h3 id="sdramsynchronous-dram">4.5.2 SDRAM：Synchronous DRAM</h3><ol type="1"><li>在DRAM的基础上增加了clock，达到同步效果</li><li>可以有burst mode，让关键字先写</li></ol><h3 id="ddrdouble-data-rate">4.5.3 DDR：Double data rate</h3><ol type="1"><li>在上升沿和下降沿各做依次写</li></ol><h3 id="flash">4.5.4 flash</h3><ol type="1"><li>flash在读上比DRAM慢</li></ol><h1 id="习题">习题</h1><blockquote><p>选A：cost尽可能便宜，speed尽可能快</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214124711597.png"alt="image-20221214124711597" /><figcaption aria-hidden="true">image-20221214124711597</figcaption></figure><blockquote><p>选B：两级cache时，一级cache不需要很大</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214124755592.png" alt="image-20221214124755592"  /></p><blockquote><p>选A</p><ol type="1"><li>B：I/O不仅指与人的交互，还有CPU与内存的交互</li><li>C：I/O性能很重要</li></ol></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214125100925.png"alt="image-20221214125100925" /><figcaption aria-hidden="true">image-20221214125100925</figcaption></figure><blockquote><p>选C：直接映射时block conflict的概率最高</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214174637040.png"alt="image-20221214174637040" /><figcaption aria-hidden="true">image-20221214174637040</figcaption></figure><blockquote><p>选D：当进程工作时，并不是程序访问的所有内容都会被放到主存。如果电脑有<strong>虚拟内存</strong>，一些内容会仍停留在<strong>磁盘</strong>。地址空间会被划分成固定大小的block，称为<strong>pages</strong>。任何时候，每一个<strong>page</strong>会停留在主存或<strong>磁盘</strong>中。</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214174742777.png" alt="image-20221214174742777"  /></p><blockquote><p>选A：</p><ol type="1"><li>Write through 与 Write back 对比，对虚拟内存没有影响</li><li>full-associative map 与 其它映射方法 对比</li><li>TLB cache 与 no cache 对比</li><li>LRU replacement 与 其它替换策略 对比</li></ol></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214175356757.png"alt="image-20221214175356757" /><figcaption aria-hidden="true">image-20221214175356757</figcaption></figure><blockquote><p>选A</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214175804610.png"alt="image-20221214175804610" /><figcaption aria-hidden="true">image-20221214175804610</figcaption></figure><blockquote><p>选B：</p><ol type="1"><li>内存为256MB：28bit</li><li>4KB cache：2<sup>12</sup></li><li>block size 32B：5bit</li><li>2-way associative：1bit</li><li>index的长度：12-5-1=6bit</li></ol></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214175819564.png"alt="image-20221214175819564" /><figcaption aria-hidden="true">image-20221214175819564</figcaption></figure><blockquote><p>选B：把1个bank替换为多个banks，有哪些好处–提高了带宽</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214180148625.png"alt="image-20221214180148625" /><figcaption aria-hidden="true">image-20221214180148625</figcaption></figure><blockquote><p>选D：</p><ol type="1"><li>AMAT = Hit Time + Miss Rate * Miss Penalty</li><li>IC * CC * IPC</li><li>改进的程度 = Told / Tnew</li><li>CPU Time = IC * CC * CPI</li></ol></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214180335701.png"alt="image-20221214180335701" /><figcaption aria-hidden="true">image-20221214180335701</figcaption></figure><blockquote><p>选B：当程序运行的时候，使用的内存地址为<strong>逻辑地址</strong></p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214180527597.png"alt="image-20221214180527597" /><figcaption aria-hidden="true">image-20221214180527597</figcaption></figure><blockquote><p>选A：对于全关联来说，组关联的优点在于–tag更小，占用的芯片面积更少</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214180639388.png"alt="image-20221214180639388" /><figcaption aria-hidden="true">image-20221214180639388</figcaption></figure><blockquote><p>选D：假设cache中有M个block，每K个block分为一个组，则它是一个K-way组关联</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214180841186.png"alt="image-20221214180841186" /><figcaption aria-hidden="true">image-20221214180841186</figcaption></figure><blockquote><p>选A：增强了空间局部性--访问了x，x的附近也会被访问</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214181048556.png"alt="image-20221214181048556" /><figcaption aria-hidden="true">image-20221214181048556</figcaption></figure><blockquote><ol type="1"><li>cache大小：64KB--2<sup>16</sup></li><li>每一行大小：128B--2<sup>7</sup></li><li>4-way组关联：2<sup>2</sup></li></ol></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214181405480.png"alt="image-20221214181405480" /><figcaption aria-hidden="true">image-20221214181405480</figcaption></figure><blockquote><p>选B：如果block size增大了，missrate可能会降低，正确的表述为：在一定范围内，block size增大，missrate降低</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214181455496.png"alt="image-20221214181455496" /><figcaption aria-hidden="true">image-20221214181455496</figcaption></figure><blockquote><p>选D：二级cache的AMAT = Hit time<sub>L1</sub> + Miss rate<sub>L1</sub>* (Hit time<sub>L2</sub> + Miss rate<sub>L2</sub> * Misspenalty<sub>L2</sub>)</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214181556596.png"alt="image-20221214181556596" /><figcaption aria-hidden="true">image-20221214181556596</figcaption></figure><blockquote><p>在一个2-way组关联的cache中，假设cache有4个block，每个block有1word，每个set有2个block。对于指令<code>LOAD R1, 0x18</code>，这次访问<strong>miss</strong>了，<strong>不需要replacement</strong>，新的block会放在<strong>Set0 Block 0</strong></p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214181716064.png"alt="image-20221214181716064" /><figcaption aria-hidden="true">image-20221214181716064</figcaption></figure><blockquote><p>memory的表现为：</p><ol type="1"><li>送地址：4 clock</li><li>访问每个word：56 clock</li><li>传输数据：4 clock</li></ol><p>假设一个block有4 word，一个word有8 byte，那么miss penalty为<strong>(4+ 56 + 4) × 4 = 256</strong> clock，bandwidth为<strong><spanclass="math inline">\(\frac{4 *8}{256}=\frac{1}{8}\)</span></strong></p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214182030080.png"alt="image-20221214182030080" /><figcaption aria-hidden="true">image-20221214182030080</figcaption></figure><blockquote><ol type="1"><li>miss rate = 50%<ol type="1"><li>每次访问数组时，偶数次miss，然后装入2 word，从而奇数次hit</li></ol></li><li>AMAT = 8 + 50% * 70 = 43 ns</li><li>CPI计算：<ol type="1"><li>先用AMAT与频率换算成clock cycle</li><li>然后再计算平均每条指令需要的clock cycle</li></ol></li></ol></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214182448100.png"alt="image-20221214182448100" /><figcaption aria-hidden="true">image-20221214182448100</figcaption></figure><blockquote><p>假设cache的其它参数(容量、关联性、block大小)都不变，对于下列三个问题：</p><ol type="1"><li>blocksize翻倍，block数量降低，index变小，tag变大，但不是翻倍的关系</li><li>直接映射的cache，容量翻倍，block数量翻倍，会降低conflict miss</li><li>直接映射的cache，容量翻倍，强制miss的次数倍增</li></ol></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214182751718.png" alt="image-20221214182751718"  /></p><blockquote><p>什么是virtual indexed和physical tagged cache？</p><ol type="1"><li>virtualindexed：index部分在page-offset中，因此不需要经过MMU翻译</li><li>physical tagged：tag在page number中，需要经过MMU翻译</li></ol><p>通过index在cache中找对应的block 与 MMU翻译pagenumber并行进行，降低了时间消耗</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214183259142.png"alt="image-20221214183259142" /><figcaption aria-hidden="true">image-20221214183259142</figcaption></figure><blockquote><p>假设一个cache使用write-back策略，被交换的block有20%的几率为dirty，cachemiss的概率为10%。假设hit time为1 cycle，miss penalty为20cycle，写回dirty block为20 cycle</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214184127692.png"alt="image-20221214184127692" /><figcaption aria-hidden="true">image-20221214184127692</figcaption></figure><blockquote><p>第3问需要：图+语言描述</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214184359869.png"alt="image-20221214184359869" /><figcaption aria-hidden="true">image-20221214184359869</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214184439146.png"alt="image-20221214184439146" /><figcaption aria-hidden="true">image-20221214184439146</figcaption></figure><h1 id="chapter-5extend-2-supporting-m-coperation">Chapter 5：Extend 2Supporting M Coperation</h1><h2 id="之前的流水线cpu">5.1 之前的流水线CPU</h2><ol type="1"><li>ALU部分是一个门电路，只需要1个cycle就可以完成计算</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214185314918.png" alt="image-20221214185314918" style="zoom:80%;" /></p><h2 id="扩展流水线cpu支持多周期运算">5.2扩展流水线CPU，支持多周期运算</h2><h3 id="包含fp运算单元的5阶段流水线">5.2.1包含FP运算单元的5阶段流水线</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214185627169.png" alt="image-20221214185627169" style="zoom: 80%;" /></p><h3 id="两个指标latency和initiation-interval">5.2.2两个指标：Latency和Initiation interval</h3><ol type="1"><li><strong>Latency</strong>：指令开始到结束所需的时间</li><li><strong>Initiationinterval</strong>：指令开始后，再经过多长时间，可以重新开始</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214185908103.png" alt="image-20221214185908103" style="zoom:80%;" /></p><blockquote><p>流水级</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214190024718.png" alt="image-20221214190024718" style="zoom:80%;" /></p><blockquote><p>新的情况</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214190600531.png" alt="image-20221214190600531" style="zoom:80%;" /></p><h3 id="按序发射乱序完成">5.2.3 按序发射，乱序完成</h3><p>结构冲突：</p><ol type="1"><li><p>WB阶段要写寄存器，ID阶段要读寄存器：doublebump，上升沿写，下降沿读</p></li><li><p>IF和MEM都要访问存储器：将存储器分为指令存储器、数据存储器</p></li><li><p>同一个周期有多个WB</p><ol type="1"><li>多端口读写，但成本太高</li><li>阻塞stall<ol type="1"><li>在ID阶段stall：多增加一些判断逻辑，但是与原来的CPU是统一的</li></ol></li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214190709233.png" alt="image-20221214190709233" style="zoom:80%;" /></p><h3 id="如何解决write-port-conflict">5.2.4 如何解决write portconflict</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214191641942.png"alt="image-20221214191641942" /><figcaption aria-hidden="true">image-20221214191641942</figcaption></figure><h2 id="data-hazard的种类">5.3 data hazard的种类</h2><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221214192313856.png" alt="image-20221214192313856" style="zoom:80%;" /></p><ol type="1"><li><strong>RAW</strong> true dependence：A写Rx，B读Rx</li><li><strong>WAW</strong> output dependence：A写Rx，B写Rx</li><li><strong>WAR</strong> anti-dependence：A读Rx，B写Rx</li></ol><h3 id="raw依赖">5.3.1 RAW依赖</h3><ol type="1"><li>B在A写寄存器之前，就读了寄存器的值，可能导致B得到了一个旧的value</li><li>解决方法：forwarding</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215005704708.png" alt="image-20221215005704708" style="zoom:80%;" /></p><blockquote><p>填写技巧：</p><ol type="1"><li>一旦有一行stall，下面都是stall</li><li>stall一定出现在ID的后面</li><li>stall结束时，与上一行的stage之间一定有一个forward</li></ol></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215010356977.png" alt="image-20221215010356977" style="zoom:80%;" /></p><h3 id="waw依赖">5.3.2 WAW依赖</h3><ol type="1"><li>B在A写寄存器之前，就写了寄存器的值，可能导致A再次写寄存器，从而使寄存器保存了一个旧的value</li><li>解决方法：<ol type="1"><li>阻塞A</li><li>直接扔掉A这条指令</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215005805734.png" alt="image-20221215005805734" style="zoom:80%;" /></p><blockquote><ol type="1"><li>在WB之前检测是否需要stall</li><li>注意：整数指令，MEM=&gt;WB；浮点指令，没有MEM阶段</li></ol></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215010510079.png" alt="image-20221215010510079" style="zoom:80%;" /></p><h3 id="war依赖">5.3.3 WAR依赖</h3><ol type="1"><li>B在A读寄存器之前，就写了寄存器的值，可能导致A读寄存器时，读到了一个新的不正确的value</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215010048032.png" alt="image-20221215010048032" style="zoom:80%;" /></p><h3 id="在id阶段需要检查的内容">5.3.4 在ID阶段需要检查的内容</h3><ol type="1"><li>结构冲突<ol type="1"><li>除法、寄存器写端口</li></ol></li><li>RAW冲突<ol type="1"><li>如果有RAW冲突，则直接stall，直到<ol type="1"><li>源寄存器不再是其它指令的目标寄存器</li><li>源寄存器不再是EX/MEM阶段load指令的目标寄存器</li></ol></li></ol></li><li>WAW冲突<ol type="1"><li>如果有WAW冲突，则直接stall / cancel</li></ol></li></ol><h1 id="chpater-7dynamic-schedule--scoreboard">Chpater 7：DynamicSchedule--Scoreboard</h1><p>统计数据表明，每5条指令，大概率就有一条跳转指令</p><h2 id="指令级并行ilp">7.1 指令级并行ILP</h2><h3 id="指令级并行的目标最小化cpi">7.1.1指令级并行的目标：最小化CPI</h3><p>CPI = 理想CPI + 结构冲突导致的stall + 数据冲突导致的stall +控制冲突导致的stall</p><ol type="1"><li>理想CPI：实现某个算法的最优表现</li><li>结构冲突：HW不能支持这种指令的组合</li><li>数据冲突：当前指令依赖于之前指令的结果</li><li>控制冲突：由获取指令和决定控制流更改(分支和跳转)之间的延迟引起冲突</li></ol><h3 id="如何实现ilp">7.1.2 如何实现ILP</h3><ol type="1"><li>基于硬件的动态解决方案</li><li>基于编译优化的静态解决方案</li></ol><h3 id="降低stall的方法">7.1.3 降低stall的方法</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215012529320.png" alt="image-20221215012529320" style="zoom:80%;" /></p><h3 id="instruction-level-parallelism-ilp">7.1.4 Instruction-LevelParallelism ILP</h3><ol type="1"><li>为了获得实质性的性能增强，我们必须跨多个基本块利用ILP</li><li>最简单：循环级并行性，利用循环迭代之间的并行性<ol type="1"><li>使用<code>Vector</code>(<code>SIMD</code>) &amp;<code>GPU</code></li><li><code>Vector</code>：如将多个寄存器与多个寄存器相加，结果保存到多个寄存器中–即同时处理多个寄存器</li><li>如果不是<code>Vector</code>，则通过分支预测进行动态ILP，或通过编译器展开循环进行静态ILP</li></ol></li></ol><h2 id="数据依赖">7.2 数据依赖</h2><h3 id="真实数据依赖raw-写后读">7.2.1 真实数据依赖：RAW 写后读</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215013129216.png" alt="image-20221215013129216" style="zoom:80%;" /></p><h3 id="命名依赖">7.2.2 命名依赖</h3><ol type="1"><li><p>命名依赖：后面要写的寄存器，出现在了前面的源/目的寄存器中</p><ol type="1"><li>可以通过寄存器重命名解决<ol type="1"><li>编译器解决：更容易知道重命名到什么时候</li><li>硬件解决：需要考虑重命名到什么时候、CPU是否支持多个重命名同时存在</li></ol></li></ol></li><li><p>WAR 读后写--anti-dependence</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215013200891.png" alt="image-20221215013200891" style="zoom:80%;" /></p></li><li><p>WAW 写后写–output dependence</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215013602548.png" alt="image-20221215013602548" style="zoom:80%;" /></p></li></ol><h3 id="控制依赖">7.2.3 控制依赖</h3><ol type="1"><li>一般情况下，CPU的指令重排只在两个跳转之间进行，不会跨越跳转</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224121945082.png" alt="image-20221224121945082" style="zoom:80%;" /></p><blockquote><p>Example1：由于beq的存在，or指令可能与add有依赖，也可能与sub有依赖</p><p>Example 2：x4在skip后没有使用，sub指令可能可以被移动到beq之前</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224122000258.png" alt="image-20221224122000258" style="zoom:80%;" /></p></blockquote><h3 id="异常">7.2.4 异常</h3><ol type="1"><li>指令重排不能影响异常的精确性</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224122519160.png" alt="image-20221224122519160" style="zoom:80%;" /></p><h2 id="ilp软件方法--静态调度">7.3 ILP：软件方法--静态调度</h2><h3 id="相关技术">7.3.1 相关技术</h3><ol type="1"><li>实现ILP的基本编译器技术<ol type="1"><li>循环展开</li></ol></li><li>静态分支预测</li><li>静态多重问题：VLIW</li><li>实现ILP的高级编译器支持<ol type="1"><li>软件流水线</li><li>全局代码调度</li></ol></li><li>在编译时实现更高ILP的硬件支持<ol type="1"><li>硬件为编译器提供更多指令级</li><li>条件或谓词指令</li><li>具有硬件支持的编译器推测</li></ol></li></ol><h3 id="示例-2">7.3.2 示例</h3><blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224124330255.png" alt="image-20221224124330255" style="zoom:80%;" /></p><p>指令没有重排：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224124339110.png" alt="image-20221224124339110" style="zoom:80%;" /></p><p>指令重排后：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224124538331.png" alt="image-20221224124538331" style="zoom:80%;" /></p></blockquote><h3 id="跳转指令的delay-slot">7.3.3 跳转指令的delay slot</h3><ol type="1"><li>跳转指令后面的一条指令，不论跳转是否成功，都可以执行完成</li><li>可以把一条指令(不论跳还是不跳都要执行)放在branch的后面，就可以充分利用branch的delayslot</li><li>一般是从跳转前拿一条指令放在后面，这条指令的执行不影响跳转的结果</li></ol><h2 id="ilp硬件方法--动态调度">7.4 ILP：硬件方法--动态调度</h2><h3 id="为什么需要动态调度">7.4.1 为什么需要动态调度</h3><blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224125602940.png" alt="image-20221224125602940" style="zoom:80%;" /></p></blockquote><ol type="1"><li>某个被stall的指令，与之前的指令没有依赖关系，但由于之前的指令stall了，它也不得不stall</li><li>可以通过动态调度，让后面的指令先执行</li><li>也成为指令重排</li></ol><h3 id="基本思路">7.4.2 基本思路</h3><ol type="1"><li>将指令的ID阶段分为两个阶段<ol type="1"><li>Issue(发射)：译码指令，判断是否有结构冲突</li><li>ReadOperands：等待，直到没有数据冲突，然后读寄存器，这里要有能够支持等待的存储单元</li></ol></li></ol><h2 id="scoreboard-计分板">7.5 Scoreboard 计分板</h2><ol type="1"><li>当资源充足且无数据依赖性时，允许指令无序执行</li><li>顺序issue</li><li>乱序EXE</li><li>乱序completion</li></ol><h3 id="基本结构">7.5.1 基本结构</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224131058716.png" alt="image-20221224131058716" style="zoom: 67%;" /></p><h3 id="计分板的流水级">7.5.2 计分板的流水级</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224131346039.png" alt="image-20221224131346039" style="zoom: 80%;" /></p><ol type="1"><li>发出（Issue）：在以下情况下发出指令<ol type="1"><li>功能单元可用</li><li>没有其他活动指令具有相同的目标寄存器。</li><li>没有<strong>structural</strong>冲突、<strong>WAW</strong>冲突</li></ol></li><li>读取操作数（RO）<ol type="1"><li>两个操作数都可用，才能进入EX阶段，否则一直在RO阶段</li><li>这意味着以前发出但未完成的指令都没有将操作数作为目标</li><li>这可动态解决<strong>RAW</strong>冲突</li></ol></li><li>执行（EX）<ol type="1"><li>完成后通知记分板，以便重新使用功能单元</li></ol></li><li>写入结果（WB）<ol type="1"><li>记分板检查<strong>WAR</strong>冲突，如果有则stall</li></ol></li></ol><h3 id="计分板算法">7.5.3 计分板算法</h3><ol type="1"><li><p>记分板全权负责指令发布和执行</p><ol type="1"><li>创建相关性记录</li><li>决定何时获取操作数</li><li>决定何时开始执行</li><li>决定何时可以将结果写入寄存器</li></ol></li><li><p>三种数据结构</p><ol type="1"><li><p><strong>Instruction status</strong></p><ol type="1"><li>指令在四个步骤中的哪一个</li></ol></li><li><p><strong>Functional unit status</strong></p><table><thead><tr><th style="text-align: center;">状态</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr><td style="text-align: center;">Busy</td><td style="text-align: center;">表示当前单元是否被占用</td></tr><tr><td style="text-align: center;">Op</td><td style="text-align: center;">当前单元正在执行的指令(如add orsubtract)</td></tr><tr><td style="text-align: center;">Fi</td><td style="text-align: center;">目标寄存器</td></tr><tr><td style="text-align: center;">Fj, Fk</td><td style="text-align: center;">源寄存器</td></tr><tr><td style="text-align: center;">Qj, Qk</td><td style="text-align: center;">生成源寄存器Fj, Fk的功能单元</td></tr><tr><td style="text-align: center;">Rj, Rk</td><td style="text-align: center;">判断源寄存器Fj,Fk是否已经ready；当操作数被读取之后，设为NO</td></tr></tbody></table></li><li><p><strong>Register result status</strong></p><ol type="1"><li>哪个功能单元将写入该寄存器</li></ol></li></ol></li></ol><h3 id="记分牌算法的具体运行方式">7.5.4 记分牌算法的具体运行方式</h3><p>指令的等待：Function Unit，每个Function Unit最多有1条指令等待执行</p><ol type="1"><li><strong>Issue</strong>：<ol type="1"><li>如果对应功能部件被占用，则<strong>stall</strong>：防止结构冲突</li><li>计算完成后，更新记分牌<ol type="1"><li><code>Function Unit Status</code>：<ol type="1"><li><code>Busy</code>：设置为<code>Yes</code></li><li><code>Op</code>：设置为对应的操作</li><li><code>Fi</code>：设置为目标寄存器</li><li><code>Fj,Fk</code>：设置为源寄存器</li><li><code>Qj,Qk</code>：如果源寄存器被占用，则设置为对应的功能部件</li><li><code>Rj,Rk</code>：如果源寄存器未被占用，则为<code>Yes</code>；否则为<code>No</code></li></ol></li><li><code>Register Result Statue</code>：<ol type="1"><li><code>Fi</code>对应的位置：设置为当前部件</li></ol></li></ol></li></ol></li><li><strong>RO</strong>：<ol type="1"><li>如果<code>Rj,Rk</code>不全为<code>Yes</code>，则<strong>stall</strong>：防止RAW冲突</li><li>读取源寄存器</li></ol></li><li><strong>EXE</strong>：<ol type="1"><li>功能部件计算结果</li><li>计算完成后，更新记分牌<ol type="1"><li><code>Function Unit Status</code>：<ol type="1"><li><code>Rj,Rk</code>：设置为<code>No</code>，表示释放对应的寄存器</li></ol></li></ol></li></ol></li><li><strong>WB</strong>：<ol type="1"><li>将计算结果写入目标寄存器</li><li>计算完成后，更新记分牌：<ol type="1"><li><code>Function Unit Status</code>：<ol type="1"><li>清空当前功能部件</li><li>如果其它功能部件中，<code>Qj,Qk</code>对应的部件为当前部件，则将其清除，并将<code>Rj,Rk</code>设置为<code>Yes</code></li></ol></li><li><code>Register Result Statue</code>：<ol type="1"><li>清空<code>Fi</code>对应的位置</li></ol></li></ol></li></ol></li></ol><h3 id="示例-3">7.5.5 示例</h3><blockquote><p>详见视频讲解</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224132827051.png"alt="image-20221224132827051" /><figcaption aria-hidden="true">image-20221224132827051</figcaption></figure><h3 id="scoreboard的局限性">7.5.6 Scoreboard的局限性</h3><ol type="1"><li>如果后面的每一条指令都依赖前面的指令，则Scoreboard用处不大</li><li>issue queue的大小问题：<ol type="1"><li>window：CPU有多少指令可以处于等待状态，一般不能超出一个branch的范围</li></ol></li><li>放弃了功能部件的流水性</li><li>存在WAR和WAW冲突，但Scoreboard选择stall解决</li></ol><h2 id="寄存器重命名">7.6 寄存器重命名</h2><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224143115212.png" alt="image-20221224143115212" style="zoom:80%;" /></p><ol type="1"><li>任何指令的写，都不写入寄存器，而是写入换名寄存器中</li><li>之后对该寄存器的读，直接读取换名寄存器</li></ol><h2 id="scoreboard-vs.-tomasulo">7.7 Scoreboard vs. Tomasulo</h2><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224151613454.png" alt="image-20221224151613454" style="zoom:80%;" /></p><h1 id="chapter-8dynamic-schedule--tomasulo">Chapter 8：DynamicSchedule--Tomasulo</h1><h2 id="tomasulo算法">8.1 Tomasulo算法</h2><h3 id="基础思想">8.1.1 基础思想</h3><ol type="1"><li>指令&amp;缓存 被分布在每个功能单元(FU，Function Units)中<ol type="1"><li><strong>FU buffer</strong>被称作<strong>保留站(RS，reservationstations)</strong>，具有挂起的操作数</li></ol></li><li>指令中的寄存器被替换为 <strong>具体的值</strong> /<strong>指向保留站的指针</strong>，被称为<code>register renaming</code><ol type="1"><li>避免了WAR、WAW冲突</li><li>保留站比寄存器多，因此可以进行一些编译器不能进行的优化</li></ol></li><li>当指令要进行计算时，操作数 从保留站中通过<strong>CDB(Common DataBus)</strong>广播获取，而不是寄存器<ol type="1"><li>寄存器进保留站只有一个时刻：指令进入保留站的时候</li></ol></li><li>Load、Store也被视为FU，也拥有RS</li><li>整数指令可以穿过branch使用，如循环中下一次的指令可以直接使用上一次计算出来的值</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224153655313.png" alt="image-20221224153655313" style="zoom:80%;" /></p><h3 id="保留站的内容">8.1.2 保留站的内容</h3><table><thead><tr><th style="text-align: center;">状态</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr><td style="text-align: center;">Busy</td><td style="text-align: center;">表示当前行是否有指令</td></tr><tr><td style="text-align: center;">Op</td><td style="text-align: center;">当前行的指令(如add or subtract)</td></tr><tr><td style="text-align: center;">Vj, Vk</td><td style="text-align: center;">源寄存器能读取到的数据</td></tr><tr><td style="text-align: center;">Qj, Qk</td><td style="text-align: center;">尚不能读取到的数据将由哪条指令算出</td></tr><tr><td style="text-align: center;">A</td><tdstyle="text-align: center;">指令的地址，用于存放立即数和计算得到的地址数据</td></tr></tbody></table><h3 id="三个阶段">8.1.3 三个阶段</h3><p>Tomasulo算法的调度分为三个步骤：<strong>发射</strong>、<strong>执行</strong>、<strong>写回</strong></p><ol type="1"><li>发射<strong>Issue</strong>：<ol type="1"><li><strong>Tomasulo算法是顺序发射的</strong>，即指令按照程序中的顺序一条接一条被发射到保留站</li><li><strong>判断能否发射的唯一标准是指令对应通路的保留站是否有空余位置</strong>，只要保留站有空余，就可以把指令发射到保留站中</li><li>周期结束时会更新保留站和寄存器结果状态表，如果指令有可以读取的数据，就会立刻拷贝到保留站中</li><li>寄存器结果状态表中总是存有最新的值，即如果后序指令的目的寄存器和前序指令的目的寄存器重合，那就只保留后序指令的写信息</li></ol></li><li>执行<strong>EXE</strong>：<ol type="1"><li>指令通过拷贝数据和监听CDB获得源数据，然后开始执行</li><li>执行可能是多周期的，在执行过程中不改变处理器状态</li></ol></li><li>写回<strong>WB</strong>：<ol type="1"><li>指令在写回阶段通过CDB总线将数据直通到寄存器堆和各个保留站</li><li>周期结束时，根据寄存器结果状态表来更新寄存器堆，并且清除保留站和寄存器结果状态表的信息</li></ol></li></ol><h3 id="data-path">8.1.4 Data Path</h3><ol type="1"><li>Normal Data Bus：数据 + 目标地址</li><li>Common Data Bus：数据 + 源地址<ol type="1"><li>64-bit数据 + 4-bit 功能单元的源地址</li><li>如果与期望的功能单元地址匹配，则写入</li></ol></li></ol><h3 id="具体运行方式">8.1.5 具体运行方式</h3><ol type="1"><li><strong>Issue</strong>：<ol type="1"><li>如果对应功能部件被占用，则<strong>stall</strong>：防止结构冲突</li><li>计算完成后，更新保留站<ol type="1"><li><code>Reservation Station</code>：<ol type="1"><li><code>Busy</code>：设置为<code>Yes</code></li><li><code>Op</code>：设置为对应的操作</li><li><code>Vj,Vk</code>：设置为读取到的源寄存器的值</li><li><code>Qj,Qk</code>：如果源寄存器被占用，则设置为对应的功能部件</li><li><code>A</code>：如果指令为LD/ST，则设置为计算出的目标地址</li></ol></li><li><code>Register Result Statue</code>：<ol type="1"><li>目标寄存器对应的位置：设置为当前部件</li></ol></li></ol></li></ol></li><li><strong>EXE</strong>：<ol type="1"><li>如果<code>Vj,Vk</code>没有都被填入，则<strong>stall</strong>：防止RAW冲突</li><li>功能部件计算结果</li></ol></li><li><strong>WB</strong>：<ol type="1"><li>将计算出的结果放入<code>CDB</code>中进行广播，并写入寄存器堆</li><li>计算完成后，更新保留站<ol type="1"><li><code>Reservation Station</code>：<ol type="1"><li>清空当前功能部件</li><li>如果其它功能部件中，<code>Qj,Qk</code>对应的部件为当前部件，则读取CDB中的值，放入对应的<code>Vj,Vk</code>中</li></ol></li><li><code>Register Result Statue</code>：<ol type="1"><li>清空<code>Fi</code>对应的位置</li></ol></li></ol></li></ol></li></ol><h3 id="示例-4">8.1.6 示例</h3><blockquote><p>具体见视频</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224160451110.png" alt="image-20221224160451110" style="zoom:80%;" /></p><h3 id="优缺点">8.1.7 优缺点</h3><blockquote><p>Tomasulo算法记录寄存器的值，Scoreboard算法只记录寄存器的编号</p></blockquote><p>优点：</p><ol type="1"><li>将hazard detection logic分散开<ol type="1"><li>每个功能单元都有一个保留站，使用CDB进行广播</li><li>如果多条指令等待同一个结果，并且每条指令都有其它的操作数，当目标结果在CDB中被广播时，这些指令可以同时释放</li></ol></li><li>可以消除WAW、WAR冲突</li></ol><p>缺点：</p><ol type="1"><li>需要实现一个高速CDB</li><li>每一个cycle只能有一个功能部件完成，因为CDB上同时只有一个数据</li></ol><h3 id="tomasolo算法的指令可以跨越循环的前后轮">8.1.8Tomasolo算法的指令可以跨越循环的前后轮</h3><ol type="1"><li>Tomasolo算法可以实现事实上的动态展开循环，每一轮都可以正常进行<ol type="1"><li>要求branch为预测跳转</li></ol></li><li>寄存器重命名<ol type="1"><li>多次迭代使用不同的物理目标</li></ol></li><li>寄存器重命名<ol type="1"><li>多次迭代使用不同的寄存器物理目的地（动态循环展开）</li></ol></li><li>保留站<ol type="1"><li>允许发出指令以推进过去的整数控制流操作</li><li>还缓冲寄存器的旧值—完全避免了我们在记分板上看到的WAR暂停</li></ol></li><li>其他观点：Tomasulo动态构建数据流依赖图</li></ol><blockquote><p>示例：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224163547124.png" alt="image-20221224163547124" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224164347175.png" alt="image-20221224164347175" style="zoom:80%;" /></p><ol type="1"><li>注意，这里直接将Load2写入了F0对应的位置<ol type="1"><li>因为需要Load1结果的指令MULTD此时等待的是Load1的值，而不是F0的值</li></ol></li></ol></blockquote><h3 id="精确中断">8.1.9 精确中断</h3><ol type="1"><li>Tomasulo算法的特点：<ol type="1"><li>顺序issue</li><li>乱序execution</li><li>乱序completion</li></ol></li><li>需要修复乱序完成的操作，从而能在指令流中找到精确的断点<ol type="1"><li>Speculation</li><li>Reorder buffer</li></ol></li></ol><h2 id="scoreboard算法通过寄存器重命名避免warwaw等待">8.2Scoreboard算法：通过寄存器重命名避免WAR、WAW等待</h2><h3 id="scoreboard的流水级">8.2.1 Scoreboard的流水级</h3><ol type="1"><li><strong>Issue</strong>：在以下情况下发出指令<ol type="1"><li>功能单元可用</li><li>没有其他活动指令具有相同的目标寄存器。</li><li>解决了：<strong>structural</strong>冲突、<strong>WAW</strong>冲突</li></ol></li><li><strong>Read Operands</strong>（RD）<ol type="1"><li>两个操作数都可用，才能进入EX阶段，否则一直在RO阶段</li><li>这意味着以前发出但未完成的指令都没有将操作数作为目标</li><li>解决了：<strong>RAW</strong>冲突</li></ol></li><li><strong>Execution</strong>（EX）<ol type="1"><li>完成后通知记分板，以便重新使用功能单元</li></ol></li><li><strong>Write Result</strong>（WB）<ol type="1"><li>记分板检查<strong>WAR</strong>冲突，如果有则stall</li></ol></li></ol><h3 id="scoreboard算法">8.2.2 Scoreboard算法</h3><ol type="1"><li><p>记分板全权负责指令发布和执行</p><ol type="1"><li>创建相关性记录</li><li>决定何时获取操作数</li><li>决定何时开始执行</li><li>决定何时可以将结果写入寄存器</li></ol></li><li><p>三种数据结构</p><ol type="1"><li><p><strong>Instruction status</strong></p><ol type="1"><li>指令在四个步骤中的哪一个</li></ol></li><li><p><strong>Functional unit status</strong></p><ol type="1"><li>buzy，op，Fi，Fj，Fk，Qj，Qk，Rj，Rk</li></ol></li><li><p><strong>Register result status</strong></p><ol type="1"><li>哪个功能单元将写入该寄存器</li></ol></li></ol></li></ol><h3 id="explicit-renaming-显式寄存器重命名">8.2.3 Explicit Renaming显式寄存器重命名</h3><h4 id="前提">8.2.3.1 前提</h4><ol type="1"><li>物理寄存器 &gt; 逻辑寄存器</li></ol><h4 id="核心思路">8.2.3.2 核心思路</h4><p>对每一条需要写寄存器的指令，分配一个新的物理目标寄存器</p><ol type="1"><li>与编译器优化方式(SSA, Static SingleAssignment)类似，但是是硬件实现</li><li>消除了WAR和WAW冲突</li><li>与Tomasulo类似，更加容易支持全乱序完成</li><li>类似于基于硬件的动态编译</li></ol><h4 id="实现机制">8.2.3.3 实现机制</h4><p>维护一个<strong>translation table</strong></p><ol type="1"><li>映射：ISA寄存器 =&gt; 物理寄存器</li><li>写寄存器时：从freelist中得到一个新的寄存器，替换原有项</li><li>释放物理寄存器的时机：所有使用该物理寄存器的指令均已执行完成<ol type="1"><li>由于第二次写同一个逻辑寄存器时，该逻辑寄存器会被分配另一个物理寄存器</li><li>因此，只有两次写同一个逻辑寄存器之间的指令，有可能使用同一个物理寄存器</li></ol></li></ol><h4 id="优点">8.2.3.4 优点</h4><ol type="1"><li>将<strong>renaming</strong>与<strong>scheduling</strong>分离<ol type="1"><li>流水线可以更贴近于标准MIPS流水线，只是每个周期可能会发射多条指令</li><li>否则的话，流水线更类似于Tomasulo或Scoreboard</li><li>可以使用标准的<code>forwarding</code>、<code>bypassing</code></li></ol></li><li>允许数据从单个寄存器组中读取<ol type="1"><li>不需要从<code>reservation stations</code>或<code>reorder buffer</code>中获取数据</li><li>对平衡流水线来说，很重要</li></ol></li><li>是另一种获取<strong>精确断点</strong>的方式：<ol type="1"><li>要获得精确的断点，所有需要“撤消”的操作就是撤消表映射</li><li>在<code>reorder buffer</code>和<code>future file</code>之间提供有趣的混合<ol type="1"><li>结果立即写回寄存器文件</li><li>寄存器名称按程序顺序“释放”（通过ROB）</li></ol></li></ol></li></ol><h4 id="需要的支持">8.2.3.5 需要的支持</h4><ol type="1"><li>快速访问翻译表</li><li>一种物理寄存器文件，其寄存器数超过ISA指定的寄存器数</li><li>能够找出哪些物理寄存器是free的<ol type="1"><li>没有free的寄存器 ⇒ issue会被stall</li></ol></li><li>寄存器重命名不需要保留站，然而：<ol type="1"><li>许多现代体系结构使用<code>explicit register renaming</code> +<code>Tomasulo-like reservation stations</code>来控制执行流程</li></ol></li><li>两个问题：<ol type="1"><li>如何管理<code>free list</code>？</li><li>显示寄存器重命名 如何与 精确中断相结合？</li></ol></li></ol><h4 id="示例-5">8.2.3.6 示例</h4><blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224183942183.png" alt="image-20221224183942183" style="zoom:80%;" /></p><ol type="1"><li>物理寄存器表 &gt; ISA寄存器表</li><li>在<code>issue</code>阶段，每条指令从<code>freelist</code>中申请一个寄存器，作为自己的目的寄存器</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224184043723.png" alt="image-20221224184043723" style="zoom:80%;" /></p><ol type="1"><li>注意物理寄存器<code>P0</code>在这次load之后已经<code>dead</code><ol type="1"><li>当我们完成load操作后，我们释放该寄存器</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224184301168.png" alt="image-20221224184301168" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224184324219.png" alt="image-20221224184324219" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224184354451.png" alt="image-20221224184354451" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224184405761.png" alt="image-20221224184405761" style="zoom:80%;" /></p></blockquote><h4 id="在scoreboard中使用显式重命名">8.2.3.7在Scoreboard中使用显式重命名</h4><ol type="1"><li>实现一个RenameTable：告诉Scoreboard，指令里面的哪个寄存器被换成哪个寄存器了</li><li>Rename Table后面是一个更大的寄存器表，该表不对ISA公开，只能由RenameTable使用</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224184559742.png" alt="image-20221224184559742" style="zoom:80%;" /></p><h4 id="显式重命名scoreboard的四个阶段">8.2.3.8显式重命名Scoreboard的四个阶段</h4><ol type="1"><li><strong>Issue</strong>：指令译码、检查是否有结构冲突、<strong>为目标寄存器申请新的物理寄存器</strong><ol type="1"><li>指令按序issue</li><li>如果没有物理寄存器，则stall</li><li>如果有结构冲突，则stall</li></ol></li><li><strong>Read Operands</strong>：直到没有冲突的时候，读取操作数<ol type="1"><li>解决了RAW冲突，因为我们等待指令写回数据</li></ol></li><li><strong>Execution</strong>：计算</li><li><strong>Write Result</strong>：结束计算</li><li>在这个过程中，没有检查WAR、WAW冲突</li></ol><blockquote><p>示例见视频</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224202935623.png" alt="image-20221224202935623" style="zoom:80%;" /></p></blockquote><h1 id="chapter-9-branch-predictor-speculation">Chapter 9 ：BranchPredictor &amp; Speculation</h1><h2 id="control-hazard">9.1 Control Hazard</h2><ol type="1"><li><strong>Flushing</strong>：<ol type="1"><li>每次遇到跳转，直接stall，直到跳转指令完成</li></ol></li><li><strong>Predict-not-taken</strong>：<ol type="1"><li>直接读入跳转指令的下一条指令</li><li>如果发现跳转指令为跳转，则清空流水线，此时浪费了1个周期</li></ol></li><li><strong>Predict-taken</strong>：<ol type="1"><li>读入如果跳转时的下一条指令</li><li>如果发现跳转指令为不跳转，则清空流水线，此时浪费了1个周期</li></ol></li><li><strong>Delayed Branch</strong></li></ol><h2 id="动态硬件预测">9.2 动态硬件预测</h2><blockquote><p>动态硬件预测，只有当前跳转指令被反复执行到的前提下，才有意义</p><p>预测是基于数据的预测，因此只能预测下一次遇到当前地址的跳转指令时，是否跳转</p></blockquote><h3 id="bit-branch-prediction-buffer">9.2.1 1-bit Branch-PredictionBuffer</h3><ol type="1"><li>Performance = ƒ(accuracy, cost of misprediction)</li><li><strong>BHT</strong>，<code>Branch History Table</code>：<ol type="1"><li><code>index</code>：PC地址的低位</li><li><code>value</code>：1位，记录上一次是否跳转</li></ol></li><li>问题：<ol type="1"><li>在一个循环中，1-bitBHT会导致2次misprediction：进入循环、退出循环</li><li>accurancy：(n-2)/n</li></ol></li></ol><h3 id="bit-branch-prediction-buffer-1">9.2.2 2-bit Branch-PredictionBuffer</h3><blockquote><p>策略1：初始为Taken，发生2次not-taken后，才预测not-taken</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224204931564.png" alt="image-20221224204931564" style="zoom:80%;" /></p><blockquote><p>策略2：进入临时状态后，如果是taken，就回到taken了</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224205039036.png" alt="image-20221224205039036" style="zoom:80%;" /></p><h3 id="n-bit-branch-prediction-buffer">9.2.3 n-bit Branch-PredictionBuffer</h3><blockquote><p>与1-bit和2-bit类似，设计更加复杂的状态图</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224205242395.png" alt="image-20221224205242395" style="zoom:80%;" /></p><h3 id="branch-target-buffer">9.2.4 Branch Target Buffer</h3><ol type="1"><li>在循环中，每次跳转时，跳转的目的地址都是一样的</li><li>可以将跳转的目的地址缓存起来，减少一次加法</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224210044159.png" alt="image-20221224210044159" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224210258569.png" alt="image-20221224210258569" style="zoom:80%;" /></p><h3 id="integrated-instruction-fetch-units-集成指令获取单元">9.2.5Integrated Instruction Fetch Units 集成指令获取单元</h3><p>将IF阶段扩展，IF阶段可以实现：</p><ol type="1"><li>branch predication</li><li>Instruction prefetch</li><li>Instruction memory access and buffering</li></ol><h3 id="return-address-predictor">9.2.6 Return Address Predictor</h3><ol type="1"><li>间接跳转：目的地地址在运行时变化<ol type="1"><li>如从函数返回、使用函数指针跳转、对虚函数的访问</li></ol></li><li>寄存器的存在，使得难以预测跳转的地址</li><li>SPEC89：程序返回占间接跳转的85%</li><li><code>Branch Target Buffer</code>对return不起作用</li><li><code>LR(Link Register)</code>寄存器：用于存储函数的返回地址，在RISCV中是<code>ra</code>寄存器<ol type="1"><li>进入函数时，通常会先将<code>LR</code>寄存器保存进堆栈，然后再执行函数的逻辑</li></ol></li></ol><h2 id="hardware-based-speculation-投机">9.3 Hardware Based Speculation投机</h2><h3 id="tomasulo的缺点">9.3.1 Tomasulo的缺点</h3><ol type="1"><li>无法实现精确中断<ol type="1"><li>精确中断：中断发生时，该指令之前的指令均执行完成，后面的指令均没有执行</li></ol></li><li>WB阶段检测中断<ol type="1"><li>外部中断：找到最后面已经完成的指令，这之前的全部完成，之后的全部没有完成</li><li>内部中断：<ol type="1"><li>非法指令、除0异常：直接终止程序</li><li>缺页异常：仍需要回到产生中断的那条指令，要求必须精确中断。可以通过添加内存栅栏，让CPU强制等待到当前指令</li></ol></li></ol></li><li>会部分overlap<ol type="1"><li>整数单元先跑，浮点单元后跑</li><li>尽管可以issue，但后续基本块在分支解决之前无法开始执行</li></ol></li></ol><h3 id="hardward-based-speculation">9.3.2 Hardward-basedSpeculation</h3><blockquote><p>投机：在不知道branch指令是否跳转的情况下，先去做后面的指令</p></blockquote><ol type="1"><li>对branch的结果做speculation，假装预测是对的来执行程序</li><li>关键点<ol type="1"><li>动态分支预测，选择跳转到哪里</li><li>由于跳转指令依赖于寄存器，因此跳转指令可能也要等待其它指令的执行完成</li><li>指令可以先执行，但指令的执行结果必须等待之前的指令均执行完，才能写入内存/寄存器</li><li><strong>乱序执行、顺序写入</strong></li></ol></li><li>算法<ol type="1"><li>按照预测的顺序执行，但是不commit</li><li>只有预测的结果正确时，才将其提交：写寄存器组、写内存</li><li>如果预测结果不正确，则回滚：清空Reorder Buffer</li></ol></li></ol><h3 id="基于tomasulo算法的投机执行-speculative-execution">9.3.3基于Tomasulo算法的投机执行 Speculative execution</h3><h4 id="基础思想-1">9.3.3.1 基础思想</h4><ol type="1"><li>将指令的完成、指令的提交、结果的bypass分开<ol type="1"><li>如果当前指令的结果是其它指令所需要的，则仍可以给出去，即使当前指令是推测执行的</li><li>因为后面的指令也保证不会写入</li></ol></li><li>处于推测执行的指令，均可以正常执行，但不会写回，直到当前指令不再是speculative<ol type="1"><li>按照顺序commit</li><li>当branch指令commit的时候<ol type="1"><li>如果branch指令预测正确，则后续所有指令按序commit</li><li>如果branch指令预测错误，则直接舍弃后面的指令</li></ol></li></ol></li></ol><h4 id="结构">9.3.3.2 结构</h4><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221224214459406.png" alt="image-20221224214459406" style="zoom:80%;" /></p><ol type="1"><li>指令队列<code>Instruction queue</code>：用于一次取值取多条指令</li><li><code>Reorder Buffer</code>：<ol type="1"><li>Reorder Buffer的来源是CDB、地址单元，出口是寄存器组、内存单元</li><li>即原来的<code>store buffer</code>的拓展，记录哪个地址有哪个值需要写入</li><li>排序的依据：原来的指令顺序</li><li>由于要commit的指令，要么写寄存器，要么写内存，因此可以使用该模块实现顺序commit</li><li>原来CDB广播的数据是直接进寄存器组的，这里添加了一个ReorderBuffer，让其能够顺序commit</li></ol></li></ol><h4 id="和tomasulo算法的区别">9.3.3.3 和Tomasulo算法的区别</h4><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221227210505579.png" alt="image-20221227210505579" style="zoom: 80%;" /></p><ol type="1"><li>增加了<code>Reorder Buffer</code>，删除了<code>Store Buffer</code></li><li>寄存器的重命名是通过<code>Reorder Buffer</code>，而不是通过保留站<ol type="1"><li>即，通过<code>Reorder Buffer</code>暂存数据</li></ol></li><li>保留站只用来存放：已经issue，没有execution的指令的opcode、operands</li><li><code>Reorder Buffer</code>会保存指令的结果，并且将操作数bypass给还没有完成的指令</li></ol><h4 id="reorder-buffer-的每个实例包含">9.3.3.4 Reorder Buffer的每个实例包含</h4><ol type="1"><li>指令的类型</li><li>目的寄存器</li><li>计算出的值</li><li>是否已经就绪</li><li>异常向量</li></ol><h4 id="投机tomasulo算法的四个步骤">9.3.3.5投机Tomasulo算法的四个步骤</h4><ol type="1"><li><strong>Issue</strong>：从FP Op Queue中得到一条指令<ol type="1"><li>如果保留站、Reorder Buffer均有空，则发射该指令</li><li>将该指令存入保留站，并且在Reorder Buffer中为目的寄存器分配一个空间<ol type="1"><li>这一步也叫<strong>dispatch(分派)</strong></li></ol></li><li>更新该实例的控制单元为<code>in use</code></li></ol></li><li><strong>Execution</strong>：对操作数进行计算<ol type="1"><li>如果两个操作数均ready，则进行计算</li><li>否则，等待<code>CDB</code>广播两个操作数，直到两个操作数均在保留站中</li><li>解决<strong>RAW</strong>冲突</li></ol></li><li><strong>Write Result</strong>：完成计算<ol type="1"><li>写入<code>CDB</code>进行广播</li><li>写入<code>Reorder Buffer</code></li><li>标记保留站中对应的位置为<code>free</code></li></ol></li><li><strong>Commit</strong>：使用<code>Reorder</code>的结果更新寄存器<ol type="1"><li>当<code>Reorder Buffer</code>头部的指令已经有结果了，更新寄存器/写入内存，并将其从<code>Reorder Buffer</code>中移除</li><li>如果跳转指令预测错误，则清空<code>Reorder Buffer</code><ol type="1"><li>这一步也叫<strong>graduation(毕业)</strong></li></ol></li></ol></li></ol><h4 id="commit时的操作">9.3.3.6 commit时的操作</h4><p>当一条指令变为<code>Reorder Buffer</code>的头部指令，并且已经计算出结果时</p><ol type="1"><li>如果当前指令不是跳转指令<ol type="1"><li>更新寄存器</li><li>从<code>ROB</code>中删除该寄存器</li><li>如果是<code>store</code>指令，则更新内存</li></ol></li><li>如果是跳转指令，但是预测错误<ol type="1"><li>清空<code>ROB</code></li><li>流水线从branch的正确分支那里重新开始执行</li></ol></li><li>如果是跳转指令，并且预测正确<ol type="1"><li>branch的执行就结束了</li></ol></li></ol><h4 id="示例-6">9.3.3.7 示例</h4><ol type="1"><li>使用<code>ROB</code>实现重命名：保留站中等待的，是<code>ROB</code>中的项，而不是之前的保留站的项</li><li><code>ROB</code>保证了提交的顺序与原始指令的顺序是一样的</li></ol><blockquote><p>详细见视频</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221227213235003.png" alt="image-20221227213235003" style="zoom:80%;" /></p><ol start="3" type="1"><li>跳转指令依旧需要进入<code>ROB</code></li><li>当后面的指令需要读寄存器时，要选择离它最近的<code>ROB</code>项</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221227213510760.png" alt="image-20221227213510760" style="zoom:80%;" /></p><h4 id="新问题memory-disambiguation">9.3.3.8 新问题：memorydisambiguation</h4><ol type="1"><li><p>问题：给定一个指令序列，先store后load，它们两个访问的地址是否时相同的</p><ol type="1"><li>或者说，两条指令是否有RWA冲突</li><li>如下面的例子中，R2可能与R3的值相同，导致访问同一个地址</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221227214115916.png" alt="image-20221227214115916" style="zoom:80%;" /></p></li><li><p>我们是否能够先执行LD指令，后执行ST指令？</p><ol type="1"><li>如果存储的是寄存器的值，可能会由于一些对于R2的操作指令，使得ST指令被delay很长时间</li><li>我们可能想要在同一个周期里，开始执行这两条指令(ST和LD可以通过doublebump在同一个周期内完成)</li></ol></li><li><p>解决方法：</p><ol type="1"><li>在进行内存操作时，要保证<code>ROB</code>中所有内存操作的地址均已得到，才能进行内存操作</li><li><code>ROB</code>需要跟踪所有修改内存的指令，按照源码的顺序<ol type="1"><li>当地址已经获得的时候，记录地址、值，而不是寄存器的地址</li><li>保存先进先出的顺序：保证<code>load</code>和<code>store</code>的执行顺序没有被打乱<ol type="1"><li>如下图中，LD指令必须在ST指令之后执行</li></ol></li></ol></li><li>硬件支持：<ol type="1"><li>当我们有一个<code>load</code>的地址的时候，检查<code>store</code>队列<ol type="1"><li>如果在<code>load</code>之前有<code>store</code>指令的地址于其相同，则暂停<code>load</code>指令</li><li>如果<code>load</code>指令的地址与之前的<code>store</code>指令的地址相同时，会有一个<strong>memory-inducedRAW hazard</strong><ol type="1"><li>如果<code>store</code>的值已经可用，则返回该值</li><li>如果<code>store</code>的值不可用，则将对应<code>ROB</code>的序号放入<code>load</code>指令的source中</li></ol></li><li>否则，执行<code>load</code>指令</li></ol></li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221227214615277.png" alt="image-20221227214615277" style="zoom:80%;" /></p></li></ol><h4 id="对精确中断的硬件支持">9.3.3.9 对精确中断的硬件支持</h4><ol type="1"><li>如果在某一条指令产生了中断，则将<code>ROB</code>中对应指令的<ol type="1"><li>后面的指令全部清空</li><li>前面的指令正常运行</li></ol></li></ol><h2 id="记分牌tomasulo带投机的tomasulo三种算法对比">9.4记分牌、Tomasulo、带投机的Tomasulo三种算法对比</h2><p>三者按顺序，依次解决了更多的问题</p><ol type="1"><li>记分牌：RAW问题</li><li>Tomasulo：WAW、WAR问题；RAW问题</li><li>带投机的Tomasulo：精确中断；WAW、WAR问题；RAW问题</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221227220037677.png" alt="image-20221227220037677" style="zoom:80%;" /></p><h1 id="chapter-10superscalar-vliw">Chapter 10：SuperScalar &amp;VLIW</h1><h2 id="获取cpi1multiple-issue-processor-多发处理器">10.1获取CPI&lt;1：Multiple Issue Processor 多发处理器</h2><p>CPI&lt;1：单位时间内能够处理多条指令</p><ol type="1"><li><strong>VectorProcessing</strong>：向量计算（把数据拼在一起、数据并行）<ol type="1"><li>将多个数据拼成一个向量，指令对向量进行计算</li><li>在RISCV中，该指令称为vector指令</li><li>在其它处理器中，该指令称为SIMD指令</li></ol></li><li><strong>Superscalar</strong>：超标量<ol type="1"><li>每个周期可以执行的指令数量是变化的(1~8)</li><li>可以由编译器或硬件调度(Tomasulo)</li><li>如：IBM PowerPC、Sun UltraSparc</li></ol></li><li><strong>Very Long InstructionWords(VLIW)</strong>：超长指令字（把指令拼在一起、指令并行）<ol type="1"><li>在一个指令中，放固定数量的指令</li><li>该指令由编译器产生，将操作放到wide templates(TBD)中</li><li>编译器要保证放在一起的这几条指令之间，没有依赖关系</li></ol></li><li>新的性能指标：<strong>Instruction Per Clock cycle，IPC</strong></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228133757237.png" alt="image-20221228133757237" style="zoom:80%;" /></p><h2 id="superscalar">10.2 SuperScalar</h2><ol type="1"><li>每个周期尽可能发射足够多的指令，让每个功能单元均处于busy状态<ol type="1"><li>静态调度：编译器优化，按序执行</li><li>动态调度：使用基于Tomasulo算法的技术，乱序执行</li></ol></li></ol><h3 id="静态调度superscalar">10.2.1 静态调度SuperScalar</h3><ol type="1"><li><p>指令按序发射</p></li><li><p>在issue的时候，会检查所有流水线冲突，会在一个周期内发射<strong>0~8</strong>条指令</p></li><li><p><strong>Issue packet</strong>：fetchunit在取值的时候，会在一个周期内取多条指令，这些指令可能会在一个周期内发射</p><ol type="1"><li>如果指令存在结构冲突/数据冲突，则指令就不会issue</li><li>如果是N-issue，则一个周期内发射0~N条指令</li></ol></li><li><p>Issue阶段会被分开，并且实现流水</p><ol type="1"><li><strong>withinpacket</strong>：确定当前packet中会有多少指令能够同时发射</li><li><strong>betweenpacket</strong>：检查选中的指令中，是否与之前的packet有冲突</li></ol></li><li><p>在一个周期内执行issue check，会限制clock cycletime：需要O(n<sup>2</sup>-n)次比较</p><ol type="1"><li>因此，将issue阶段分割，并且实现流水<ol type="1"><li>第一个阶段：决定由多少指令可以同时发射</li><li>第二个阶段：检查是否与之前的指令由冲突</li></ol></li><li>branch penalties会更高，因此预测准确更重要</li></ol></li><li><p>多发的难点：</p><ol type="1"><li><p>译码</p></li><li><p>issue：难于找到一条FP和一条整数指令，两者完全没有关系</p></li><li><p>寄存器组：需要在一个周期内完成2 * N个写、 1 * N 个读</p></li><li><p>Rename的逻辑：必须能够在一个周期内，对同一个寄存器，换名两次，举例如下</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228140028153.png" alt="image-20221228140028153" style="zoom:67%;" /></p></li><li><p>Result buses：需要在一个周期内，完成多条指令</p><ol type="1"><li>因此，需要一个<strong>multiplebuses</strong>，对于每一个保留站都有一个匹配逻辑</li><li>或者，需要<strong>multiple forwarding paths</strong></li></ol></li></ol></li></ol><blockquote><p>双发流水线：dual-issue pipeline</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228134516306.png" alt="image-20221228134516306" style="zoom:80%;" /></p><p>Scalar MIPS</p><ol type="1"><li>一次两条指令，一条浮点，一条整数</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228135012355.png" alt="image-20221228135012355" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228135030569.png" alt="image-20221228135030569" style="zoom:80%;" /></p></blockquote><h3 id="动态调度superscalar">10.2.2 动态调度SuperScalar</h3><ol type="1"><li>两种不同的方法用于解决一个周期内issue多条指令：<ol type="1"><li><strong>pipeline</strong>：将两条指令分别在一个周期的上升沿、下降沿执行</li><li><strong>widen issuelogic</strong>：有一个更宽的逻辑单元，同时可以处理两条指令</li><li>现在一般两种方法都用</li></ol></li></ol><blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228164443843.png" alt="image-20221228164443843" style="zoom:80%;" /></p><ol type="1"><li>双发 ≠ 双执行，只有数据都准备好了，才能执行</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228164841564.png" alt="image-20221228164841564"  /></p><ol start="2" type="1"><li>如果有多个整数单元，则</li></ol><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228165033244.png"alt="image-20221228165033244" /><figcaption aria-hidden="true">image-20221228165033244</figcaption></figure><ol start="3" type="1"><li><p>假设整数部分有3个单元：ALU、计算地址(ADD)、比较器(SUB)</p><ol type="1"><li><p>双发，但不使用speculation</p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228165428654.png"alt="image-20221228165428654" /><figcaption aria-hidden="true">image-20221228165428654</figcaption></figure></li><li><p>双发，使用speculation</p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228165822014.png"alt="image-20221228165822014" /><figcaption aria-hidden="true">image-20221228165822014</figcaption></figure></li></ol></li></ol></blockquote><h3 id="ilp软件方法">10.2.3 ILP软件方法</h3><ol type="1"><li>循环展开</li><li>静态分支预测</li><li>静态多发：VLIW(超长指令字)</li><li>高级编译器支持：<ol type="1"><li>软件流水线：software pipeline</li><li>全局代码调度：global code scheduling</li></ol></li><li>硬件对软件的支持<ol type="1"><li>条件/预测指令，如ADDHI(前面的比较成功，则执行)、SUBLO(前面的比较s失败，则执行)</li><li>编译器投机</li></ol></li></ol><blockquote><p>示例：</p><ol type="1"><li><p>C代码：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228171353327.png" alt="image-20221228171353327" style="zoom:50%;" /></p></li><li><p>翻译为MIPS</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228171429256.png" alt="image-20221228171429256" style="zoom: 67%;" /></p></li><li><p>检查hazard</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228171251264.png" alt="image-20221228171251264" style="zoom: 80%;" /></p></li><li><p>利用延迟槽减少stall</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228171559410.png" alt="image-20221228171559410" style="zoom:67%;" /></p></li><li><p>循环展开：要求循环次数必须是4的整数倍</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228171733770.png" alt="image-20221228171733770" style="zoom:67%;" /></p></li></ol></blockquote><p>从编译器角度看code movement</p><ol type="1"><li>编译器要考虑程序里面的依赖关系</li><li>不管流水线是否有硬件冲突</li><li>编译器要通过指令重排，避免冲突</li><li>编译器主要考虑RAW(真实依赖)，通过寄存器来判断</li><li>如果有RAW依赖，则不能并行</li><li>编译器很难判断<code>memory disambiguation</code><ol type="1"><li><code>100(R4)</code>与<code>20(R6)</code>是否相等?</li><li>在不同的循环中，<code>100(R4)</code>与<code>20(R6)</code>是否相等?</li></ol></li></ol><p>循环展开的细节</p><ol type="1"><li>通常不知道循环的具体次数</li><li>假设有n次，且我们会将循环中的内容展开k遍</li><li>通常不是简单展开，而是产生一个相邻循环的pair<ol type="1"><li>先执行<code>n % k</code>遍</li><li>然后再进行<code>n / k</code>次展开</li></ol></li></ol><h2 id="静态多发vliw">10.3 静态多发：VLIW</h2><ol type="1"><li>VLIW：Very Long Instruction Word</li><li>每个超长指令字中，存储的指令的类型是固定的</li><li>在指令集的设计中需要进行平衡tradeoff<ol type="1"><li>超长指令字可以提供多条指令的空间</li><li>编译器放入的多条指令，相互之间是没有依赖关系的</li><li>例如：2个整数指令、2个FP指令、2个Memory访问、1个branch</li><li>需要编译技术，在多个跳转之间进行调度</li></ol></li><li>VLIW的问题：<ol type="1"><li>技术问题：<ol type="1"><li>代码大小增加了</li><li>会有unused function slots</li><li>任何功能单元上的stall，会引起多条指令的stall</li></ol></li><li>逻辑问题：<ol type="1"><li>二进制代码的兼容性</li></ol></li><li>多发处理器的主要挑战：<ol type="1"><li>如何实现更大的ILP</li></ol></li></ol></li></ol><blockquote><p>VLIW的循环展开示例：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228173334604.png" alt="image-20221228173334604" style="zoom:80%;" /></p></blockquote><h1 id="chapter-11multithreading">Chapter 11：Multithreading</h1><h2 id="多线程软件">11.1 多线程软件</h2><h3 id="进程线程">11.1.1 进程&amp;线程</h3><ol type="1"><li>进程<ol type="1"><li>每个进程有独特的地址空间<strong>unique address space</strong></li><li>可以有多个线程</li></ol></li><li>线程：每个线程有它独特的执行上下文<strong>unique executioncontext</strong><ol type="1"><li>独立的<strong>PC、registers、stack</strong></li><li>一个进程的所有线程，共享相同的地址空间</li><li>可以有私有的堆空间，但一般情况下，一个进程的所有线程共用一个堆</li></ol></li></ol><h3 id="多线程应用进程被划分成了线程">11.1.2多线程应用：进程被划分成了线程</h3><ol type="1"><li>增加并发度concurrency/并行度<ol type="1"><li>并发<strong>concurrent</strong>：外面来了一件事，但手头的事不能停下，因此会<strong>被动</strong>的同时做两件事</li><li>并行<strong>parallel</strong>：<strong>主动</strong>将任务分为两部分，同时进行</li></ol></li><li>部分阻塞</li><li>集中资源管理</li></ol><h3 id="如何保证流水线之间的指令没有依赖关系">11.1.3如何保证流水线之间的指令没有依赖关系</h3><ol type="1"><li>交替执行不同线程的指令</li><li>寄存器组是分bank的，每个线程使用不同的bank</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228200901905.png" alt="image-20221228200901905" style="zoom:80%;" /></p><h3 id="多线程体系结构">11.1.4 多线程体系结构</h3><ol type="1"><li>如果处理器可以执行多个软件线程，则<ol type="1"><li>可以同时执行：线程可以由硬件切换(交替执行interleaved)，而不是由OS控制</li></ol></li><li>共享资源<ol type="1"><li>更好的资源利用率、更好的吞吐量</li></ol></li><li>可以是同一个进程，也可以不是<ol type="1"><li>如果不是，问题主要是页表的切换</li><li>页表可能会有多份</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228201817048.png" alt="image-20221228201817048" style="zoom:80%;" /></p><h3 id="多线程的开销">11.1.5 多线程的开销</h3><ol type="1"><li>对于每个软件来说，CPU更慢了</li><li>每个线程需要有各自独立的user state：GPRs、PC</li><li>也需要独立的OS控制状态：虚拟内存页表、异常处理寄存器</li></ol><h3 id="线程调度策略">11.1.6 线程调度策略</h3><ol type="1"><li>Fixed interleave（CDC 6600 PPUs，1965）<ol type="1"><li>每N个周期，每N个线程各自执行一条指令</li><li>如果线程没有ready，就stall</li></ol></li><li>Software-controlled interleave（TI ASC PPUs，1971）<ol type="1"><li>OS在N个线程之间，分配S个流水线槽位</li><li>硬件在S个流水线槽位之间，做固定的interleave</li></ol></li><li>Hardware-controlled thread scheduling（HEP，1982）<ol type="1"><li>硬件跟踪哪个线程ready to go</li><li>根据硬件优先的模式，选择下一个要执行的线程</li></ol></li></ol><blockquote><p>DenelcorHEP是一个<code>uniform shared memory multiprocessor</code></p><ol type="1"><li>有多个处理器，共享一个内存<code>uniform shared memory</code></li><li>是一个细粒度(fine-grain)的多线程</li><li>可以忍受内存的延迟、同步的延迟、功能单元的延迟</li><li>每个处理器有120个线程，时钟周期频率为10MHz</li></ol></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228205019642.png" alt="image-20221228205019642" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228205100162.png" alt="image-20221228205100162" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228205956744.png" alt="image-20221228205956744" style="zoom:80%;" /></p><h3 id="coarse-grain-multithreading-粗粒度多线程">11.1.7 Coarse-GrainMultithreading 粗粒度多线程</h3><ol type="1"><li>Tera MTA为超算应用设计<ol type="1"><li>数据特点：数据集很大，局部性较低</li><li>没有data cache</li><li>有很多并行的线程，去隐藏一个large memory latency</li></ol></li><li>其它应用会更加cache friendly<ol type="1"><li>当cache hit时，会有更少的流水线bubble</li><li>只增加一部分线程，去隐藏偶尔的cache miss latencies</li><li>当cache miss的时候，交换线程</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228211102172.png" alt="image-20221228211102172" style="zoom:80%;" /></p><h2 id="多线程设计">11.2 多线程设计</h2><ol type="1"><li>细粒度多线程<code>Fine-grained multithreading</code><ol type="1"><li>每一个时钟周期，都在不同线程间切换</li><li>多个线程的指令执行，是交织(interleave)在一起的</li><li>interleave是以轮询的方式进行的：CPU认为指令序列就是交替好的</li><li>一旦发生停顿，所有线程均中断</li></ol></li><li>粗粒度多线程<code>Coarse-grained multithreading</code><ol type="1"><li>一直跑单个线程，只有在成本比较高的停顿发生时，才会进行线程切换</li><li>如：二级/三级cache miss、功能单元的数据冲突</li><li>会有线程切换的开销</li><li>在解决停顿时间较长的情况时，比较划算</li></ol></li><li>设计时需要考虑<ol type="1"><li>上下文切换的开销</li><li>需要支持多少线程</li><li>期望的应用级并行度</li></ol></li></ol><h3 id="superscalar-machine-efficiency">11.2.1 Superscalar MachineEfficiency</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228212635659.png" alt="image-20221228212635659" style="zoom:80%;" /></p><ol type="1"><li>垂直waste：通常是cache miss</li></ol><h3 id="垂直多线程">11.2.2 垂直多线程</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228212716432.png" alt="image-20221228212716432" style="zoom:80%;" /></p><ol type="1"><li>消除了垂直waste，但是会没有解决水平waste</li></ol><h3 id="芯片多线程">11.2.3 芯片多线程</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228212851825.png" alt="image-20221228212851825" style="zoom:80%;" /></p><ol type="1"><li>消除了水平waste，但是还有一部分垂直waste</li></ol><h3 id="同时多线程-out-of-order-simultaneous-multithreading">11.2.4同时多线程 Out-of-Order Simultaneous Multithreading</h3><ol type="1"><li><p>在细粒度的基础上进行改良</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228213316756.png" alt="image-20221228213316756" style="zoom:80%;" /></p></li><li><p>基础Out-of-order流水线</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228214452860.png" alt="image-20221228214452860" style="zoom:80%;" /></p></li><li><p>SMT流水线</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228214505388.png" alt="image-20221228214505388" style="zoom:80%;" /></p></li><li><p>SMT的设计挑战</p><ol type="1"><li>要在细粒度实现的表现与单线程的表现之间进行权衡<ol type="1"><li>首选线程：可能会牺牲吞吐量</li><li>不太可能混合来自多个线程的指令</li><li>最大限度地提高单线程性能，应尽可能提前提取，并在分支预测失误或预取缓冲区中发生未命中时释放提取单元</li></ol></li><li>一个较大的寄存器文件，用于保存多个上下文</li><li>不影响时钟周期，例如在指令发出时，在指令完成时</li><li>确保cache和TLB冲突不会导致性能下降</li></ol></li></ol><h3 id="投机乱序超标量的处理器">11.2.5 投机、乱序、超标量的处理器</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228215205370.png" alt="image-20221228215205370" style="zoom:80%;" /></p><h3 id="芯片多线程-1">11.2.6 芯片多线程</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221228215601834.png" alt="image-20221228215601834" style="zoom:80%;" /></p><h1 id="chapter-12dlp--vector-simd-gpu">Chapter 12：DLP--Vector &amp;SIMD &amp; GPU</h1><p>数据级并行</p><ol type="1"><li>Vector Processor</li><li>GPU</li></ol><p>线程级并行</p><ol type="1"><li>SMP/DSM</li><li>Cache coherence</li><li>Synchronization</li></ol><h2 id="程序执行四种模式">12.1 程序执行四种模式</h2><ol type="1"><li><p>SISD：单一指令、单一数据</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229123911394.png" alt="image-20221229123911394" style="zoom:80%;" /></p></li><li><p>SIMD：单一指令、多个数据</p><ol type="1"><li>SIMD必须在最小段里面执行，因为要保证指令是单一的</li><li>如果跳转的话，指令就不一样了</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229123901541.png" alt="image-20221229123901541" style="zoom:80%;" /></p></li><li><p>MIMD：多条指令、多个数据</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229123853310.png" alt="image-20221229123853310" style="zoom:80%;" /></p></li><li><p>MISD：多条指令、单一数据</p><ol type="1"><li>比较罕见</li></ol></li></ol><h2 id="simd">12.2 SIMD</h2><ol type="1"><li>SIMD体系结构可以利用显著的数据级并行性：<ol type="1"><li>面向矩阵的科学计算</li><li>面向媒体的图像和声音处理器</li></ol></li><li>SIMD比MIMD更节能<ol type="1"><li>每个数据操作只需要获取一条指令</li><li>使SIMD对个人移动设备具有吸引力</li></ol></li><li>SIMD允许程序员继续按串行的思路思考</li></ol><h2 id="vector-processing-向量计算">12.3 Vector Processing 向量计算</h2><ol type="1"><li>在处理单元的个数不变的时候，相当于做了一次循环展开，节省了branch的开销</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229124703373.png" alt="image-20221229124703373" style="zoom: 67%;" /></p><h3 id="向量计算的特点">12.3.1 向量计算的特点</h3><ol type="1"><li>单矢量指令意味着大量的重复工作（循环）<ol type="1"><li>可以减少IF的次数</li></ol></li><li>每个结果独立于以前的结果<ol type="1"><li>长管道，编译器确保无依赖性</li><li>提高时钟频率，因为基本上都是整数运算，可以很快完成</li><li>硬件不必检查数据危害</li></ol></li><li>访问存储器的向量指令具有已知的访问模式<ol type="1"><li>内存是高度交错的</li><li>内存的读取延迟会被分摊(amortize)到超过64个元素</li><li>不需要（数据）缓存</li></ol></li><li>减少管道中的分支和分支问题<ol type="1"><li>通常由回路分支引起的控制危险是不存在的</li></ol></li></ol><h3 id="vector架构的类型">12.3.2 Vector架构的类型</h3><ol type="1"><li><strong>memory-memory vector processors</strong>：<ol type="1"><li>所有的向量操作，都在<strong>内存</strong>之间进行，向量存储在内存中</li><li>可以给出两个内存地址作为source，一个内存地址作为target</li></ol></li><li><strong>vector-register processors</strong>：<ol type="1"><li>所有的向量操作，都在<strong>vector寄存器</strong>之间进行(处理load和store)</li><li>vector等价于load-store架构</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229180515728.png" alt="image-20221229180515728" style="zoom:80%;" /></p><h4 id="vector-register-architecture">12.3.2.1 vector-registerarchitecture</h4><ol type="1"><li>基础想法<ol type="1"><li>把一组数据读到<code>vector register</code>中</li><li>在寄存器上进行操作</li><li>将结果写回memory</li></ol></li><li>寄存器由编译器控制<ol type="1"><li>用于隐藏memory latency</li><li>影响内存的带宽</li></ol></li></ol><h4 id="vector-memory-memory-achitecture">12.3.2.2 Vector Memory-MemoryAchitecture</h4><ol type="1"><li>矢量内存结构（VMMA）需要更大的主内存带宽，为什么？<ol type="1"><li>所有操作数都必须从内存中读取</li></ol></li><li>VMMA使多个向量操作的执行难以重叠，为什么？<ol type="1"><li>必须检查对内存地址的依赖关系</li></ol></li><li>VMMA导致更大的启动延迟<ol type="1"><li>在CDC Star-100上，当矢量&lt;100个元素时，标量代码更快</li><li>对于Cray-1，向量/标量盈亏平衡点约为2个元素</li></ol></li></ol><h4 id="vector-processor的组件">12.3.2.3 Vector Processor的组件</h4><ol type="1"><li>Vector Register：向量寄存器，固定长度的bank，存储一个vector<ol type="1"><li>至少2个读端口，1个写端口</li><li>通常有8~32个向量寄存器，每个存入64-128个64bit单元</li></ol></li><li>Vector FunctionalUnits(FUs)：向量功能单元，完全流水，每个周期启动一个新的计算<ol type="1"><li>通常有4~8个FUs：FP add，FP mult，FP reciprocal，integeradd，logical，shift</li><li>同一种功能单元可能有多个</li></ol></li><li>Vector Load-Store Units(LSUs)<ol type="1"><li>完全流水</li><li>每个周期可以读/写多个元素</li><li>可能有多个LSUs</li></ol></li><li>Scalar register：标量寄存器，用于浮点标量/地址计算</li><li>Cross-bar：矩阵，将所有部件连起来</li></ol><h4 id="基础向量指令">12.3.2.4 基础向量指令</h4><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229182638897.png" alt="image-20221229182638897" style="zoom:80%;" /></p><h4 id="向量指令的执行时间">12.3.2.5 向量指令的执行时间</h4><ol type="1"><li>执行事件取决于三个因素<ol type="1"><li>向量的长度</li><li>是否有结构冲突</li><li>数据依赖</li></ol></li><li>RV64V功能单元每个时钟周期消耗一个element<ol type="1"><li>流水计算，而不是并行计算</li><li>执行时间大约为vector的长度</li></ol></li><li>Convey<ol type="1"><li>有可能可以同时执行的向量指令的集合</li></ol></li></ol><h4 id="chimes-节拍">12.3.2.6 Chimes 节拍</h4><ol type="1"><li><p>在同一个convey中的指令可能有RAW依赖</p></li><li><p>Chaining</p><ol type="1"><li>一旦向量操作的源向量均已可用，允许该向量操作尽早执行</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229183506548.png" alt="image-20221229183506548" style="zoom: 80%;" /></p></li><li><p>Chime</p><ol type="1"><li>执行一次传送的时间单元</li><li>m个convey在m个chimes中执行，向量长度为n</li><li>对于长度为n的向量，需要m*n个时钟周期</li></ol></li></ol><h4 id="vector内存操作">12.3.2.7 Vector内存操作</h4><ol type="1"><li>load/store操作在寄存器和内存之间移动数据</li><li>三种类型的寻址<ol type="1"><li>Unit stride：单位步幅<ol type="1"><li>给出每个单元的大小，然后一个单元一个单元的读取</li><li>最快的</li></ol></li><li>Non-unit(constant) stride：非单位（恒定）步幅</li><li>Indexed(gather-scatter)：索引（聚集-分散）<ol type="1"><li>寄存器间接的矢量等效</li><li>适用于稀疏数据阵列</li><li>增加矢量化程序的数量</li><li>压缩/扩展变量</li></ol></li></ol></li><li>支持内存中各种数据宽度的组合<ol type="1"><li>｛.L、.W、.H、.B｝x｛64b、32b、16b、8b｝</li></ol></li></ol><blockquote><p>Vector 内存系统</p></blockquote><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229184004888.png" alt="image-20221229184004888" style="zoom:80%;" /></p><h4 id="daxpy">12.3.2.8 DAXPY</h4><ol type="1"><li>设X、Y为向量，a为标量，则DAXPY表示的操作为：Y = a * X + Y</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229184056542.png" alt="image-20221229184056542" style="zoom:80%;" /></p><h4 id="向量长度">12.3.2.9 向量长度</h4><ol type="1"><li>一个向量的具体长度是不确定的，但是有一个最大长度(<strong>MVL，maximumvector length</strong>)</li><li><strong>vector-lengthregister(VL)</strong>：控制任何矢量操作的长度，包括矢量加载或存储<ol type="1"><li>例如：VL=10时，vadd.vv为</li><li>for(I=0；I&lt;10；I++) V1[I]=V2[I]+V3[I]</li></ol></li><li>VL可以是从0到MVL的任何值</li></ol><h4 id="strip-mining">12.3.2.10 Strip Mining</h4><ol type="1"><li>当向量长度 &gt; MVL时，需要进行<strong>Strip Mining</strong><ol type="1"><li>生成一个循环计算，每个循环计算的向量长度为MVL</li><li>循环结束后，计算不足MVL的部分</li></ol></li></ol><h3 id="向量操作的优化">12.3.3 向量操作的优化</h3><h4 id="vector-chaining">12.3.3.1 Vector Chaining</h4><ol type="1"><li>是forward在向量上的延展</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229184918604.png" alt="image-20221229184918604" style="zoom:80%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229184936670.png" alt="image-20221229184936670" style="zoom:80%;" /></p><h4 id="条件执行">12.3.3.2 条件执行</h4><ol type="1"><li><p>假设源码如下：</p><ol type="1"><li>由于对每个单元的操作不一样，因此需要条件执行</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229185049389.png" alt="image-20221229185049389" style="zoom:80%;" /></p></li><li><p>解决方法：条件执行</p><ol type="1"><li>为向量的每个单元添加一个1-bit <strong>vector flagregister</strong></li><li>使用<strong>vector compare</strong>，设置flag register</li><li>将flag register作为<strong>mask</strong>，控制向量减法</li></ol></li><li><p>示例：</p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229185255149.png" alt="image-20221229185255149" style="zoom:80%;" /></p></li></ol><h4 id="压缩扩展操作">12.3.3.3 压缩/扩展操作</h4><ol type="1"><li>如果向量比较稀疏，可以通过mask做压缩</li><li>然后可以将另一次向量操作，填进当前操作的空余部分</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229185626244.png" alt="image-20221229185626244" style="zoom:80%;" /></p><h3 id="vector的优点">12.3.4 Vector的优点</h3><ol type="1"><li>易于获得高性能；N次操作：<ol type="1"><li>没有依赖关系</li><li>使用相同的功能单元</li><li>存取不相交寄存器</li><li>按照与前面指令相同的顺序访问寄存器</li><li>访问连续存储器字或已知模式</li><li>可以利用大内存带宽</li><li>隐藏内存延迟（以及任何其他延迟）</li></ol></li><li>可扩展：通过添加硬件资源获得更高的性能</li><li>紧凑型：用一条简短的指令描述N个操作</li><li>可预测：性能与统计性能（缓存）</li><li>多媒体就绪：N * 64b、2N * 32b、4N * 16b、8N * 8b</li><li>需要成熟的编译器技术</li></ol><h2 id="simd-1">12.4 SIMD</h2><ol type="1"><li>多媒体应用需要的时比正常word更窄的数据类型<ol type="1"><li>如RGBA在做运算时，每个通道要分开计算，即一个计算单元为8-bit</li></ol></li><li>SIMD与向量计算相比，限制在于：<ol type="1"><li>数据的个数被编码进了op code中</li><li>无复杂的寻址模式（stride、scatter-gather）</li><li>无mask register</li></ol></li></ol><h3 id="simd实现">12.4.1 SIMD实现</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229211750960.png" alt="image-20221229211750960" style="zoom:80%;" /></p><h3 id="simd代码示例">12.4.2 SIMD代码示例</h3><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229211810511.png" alt="image-20221229211810511" style="zoom:80%;" /></p><h2 id="gpugraphical-processing-units">12.5 GPU：Graphical ProcessingUnits</h2><ol type="1"><li>基础思路：<ol type="1"><li>异构的计算模型：Heterogeneous execution model<ol type="1"><li>CPU是主机，GPU是设备</li></ol></li><li>为GPU开发一种类似C语言的编程代码</li><li>编程模型为<strong>SIMT：Single Instruction MultipleThread</strong></li></ol></li><li>GPU单个指令的计算能力不强，但是并行度非常高，路数很多</li><li>GPU是一个典型的SIMD</li></ol><h3 id="threads-and-blocks">12.5.1 Threads and Blocks</h3><ol type="1"><li>一个thread与一个data element关联</li><li>thread组成block，block组成grid</li><li>GPU硬件进行thread的管理</li></ol><h3 id="nvidia-gpu-架构">12.5.2 NVIDIA GPU 架构</h3><ol type="1"><li>与vector machines类似：<ol type="1"><li>数据级并行</li><li>可以进行scatter-gather传输</li><li>有mask registers</li><li>有更大的寄存器组</li></ol></li><li>区别：<ol type="1"><li>没有标量的处理</li><li>使用多线程去隐藏memory latency</li><li>有很多的功能单元，不再流水，而是完全的并行<ol type="1"><li>4096个线程就是4096个加法器、4096个乘法器…</li></ol></li></ol></li></ol><h1 id="chapter-13multiprocessors">Chapter 13：Multiprocessors</h1><h2 id="为什么要使用多处理器">13.1 为什么要使用多处理器</h2><ol type="1"><li>应用的需求<ol type="1"><li>单一处理器性能的提升，可以解决latency的问题，但不能解决单位时间内获取更多的产出的问题</li></ol></li><li>微处理器已经是最快的CPU了</li><li>摩尔定律的失效</li><li>能够使用并行的软件逐渐增多</li></ol><h3 id="多处理器的目标">13.1.1 多处理器的目标</h3><ol type="1"><li>性能：<ol type="1"><li>突破单一处理器的限制</li><li>如ILP(branch预测，RAW冲突、内存)</li></ol></li><li>更低的成本：<ol type="1"><li>使用廉价的部分，构建一个大的系统</li></ol></li><li>可扩展性scalability：<ol type="1"><li>只要多加处理器，就能获得更好的性能</li></ol></li><li>错误容忍：<ol type="1"><li>如果有少量处理器失效，仍能继续进行运算</li></ol></li></ol><h3 id="并行计算机">13.1.2 并行计算机</h3><ol type="1"><li>定义：并行计算机是一组处理单元，相互协作、通信处理大的问题</li><li>相关参数：<ol type="1"><li>多少个计算机</li><li>每一个计算单元有多强大</li><li>如何进行协作、通信</li><li>数据是怎么发送的</li><li>通信的类型是什么</li><li>对程序员来说，硬件和软件的基本单元是什么</li><li>如何形成性能的</li></ol></li></ol><h3 id="catalogue-the-parallelmimd-processors">13.1.3 Catalogue theParallel(MIMD) Processors</h3><ol type="1"><li>main memory的组成方式<ol type="1"><li>Shared：所有核共享一个内存<strong>UMA</strong></li><li>Distributed：每个核都有一个内存<strong>NUMA</strong></li></ol></li><li>对硬件来说，memory的性能<ol type="1"><li>如memory access latency的表现？<ol type="1"><li>Shared：每个核访问的不同内存的时间是一致的</li><li>Distributed：每个核访问不同内存的时间是不同的</li></ol></li></ol></li><li>对软件来说，memory的性能<ol type="1"><li>处理器是否能够直接通过内存通信<ol type="1"><li>Shared(shared memory)：可以直接通过load/store进行通信</li><li>Distributed(message passing)：通过message进行通信</li></ol></li></ol></li><li>是否正交<ol type="1"><li><strong>DSM</strong>：物理上是分布的，逻辑上是共享的</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230143600300.png" alt="image-20221230143600300" style="zoom:80%;" /></p><h4 id="uma">13.1.3.1 UMA</h4><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230143953225.png" alt="image-20221230143953225" style="zoom:67%;" /></p><ol type="1"><li>理想模型：<ol type="1"><li>优秀(single-cycle)的内存访问延迟</li><li>优秀(infinite)的内存访问带宽</li></ol></li><li>实际系统<ol type="1"><li>当处理器个数上升时，latency会变长</li><li>bandwidth是有限的</li><li>添加memory banks，latency也会变大</li></ol></li><li>也就是说，UMA做不大</li></ol><h4 id="uma-vs-numa">13.1.3.2 UMA vs NUMA</h4><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230144111509.png" alt="image-20221230144111509" style="zoom:80%;" /></p><ol type="1"><li><strong>UMA：uniform memory access</strong><ol type="1"><li>p0访问m0~m3的延迟都是一样的</li><li>当系统变大时，延迟会增加</li><li>data放在哪一块是不重要的</li></ol></li><li><strong>NUMA：non-uniform memory access</strong><ol type="1"><li>p0访问m0会更快，m1~m3会更慢</li><li>p0发送请求给m0，如果m0发现数据不在当前内存，则向Interconnect发消息，获取其它内存单元的数据</li><li>data放在哪里很重要</li></ol></li></ol><h3 id="主要的mimd类型">13.1.4 主要的MIMD类型</h3><ol type="1"><li>中心化的共享内存</li><li>去中心化的内存：内存单元跟随CPU<ol type="1"><li>内存带宽变大，但是会有更高的通信延迟</li><li>软件模型更复杂</li></ol></li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230144659638.png" alt="image-20221230144659638" style="zoom: 67%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230144739997.png" alt="image-20221230144739997" style="zoom:67%;" /></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230144820146.png" alt="image-20221230144820146" style="zoom: 67%;" /></p><h3 id="并行架构">13.1.5 并行架构</h3><ol type="1"><li>并行架构拓展了传统的计算机架构，主要通过通信<ol type="1"><li>抽象：在硬件和软件上有不同的接口</li></ol></li><li>并行的编程模型<ol type="1"><li>multiprogramming：有很多任务，不考虑通信问题</li><li>shared address space：通过内存进行通信</li><li>message passing：发送/接收消息</li><li>dataparallel：由代理(agents)同时操作数据集，然后全局地同时交换信息</li></ol></li><li>通信的抽象：<ol type="1"><li>共享地址空间：load、store、原子的swap</li><li>信号传递：send、receive调用库函数</li></ol></li></ol><h4 id="shared-address-model">13.1.5.1 Shared Address Model</h4><ol type="1"><li>每个处理器都可以访问机器上的任何一个物理地址</li><li>每个进程都可以访问和别的进程共享的数据</li><li>数据的传输：load、store</li><li>数据的大小：byte、word、cache blocks</li><li>使用虚拟内存，将虚拟空间映射到本地/远程物理空间</li><li>应用memory层级模型<ol type="1"><li>通信会将数据移动到本地的cache</li></ol></li><li>对于分布式内存架构，需要一个layer(硬件/软件)，做透明的地址映射</li><li>重点是：数据的一致性、数据保护</li><li>对于多机系统来说，地址的映射是由软件完成的，通常是OS的一部分</li><li>scalability是有限的，因为通信方式与处理器的地址空间紧密的联系在一起</li></ol><h4 id="message-passing-model">13.1.5.2 Message Passing Model</h4><ol type="1"><li>整个计算机（CPU、内存、I/O设备）作为<strong>显式I/O操作</strong>进行通信<ol type="1"><li>本质上是NUMA，但集成在I/O设备与内存系统之间</li></ol></li><li>发送指定远程计算机上的本地缓冲区+接收进程</li><li>接收指定远程计算机上的发送进程+放置数据的本地缓冲区<ol type="1"><li>通常发送的信息包含process tag</li><li>接收在tag上有规则：match 1，match any</li><li>同步：当发送完成时，当缓冲区空闲时，当请求被接受时，接收等待发送</li></ol></li><li>发送+接收=&gt;memory-memory copy<ol type="1"><li>其中每个副本提供本地地址，并且执行成对同步</li></ol></li></ol><h2 id="cache-coherence-一致性问题">13.2 Cache coherence 一致性问题</h2><p>SMP的特性：</p><ol type="1"><li>有限的处理器数量</li><li>足够大的cache：提供更大的memory bandwidth</li><li>UMA：uniform memory access time</li></ol><p><strong>Cache coherence</strong></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230151715739.png" alt="image-20221230151715739" style="zoom:80%;" /></p><p><strong>Synchronization</strong>：</p><ol type="1"><li>原子的读/写操作</li></ol><p>内存一致性模型：</p><ol type="1"><li>处理器必须以什么样的顺序观察别的处理器写的数据</li><li>读和写之间的关系是什么样的</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230152443104.png" alt="image-20221230152443104" style="zoom:80%;" /></p><p>coherency的意义：</p><ol type="1"><li>严格定义：所有的read必须返回最新的write数据</li><li>更优的定义：所有的write必须最终被read看到，所有的write以一种正确的顺序被看到(串行)</li><li>两条规则去实现：<ol type="1"><li>如果P写了x，P1要读x，只有当read和write分开足够远时，P的write才能被P1的read看到</li><li>写到同一个地方的数据必须串行起来，以一种相同的顺序被看到<ol type="1"><li>只会看到最新的写</li></ol></li></ol></li></ol><p><strong>cache coherence的定义：</strong></p><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230153040285.png" alt="image-20221230153040285" style="zoom:80%;" /></p><h3 id="硬件coherence协议">13.2.1 硬件Coherence协议</h3><ol type="1"><li><strong>Snooping算法</strong>：Snoopy Bus<ol type="1"><li>所有对数据的请求都要发给所有处理器</li><li>处理器监听是否有对数据的请求与其相关，如果于其相关，则修改自己的cache中的数据</li><li>需要广播的机制</li><li>如果有bus，则work well</li><li>适用于小规模的机器</li></ol></li><li><strong>Directoy-Based Scheme</strong>：discuss later<ol type="1"><li>有一个中央的目录，知道哪一个处理器拥有哪一段地址</li><li>如果需要修改数据，则向中央目录发送点对点请求</li><li>中央目录将该请求发送到每个与其相关的处理器</li><li>只有当处理器不在一个bus上时，才更优</li></ol></li></ol><h3 id="snoopy协议">13.2.2 Snoopy协议</h3><ol type="1"><li><strong>Write Invalidate</strong>协议：<ol type="1"><li>多个reader，单一writer</li><li>写到shared data时，会发送一个invalidate的消息，给所有的cache</li><li>当cache读到invalidate的数据时，就会发生miss<ol type="1"><li>write-through：内存总是最新的</li><li>write-back：先看别的cache中，是否有当前数据的最新copy</li></ol></li></ol></li><li><strong>Write Broadcast</strong>协议：<ol type="1"><li>写的时候，会将数据发送到bus上，处理器用该数据更新自己的cache</li><li>不会导致新的miss</li></ol></li><li>写的串行化：通过bus访问实现</li><li>总结：<ol type="1"><li>所有的cache会看到所有的bus事件，并进行响应</li><li>协议依赖于bus事件的全局可见性</li><li>由于bus上只能有一个数据，因此可以强制串行write</li></ol></li></ol><blockquote><p>示例：write-back cache、write invalidate</p><ol type="1"><li>最后一次读X时，让其它的cache中进行一次write-back，然后从memory中读取X</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230154822756.png" alt="image-20221230154822756" style="zoom:80%;" /></p><p>示例：write-back cache、broadcast</p><ol type="1"><li>广播时，会将内存中的数据也修改了(事实上的through)</li></ol><p><img src=" https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221230154953997.png" alt="image-20221230154953997" style="zoom:80%;" /></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/09/13/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/09/13/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="chapter-1计算机网络的概念">Chapter 1：计算机网络的概念</h1><h2 id="概念组成功能分类">1.1 概念、组成、功能、分类</h2><h3 id="计算机网络的概念">1.1.1 计算机网络的概念</h3><ol type="1"><li><strong>计算机网络</strong>：是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统</li><li>计算机网络是<strong>互连</strong>的、<strong>自治</strong>的计算机集合<ol type="1"><li>互联：互连互通，使用通信链路</li><li>自治：无主从关系</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108140214225.png" alt="image-20221108140214225" style="zoom: 67%;" /></p><h3 id="计算机网络的功能">1.1.2 计算机网络的功能</h3><ol type="1"><li><strong>数据通信</strong>：连通性</li><li><strong>资源共享</strong>：硬件、软件、数据</li><li>分布式处理：多台计算机各自承担同一工作任务的不同部分</li><li>提高可靠性：一台计算机宕机了，可以由另一台计算机替代它</li><li>负载均衡：多台计算机相互配合</li></ol><h3 id="计算机网络的组成">1.1.3 计算机网络的组成</h3><ol type="1"><li><p>组成部分：硬件、软件、协议</p></li><li><p><strong>工作方式</strong>：</p><ol type="1"><li>边缘部分：主机所在的部分，用户可以直接使用<ol type="1"><li><p>C/S方式</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231152632850.png" alt="image-20221231152632850" style="zoom:80%;" /></p></li><li><p>P2P方式</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231152643718.png" alt="image-20221231152643718" style="zoom:80%;" /></p></li></ol></li><li>核心部分：为边缘部分服务</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108140609953.png" alt="image-20221108140609953" style="zoom: 67%;" /></p></li><li><p><strong>功能组成</strong></p><ol type="1"><li>通信子网：实现数据通信</li><li>资源子网：实现资源共享、数据处理</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108140715884.png" alt="image-20221108140715884" style="zoom: 67%;" /></p></li></ol><h3 id="计算机网络的分类">1.1.4 计算机网络的分类</h3><ol type="1"><li><p>按分布范围分：</p><ol type="1"><li>广域网WAN：交换技术</li><li>城域网MAN</li><li>局域网WAN</li><li>个人区域网PAN：广播技术</li></ol></li><li><p>按使用者分：</p><ol type="1"><li>公用网：交钱就能进，如电信网</li><li>专用网：必须有特殊身份，如军队使用的网络</li></ol></li><li><p>按交换技术分：</p><ol type="1"><li>电路交换</li><li>报文交换</li><li>分组交换</li></ol></li><li><p>按拓扑结构分：</p><ol type="1"><li>总线型</li><li>星型</li><li>环型</li><li>网状型</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108141011216.png" alt="image-20221108141011216" style="zoom:67%;" /></p></li><li><p>按传输技术分：</p><ol type="1"><li>广播式网络：共享公共通信信道</li><li>点对点网络：使用分组存储转发、路由选择的机制</li></ol></li></ol><h3 id="总结">1.1.5 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108141244410.png" alt="image-20221108141244410" style="zoom:80%;" /></p><h2 id="标准化工作及相关组织">1.2 标准化工作及相关组织</h2><h3 id="标准的分类">1.2.1 标准的分类</h3><ol type="1"><li>法定标准<ol type="1"><li>由权威机构制定的、正式的、合法的标准</li><li>如：OSI</li></ol></li><li>事实标准<ol type="1"><li>某些公司的产品在竞争中占据了主流，时间长了，这些产品中的技术和协议就成了标准</li><li>如：TCP/IP</li></ol></li></ol><h3 id="rfc">1.2.2 RFC</h3><ol type="1"><li>RFC：Request For Comments，是因特网标准的形式</li><li>RFC上升为因特网正式标准的四个阶段<ol type="1"><li>因特网草案(Internet Draft)：这个阶段还不是RFC文档</li><li>建议标准(Proposed Standard)：从这个阶段开始成为RFC文档</li><li>草案标准(Draft Standard)：交给IEFT、IAB进行审核</li><li>因特网标准(Internet Standard)：审核通过后，就成为因特网标准</li></ol></li></ol><h3 id="标准化工作的相关组织">1.2.3 标准化工作的相关组织</h3><ol type="1"><li><strong>国际标准化组织ISO</strong>：<ol type="1"><li>OSI参考模型，HDLC协议</li></ol></li><li>国际电信联盟ITU：<ol type="1"><li>制定通信规则</li></ol></li><li>电气电子工程师学会IEEE：<ol type="1"><li>学术机构、IEEE802系列标准、5G</li></ol></li><li>Internet工程任务组IETF：<ol type="1"><li>负责因特网相关标准的制定</li></ol></li></ol><h3 id="总结-1">1.2.4 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108142307828.png" alt="image-20221108142307828" style="zoom:80%;" /></p><h2 id="速率相关的性能指标">1.3 速率相关的性能指标</h2><h3 id="速率">1.3.1 速率</h3><ol type="1"><li><p>速率、<strong>数据率</strong>、<strong>数据传输速率</strong>、<strong>比特率</strong></p><ol type="1"><li>连接在计算机网络上的主机在数字信道上传送<strong>数据位数的速率</strong></li><li>单位：b/s, kb/s, Mb/s, Gb/s, Tb/s，依次递增10<sup>3</sup></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108142711478.png" alt="image-20221108142711478" style="zoom:80%;" /></p></li></ol><h3 id="带宽">1.3.2 带宽</h3><ol type="1"><li><p>带宽：单位时间内，从网络中某一点到另一点所能通过的<strong>最高数据率</strong></p><ol type="1"><li>网络设备所能支持的最高速度</li><li>单位：b/s, kb/s, Mb/s, Gb/s</li></ol></li><li><p>带宽是链路的发送端发送数据的速率</p><ol type="1"><li>传播速率一般都是2×10<sup>8</sup> m/s</li></ol></li><li><p>带宽变大，会使链路发送数据的速率变大，但是不会影响数据传播的速率</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108143352010.png" alt="image-20221108143352010" style="zoom:80%;" /></p></li></ol><h3 id="吞吐量">1.3.3 吞吐量</h3><ol type="1"><li><p>吞吐量：单位时间内，通过<strong>某个网络(/信道/接口)</strong>的数据量</p><ol type="1"><li>单位：b/s, kb/s, Mb/s</li></ol></li><li><p>吞吐量受网络的带宽、网络的额定速率的限制</p><ol type="1"><li>链路带宽：理想情况下，接收方接受数据的最高速率</li><li>吞吐量：多个发送方发来数据的速率之和，一般小于链路带宽</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221108143744006.png" alt="image-20221108143744006" style="zoom:67%;" /></p></li></ol><h2 id="时延时延带宽积rtt利用率">1.4 时延、时延带宽积、RTT、利用率</h2><h3 id="时延">1.4.1 时延</h3><p>时延：数据从网络的一端传送到另一端所需的时间，也叫延迟/迟延，单位是s</p><ol type="1"><li><p>发送时延(传输时延)：</p><ol type="1"><li>从发送分组的第一个bit算起，到该分组的最后一个bit发送完毕的所需时间</li><li><span class="math inline">\(发送时延 =\frac{数据长度}{信道带宽(发送速率)}\)</span></li><li>发生在<strong>主机</strong>内</li><li>高速链路：提高了信道带宽(发送速率)</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109132505719.png" alt="image-20221109132505719" style="zoom:80%;" /></p></li><li><p>传播时延：</p><ol type="1"><li>电磁波在信道上传播一定距离所需的时间</li><li><span class="math inline">\(传播时延 =\frac{信道长度}{电磁波在信道上的传播速率}\)</span></li><li>发生在<strong>信道</strong>上</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109132649076.png" alt="image-20221109132649076" style="zoom:80%;" /></p></li><li><p>排队时延：</p><ol type="1"><li>等待输出/入链路所需的时间</li><li>发生在<strong>路由器</strong>，类似过安检排队</li></ol></li><li><p>处理时延：</p><ol type="1"><li>处理数据所需的时间</li><li>发送在<strong>路由器</strong>，类似过安检时的扫描</li></ol></li></ol><h3 id="时延带宽积">1.4.2 时延带宽积</h3><ol type="1"><li><span class="math inline">\(时延带宽积 = 传播时延 ×带宽\)</span>，单位为bit</li><li>也称为：以比特为单位的链路长度，即某段线路现在有多少比特，链路容量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109133245849.png" alt="image-20221109133245849" style="zoom:80%;" /></p><h3 id="往返时延rtt">1.4.3 往返时延RTT</h3><ol type="1"><li><strong>RTT</strong>：从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延<ol type="1"><li>RTT越大，在收到确认之前，可发送的数据越多</li></ol></li><li><span class="math inline">\(RTT = 传播时延×2+末端处理时间\)</span><ol type="1"><li>RTT不包括发送时延(传输时延)</li></ol></li></ol><h3 id="利用率">1.4.4 利用率</h3><ol type="1"><li>信道利用率：<span class="math inline">\(信道利用率 =\frac{有数据通过的时间}{(有+无)数据通过的时间}\)</span></li><li>网络利用率：信道利用率的加权平均值</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109133634462.png" alt="image-20221109133634462" style="zoom: 67%;" /></p><h3 id="总结-2">1.4.5 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109133702155.png" alt="image-20221109133702155" style="zoom:80%;" /></p><h2 id="分层结构协议接口服务">1.5 分层结构、协议、接口、服务</h2><h3 id="分层的基本原则">1.5.1 分层的基本原则</h3><ol type="1"><li>各层之间相互独立，每层只实现一种相对独立的功能</li><li>每层之间界面自然清晰，易于理解，相互交流尽可能少</li><li>结构上可分割开，每层都采用最合适的技术来实现</li><li>保持下层对上层的独立性，上层单向使用下层提供的服务</li><li>整个分层结构应该能促进标准化工作</li></ol><h3 id="概念">1.5.2 概念</h3><ol type="1"><li>实体：第n层中的活动元素称为n层实体</li><li>对等实体：同一层的实体</li><li>协议：为进行网络中的对等实体数据交换而建立的规则、标准、约定，称为网络协议【水平】<ol type="1"><li>语法：规定传输数据的格式</li><li>语义：规定所要完成的功能</li><li>同步：规定各种操作的顺序</li></ol></li><li>接口(访问服务点SAP)：上层使用下层服务的入口</li><li>服务：下层为相邻上层提供的功能调用【垂直】</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109211117196.png" alt="image-20221109211117196" style="zoom:67%;" /></p><ol type="1"><li><strong>SDU</strong>服务数据单元：为完成用户所要求的功能而应传送的数据</li><li><strong>PCI</strong>协议控制信息：控制协议操作的信息</li><li><strong>PDU</strong>协议数据单元：对等层次之间传送的数据单位</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109211219883.png" alt="image-20221109211219883" style="zoom: 50%;" /></p><h3 id="概念总结">1.5.3 概念总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109211511126.png" alt="image-20221109211511126" style="zoom:80%;" /></p><h3 id="总结-3">1.5.4 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109211533054.png" alt="image-20221109211533054" style="zoom:80%;" /></p><h2 id="osi参考模型">1.6 OSI参考模型</h2><h3 id="osi提出的背景">1.6.1 OSI提出的背景</h3><ol type="1"><li>目的：支持<strong>异构网络系统</strong>的互联互通</li><li>ISO在1984年提出开放系统互联(OSI)参考模型</li><li>理论成功，市场失败<ol type="1"><li>专家没有实操的经验</li><li>OSI实现复杂，运行效率低</li><li>制定时间过长，没有及时进入市场</li><li>层次划分不合理，有些功能会在多个层次中多次出现</li></ol></li></ol><h3 id="osi七层结构">1.6.2 OSI七层结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109212411182.png" alt="image-20221109212411182" style="zoom:80%;" /></p><h3 id="osi参考模型解释通信过程">1.6.3 OSI参考模型解释通信过程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109212814640.png" alt="image-20221109212814640" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109213106176.png" alt="image-20221109213106176" style="zoom:80%;" /></p><h3 id="osi不同分层">1.6.4 OSI不同分层</h3><h4 id="应用层">1.6.4.1 应用层</h4><ol type="1"><li>应用层：用户与网络的界面，即所有能和用户交互<strong>产生网络流量</strong>的程序</li><li>典型应用层服务<ol type="1"><li>文件传输：FTP</li><li>电子邮件：SMTP</li><li>万维网：HTTP</li></ol></li></ol><h4 id="表示层">1.6.4.2 表示层</h4><ol type="1"><li>表示层：用于处理在两个通信系统中交换信息的<strong>表示方式</strong>（语法和语义）</li><li>功能<ol type="1"><li>数据格式的变换：翻译官</li><li>数据加密解密</li><li>数据压缩和恢复</li></ol></li></ol><h4 id="会话层">1.6.4.3 会话层</h4><ol type="1"><li>会话层：向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据</li><li>会话，也叫<strong>建立同步SYN</strong></li><li>功能：<ol type="1"><li>建立、管理、终止会话</li><li>使用校验点，可使会话在通信失效时，从<strong>校验点/同步点</strong>继续恢复通信，实现数据同步<ol type="1"><li>适用于传输大文件</li></ol></li></ol></li><li>主要协议：ADSP、ASP</li></ol><h4 id="传输层">1.6.4.4 传输层</h4><ol type="1"><li>负责主机中<strong>两个进程</strong>的通信，即<strong>端到端</strong>的通信。传输单位是报文段/用户数据报</li><li>功能<ol type="1"><li>可靠传输、不可靠传输</li><li>差错控制</li><li>流量控制：接收端控制发送端发送的速率</li><li>复用分用<ol type="1"><li>复用：多个应用层进程可同时使用下面运输层的服务</li><li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程</li></ol></li></ol></li><li>主要协议：TCP、UDP</li></ol><h4 id="网络层">1.6.4.5 网络层</h4><ol type="1"><li>网络层：把分组从源端传送到目的端，为分组交换网上的不同主机提供通信服务</li><li>传输单位：<strong>数据报</strong></li><li>功能<ol type="1"><li>路由选择：最佳路径</li><li>差错控制</li><li>流量控制：协调发送端和接收端的速度，限制发送方的速度</li><li>拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状"态。因此要采取一定措施，缓解这种拥塞</li></ol></li><li>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</li></ol><h4 id="数据链路层">1.6.4.6 数据链路层</h4><ol type="1"><li>数据链路层：把网络层传下来的数据报组装成帧</li><li>传输单位：<strong>帧</strong></li><li>功能：<ol type="1"><li>成帧：定义帧的开始和结束</li><li>差错控制：帧错、位错</li><li>流量控制</li><li>访问(接入)控制：控制对信道的访问</li></ol></li><li>主要协议：SDLC、HDLC、PPP、STP</li></ol><h4 id="物理层">1.6.4.7 物理层</h4><ol type="1"><li>物理层：在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong></li><li>传输单位：<strong>比特</strong></li><li>透明传输：不管所传的数据是什么比特组合，都能在链路上传送</li><li>功能：<ol type="1"><li>定义接口特性</li><li>定义传输模式<ol type="1"><li>单工：只有一个人能够说话</li><li>半双工：两个人均能说话，但同一时间只有一个人说话</li><li>双工：两个人均能说话</li></ol></li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ol></li><li>主要协议：Rj45、802.3</li></ol><h3 id="总结-4">1.6.3 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221109220133205.png" alt="image-20221109220133205" style="zoom:80%;" /></p><h2 id="tcpip参考模型5层参考模型">1.7 TCP/IP参考模型、5层参考模型</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110211627791.png" alt="image-20221110211627791" style="zoom:80%;" /></p><h3 id="osi与tcpip的共同点">1.7.1 OSI与TCP/IP的共同点</h3><ol type="1"><li>都分层</li><li>基于独立的协议栈的概念</li><li>可以实现异构网络互联</li></ol><h3 id="osi与tcpip的不同点">1.7.2 OSI与TCP/IP的不同点</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110212313192.png" alt="image-20221110212313192" style="zoom:80%;" /></p><h3 id="层参考模型">1.7.3 5层参考模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110212523658.png" alt="image-20221110212523658" style="zoom:80%;" /></p><h3 id="层参考模型的数据封装与解封装">1.7.45层参考模型的数据封装与解封装</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110212735024.png" alt="image-20221110212735024" style="zoom:80%;" /></p><h2 id="第一章知识总结">1.8 第一章知识总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110212818174.png" alt="image-20221110212818174" style="zoom:80%;" /></p><h1 id="chapter-2物理层">Chapter 2：物理层</h1><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110213211010.png" alt="image-20221110213211010" style="zoom:50%;" /></p><h2 id="物理层的基本概念">2.1 物理层的基本概念</h2><ol type="1"><li>物理层：解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是具体的传输媒体</li><li>主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性【定义标准】<ol type="1"><li><strong>机械特性</strong>：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目</strong>、<strong>引脚数量</strong>、排列情况</li><li><strong>电气特性</strong>：规定传输<strong>二进制位</strong>时，线路上信号的<strong>电压范围</strong>、阻抗匹配、<strong>传输速率</strong>、<strong>距离限制</strong>等</li><li><strong>功能特性</strong>：指明某条线上出现某一<strong>电平表示何种意义</strong>，接口部件的信号线的用途</li><li><strong>规程特性(过程特性)</strong>：定义各条物理线路的工作<strong>规程</strong>和<strong>时序</strong>关系</li></ol></li></ol><h2 id="数据通信的基础知识">2.2 数据通信的基础知识</h2><h3 id="典型的数据通信模型">2.2.1 典型的数据通信模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110214223211.png" alt="image-20221110214223211" style="zoom:80%;" /></p><h3 id="相关术语">2.2.2 相关术语</h3><ol type="1"><li><p>通信的目的：传送消息</p></li><li><p><strong>数据</strong>：传送信息的实体，通常是有意义的符号序列</p></li><li><p><strong>信号</strong>：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong></p><ol type="1"><li>数字信号：代表消息的参数取值是离散的</li><li>模拟信号：代表消息的参数取值是连续的</li></ol></li><li><p><strong>信源</strong>：产生和发送数据的源头</p></li><li><p><strong>信宿</strong>：接收数据的终点</p></li><li><p><strong>信道</strong>：信号传输的媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110215133733.png" alt="image-20221110215133733" style="zoom:80%;" /></p></li></ol><h3 id="三种通信方式">2.2.3 三种通信方式</h3><ol type="1"><li><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互，仅需要<strong>一条</strong>信道</li><li><strong>半双工通信</strong>：通信的双方都可以发送或接收消息，但任何一方都不能同时发送和接收，需要<strong>两条</strong>信道</li><li><strong>全双工通信</strong>：通信双方可以同时发送和接收消息，也需要<strong>两条</strong>信道</li></ol><h3 id="两种数据传输方式">2.2.4 两种数据传输方式</h3><ol type="1"><li>串行传输：速度慢，费用低，适合远距离</li><li>并行传输：速度快，费用高，适合近距离，用于计算机内部数据传输</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110215514788.png" alt="image-20221110215514788" style="zoom:80%;" /></p><h2 id="码元波特速率带宽计算">2.3码元、波特、速率、带宽(<strong>计算</strong>)</h2><h3 id="码元">2.3.1 码元</h3><ol type="1"><li><strong>码元</strong>是指用一个<strong>固定时长</strong>的<strong>信号波形</strong>(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<strong>k进制码元</strong>，而该时长称为<strong>码元宽度</strong><ol type="1"><li>当码元的离散状态有M个时(M大于2)，此时码元为<strong>M进制码元</strong></li></ol></li><li><strong>1码元可以携带多个比特的信息量</strong>。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113162232308.png" alt="image-20221113162232308" style="zoom:80%;" /></p><h3 id="速率波特带宽">2.3.2 速率、波特、带宽</h3><ol type="1"><li>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。</li><li><strong>码元传输速率</strong>：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的<strong>码元个数</strong>(也可称为<strong>脉冲个数或信号变化的次数</strong>)<ol type="1"><li>单位是<strong>波特(Baud)</strong></li><li><strong>1波特</strong>：表示数字通信系统每秒传输一个码元，<strong>1Baud= 1码元/s</strong></li><li>这里的码元可以是多进制的，也可以是二进制的，但<strong>码元速率与进制数无关</strong></li></ol></li><li><strong>信息传输速率</strong>：别名信息速率、比特率等，表示单位时间内数字通信系统传输的<strong>二进制码元个数</strong>(即比特数)<ol type="1"><li>单位：<strong>比特/秒(b/s)</strong></li></ol></li><li><strong>关系</strong>：若一个码元携带n bit的信息量，则MBaud的码元传输速率所对应的信息传输速率为<span class="math inline">\(M ×n\)</span> bit/s</li><li><strong>带宽</strong>：表示在单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”，常用来表示网络的通信线路所能传输数据的能力<ol type="1"><li>单位：<strong>比特/秒(b/s)</strong></li></ol></li></ol><h3 id="练习题">2.3.3 练习题</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113163219588.png" alt="image-20221113163219588" style="zoom: 80%;" /></p><h2 id="奈氏准则香农定理计算">2.4奈氏准则、香农定理(<strong>计算</strong>)</h2><h3 id="失真">2.4.1 失真</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113163436831.png" alt="image-20221113163436831" style="zoom:80%;" /></p><p>影响失真程度的因素：</p><ol type="1"><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ol><h3 id="失真的一种现象码间串扰">2.4.2 失真的一种现象：码间串扰</h3><ol type="1"><li><strong>信道带宽</strong>：信道能够通过的<strong>最高频率和最低频率之差</strong></li><li><strong>码间串扰</strong>：<strong>接收端</strong>收到的信号波形<strong>失去了码元之间清晰界限</strong>的现象</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113163739821.png" alt="image-20221113163739821" style="zoom:80%;" /></p><h3 id="奈氏准则奈奎斯特定理极限码元传输速率">2.4.3奈氏准则(奈奎斯特定理)：极限码元传输速率</h3><ol type="1"><li><p><strong>奈氏准则</strong>：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，<strong>极限码元传输速率</strong>为<strong>2W</strong>(Baud)</p><ol type="1"><li>W：信道带宽，单位是<strong>Hz</strong></li></ol></li><li><p>理想低通信道下的<strong>极限数据传输率</strong>：<strong>2Wlog<sub>2</sub>V</strong> (b/s)</p><ol type="1"><li>W：信道带宽，单位是<strong>Hz</strong></li><li>V：几种码元/码元的离散电平数目</li></ol></li><li><p>结论：</p><ol type="1"><li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能</li><li>信道的<strong>频带越宽</strong>(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输</li><li>奈氏准则给出了<strong>码元传输速率</strong>的限制，但并没有对信息传输速率给出限制</li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用<strong>多元制的调制方法</strong></li></ol></li><li><p>例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113165306084.png" alt="image-20221113165306084" style="zoom:67%;" /></p></li></ol><h3 id="香农定理数据传输速率">2.4.4 香农定理：数据传输速率</h3><ol type="1"><li><p><strong>噪声</strong>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，<strong>信噪比</strong>就很重要</p></li><li><p>信噪比=<spanclass="math inline">\(\frac{信号的平均功率}{噪声的平均功率}\)</span>，记为<strong>S/N</strong>，用分贝<strong>db</strong>作为度量单位</p><ol type="1"><li><strong>信噪比(dB) = 10 log<sub>10</sub>(S/N)</strong></li></ol></li><li><p>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值</p><ol type="1"><li><strong>信道的极限数据传输速率 = W log<sub>2</sub>(1+S/N)(b/s)</strong></li><li>W：信道带宽，单位是<strong>Hz</strong></li><li>S/N：信噪比</li><li>S：信道所传信号的平均功率</li><li>N：信道内的高斯噪声功率</li></ol></li><li><p>结论：</p><ol type="1"><li>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong></li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了</li><li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输</li><li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少</li><li>从香农定理可以看出，若信道带宽w或信噪比S/N没有上限(不可能)，那么信道的极限信息传输速率也就没有上限</li></ol></li><li><p>例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113170048282.png" alt="image-20221113170048282" style="zoom:67%;" /></p></li></ol><h3 id="奈氏准则与香农定理">2.4.5 奈氏准则与香农定理</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113170318805.png" alt="image-20221113170318805" style="zoom:80%;" /></p><p>例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113170400885.png" alt="image-20221113170400885" style="zoom:80%;" /></p><h3 id="采样定理">2.4.6 采样定理</h3><p><span class="math display">\[f_{采样频率} ≥ 2f_{信号最高频率}\]</span></p><ol type="1"><li>对于一个正弦波，我们只需要确定两个点，就可以确定其波形</li><li>因此只需要在一个正弦波周期中，取到两个点，就可以得到正弦波的波形</li><li>故：采样频率 ≥ 2信号最高频率</li></ol><h2 id="编码调制">2.5 编码&amp;调制</h2><h3 id="基带信号与宽带信号">2.5.1 基带信号与宽带信号</h3><ol type="1"><li>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道<ol type="1"><li>按传输信号分：模拟信道、数字信道</li><li>按传输介质分：无线信道、有线信道</li></ol></li><li>信道上传输的信号<ol type="1"><li><strong>基带信号Baseband</strong>：将数字信号1和0直接用两种不同的电压表示，再送到<strong>数字信道</strong>上去传输(<strong>基带传输</strong>)<ol type="1"><li><strong>来自信源</strong>的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号</li><li>基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号</li></ol></li><li><strong>宽带信号Passband</strong>：将基带信号进行调制后形成的频分复用模拟信号，再传送到<strong>模拟信道</strong>上去传输(<strong>宽带传输</strong>)<ol type="1"><li>把基带信号经过<strong>载波调制</strong>后，把信号的<strong>频率范围搬移</strong>到<strong>较高的频段</strong>以便在信道中传输(即仅在一段频率范围内能够通过信道)</li></ol></li><li>在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化)</li><li>在传输距离较远时，计算机网络采用宽带传输方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)</li></ol></li></ol><h3 id="编码与调制">2.5.2 编码与调制</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113171517993.png" alt="image-20221113171517993" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113171553542.png" alt="image-20221113171553542" style="zoom:80%;" /></p><h3 id="数字数据-编码为-数字信号">2.5.3 数字数据 编码为 数字信号</h3><ol type="1"><li><p><strong>非归零编码【NRZ】</strong>：高1低0</p><ol type="1"><li>编码容易实现</li><li>但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方<strong>难以保持同步</strong></li></ol></li><li><p>归零编码【RZ】：信号电平在一个码元之内都要恢复到0</p></li><li><p>反向不归零编码【NRZI】：信号电平翻转表示0，不变表示1</p><ol type="1"><li>需要时钟信号</li></ol></li><li><p><strong>曼彻斯特编码</strong>：</p><ol type="1"><li>规则：将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1；码元0则正好相反。也可以采用相反的规定</li><li>该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号(可用于同步)又作数据信号</li><li>但它所占的频带宽度是原始的基带宽度的两倍</li><li>每一个码元都被调成两个电平，所以<strong>数据传输速率只有调制速率的1/2</strong></li></ol></li><li><p><strong>差分曼彻斯特编码</strong>：同1异0</p><ol type="1"><li>规则：常用于局域网传输，其规则是:若码元为1，则前半个码元的电平，与上一个码元的后半个码元的电平相同，若为0，则相反</li><li>该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113172748058.png" alt="image-20221113172748058" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113172758786.png" alt="image-20221113172758786" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113172219724.png" alt="image-20221113172219724" style="zoom:67%;" /></p></li><li><p>4B/5B编码</p><ol type="1"><li>比特流中插入额外的比特以打破连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B</li><li>编码效率为80%</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113172937516.png" alt="image-20221113172937516" style="zoom:67%;" /></p></li></ol><h3 id="数字数据-调制为-模拟信号">2.5.4 数字数据 调制为 模拟信号</h3><ol type="1"><li>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程</li><li>分为：调幅(ASK)、调频(FSK)、调相(PSK)、调幅+调相(QAM)</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113173212187.png" alt="image-20221113173212187" style="zoom:67%;" /></p><h3 id="模拟数据-编码为-数字信号">2.5.5 模拟数据 编码为 数字信号</h3><ol type="1"><li>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列(即实现<strong>音频数字化</strong>)</li><li>最典型的例子就是对音频信号进行编码的脉码调制(<strong>PCM</strong>)，在计算机应用中，能够达到<strong>最高保真水平</strong>的就是<strong>PCM编码</strong>，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步：<ol type="1"><li><strong>抽样</strong>：对模拟信号进行周期性扫描<ol type="1"><li>把时间上连续的信号变为时间上离散的信号</li><li>为了使所得的离散信号能够无失真的代表被抽样的模拟数据，要使用采样定理进行采样</li><li><strong>f<sub>采样频率</sub> ≥2f<sub>信号最高频率</sub></strong></li></ol></li><li><strong>量化</strong>：把抽样取得的电平幅值按照一定的分级标准转化为对应的数字值，并取整数。<ol type="1"><li>把连续的电平幅值转化为离散的数据量</li></ol></li><li><strong>编码</strong>：把量化的结果转化为与之对应的二进制编码</li></ol></li></ol><h3 id="模拟数据-调制为-模拟信号">2.5.6 模拟数据 调制为 模拟信号</h3><ol type="1"><li>为了实现传输的有效性，可能需要较高的频率</li><li>这种调制方式还可以使用频分复用技术，充分利用带宽资源</li><li>在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113190432048.png" alt="image-20221113190432048" style="zoom:80%;" /></p><h3 id="总结-5">2.5.7 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113190415378.png" alt="image-20221113190415378" style="zoom:80%;" /></p><h2 id="复用multiplexing">2.6 复用Multiplexing</h2><h3 id="频分复用fdmafrequency-division-multiplexing">2.6.1频分复用FDMA：Frequency Division Multiplexing</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231161448196.png" alt="image-20221231161448196" style="zoom:80%;" /></p><ol type="1"><li>一人一个频段，一起发送</li><li>缺点：相邻子信道之间需要有保护频段</li></ol><h3id="正交频分复用ofdmorthogonal-frequency-division-multiplexing">2.6.2正交频分复用OFDM：Orthogonal Frequency Division Multiplexing</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231161609812.png" alt="image-20221231161609812" style="zoom:80%;" /></p><ol type="1"><li>相邻子信道之间叠在一起，不需要保护频段</li><li>使用示例：4G、5G、WIFI</li></ol><h3 id="时分复用tdmatime-division-multiplexing">2.6.3 时分复用TDMA：TimeDivision Multiplexing</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231161719420.png" alt="image-20221231161719420" style="zoom:80%;" /></p><ol type="1"><li>一人一个字节，轮流发送</li></ol><h3 id="码分复用cdmacode-division-multiplexing">2.6.4 码分复用CDMA：CodeDivision Multiplexing</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231161836274.png" alt="image-20221231161836274" style="zoom:80%;" /></p><ol type="1"><li>大家的时间、频率是重叠在一起的，同时发送，但是同一段数据对不同人表示的含义不一样</li><li>每个人使用的0/1的码型，两两之间是正交的<ol type="1"><li>正交：对应位相乘，然后相加，得到的和为0</li></ol></li><li>具体见<strong>3.5.1.3.5</strong></li></ol><h2 id="各种网络">2.7 各种网络</h2><h3 id="固定电话网">2.7.1 固定电话网</h3><h4 id="电话网">2.7.1.1 电话网</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231162429588.png" alt="image-20221231162429588" style="zoom:80%;" /></p><ol type="1"><li>电话机和端局之间：<strong>本地环路Local loop</strong><ol type="1"><li>通信的两个方向是叠加在同一根线上的</li><li>通常为模拟电路</li></ol></li><li>交换机和交换机之间：<strong>中继线trunk</strong><ol type="1"><li>中继线都是四线制的，通信的两个方向是分开的</li><li>通常为数字电路</li></ol></li></ol><h4 id="调制解调器-modems">2.7.1.2 调制解调器 Modems</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231162845030.png" alt="image-20221231162845030" style="zoom:80%;" /></p><ol type="1"><li>由于中继线是数字化的，因此分配给每个用户的通话频率是固定的，不能超过4kHz</li><li>需要将基带信号调制为4kHz以内的音频信号，在电话线上进行传输</li><li><strong>modems</strong>：调制解调器</li></ol><h4 id="adsl">2.7.1.3 ADSL</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231163129059.png" alt="image-20221231163129059" style="zoom:80%;" /></p><ol type="1"><li><strong>ADSL</strong>：在本地环路上，低频部分用于打电话，高频部分用于上网<ol type="1"><li>高频部分通过频分复用，分为上传/下载部分</li></ol></li></ol><h4 id="ftth">2.7.1.4 FTTH</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231163253090.png" alt="image-20221231163253090" style="zoom:80%;" /></p><ol type="1"><li><strong>FTTH</strong>：电信局通过一根光纤连接到分光器，由分光器将数据分发给家家户户<ol type="1"><li>家庭到电信局的数据：发给分光器，然后走共享光纤</li><li>电信局到家庭的数据：走共享光纤发给分光器，然后广播</li></ol></li><li>分光器：是无源设备</li></ol><h4 id="t1">2.7.1.5 T1</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231163608997.png" alt="image-20221231163608997" style="zoom:80%;" /></p><h4 id="sonetsdh">2.7.1.6 SONET、SDH</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231163802561.png" alt="image-20221231163802561" style="zoom:80%;" /></p><ol type="1"><li>将一个2M的电路，一步甩到几个G的电路上跑</li></ol><h3 id="移动通信网">2.7.2 移动通信网</h3><table><colgroup><col style="width: 3%" /><col style="width: 7%" /><col style="width: 13%" /><col style="width: 17%" /><col style="width: 57%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">采用技术</th><th style="text-align: center;">支持的通信</th><th style="text-align: center;">复用方法</th><th style="text-align: center;">标准</th></tr></thead><tbody><tr><td style="text-align: center;">1G</td><td style="text-align: center;">模拟技术</td><td style="text-align: center;">话音通信</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">2G</td><td style="text-align: center;">数字技术</td><td style="text-align: center;">话音通信</td><td style="text-align: center;">码分复用</td><td style="text-align: center;">GSM(欧洲)、CDMA(北美)</td></tr><tr><td style="text-align: center;">3G</td><td style="text-align: center;">数字技术</td><td style="text-align: center;">话音、数据通信</td><td style="text-align: center;">CDMA标准的码分复用</td><td style="text-align: center;">WCDMA(欧洲, 中国联通)<br>CDMA-2000(北美, 中国电信) <br>TDSCDMA(中国移动)</td></tr><tr><td style="text-align: center;">4G</td><td style="text-align: center;">数字技术</td><td style="text-align: center;">数据通信</td><td style="text-align: center;">正交频分复用OFDM</td><td style="text-align: center;">TD-LTE、FDD-LTE</td></tr><tr><td style="text-align: center;">5G</td><td style="text-align: center;">数字技术</td><td style="text-align: center;">数据通信</td><td style="text-align: center;">都会用到</td><td style="text-align: center;"></td></tr></tbody></table><h2 id="物理层的传输介质">2.8 物理层的传输介质</h2><h3 id="传输介质及分类">2.8.1 传输介质及分类</h3><ol type="1"><li>传输介质<ol type="1"><li>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路</li><li>传输媒体并不是物理层</li><li>传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层</li><li>在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了<strong>电气特性</strong>，因此能够识别所传送的比特流</li></ol></li><li>传输介质的分类<ol type="1"><li>导向性传输介质：<ol type="1"><li>电磁波被导向沿着固体媒介(铜线/光纤)传播</li></ol></li><li>非导向性传输介质：<ol type="1"><li>自由空间，介质可以是空气、真空、海水灯</li></ol></li></ol></li></ol><h3 id="导向性传输介质双绞线">2.8.2 导向性传输介质：双绞线</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113190911864.png" alt="image-20221113190911864" style="zoom:80%;" /></p><ol type="1"><li>双绞线是古老、又最常用的传输介质</li><li>它由<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的<strong>铜导线</strong>组成</li><li><strong>绞合可以减少对相邻导线的电磁干扰</strong></li><li>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<strong>金属丝</strong>编织成的屏蔽层，这就是<strong>屏蔽双绞线(STP)</strong>，无屏蔽层的双绞线就称为<strong>非屏蔽双绞线(UTP)</strong></li><li>特点：<ol type="1"><li>双绞线价格<strong>便宜</strong>，是最常用的传输介质之一，在局域网和传统电话网中普遍使用</li><li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里</li><li>距离太远时，对于<strong>模拟传输</strong>，要用<strong>放大器</strong>放大衰减的信号；对于<strong>数字传输</strong>，要用<strong>中继器</strong>将失真的信号整形</li></ol></li></ol><h3 id="导向性传输介质同轴电缆">2.8.3 导向性传输介质：同轴电缆</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113191213938.png" alt="image-20221113191213938" style="zoom:80%;" /></p><ol type="1"><li>同轴电缆由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层构成</li><li>按特性阻抗数值的不同，通常将同轴电缆分为两类：50Ω同轴电缆和75Ω同轴电缆。<ol type="1"><li>50Ω同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，它在局域网中得到广泛应用</li><li>75Ω同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，它主要用于有线电视系统</li></ol></li><li>同轴电缆 vs 双绞线<ol type="1"><li>由于外导体屏蔽层的作用，同轴电缆<strong>抗干扰特性</strong>比双线好，被广泛用于传输较高，速率的数据，其传输距离更远</li><li>但价格较双绞线贵</li></ol></li></ol><h3 id="导向性传输介质光纤">2.8.4 导向性传输介质：光纤</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113191544856.png" alt="image-20221113191544856" style="zoom:80%;" /></p><ol type="1"><li><p>光纤通信就是利用光导纤维(简称光纤)传递光脉冲来进行通信。有光脉冲表示1，无光脉冲表示0</p></li><li><p>而可见光的频率大约是10MHz，因此光纤通信系统的<strong>带宽远远大于</strong>目前其他各种传输媒体的带宽</p></li><li><p>光纤主要由<strong>纤芯(实心的!)</strong>和<strong>包层</strong>构成</p><ol type="1"><li>光波通过纤芯进行传导，包层较纤芯有较低的折射率</li><li>当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角</li><li>因此，如果入射角足够大，就会出现全反射，即光线碰到包，层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去</li></ol></li><li><p>多模光纤与单模光纤</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113191723325.png" alt="image-20221113191723325" style="zoom:80%;" /></p></li><li><p>特点：</p><ol type="1"><li>传输<strong>损耗小</strong>，中继距离长，对远距离传输特别经济</li><li><strong>抗雷电</strong>和<strong>电磁干扰</strong>性能好</li><li>无串音干扰，保密性好，也<strong>不易被窃听或截取数据</strong></li><li><strong>体积小，重量轻</strong></li></ol></li></ol><h3 id="非导向性传输介质">2.8.5 非导向性传输介质</h3><ol type="1"><li>无线电波：<ol type="1"><li>信号向所有方向传播</li><li>较强<strong>穿透能力</strong>，可传远距离</li><li>广泛应用于通信领域</li></ol></li><li>微波：<ol type="1"><li>信号固定方向传播</li><li>微波通信频率较高、频段范围宽，因此数据率很高</li><li>应用于地面微波接力通信、卫星通信</li><li>卫星通信：<ol type="1"><li>优点：通信容量大、距离远、覆盖广、广播通信和多址通信</li><li>缺点：传播时延长(250~270ms)、受气候影响大、误码率高、成本高</li></ol></li></ol></li><li>红外线、激光：<ol type="1"><li>信号固定方向传播</li><li>把要传输的信号分别<strong>转换为各自的信号格式</strong>，即红外信号和激光信号，再向空间中传播</li></ol></li></ol><h3 id="总结-6">2.8.6 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113192314851.png" alt="image-20221113192314851" style="zoom:80%;" /></p><h2 id="物理层设备">2.9 物理层设备</h2><h3 id="中继器">2.9.1 中继器</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113192538817.png" alt="image-20221113192538817" style="zoom:80%;" /></p><ol type="1"><li>诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误</li><li>中继器的功能：对信号进行<strong>再生</strong>和<strong>还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度</li><li>中继器的两端：<ol type="1"><li>两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类</strong>网络的互连，且两个网段速率要相同</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据</li><li>两端可连相同媒体，也可连不同媒体</li><li>中继器两端的网段一定要是同一个协议。(中继器不会存储转发)</li></ol></li><li><strong>5-4-3规则</strong>：<ol type="1"><li>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障</li><li>只能有最多不超过<strong>5</strong>个网段，最多有<strong>4</strong>个物理层的设备，只有<strong>3</strong>个段可以挂接计算机</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113192930270.png" alt="image-20221113192930270" style="zoom:80%;" /></p><h3 id="集线器多口中继器">2.9.2 集线器(多口中继器)</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113193026268.png" alt="image-20221113193026268" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113193631458.png" alt="image-20221113193631458" style="zoom:80%;" /></p><ol type="1"><li>集线器的功能：对信号进行<strong>再生放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有(除输入端口外)处于工作，状态的端口上，以增加信号传输的距离，延长网络的长度<ol type="1"><li>不具备信号的定向传送能力，是一个共享式设备【广播】</li></ol></li></ol><h2 id="物理层总结">2.10 物理层总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221113193707636.png" alt="image-20221113193707636" style="zoom:80%;" /></p><h1 id="chapter-3数据链路层">Chapter 3：数据链路层</h1><h2 id="数据链路层功能概述">3.1 数据链路层功能概述</h2><h3 id="数据链路层的相关概念">3.1.1 数据链路层的相关概念</h3><ol type="1"><li><strong>结点</strong>：主机、路由器</li><li><strong>链路</strong>：网络中两个结点之间的<strong>物理通道</strong><ol type="1"><li>链路的传输介质主要有双绞线、光纤和微波</li><li>链路分为有线链路、无线链路。</li></ol></li><li><strong>数据链路</strong>：网络中两个结点之间的<strong>逻辑通道</strong>，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路</li><li><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报</li><li><strong>数据链路层</strong>负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报</li></ol><h3 id="数据链路层的功能">3.1.2 数据链路层的功能</h3><p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据<strong>可靠</strong>地传输到相邻节点的目标机网络层。其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115102409340.png" alt="image-20221115102409340" style="zoom:80%;" /></p><ol type="1"><li>为网络层提供服务：<ol type="1"><li>无确认无连接服务：通信质量好的有线通信</li><li>有确认无连接服务：无线通信</li><li>有确认面向连接服务：无线通信</li><li><strong>有连接一定有确认</strong></li></ol></li><li>链路管理：<ol type="1"><li>连接的建立、维持、释放</li><li>用于面向连接的服务</li></ol></li><li>组帧</li><li>流量控制<ol type="1"><li>限制发送方</li></ol></li><li>差错控制<ol type="1"><li>帧错</li><li>位错</li></ol></li></ol><h2 id="封装成帧-透明传输">3.2 封装成帧 &amp; 透明传输</h2><h3 id="封装成帧">3.2.1 封装成帧</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115103117195.png" alt="image-20221115103117195" style="zoom:80%;" /></p><ol type="1"><li><strong>封装成帧</strong>：在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束</li><li>首部和尾部包含很多控制信息，其中一个重要的作用为：<strong>帧定界</strong>（确定帧的界限）</li><li><strong>帧同步</strong>：<strong>接收方</strong>应当能从接收到的二进制比特流中区分出帧的起始和终止</li></ol><h3 id="透明传输">3.2.2 透明传输</h3><ol type="1"><li><strong>透明传输</strong>：指不管所传的数据是什么样的比特组合，都应当能够在链路上传输。因此，链路层就“看不见”有什么妨碍数据传输的东西</li><li>当所传的数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使得接收方不会将这样的数据误认为时某种控制信息。这样才能保证数据链路层的传输是透明的</li></ol><h3 id="组帧的四种方法">3.2.3 组帧的四种方法</h3><h4 id="字符计数法">3.2.3.1 字符计数法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115103709113.png" alt="image-20221115103709113" style="zoom: 67%;" /></p><ol type="1"><li>帧首部使用一个计数字段(第一个<strong>字节</strong>，8位)来表明帧内字符(节)数</li><li>缺点：一旦第一个字节出错，后面所有的帧都会跟着出错</li></ol><h4 id="字符节填充法">3.2.3.2 字符(节)填充法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115103822523.png" alt="image-20221115103822523" style="zoom: 67%;" /></p><ol type="1"><li>SOH和EOT具体指什么，根据具体的协议而定</li><li>当传送的帧由ASCII码文本文件组成时，不管键盘上输入的是什么字符，都可以放在帧里传过去，即<strong>透明传输</strong></li><li>当传送的帧是由非ASCII码的文本文件组成时(二进制代码或图像等)，就要<strong>采用字符填充方法实现透明传输</strong></li><li>字符填充法：在数据中的EOT/SOH前方添加一个<strong>转义字符ESC</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115104254949.png" alt="image-20221115104254949" style="zoom:80%;" /></p><h4 id="零比特填充法重点">3.2.3.3零比特填充法(<strong>重点</strong>)</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115104336747.png" alt="image-20221115104336747" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115104456514.png" alt="image-20221115104456514" style="zoom:67%;" /></p><ol type="1"><li>发送端：扫描整个信息字段，只要连续5个1，就立即填入1个0</li><li>接收端：先找到标志字段确定边界，再对比特流进行扫描，发现连续5个1时，就把后面的0删除</li></ol><h4 id="违规编码法">3.2.3.4 违规编码法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115104613011.png" alt="image-20221115104613011" style="zoom:80%;" /></p><ol type="1"><li>用两个编码中不会用到的电平，表示帧的开始和结束</li><li>目前普遍使用的帧同步法是：<strong>比特填充</strong>和<strong>违规编码</strong></li></ol><h2 id="差错控制">3.3 差错控制</h2><h3 id="检错编码">3.3.1 检错编码</h3><h4 id="差错从何而来">3.3.1.1 差错从何而来</h4><ol type="1"><li>概括来说，传输中的差错都是由于噪声引起的</li><li>全局性差错：由于线路本身电气特性所产生的<strong>随机噪声</strong>(热噪声)，是信道固有的，随机存在的<ol type="1"><li>解决办法：提高信噪比来减少或避免干扰(对传感器下手)</li></ol></li><li>局部性：外界特定的短暂原因所造成的<strong>冲击噪声</strong>，是产生差错的主要原因。<ol type="1"><li>解决办法：通常利用编码技术来解决</li></ol></li><li>差错的分类<ol type="1"><li>位错：比特位出错，1变成0，0变成1</li><li>帧错：【#1】-【#2】-【#3】<ol type="1"><li>帧丢失：【#1】-【#3】</li><li>帧重复：【#1】-【#2】-【#2】-【#3】</li><li>帧失序：【#1】-【#3】-【#2】</li></ol></li></ol></li></ol><h4 id="数据链路层的差错控制比特错">3.3.1.2数据链路层的差错控制(比特错)</h4><ol type="1"><li>差错控制(比特错)<ol type="1"><li>检错编码：奇偶校验码、循环冗余码CRC</li><li>纠错编码：海明码</li></ol></li><li>数据链路层的编码 vs 物理层的编码<ol type="1"><li>数据链路层编码和物理层的数据编码与调制不同</li><li>物理层编码针对的是<strong>单个比特</strong>，解决传输过程中比特的同步等问题，如曼彻斯特编码</li><li>而数据链路层的编码针对的是<strong>一组比特</strong>，它通过冗余码的技术实现一组二进制比特串在传输过程是否出现了差错</li></ol></li><li>冗余编码<ol type="1"><li>在数据发送之前，先按某种关系<strong>附加</strong>上一定的<strong>冗余位</strong>，构成一个符合某一规则的码字后再发送</li><li>当要发送的有效数据变化时，相应的冗余位也随之变化，使码字遵从不变的规则</li><li>接收端根据收到码字是否仍符合原规则，从而判断是否出错。</li></ol></li></ol><h5 id="检错编码奇偶校验码">3.3.1.2.1 检错编码：奇偶校验码</h5><ol type="1"><li>奇偶校验码：<strong>n-1</strong>位信息元，1位校验元<ol type="1"><li>奇校验码：”1“的个数是奇数</li><li>偶校验码：”1“的个数是偶数</li><li>注意，这里的个数包含校验元本身</li></ol></li><li>特点：只能检查出<strong>奇数个比特</strong>错误，检错能力位50%</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115110125756.png" alt="image-20221115110125756" style="zoom:67%;" /></p><h5 id="检错编码crc循环冗余码重点">3.3.1.2.2检错编码：CRC循环冗余码(<strong>重点</strong>)</h5><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115110614634.png" alt="image-20221115110614634" style="zoom:80%;" /></p><ol type="1"><li><p>最终发送的数据：要发送的数据 + 帧检验序列FCS</p></li><li><p>计算冗余码</p><ol type="1"><li>加0：若生成多项式的G(x)的阶为r，则加r个0</li><li>模2除法：数据加0后除以多项式，余数为冗余码/FCS/CRC校验码的比特序列</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115111043531.png" alt="image-20221115111043531" style="zoom:80%;" /></p></li><li><p>接收端检测的过程：</p><ol type="1"><li>把收到的每一个帧都除以同样的除数，然后检查得到的余数R<ol type="1"><li>余数为0，判定这个帧没有差错，接受。</li><li>余数为不为0，判定这个帧有差错(无法确定到位)，丢弃</li></ol></li><li>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输</li></ol></li><li><p>在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对帧的无差错接收，即“<strong>凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错</strong>”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。“凡是接收端数据链路层接收的帧均无差错”</p><ol type="1"><li><strong>可靠传输</strong>：数据链路层发送端发送什么，接收端就收到什么</li><li>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输</li></ol></li></ol><h3 id="纠错编码海明码重点">3.3.2纠错编码：海明码(<strong>重点</strong>)</h3><p>海明码：<strong>发现双</strong>比特错，<strong>纠正单</strong>比特错</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115111706921.png" alt="image-20221115111706921" style="zoom:80%;" /></p><ol type="1"><li><p>海明不等式：<span class="math inline">\(2^r \gek+r+1\)</span></p><ol type="1"><li><span class="math inline">\(r\)</span>：冗余信息位</li><li><span class="math inline">\(k\)</span>：信息位</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115111801363.png" alt="image-20221115111801363" style="zoom: 67%;" /></p></li><li><p>确定校验码和数据的位置</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115111902445.png" alt="image-20221115111902445" style="zoom:80%;" /></p></li><li><p>求校验码的值</p><ol type="1"><li>要校验的位：<ol type="1"><li>如1的二进制表示为0001，则P<sub>1</sub>要校验的位为：P<sub>1</sub>、D<sub>1</sub>(0011)、D<sub>2</sub>(0101)、D<sub>4</sub>(0111)、D<sub>5</sub>(1001)</li><li>如2的二进制表示为0010，则P<sub>2</sub>要校验的位为：P<sub>2</sub>、D<sub>1</sub>(0011)、D<sub>3</sub>(0110)、D<sub>4</sub>(0111)、D<sub>6</sub>(1010)</li></ol></li><li>校验码的值<ol type="1"><li><strong>令所有要校验的位异或=0</strong></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115112532663.png" alt="image-20221115112532663" style="zoom:80%;" /></p></li><li><p>检错并纠错</p><ol type="1"><li><strong>令所有要校验的位异或运算</strong></li><li>异或出来的结果逆序排列，所得结果即为出错的位置</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115112835685.png" alt="image-20221115112835685" style="zoom:80%;" /></p></li></ol><h3 id="总结-7">3.3.3 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221115112859589.png" alt="image-20221115112859589" style="zoom:80%;" /></p><h2 id="流量控制与可靠传输">3.4 流量控制与可靠传输</h2><p><strong>较高的发送速度</strong>和<strong>较低的接收能力</strong>的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作</p><h3 id="流量控制与可靠传输机制">3.4.1 流量控制与可靠传输机制</h3><h4 id="数据链路层的流量控制-与-传输层流量控制的区别">3.4.1.1数据链路层的流量控制 与 传输层流量控制的区别</h4><ol type="1"><li><strong>数据链路层</strong>的流量控制是：<strong>点对点</strong>的(两个相邻节点之间)</li><li><strong>传输层</strong>的流量控制是：<strong>端到端</strong>的(两个主机之间)</li><li><strong>数据链路层</strong>流量控制手段：接收方收不下就不回复确认</li><li><strong>传输层</strong>流量控制手段：接收端给发送端一个窗口公告</li></ol><h4 id="流量控制的方法">3.4.1.2 流量控制的方法</h4><ol type="1"><li><p>停止-等待协议：每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117211143333.png" alt="image-20221117211143333" style="zoom:67%;" /></p></li><li><p>滑动窗口协议：<strong>链路层中，窗口的大小在发送过程中为固定值</strong></p><ol type="1"><li>后退N帧协议：GBN</li><li>选择重传协议：SR</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117211302482.png" alt="image-20221117211302482" style="zoom:67%;" /></p></li></ol><table><thead><tr><th style="text-align: center;">协议</th><th style="text-align: center;">发送窗口大小</th><th style="text-align: center;">接收窗口大小</th></tr></thead><tbody><tr><td style="text-align: center;">停止-等待协议</td><td style="text-align: center;">=1</td><td style="text-align: center;">=1</td></tr><tr><td style="text-align: center;">后退N帧协议：GBN</td><td style="text-align: center;">&gt;1</td><td style="text-align: center;">=1</td></tr><tr><td style="text-align: center;">选择重传协议：SR</td><td style="text-align: center;">&gt;1</td><td style="text-align: center;">&gt;1</td></tr></tbody></table><h4 id="可靠传输流量控制滑动窗口">3.4.1.3可靠传输、流量控制、滑动窗口</h4><ol type="1"><li>可靠传输：发送端发啥，接收端收啥</li><li>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧</li><li>滑动窗口解决：<ol type="1"><li>流量控制：收不下就不给确认，想发也发不了</li><li>可靠传输：发送方自动重传</li></ol></li></ol><h3 id="停止-等待协议">3.4.2 停止-等待协议</h3><ol type="1"><li>为什么要有停止-等待协议?<ol type="1"><li>除了比特出差错，底层信道还会出现丢包问题。</li><li>丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失</li></ol></li><li>研究停等协议的前提?<ol type="1"><li>虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据(发送方)，一方接收数据(接收方)</li><li>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的</li><li>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</li></ol></li><li>停等协议有几种应用情况?<ol type="1"><li>无差错情况&amp;有差错情况</li></ol></li></ol><h4 id="停止-等待协议无差错情况">3.4.2.1 停止-等待协议：无差错情况</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117212318210.png" alt="image-20221117212318210" style="zoom:80%;" /></p><h4 id="停止-等待协议有差错情况">3.4.2.2 停止-等待协议：有差错情况</h4><ol type="1"><li><p>数据帧丢失 / 检测到帧出错</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117212602243.png" alt="image-20221117212602243" style="zoom: 67%;" /></p></li><li><p>ACK丢失</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117212647980.png" alt="image-20221117212647980" style="zoom:67%;" /></p></li><li><p>ACK迟到</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117212727252.png" alt="image-20221117212727252" style="zoom:67%;" /></p></li></ol><h4 id="停止-等待协议性能分析">3.4.2.3 停止-等待协议：性能分析</h4><p>优点：</p><ol type="1"><li>简单</li></ol><p>缺点：</p><ol type="1"><li>信道利用率太低</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117212856763.png" alt="image-20221117212856763" style="zoom:80%;" /></p><h4 id="信道利用率">3.4.2.4 信道利用率</h4><p>信道利用率：发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率</p><ol type="1"><li>信道利用率 = <span class="math inline">\((L / C)/T\)</span></li><li><span class="math inline">\(L\)</span>：<spanclass="math inline">\(T\)</span>时间内发送<spanclass="math inline">\(L\)</span>比特数据</li><li><span class="math inline">\(C\)</span>：发送方数据传输率</li><li><spanclass="math inline">\(T\)</span>：发送周期，从开始发送数据，到收到第一个确认帧为止</li></ol><p>信道吞吐率 = 信道利用率 × 发送方的发送速率</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117213239451.png" alt="image-20221117213239451" style="zoom:80%;" /></p><h4 id="总结-8">3.4.2.5 总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117213301011.png" alt="image-20221117213301011" style="zoom:80%;" /></p><h3 id="后退n帧协议-go-back-n">3.4.3 后退N帧协议 Go Back N</h3><h4 id="停止等待协议的弊端">3.4.3.1 停止等待协议的弊端</h4><ol type="1"><li>信道利用率过低</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117220840158.png" alt="image-20221117220840158" style="zoom: 67%;" /></p><h4 id="后退n帧协议中的滑动窗口">3.4.3.2 后退N帧协议中的滑动窗口</h4><ol type="1"><li>发送窗口：发送方维持一组连续的允许发送的帧的序号</li><li>接收窗口：接收方维持一组连续的允许接收的帧的序号</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117221239590.png" alt="image-20221117221239590" style="zoom:67%;" /></p><h4 id="gbn发送方">3.4.3.3 GBN发送方</h4><ol type="1"><li>上层的调用<ol type="1"><li>上层要发送数据时，发送方先检查发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧并将其发送</li><li>如果窗口<strong>已满</strong>，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送</li><li>实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧</li></ol></li><li>收到了一个ACK<ol type="1"><li>GBN协议中，对n号帧的确认采用<strong>累积确认</strong>的方式，标明接收方已经收到n号帧和它之前的全部帧。</li></ol></li><li>超时事件<ol type="1"><li>协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为</li><li>就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失</li><li>如果出现超时，发送方重传所有已发送但未被确认的帧</li></ol></li></ol><h4 id="gbn接收方">3.4.3.4 GBN接收方</h4><ol type="1"><li>如果正确收到n号帧，并且<strong>按序</strong>，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层</li><li>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK<ol type="1"><li>接收方无需缓存任何失序帧，只需要维护一个信息：expectedseqnum(下一个按序接收的帧序号)</li></ol></li></ol><h4 id="运行中的gbn协议">3.4.3.5 运行中的GBN协议</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117222217016.png" alt="image-20221117222217016" style="zoom:80%;" /></p><h4 id="滑动窗口长度发送窗口最大为2n-1接收窗口为1">3.4.3.6滑动窗口长度：发送窗口最大为<spanclass="math inline">\(2^{n}-1\)</span>，接收窗口为1</h4><p>窗口大小和序号大小相比，窗口大小过大时，可能导致</p><ol type="1"><li>接收方并不知道收到的0号帧是新的还是旧的</li></ol><h4 id="gbn协议重点总结">3.4.3.7 GBN协议重点总结</h4><ol type="1"><li>累计确认：ACK N表示0~N都已经正常收到</li><li>捎带确认：将确认帧放到接收方要发送的数据中</li><li>接收方只按顺序接收帧，不按序都丢弃</li><li>确认序列号最大的、按序到达的帧</li><li>发送窗口最大为<spanclass="math inline">\(2^{n}-1\)</span>，接收窗口大小为1</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117223002240.png" alt="image-20221117223002240" style="zoom:80%;" /></p><h4 id="gbn协议性能分析">3.4.3.8 GBN协议性能分析</h4><p>优点：</p><ol type="1"><li>因连续发送数据帧而提高了信道利用率</li></ol><p>缺点：</p><ol type="1"><li>在重传时必须把原来已经正确传送的数据帧重传，是传送效率降低</li></ol><h4 id="总结-9">3.4.3.9 总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117223109038.png" alt="image-20221117223109038" style="zoom:80%;" /></p><h3 id="选择重传协议-selective-repeat">3.4.4 选择重传协议 SelectiveRepeat</h3><h4 id="gbn协议的弊端">3.4.4.1 GBN协议的弊端</h4><ol type="1"><li>累计确认 ==&gt; 批量重传</li><li>解决方法：只重传出错的帧<ol type="1"><li>设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧</li></ol></li></ol><h4 id="选择重传协议中的滑动窗口">3.4.4.2 选择重传协议中的滑动窗口</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117214705045.png" alt="image-20221117214705045" style="zoom:80%;" /></p><h4 id="sr发送方">3.4.4.3 SR发送方</h4><ol type="1"><li><p>上层的调用</p><ol type="1"><li>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧</li><li>否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输</li></ol></li><li><p>收到了一个ACK</p><ol type="1"><li>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收</li><li>如果该帧序号是窗口的下界(最左边第一个窗口对应的序号)，则窗口向前移动到具有最小序号的未确认帧处</li><li>如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117215330140.png" alt="image-20221117215330140" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117215306773.png" alt="image-20221117215306773" style="zoom:80%;" /></p></li><li><p>超时事件</p><ol type="1"><li>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧</li></ol></li></ol><h4 id="sr接收方">3.4.4.4 SR接收方</h4><p>来者不拒(窗口内的帧)</p><ol type="1"><li>SR接收方将<strong>确认一个正确接收的帧</strong>而<strong>不管其是否按序</strong></li><li>失序的帧将被<strong>缓存</strong>，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有帧(即序号更小的帧)皆被收到为止</li><li>这时才可以将一批帧按序交付给上层，然后向前移动滑动窗口</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117215537537.png" alt="image-20221117215537537" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117215630148.png" alt="image-20221117215630148" style="zoom:80%;" /></p><h4 id="运行中的sr">3.4.4.5 运行中的SR</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117215928586.png" alt="image-20221117215928586" style="zoom:80%;" /></p><h4 id="滑动窗口长度发送窗口接收窗口最大为2n-1">3.4.4.6滑动窗口长度：发送窗口=接收窗口，最大为<spanclass="math inline">\(2^{n-1}\)</span></h4><p>窗口大小和序号大小相比，窗口大小过大时，可能导致</p><ol type="1"><li>接收方并不知道收到的0号帧是新的还是旧的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117220136622.png" alt="image-20221117220136622" style="zoom:80%;" /></p><p>滑动窗口大小的设置：</p><ol type="1"><li>发送窗口最好等于接收窗口<ol type="1"><li>大了会溢出，小了没意义</li></ol></li><li><span class="math inline">\(W_{Tmax}=W_{Rmax}=2^{n-1}\)</span><ol type="1"><li><span class="math inline">\(n\)</span>为编号的位数</li></ol></li></ol><h4 id="sr协议重点总结">3.4.4.7 SR协议重点总结</h4><ol type="1"><li>对数据逐一确认，收一个确认一个</li><li>只重传出错帧</li><li>接收方有缓存</li><li><span class="math inline">\(W_{Tmax}=W_{Rmax}=2^{n-1}\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117220548869.png" alt="image-20221117220548869" style="zoom:80%;" /></p><h4 id="总结-10">3.4.4.8 总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117220607511.png" alt="image-20221117220607511" style="zoom:80%;" /></p><h2 id="介质访问控制">3.5 介质访问控制</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122113957794.png" alt="image-20221122113957794" style="zoom:80%;" /></p><h3 id="信道划分介质访问控制">3.5.1 信道划分介质访问控制</h3><h4 id="传输数据使用的两种链路">3.5.1.1 传输数据使用的两种链路</h4><ol type="1"><li>点对点链路<ol type="1"><li>两个相邻节点通过一个链路相连，没有第三者</li><li>应用：PPP协议，常用于<strong>广域网</strong></li></ol></li><li>广播式电路<ol type="1"><li>所有主机共享通信介质</li><li>应用：早期的总线以太网、无线局域网，常用于<strong>局域网</strong></li><li>典型拓扑结构：<ol type="1"><li>总线型</li><li>星型：逻辑总线型，中心一般是一个集线器，更加灵活</li></ol></li></ol></li></ol><h4 id="介质访问控制-1">3.5.1.2 介质访问控制</h4><p>介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况</p><ol type="1"><li>静态划分信道：信道划分介质访问控制<ol type="1"><li>频分多路复用 FDM</li><li>时分多路复用 TDM</li><li>波分多路复用 WDM</li><li>码分多路复用 CDM</li></ol></li><li>动态划分信道<ol type="1"><li>轮询访问介质控制<ol type="1"><li>令牌传递协议</li></ol></li><li>随机访问介质访问控制<ol type="1"><li>ALOHA协议</li><li>CSMA协议</li><li>CSMA/CD协议</li><li>CSMA/CA协议</li></ol></li></ol></li></ol><h4 id="信道划分介质访问控制-1">3.5.1.3 信道划分介质访问控制</h4><ol type="1"><li>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的<strong>通信隔离开</strong>，把<strong>时域和频域资源</strong>合理的分配给网络上的设备</li><li>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备<strong>共享信道资源</strong>，提高信道利用率</li><li><strong>实际就是把广播信道转变为点对点信道</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122101917849.png" alt="image-20221122101917849" style="zoom:80%;" /></p><h5 id="频分多路复用-fdm">3.5.1.3.1 频分多路复用 FDM</h5><ol type="1"><li>所有用户在同样时间，占用不同的带宽(频率带宽)资源</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122102140039.png" alt="image-20221122102140039" style="zoom:80%;" /></p><h5 id="时分多路复用-tdm">3.5.1.3.2 时分多路复用 TDM</h5><ol type="1"><li>将时间划分为一段段等长的时分复用帧(TDM帧)</li><li>每个用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道</li><li>若一个TDM帧为8000b/s，则每个人最高2000b/s</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122102417465.png" alt="image-20221122102417465" style="zoom:80%;" /></p><h5 id="改进的时分复用统计时分复用-stdm">3.5.1.3.3改进的时分复用：统计时分复用 STDM</h5><ol type="1"><li>若一个STDM帧为8000b/s，则每个人最高8000b/s</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122102547421.png" alt="image-20221122102547421" style="zoom:80%;" /></p><h5 id="波分多路复用-wdm">3.5.1.3.4 波分多路复用 WDM</h5><ol type="1"><li>波分多路复用：就是<strong>光的频分多路复用</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122102939945.png" alt="image-20221122102939945" style="zoom:80%;" /></p><h5 id="码分多路复用-cdm重点">3.5.1.3.5 码分多路复用CDM(<strong>重点</strong>)</h5><ol type="1"><li><p><strong>码分多址CDMA</strong>：码分复用的一种方式</p></li><li><p>1个比特分为多个码片/芯片(chip)，每个站点指定一个唯一的m位的芯片序列</p></li><li><p>发送1时站点发送芯片序列，发送0时发送芯片序列的反码(通常把0写成-1)</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">A</th><th style="text-align: center;">B</th></tr></thead><tbody><tr><td style="text-align: center;">芯片序列</td><td style="text-align: center;">+1 -1 -1 +1 +1 +1 +1 -1</td><td style="text-align: center;">-1 +1 -1 +1 -1 +1 +1 +1</td></tr><tr><td style="text-align: center;">反码</td><td style="text-align: center;">-1 +1 +1 -1 -1 -1 -1 +1</td><td style="text-align: center;">+1 -1 +1 -1 +1 -1 -1 -1</td></tr></tbody></table></li><li><p><strong>如何不打架</strong>：多个站点同时发送数据时，要求每个站点<strong>芯片序列相互正交</strong>(规格内积化为0)</p><ol type="1"><li>即A和B发送的数据，对应位相乘再相加，结果为0</li></ol></li><li><p><strong>如何合并</strong>：各路数据在信道中被<strong>线性相加</strong></p><ol type="1"><li>如A发送0，B发送1，则为(-2 +2 0 0 -2 0 0 +2)</li></ol></li><li><p><strong>如何分离</strong>：合并的数据与源站的芯片序列规格化内积</p><ol type="1"><li>A发送的数据：(+1 -1 -1 +1 +1 +1 +1 -1) · (-2 +2 0 0 -2 0 0 +2) / 8 =-1 ==&gt; 0</li><li>B发送的数据：(-1 +1 -1 +1 -1 +1 +1 +1) · (-2 +2 0 0 -2 0 0 +2) / 8 =1 ==&gt; 1</li></ol></li></ol><h4 id="cd还是cs">3.5.1.4 CD还是CS</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122104208664.png" alt="image-20221122104208664" style="zoom:80%;" /></p><h3 id="aloha协议">3.5.2 ALOHA协议</h3><h4 id="纯aloha协议">3.5.2.1 纯ALOHA协议</h4><p>纯ALOHA协议思想：不监听信道，不按时间发送，随即重发。<strong>想发就发</strong></p><ol type="1"><li>冲突检测：如果发生冲突，接收方就会检测出差错，然后不予确认，发送方在一定时间内收不到ACK就判断发生冲突</li><li>冲突解决：超时后等一段随机的时间，然后重传</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122104659713.png" alt="image-20221122104659713" style="zoom:80%;" /></p><h4 id="时隙aloha协议">3.5.2.2 时隙ALOHA协议</h4><p>时隙ALOHA协议思想：把时间分为若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，如果发生冲突，则必须等到下一个时间片开始时刻再发送。<strong>控制想发就发的随意性</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122105526808.png" alt="image-20221122105526808" style="zoom:80%;" /></p><h4 id="关于aloha协议">3.5.2.3 关于ALOHA协议</h4><ol type="1"><li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低</li><li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发</li></ol><h3 id="csma协议">3.5.3 CSMA协议</h3><p>CSMA：载波监听多路访问协议，carrier sense multiple access</p><ol type="1"><li><strong>CS</strong>：载波侦听/监听，每一个站在<strong>发送数据之前</strong>要检测一下总线上是否有其他计算机在发送数据<ol type="1"><li>检测方法：当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</li></ol></li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>协议思想</strong>：发送帧之前，<strong>监听</strong>信道</li><li>监听结果：<ol type="1"><li>信道空闲：发送完整帧<ol type="1"><li>1-坚持CSMA</li><li>非坚持CSMA</li><li>p-坚持CSMA</li></ol></li><li>信道忙：推迟发送</li></ol></li></ol><h4 id="坚持csma">3.5.3.1 1-坚持CSMA</h4><ol type="1"><li>坚持：指的是对于<strong>监听信道忙</strong>之后的坚持</li><li>1-坚持CSMA思想：<ol type="1"><li>如果一个主机要发送消息，那么它先监听信道</li><li><strong>空闲则直接传输，不必等待</strong></li><li><strong>忙则一直监听，直到空闲马上传输</strong></li><li>如果<strong>有冲突</strong>(一段时间内未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程</li></ol></li><li><strong>优点</strong>：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失</li><li><strong>缺点</strong>：假如有两个或两个以上的站点有数据要发送，冲突就不可避免</li></ol><h4 id="非坚持csma">3.5.3.2 非坚持CSMA</h4><ol type="1"><li>非坚持：指的是对于<strong>监听信道忙</strong>之后就不继续监听</li><li>非坚持CSMA思想：<ol type="1"><li>如果一个主机要发送消息，那么它先监听信道</li><li><strong>空闲则直接传输，不必等待</strong></li><li><strong>忙则等待一个随机的时间，之后再进行监听</strong></li></ol></li><li>优点：采用随机的重发延迟时间可以减少冲突发生的可能性</li><li>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低</li></ol><h4 id="p-坚持csma">3.5.3.3 p-坚持CSMA</h4><ol type="1"><li>p-坚持指的是对于监听信道空闲的处理</li><li>p-坚持CSMA思想:<ol type="1"><li>如果一个主机要发送消息，那么它先监听信道</li><li><strong>空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输</strong></li><li><strong>忙则等待一个随机的时间之后再进行监听</strong></li></ol></li><li>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案</li><li>缺点：发生冲突后无法及时发现，仍会坚持把数据帧发完，造成浪费</li></ol><h4 id="三种csma对比总结">3.5.3.4 三种CSMA对比总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122112151722.png" alt="image-20221122112151722" style="zoom: 80%;" /></p><h3 id="csmacd协议">3.5.4 CSMA/CD协议</h3><p>CSMA/CD：载波监听多点接入/碰撞检测，carrier sense multiple accesswith collision detection</p><ol type="1"><li><strong>CS</strong>：载波侦听/监听，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>要检测一下总线上是否有其他计算机在发送数据</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。<strong>总线型网络</strong></li><li><strong>CD</strong>：碰撞检测(冲突检测)，<strong>“边发送边监听”</strong>，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。<strong>半双工网络</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122114347472.png" alt="image-20221122114347472" style="zoom:80%;" /></p><h4 id="传播时延对载波监听的影响">3.5.4.1 传播时延对载波监听的影响</h4><ol type="1"><li><span class="math inline">\(\tau\)</span>：端到端传播时延</li><li><spanclass="math inline">\(2\tau\)</span>：总线的端到端往返传播时延/争用期/冲突窗口/碰撞窗口</li><li>只要经过<spanclass="math inline">\(2\tau\)</span>时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122121634471.png" alt="image-20221122121634471" style="zoom:80%;" /></p><h4 id="如何确定碰撞后的重传时机">3.5.4.2 如何确定碰撞后的重传时机</h4><p><strong>阶段二进制指数规避算法</strong>：</p><ol type="1"><li>确定<strong>基本退避(推迟)时间</strong>为：争用期<spanclass="math inline">\(2\tau\)</span></li><li>定义参数k，它等于<strong>重传次数</strong>，但k不超过10，即<strong>k=min[重传次数，10]</strong><ol type="1"><li>当重传次数不超过10时，k等于重传次数</li><li>当重传次数大于10时，k就不再增大而一直等于10</li></ol></li><li>从离散的整数集合<strong>[0， 1， …，2<sup>k</sup>-1]</strong>中随机取出一个数r，重传所需要退避的时间就是<strong>r倍的基本退避时间</strong>，即<spanclass="math inline">\(2r\ \tau\)</span></li><li>当重传达<strong>16次</strong>仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122122233091.png" alt="image-20221122122233091" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122122321761.png" alt="image-20221122122321761" style="zoom: 67%;" /></p><h4 id="最小帧长-2tau-数据传输速率">3.5.4.3 最小帧长 = <spanclass="math inline">\(2\tau\)</span> × 数据传输速率</h4><ol type="1"><li>帧的传输时延至少要两倍于信号在总线中的传播时延</li><li><strong>最小帧长 = <span class="math inline">\(2\tau\)</span> ×数据传输速率</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122122456786.png" alt="image-20221122122456786" style="zoom:80%;" /></p><h4 id="总结-11">3.5.4.4 总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122122600976.png" alt="image-20221122122600976" style="zoom:80%;" /></p><h3 id="csmaca协议">3.5.5 CSMA/CA协议</h3><p>CSMA/CA：载波监听多点接入/碰撞避免，carrier sense multiple accesswith collision avoidance</p><ol type="1"><li>应用：无线局域网<ol type="1"><li>无法做到360°全面检测碰撞</li><li>隐蔽站：当A和C都检测不到信号，认为信道空闲时，同时向B发送数据帧，就会导致冲突</li></ol></li></ol><h4 id="csmaca协议工作原理">3.5.5.1 CSMA/CA协议工作原理</h4><ol type="1"><li>发送数据前，先检测信道是否空闲<ol type="1"><li>信道空闲：发出<strong>RTS (request to send)</strong>，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息</li><li>信道忙：等待</li></ol></li><li>接收端收到RTS后，将响应<strong>CTS (clear to send)</strong></li><li>发送端收到CTS后，开始发送数据帧(同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据)</li><li>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应<strong>ACK帧</strong></li><li>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止(采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间)</li></ol><h4 id="csmaca协议避免冲突的方法">3.5.5.2 CSMA/CA协议避免冲突的方法</h4><ol type="1"><li>预约信道</li><li>ACK帧</li><li>RTS/CTS帧：解决隐蔽站的问题，可以不使用</li></ol><h4 id="csmacd与csmaca">3.5.5.3 CSMA/CD与CSMA/CA</h4><p>相同点:</p><ol type="1"><li>CSMA/CD与CSMA/CA机制都从属于CSMA的思路，其核心是<strong>先听再说</strong></li><li>换言之，两个在接入信道之前都须要进行监听。当发现信道空闲后，才能进行接入</li></ol><p>不同点:</p><ol type="1"><li><strong>传输介质不同</strong>：CSMA/CD用于总线式以太网【有线】，而CSMA/CA用于无线局域网【无线】</li><li><strong>载波检测方式不同</strong>：因传输介质不同，CSMA/CD与CSMA/CA的检测方式也不同。<ol type="1"><li>CSMA/CD：通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化</li><li>CSMA/CA：采用能量检测(ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式</li></ol></li><li><strong>CSMA/CD检测冲突，CSMA/CA避免冲突</strong>，二者出现冲突后都会进行<strong>有上限的重传</strong></li></ol><h3 id="轮询访问介质访问控制">3.5.6 轮询访问介质访问控制</h3><ol type="1"><li>信道划分介质访问控制(<strong>MAC，Multiple AccessControl</strong>)协议：<strong>无冲突</strong><ol type="1"><li>基于<strong>多路复用技术</strong>划分资源</li><li>网络负载重：共享信道效率高，且公平</li><li>网络负载轻：共享信道效率低</li></ol></li><li>随机访问MAC协议：<strong>会发生冲突</strong><ol type="1"><li>用户根据意愿<strong>随机</strong>发送信息，发送信息时可独占信道带宽。</li><li>网络负载重：产生冲突开销</li><li>网络负载轻：共享信道效率高，单个结点可利用信道全部带宽</li></ol></li><li>轮询访问MAC协议/轮流协议/轮转访问MAC协议：<strong>无冲突</strong><ol type="1"><li>既要<strong>不产生冲突</strong>，又要发送时<strong>占全部带宽</strong></li><li>分为：轮询协议、令牌传递协议</li></ol></li></ol><h4 id="轮询协议">3.5.6.1 轮询协议</h4><p><strong>主节点轮流要求从属节点发送数据</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122112756494.png" alt="image-20221122112756494" style="zoom:80%;" /></p><p>缺点：</p><ol type="1"><li>轮询开销</li><li>等待延迟</li><li>单点故障：主节点宕机后，所有节点都无法发送数据</li></ol><h4 id="令牌传递协议">3.5.6.2 令牌传递协议</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122113100341.png" alt="image-20221122113100341" style="zoom:80%;" /></p><ol type="1"><li>令牌：一个特殊格式的MAC控制帧，不含任何信息<ol type="1"><li>控制信道的使用，确保同一时刻只有一个结点独占信道</li></ol></li><li>令牌环网无碰撞</li><li>发送过程：<ol type="1"><li>空闲时，令牌会在令牌环网中循环传递</li><li>当主机D要发送数据时，会修改令牌的标志位，同时将数据A附加到令牌上</li><li>令牌会按照令牌环的顺序，在令牌环网上循环一周</li><li>接收方收到包含数据的令牌时，会将数据拷贝一份，并且将自己得到的数据重新附加到令牌上</li><li>发送方再次接收到令牌时，查看令牌上的数据与自己发送的数据是否相同，判断是否发送成功</li></ol></li><li>每个节点都可以在一定时间(令牌持有时间)内获得发送数据的权力，并不是无限制的持有令牌</li><li>缺点：<ol type="1"><li>令牌开销</li><li>等待延迟</li><li>单点故障：一个节点故障，所有节点都无法发送数据</li></ol></li><li>应用于令牌环网<ol type="1"><li>物理：星型拓扑结构</li><li>逻辑：环形拓扑结构</li></ol></li><li>常用于<strong>负载较重、通信量较大</strong>的网络中</li></ol><h3 id="mac协议总结">3.5.7 MAC协议总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122113644706.png" alt="image-20221122113644706" style="zoom:80%;" /></p><h2 id="局域网以太网无线局域网">3.6 局域网、以太网、无线局域网</h2><h3 id="局域网的基本概念和体系结构">3.6.1局域网的基本概念和体系结构</h3><h4 id="局域网">3.6.1.1 局域网</h4><p>局域网(Local AreaNetwork)：简称<strong>LAN</strong>，是指在<strong>某一区域</strong>内由多台计算机互联成的计算机组，使用<strong>广播信道</strong></p><p>特点</p><ol type="1"><li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内</li><li>使用专门铺设的传输介质(双绞线、同轴电缆)进行联网，数据传输速率高(10Mb/s~10Gb/s)</li><li>通信延迟时间短，误码率低，可靠性较高</li><li>各站为平等关系，共享传输信道</li><li>多采用分布式控制和广播式通信，能进行广播和组播</li></ol><p>决定局域网的主要要素：</p><ol type="1"><li>网络拓扑</li><li>传输介质</li><li>介质访问控制方法</li></ol><h4 id="局域网拓扑结构">3.6.1.2 局域网拓扑结构</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122193904955.png" alt="image-20221122193904955" style="zoom:80%;" /></p><h4 id="局域网传输介质">3.6.1.3 局域网传输介质</h4><ol type="1"><li>有线局域网：双绞线、同轴电缆、光纤</li><li>无线局域网：电磁波</li></ol><h4 id="局域网介质访问控制方法">3.6.1.4 局域网介质访问控制方法</h4><ol type="1"><li>CSMA/CD：常用于<strong>总线型局域网</strong>，也用于树型网络</li><li>令牌总线：常用于<strong>总线型局域网</strong>，也用于树型网络<ol type="1"><li>它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环</li><li>只有令牌持有者才能控制总线，才有发送信息的权力</li></ol></li><li>令牌环：常用于<strong>环形局域网</strong>，如令牌环网</li></ol><h4 id="局域网的分类">3.6.1.5 局域网的分类</h4><ol type="1"><li><strong>以太网</strong><ol type="1"><li>以太网是应用最为广泛的局域网，包括标准以太网(10Mbps)、快速以太网(100Mbps)千兆以太网(1000Mbps)和10G以太网</li><li>它们都符合<strong>IEEE802.3</strong>系列标准规范</li><li>逻辑拓扑总线型，物理拓扑是星型或拓展星型</li><li>使用CSMA/CD.</li></ol></li><li><strong>令牌环网</strong><ol type="1"><li>物理上采用了星形拓扑结构，逻辑上是环形拓扑结构</li><li>已是“明日黄花”</li></ol></li><li>FDDI网(Fiber Distributed Data Interface)<ol type="1"><li>物理上采用了双环拓扑结构，逻辑上是环形拓扑结构</li></ol></li><li>ATM网(Asynchronous Transfer Mode)<ol type="1"><li>较新型的单元交换技术，使用53字节固定长度的单元进行交换</li></ol></li><li><strong>无线局域网</strong>(Wireless Local Area Network;<strong>WLAN</strong>)<ol type="1"><li>采用<strong>IEEE 802.11</strong>标准。</li></ol></li></ol><h4 id="ieee-802标准">3.6.1.6 IEEE 802标准</h4><ol type="1"><li>IEEE 802系列标准：是IEEE 802 LAN/MAN标准委员会制定的局域网、城域网技术标准(1980年2月成立)</li><li>其中最广泛使用的有以太网、令牌环、无线局域网等</li><li>这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责</li></ol><table><thead><tr><th style="text-align: center;">标准名</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr><td style="text-align: center;">IEEE 802.3</td><tdstyle="text-align: center;"><strong>以太网</strong>的介质访问控制协议(CSMA/CD)、物理层技术规范</td></tr><tr><td style="text-align: center;">IEEE 802.5</td><tdstyle="text-align: center;"><strong>令牌环网</strong>的介质访问控制协议、物理层技术规范</td></tr><tr><td style="text-align: center;">IEEE 802.8</td><td style="text-align: center;"><strong>光纤</strong>技术咨询组</td></tr><tr><td style="text-align: center;">IEEE 802.11</td><tdstyle="text-align: center;"><strong>无线局域网</strong>(WLAN)的介质访问控制协议、物理层技术规范</td></tr></tbody></table><h4 id="mac子层和llc子层">3.6.1.7 MAC子层和LLC子层</h4><ol type="1"><li><strong>LLC子层</strong>：逻辑链路控制子层，为<strong>网络层</strong>提供服务<ol type="1"><li>识别网络层协议，并进行封装</li><li>LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做如何处理</li><li>为网络层提供服务：无确认无连接、面向连接、带确认无连接、高速传送</li></ol></li><li><strong>MAC子层</strong>：介质访问控制子层，与<strong>物理层</strong>相关<ol type="1"><li>数据帧的封装/卸装</li><li>帧的寻址和识别</li><li>帧的接收与发送</li><li>链路的管理</li><li>帧的差错控制</li><li>屏蔽了不同物理链路种类的差异性</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122194906726.png" alt="image-20221122194906726" style="zoom:80%;" /></p><h4 id="总结-12">3.6.1.8 总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122194932952.png" alt="image-20221122194932952" style="zoom:80%;" /></p><h3 id="以太网-ethernet">3.6.2 以太网 Ethernet</h3><h4 id="以太网概述">3.6.2.1 以太网概述</h4><ol type="1"><li>以太网(<strong>Ethernet</strong>)指的是：由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的<strong>基带总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准</li><li>以太网络使用<strong>CSMA/CD</strong>(载波监听多路访问及冲突检测)技术</li><li>以太网在局域网各种技术中占统治性地位:<ol type="1"><li>造价低廉(以太网网卡不到100块)</li><li>是应用最广泛的局域网技术</li><li>比令牌环网、ATM网便宜，简单</li><li><strong>满足网络速率要求: 10Mb/s~10Gb/s</strong></li></ol></li><li>以太网两个标准<ol type="1"><li><strong>DIX Ethernet V2</strong>：第一个局域网产品(以太网)规约</li><li><strong>IEEE 802.3</strong>：IEEE802委员会802.3工作组制定的第一个IEEE的以太网标准，格式有一丢丢改动</li></ol></li><li>以太网，也叫802.3局域网</li></ol><h4 id="以太网提供无连接不可靠的服务">3.6.2.2以太网提供无连接、不可靠的服务</h4><ol type="1"><li><strong>无连接</strong>：发送方和接收方之间无“握手过程”</li><li><strong>不可靠</strong>：不对发送方的数据顿编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责</li><li><strong>以太网只实现无差错接收，不实现可靠传输</strong><ol type="1"><li>无差错接收：保证接收到的帧均正确，不正确的帧直接丢弃</li><li>可靠传输：保证所有帧都正确接收</li></ol></li></ol><h4 id="以太网传输介质与拓扑结构的发展">3.6.2.3以太网传输介质与拓扑结构的发展</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122195826747.png" alt="image-20221122195826747" style="zoom:80%;" /></p><h4 id="base-t以太网">3.6.2.4 10BASE-T以太网</h4><p>10BASE-T是传送<strong>基带信号</strong>的双绞线以太网，T表示采用<strong>双绞线</strong>，现10BASE-T采用的是<strong>无屏蔽双绞线(UTP)</strong>，传输速率是<strong>10Mb/s</strong></p><ol type="1"><li><strong>物理上采用星型拓扑，逻辑上总线型</strong>，每段双绞线最长为<strong>100m</strong></li><li>采用<strong>曼彻斯特编码</strong></li><li>采用<strong>CSMA/CD</strong>介质访问控制</li></ol><h4 id="适配器与mac地址">3.6.2.5 适配器与MAC地址</h4><ol type="1"><li>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的<ol type="1"><li>网络接口板</li><li>网络接口卡NIC (network interface card)</li><li>NOW，不再使用单独网卡</li><li>适配器上装有处理器和存储器(包括RAM和ROM)</li><li>ROM上有计算机硬件地址<strong>MAC地址</strong></li></ol></li><li>在局域网中，<strong>硬件地址</strong>又称为<strong>物理地址</strong>，或<strong>MAC地址</strong>【实际上是标识符】</li><li><strong>MAC地址</strong>：每个适配器有一个<strong>全球唯一</strong>的<strong>48位二进制地址</strong>，前24位代表厂家(由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8c-e4-b1-21<ol type="1"><li>换网卡之后，MAC地址也会变化</li><li>带电脑出差，MAC地址不会变化</li></ol></li></ol><h4 id="以太网mac帧">3.6.2.6 以太网MAC帧</h4><p>最常用的MAC帧是<strong>以太网V2</strong>的格式</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122201120733.png" alt="image-20221122201120733" style="zoom:80%;" /></p><ol type="1"><li>前导码：<ol type="1"><li>前同步码：由101010组成，用于接收方同步时钟</li><li>帧开始定界符：结尾是11，表示MAC帧的开始</li></ol></li><li>目的地址：<ol type="1"><li>单播地址：即专有网卡地址</li><li>广播地址：每一位均为1，即FFFFFFFFFFFF</li><li>多播地址</li></ol></li><li>类型：<ol type="1"><li>表示上面网络层使用的协议</li></ol></li><li>数据：<ol type="1"><li>长度可变</li><li>最多为1500，即MTU</li><li>最小为46，要满足以太网的最短帧长64B</li></ol></li><li>FCS：<ol type="1"><li>帧检验序列</li></ol></li><li>没有帧结束定界符：<ol type="1"><li>采用曼彻斯特编码，当不发送数据时，没有电压变化</li><li>两个帧之间会有最小间隔</li></ol></li></ol><p>与IEEE 802.3的区别：</p><ol type="1"><li>第三个字段是长度/类型</li><li>当长度/类型字段小于0x0600时，数据字段必须装入LLC子层</li></ol><h4 id="高速以太网">3.6.2.7 高速以太网</h4><p>速率<spanclass="math inline">\(\ge\)</span><strong>100Mb/s</strong>的以太网，称为高速以太网</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122201306224.png" alt="image-20221122201306224" style="zoom:80%;" /></p><h4 id="总结-13">3.6.2.8 总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122201323708.png" alt="image-20221122201323708" style="zoom:80%;" /></p><h3 id="无线局域网">3.6.3 无线局域网</h3><h4 id="ieee-802.11">3.6.3.1 IEEE 802.11</h4><p><strong>IEEE802.11</strong>是<strong>无线局域网</strong>通用的标准，它是由IEEE所定义的无线网络通信的标准。</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122201506771.png" alt="image-20221122201506771" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231171825181.png" alt="image-20221231171825181" style="zoom:80%;" /></p><h4 id="的mac帧头格式">3.6.3.2 802.11的MAC帧头格式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122201541222.png" alt="image-20221122201541222" style="zoom:80%;" /></p><p><strong>AP</strong>：无线接入点，也叫基站</p><p>例：若设备A向设备B发送消息，距离A近的基站为AP1，距离B近的基站为AP2，则</p><ol type="1"><li>A会将数据通过电磁波发送给AP1</li><li>AP1将数据发送给AP2</li><li>AP2通过电磁波将数据发送给B</li><li>在此过程中，MAC帧头为<ol type="1"><li><strong>DA</strong>目的地址：mac(B)</li><li><strong>SA</strong>源地址：mac(A)</li><li><strong>RA</strong>接收端：mac(AP2)</li><li><strong>TA</strong>发送端：mac(AP1)</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122202022344.png" alt="image-20221122202022344" style="zoom:80%;" /></p><h4 id="无线局域网的分类">3.6.3.3 无线局域网的分类</h4><ol type="1"><li><p>有固定基础设施的无线局域网</p><ol type="1"><li>BSS：基本服务集</li><li>ESS：扩展服务集</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122202351956.png" alt="image-20221122202351956" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122202413035.png" alt="image-20221122202413035" style="zoom:80%;" /></p></li><li><p>无固定基础设施的无线局域网的自组织网络</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122202439934.png" alt="image-20221122202439934" style="zoom:80%;" /></p></li></ol><h2 id="广域网">3.7 广域网</h2><h3 id="广域网概述">3.7.1 广域网概述</h3><ol type="1"><li>广域网(WAN， Wide Area Network)，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络</li><li>广域网的通信子网主要使用<strong>分组交换</strong>技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来，达到<strong>资源共享</strong>的目的。如因特网(Internet)是世界范围内最大的广域网</li><li>广域网与局域网的区别<ol type="1"><li>广域网覆盖的网络体系结构层次：物理层、链路层、网络层</li><li>局域网覆盖的网络体系结构层次：物理层、链路层</li><li>广域网普遍采用点对点，通过一个链路相连，全双工或者半双工</li><li>局域网普遍采用多点接入技术</li><li>广域网强调资源共享</li><li>局域网强调数据传输</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122202816704.png" alt="image-20221122202816704" style="zoom:80%;" /></p><h3 id="ppp协议面向字节">3.7.2 PPP协议：面向字节</h3><h4 id="ppp协议的特点">3.7.2.1 PPP协议的特点</h4><p>点对点协议PPP(Point-to-PointProtocol)：是目前使用最广泛的数据链路层协议</p><ol type="1"><li>用户使用拨号电话接入因特网时，一般都使用PPP协议</li><li><strong>只支持全双工链路</strong></li></ol><h4 id="ppp协议应满足的要求">3.7.2.2 PPP协议应满足的要求</h4><ol type="1"><li><strong>简单</strong>：对于链路层的帧，无需纠错，无需序号，无需流量控制。</li><li><strong>封装成帧</strong>：帧定界符</li><li><strong>透明传输</strong>：与帧定界符一样比特组合的数据应该如何处理异步线路用字节填充，同步线路用比特填充</li><li><strong>多种网络层协议</strong>：封装的IP数据报可以采用多种协议。</li><li><strong>多种类型链路</strong>：串行/并行，同步/异步，电/光</li><li><strong>差错检测</strong>：错就丢弃</li><li><strong>检测连接状态</strong>：链路是否正常工作</li><li><strong>最大传送单元</strong>：数据部分最大长度MTU，一般不超过1500B</li><li><strong>网络层地址协商</strong>：知道通信双方的网络层地址</li><li><strong>数据压缩协商</strong></li></ol><h4 id="ppp协议无需满足的要求">3.7.2.3 PPP协议无需满足的要求</h4><ol type="1"><li><strong>纠错</strong></li><li><strong>流量控制</strong></li><li><strong>序号</strong></li><li><strong>不支持多点线路</strong></li></ol><h4 id="ppp协议的三个组成部分">3.7.2.4 PPP协议的三个组成部分</h4><ol type="1"><li>一个将IP数据报封装到串行链路(同步串行/异步串行)的方法</li><li>链路控制协议<strong>LCP</strong>：建立并维护数据链路连接。<strong>身份验证</strong></li><li>网络控制协议<strong>NCP</strong>：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</li></ol><h4 id="ppp协议的状态图">3.7.2.5 PPP协议的状态图</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122203858835.png" alt="image-20221122203858835" style="zoom:80%;" /></p><h4 id="ppp协议的帧格式">3.7.2.6 PPP协议的帧格式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122204013649.png" alt="image-20221122204013649" style="zoom:80%;" /></p><h3 id="hdlc协议面向比特">3.7.3 HDLC协议：面向比特</h3><h4 id="hdlc协议简介">3.7.3.1 HDLC协议简介</h4><ol type="1"><li><strong>高级数据链路控制(High-Level Data LinkControl或简称HDLC)</strong>：是一个在同步网上传输数据、<strong>面向比特</strong>的数据链路层协议<ol type="1"><li>由国际标准化组织(<strong>ISO</strong>)根据IBM公司的SDLC(SynchronousDataLink Control)协议扩展开发而成的</li></ol></li><li>数据报文可透明传输，用于实现透明传输的"<strong>0比特插入法</strong>”易于硬件实现</li><li><strong>采用全双工通信</strong></li><li>所有帧采用<strong>CRC检验</strong>，对信息帧进行顺序<strong>编号</strong>，可防止漏收或重份，传输可靠性高</li></ol><h4 id="hdlc的站">3.7.3.2 HDLC的站</h4><ol type="1"><li><strong>主站</strong>：主要功能是发送命令(包括数据信息)帧、接收响应帧，并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等。</li><li><strong>从站</strong>：主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li><li><strong>复合站</strong>：主要功能是既能发送，又能接收命令帧和响应顿，并且负责整个链路的控制。</li></ol><p>三种数据操作方式</p><ol type="1"><li>正常响应方式：从站发送数据，要先经过主站的同意</li><li>异步平衡方式：每个复合站均可以进行数据传输，每个站地位平等</li><li>异步响应方式：从站可以不经过主站的同意，就发送数据</li></ol><h4 id="hdlc的帧格式">3.7.3.3 HDLC的帧格式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122204727226.png" alt="image-20221122204727226" style="zoom:80%;" /></p><h3 id="ppp协议-hdlc协议">3.7.4 PPP协议 &amp; HDLC协议</h3><p>相同点：</p><ol type="1"><li>均只支持<strong>全双工</strong>链路</li><li>都可以实现透明传输</li><li>都可以实现差错检测，但不纠正差错</li></ol><p>不同点：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122204853951.png" alt="image-20221122204853951" style="zoom:80%;" /></p><h3 id="总结-14">3.7.5 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122204947587.png" alt="image-20221122204947587" style="zoom:80%;" /></p><h2 id="链路层设备">3.8 链路层设备</h2><h3 id="物理层扩展以太网">3.8.1 物理层扩展以太网</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122205436676.png" alt="image-20221122205436676" style="zoom:80%;" /></p><h3 id="链路层扩展以太网网桥">3.8.2 链路层扩展以太网：网桥</h3><p>链路层扩展以太网的设备：网桥&amp;交换机</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122205855504.png" alt="image-20221122205855504" style="zoom:80%;" /></p><ol type="1"><li><strong>网桥</strong>：根据<strong>MAC帧的目的地址</strong>对帧进行<strong>转发</strong>和<strong>过滤</strong><ol type="1"><li>当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该顿转发到哪一个接口，或者是把它丢弃(即过滤)</li></ol></li><li><strong>网段</strong>：一般指一个计算机网络中使用同一物理层设备(传输介质，中继器，集线器等)能够直接通讯的那一部分</li><li>网桥的优点：<ol type="1"><li>过滤通信量，增大吞吐量</li><li>扩大了物理传输范围</li><li>提高了可靠性：一个主机故障，通常只影响一个网段</li><li>可互连不同物理层、不同MAC子层和不同速率的以太网</li></ol></li></ol><h4 id="网桥分类透明网桥">3.8.2.1 网桥分类：透明网桥</h4><p><strong>透明网桥</strong>：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备--<strong>自学习</strong></p><ol type="1"><li>每过一段时间，就会将转发表情况，然后更新最新的转发表</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122210837783.png" alt="image-20221122210837783" style="zoom:80%;" /></p><blockquote><ol type="1"><li>若A向B发送一个数据：<ol type="1"><li>A广播式发送数据，当前网段内所有主机均收到该数据，但只有B会处理这个数据</li><li>该数据包到达网桥1的1接口时<ol type="1"><li>A为发送方，因此将（地址A， 接口1）填入转发表</li><li>B为接收方，转发表中没有，因此网桥1会将这个数据包发送到除接口1外的所有接口</li></ol></li><li>该数据包到达CD网段，CD均丢弃该数据包</li><li>该数据包到达网桥2的1接口时<ol type="1"><li>A为发送方，因此将（地址A， 接口1）填入转发表</li><li>B为接收方，转发表中没有，因此网桥2会将这个数据包发送到除接口1外的所有接口</li></ol></li><li>该数据包到达EF网段，EF均丢弃该数据包</li></ol></li><li>然后F向C发送一个数据：<ol type="1"><li>F广播式发送数据，当前网段内所有主机均收到该数据，均丢弃</li><li>该数据包到达网桥2的2接口时<ol type="1"><li>F为发送方，因此将（地址F， 接口2）填入转发表</li><li>C为接收方，转发表中没有，因此网桥2会将这个数据包发送到除接口2外的所有接口</li></ol></li><li>该数据包到达CD网段，C收到数据，D丢弃数据</li><li>该数据包到达网桥1的2号接口时<ol type="1"><li>F为发送方，因此将（地址F， 接口2）填入转发表</li><li>C为接收方，转发表中没有，因此网桥1会将这个数据包发送到除接口2外的所有接口</li></ol></li><li>该数据包到达AB段，AB均丢弃该数据包</li></ol></li><li>然后B向A发送一个数据<ol type="1"><li>B广播式发送数据，当前网段内所有主机均收到该数据，但只有A会处理这个数据</li><li>该数据包到达网桥1的1接口时<ol type="1"><li>B为发送方，因此将（地址B， 接口1）填入转发表</li><li>A为接收方，转发表中存在，且为接口1，因此网桥1不会再转发</li></ol></li></ol></li></ol></blockquote><h4 id="网桥分类源路由网桥">3.8.2.2 网桥分类：源路由网桥</h4><ol type="1"><li><strong>源路由网桥</strong>：在发送帧时，把详细的<strong>最佳路由信息</strong>(路由最少/时间最短)放在<strong>帧的首部</strong>中</li><li><strong>方法</strong>：源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong><ol type="1"><li>发现帧会原路返回</li><li>发现帧中会存储经过路由数量/时间，由发送方进行比较选择</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122211055595.png" alt="image-20221122211055595" style="zoom:80%;" /></p><h3 id="多接口网桥以太网交换机">3.8.3 多接口网桥：以太网交换机</h3><h4 id="以太网交换机的简介">3.8.3.1 以太网交换机的简介</h4><p>独占传输媒体带宽：</p><ol type="1"><li>若使用集线器<ol type="1"><li>假设一个冲突域的带宽为10Mb/s，则每个主机的带宽为2.5Mb/s</li></ol></li><li>若使用集线器以太网交换机<ol type="1"><li>假设以太网交换机的带宽为10Mb/s，则每个冲突域的带宽均为10Mb/s</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122211448383.png" alt="image-20221122211448383" style="zoom:80%;" /></p><h4 id="以太网交换机的两种交换方式">3.8.3.2以太网交换机的两种交换方式</h4><ol type="1"><li>直通式交换机<ol type="1"><li>查完<strong>目的地址(6B)</strong>就<strong>立刻转发</strong></li><li><strong>延迟小</strong>，可靠性低，无法支持具有不同速率的端口的交换</li></ol></li><li>存储转发式交换机<ol type="1"><li>将帧放入<strong>高速缓存</strong>，并检查否正确，正确则转发，错误则丢弃</li><li><strong>延迟大</strong>，可靠性高，可以支持具有不同速率的端口的交换</li></ol></li></ol><h3 id="冲突域和广播域">3.8.4 冲突域和广播域</h3><ol type="1"><li><strong>冲突域</strong>：在同一个冲突域中的每一个节点都能收到所有被发送的帧<ol type="1"><li>简单的说，就是同一时间内只能有一台设备发送信息的范围</li></ol></li><li><strong>广播域</strong>：网络中能接收任一设备发出的广播帧的所有设备的集合<ol type="1"><li>简单的说，如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122211925798.png" alt="image-20221122211925798" style="zoom:80%;" /></p><blockquote><ol type="1"><li>广播域的个数：看有几个路由器</li><li>冲突域的个数：看以太网交换机的端口，一个端口对应一个冲突域</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122212044265.png" alt="image-20221122212044265" style="zoom:80%;" /></p><h3 id="生成树网桥">3.8.5 生成树网桥</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231172045308.png" alt="image-20221231172045308" style="zoom:80%;" /></p><ol type="1"><li>为了防止广播风暴，会使用生成树的算法，保证没有回路</li></ol><h3 id="总结-15">3.8.6 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122212056169.png" alt="image-20221122212056169" style="zoom:80%;" /></p><h2 id="virtual-lans-虚拟网">3.9 Virtual LANs 虚拟网</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231172156368.png" alt="image-20221231172156368" style="zoom:80%;" /></p><ol type="1"><li>逻辑的局域网和多个交换机构成的物理局域网，相互之间有多对多的映射关系</li><li>这些交换机的端口被分为两大类：<ol type="1"><li>接入端口：隶属于某一个指定的虚拟网，跑的是标准的以太网协议</li><li>中继端口trunk：用于传输交换机之间的数据，这里的数据会属于不同的虚拟网，需要识别出当前帧到底是归属于哪个虚拟网的，因此出现了<strong>IEEE802.1Q</strong>协议</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231172604512.png" alt="image-20221231172604512" style="zoom:80%;" /></p><h2 id="第三章总结">3.9 第三章总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122212157715.png" alt="image-20221122212157715"  /></p><h1 id="chapter-4网络层">Chapter 4：网络层</h1><p>互联网是无中心、有层次的</p><h2 id="网络层概述">4.1 网络层概述</h2><h3 id="网络层功能概述">4.1.1 网络层功能概述</h3><ol type="1"><li>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务</li><li>网络层传输单位是<strong>数据报</strong></li><li>功能：<ol type="1"><li><strong>路由选择与分组转发</strong>：最佳路径</li><li><strong>异构网络互联</strong></li><li><strong>拥塞控制</strong>：若<strong>所有结点</strong>都来不及接受分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态。因此要采取一定措施，缓解这种拥塞<ol type="1"><li>开环控制：静态控制</li><li>闭环控制：动态调整</li></ol></li></ol></li></ol><h3 id="数据交换方式">4.1.2 数据交换方式</h3><h4 id="网络的核心路由器">4.1.2.1 网络的核心：路由器</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122214424641.png" alt="image-20221122214424641" style="zoom:80%;" /></p><h4 id="为什么需要数据交换">4.1.2.2 为什么需要数据交换</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122214358680.png" alt="image-20221122214358680" style="zoom:80%;" /></p><h4 id="电路交换">4.1.2.3 电路交换</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221122214748051.png" alt="image-20221122214748051" style="zoom:80%;" /></p><p>电路交换的阶段：</p><ol type="1"><li>建立连接</li><li>通信</li><li>释放连接</li></ol><p>特点：<strong>独占资源</strong></p><ol type="1"><li>当A和B建立连接后，即使不说话，也不能有第三方抢占电路</li></ol><p>优点：</p><ol type="1"><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>实时性强</li></ol><p>缺点：</p><ol type="1"><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差</li><li>无差错控制能力</li></ol><h4 id="报文交换">4.1.2.4 报文交换</h4><p>报文：源应用发送的信息整体</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221123214912638.png" alt="image-20221123214912638" style="zoom:80%;" /></p><p>优点：</p><ol type="1"><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高</li><li>线路利用率较高：一段一段的占用线路</li><li>多目标服务</li></ol><p>缺点：</p><ol type="1"><li>有存储转发时延</li><li>报文大小不定，需要网络节点有较大的缓存空间</li></ol><h4 id="分组交换">4.1.2.5 分组交换</h4><p>分组：把大的数据块分割成小的数据块</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221123215116919.png" alt="image-20221123215116919" style="zoom:80%;" /></p><p>优点：</p><ol type="1"><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高：数据变小之后，出错的概率也变小了</li><li>线路利用率较高：一段一段的占用线路</li><li>相对于报文交换，存储管理更容易</li></ol><p>缺点：</p><ol type="1"><li>有存储转发时延</li><li>需要传输额外的信息量：源地址、目的地址、分组编号等</li><li>乱序到达目的主机时，需要对分组排序重组</li></ol><h4 id="报文交换分组交换例题">4.1.2.6 报文交换&amp;分组交换例题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221123221031383.png" alt="image-20221123221031383" style="zoom:80%;" /></p><p>报文交换：</p><ol type="1"><li>发送时延/传输时延为：<span class="math inline">\(\frac{10000\bit}{1000\ bps}=10s\)</span></li><li>传输时延和接收时延均忽略不计</li><li>因此总传输时间为：<span class="math inline">\(10\ s × 3=30\s\)</span></li></ol><p>分组交换：</p><ol type="1"><li>每一个分组的发送时延/传输时延为：<spanclass="math inline">\(\frac{10\ bit}{1000\ bps}=0.01s\)</span></li><li>传输时延和接收时延均忽略不计</li><li>由于每个分组连续发送，因此只需要考虑第1个分组开始发送，到最后1个分组到达所需的时间即可<ol type="1"><li>第1个分组开始发送~最后1个分组开始发送：<spanclass="math inline">\(\frac{10000\ bit}{1000\ bps}=10s\)</span></li><li>最后1个分组开始发送~最后1个分组到达：<spanclass="math inline">\(2×0.01\ s=0.02\ s\)</span></li></ol></li><li>因此总传输时间为：<span class="math inline">\(10\ s + 0.02\ s=10.02\s\)</span></li></ol><h4 id="三种数据交换方式比较总结">4.1.2.7 三种数据交换方式比较总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221123221146496.png" alt="image-20221123221146496" style="zoom:80%;" /></p><h3 id="数据报与虚电路">4.1.3 数据报与虚电路</h3><ol type="1"><li><strong>数据报</strong>：为网络层提供<strong>无连接服务</strong><ol type="1"><li>无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同</li></ol></li><li><strong>虚电路</strong>：为网络层提供<strong>连接服务</strong><ol type="1"><li>连接服务：首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接</li></ol></li></ol><h4 id="几种传输单元的名词解析">4.1.3.1 几种传输单元的名词解析</h4><table><thead><tr><th style="text-align: center;">层次</th><th style="text-align: center;">传输单元</th></tr></thead><tbody><tr><td style="text-align: center;">应用层</td><td style="text-align: center;">报文</td></tr><tr><td style="text-align: center;">传输层</td><td style="text-align: center;">报文段</td></tr><tr><td style="text-align: center;">网络层</td><td style="text-align: center;">IP数据报，分组</td></tr><tr><td style="text-align: center;">数据链路层</td><td style="text-align: center;">帧</td></tr><tr><td style="text-align: center;">物理层</td><td style="text-align: center;">比特流</td></tr></tbody></table><h4 id="数据报因特网使用">4.1.3.2 数据报（因特网使用）</h4><ol type="1"><li><strong>无连接服务</strong>：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同</li><li><strong>每个分组携带源和目的地址</strong></li><li><strong>路由器根据分组的目的地址转发分组</strong>：<ol type="1"><li>基于路由协议/算法构建转发表</li><li>检索转发表</li><li>每个分组独立性选路</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129165604477.png" alt="image-20221129165604477" style="zoom:80%;" /></p><h4 id="虚电路">4.1.3.3 虚电路</h4><ol type="1"><li>虚电路将数据报方式和电路交换方式结合，以发挥两者优点</li><li><strong>虚电路</strong>：一条源主机到目的主机类似于电路的路径(逻辑链接)，路径上所有节点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息</li><li>通信过程：</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129182313654.png" alt="image-20221129182313654" style="zoom:80%;" /></p><h4 id="数据报虚电路">4.1.3.4 数据报&amp;虚电路</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129182340378.png" alt="image-20221129182340378" style="zoom:80%;" /></p><h2 id="ip协议">4.2 IP协议</h2><h3 id="ip数据报格式">4.2.1 IP数据报格式</h3><h4 id="tcpip协议栈">4.2.1.1 TCP/IP协议栈</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129183834673.png" alt="image-20221129183834673" style="zoom:80%;" /></p><h4 id="ip数据报格式-1">4.2.1.2 IP数据报格式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129183918389.png" alt="image-20221129183918389" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129183929489.png" alt="image-20221129183929489" style="zoom:80%;" /></p><table><colgroup><col style="width: 14%" /><col style="width: 5%" /><col style="width: 15%" /><col style="width: 63%" /></colgroup><thead><tr><th style="text-align: center;">位置</th><th style="text-align: center;">长度</th><th style="text-align: center;">名称</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr><td style="text-align: center;">第1个4B：00~03</td><td style="text-align: center;">4bit</td><td style="text-align: center;">版本</td><td style="text-align: center;">4位数据，表示IPv4/IPv6</td></tr><tr><td style="text-align: center;">第1个4B：04~07</td><td style="text-align: center;">4bit</td><td style="text-align: center;">首部长度</td><tdstyle="text-align: center;">单位为<strong>4B</strong>，最小为5(此时首部长度为5*4B=20B)</td></tr><tr><td style="text-align: center;">第1个4B：08~15</td><td style="text-align: center;">8bit</td><td style="text-align: center;">区分服务</td><tdstyle="text-align: center;">表示期望获得<strong>哪种类型的服务</strong></td></tr><tr><td style="text-align: center;">第1个4B：16~31</td><td style="text-align: center;">16bit</td><td style="text-align: center;">总长度</td><tdstyle="text-align: center;">首部+数据部分的大小，单位为<strong>1B</strong></td></tr><tr><td style="text-align: center;">第2个4B：00~15</td><td style="text-align: center;">16bit</td><td style="text-align: center;">标识</td><tdstyle="text-align: center;">同一数据报的分片使用同一标识，表示为<strong>同一个IP数据报</strong></td></tr><tr><td style="text-align: center;">第2个4B：16~18</td><td style="text-align: center;">3bit</td><td style="text-align: center;">标志</td><td style="text-align: center;">只有2位有意义，<strong>× DFMF</strong></td></tr><tr><td style="text-align: center;">第2个4B：19~31</td><td style="text-align: center;">13bit</td><td style="text-align: center;">片偏移</td><tdstyle="text-align: center;">当前分片在原分组中的相对位置，单位为<strong>8B</strong></td></tr><tr><td style="text-align: center;">第3个4B：00~07</td><td style="text-align: center;">8bit</td><td style="text-align: center;">生存时间<strong>TTL</strong></td><tdstyle="text-align: center;">IP分组的保质期，经过一个路由器-1，变成0则丢弃，防止无法交付的数据报在链路中无限传递</td></tr><tr><td style="text-align: center;">第3个4B：08~15</td><td style="text-align: center;">8bit</td><td style="text-align: center;">协议</td><tdstyle="text-align: center;">数据部分的协议，如<strong>TCP(6)</strong>、<strong>UDP(17)</strong></td></tr><tr><td style="text-align: center;">第3个4B：16~31</td><td style="text-align: center;">16bit</td><td style="text-align: center;">首部检验和</td><tdstyle="text-align: center;">二进制求和，只检验首部，不检验数据部分</td></tr><tr><td style="text-align: center;">第4个4B：00~31</td><td style="text-align: center;">32bit</td><td style="text-align: center;">源地址</td><td style="text-align: center;">IPv4的地址长度：32位</td></tr><tr><td style="text-align: center;">第5个4B：00~31</td><td style="text-align: center;">32bit</td><td style="text-align: center;">目的地址</td><td style="text-align: center;">IPv4的地址长度：32位</td></tr><tr><td style="text-align: center;">可变部分</td><td style="text-align: center;">0~40B</td><td style="text-align: center;">可选字段</td><td style="text-align: center;">用来支持排错、测量、安全等措施</td></tr><tr><td style="text-align: center;">可变部分</td><td style="text-align: center;"></td><td style="text-align: center;">填充</td><td style="text-align: center;">全0，把首部补成4B的整数倍</td></tr></tbody></table><p>协议：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129184949335.png" alt="image-20221129184949335"  /></p><p>三个长度：</p><ol type="1"><li><strong>总</strong>长度：单位为<strong>1B</strong></li><li><strong>片</strong>偏移：单位为<strong>8B</strong></li><li><strong>首</strong>部长度：单位为<strong>4B</strong></li></ol><blockquote><p><strong>1总8片的首4</strong></p></blockquote><h3 id="ip数据报分片">4.2.2 IP数据报分片</h3><h4 id="最大传送单元mtu">4.2.2.1 最大传送单元MTU</h4><ol type="1"><li><strong>MTU</strong>：链路层数据帧可封装数据的上限<ol type="1"><li>以太网的MTU位1500字节</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129185458558.png" alt="image-20221129185458558" style="zoom:80%;" /></p><h4 id="ip数据报分片-1">4.2.2.2 IP数据报分片</h4><ol type="1"><li>标志：× _ _<ol type="1"><li>中间位<strong>DF</strong>(Don’t Fragment)<ol type="1"><li>DF=1：禁止分片</li><li>DF=0：允许分片</li></ol></li><li>最低位<strong>MF</strong>(More Fragment)<ol type="1"><li>MF=1：后面还有分片</li><li>MF=0：当前分片为最后一片</li></ol></li></ol></li><li>片偏移：<ol type="1"><li>当前分片在原分组中的相对位置，以<strong>8B</strong>为单位</li><li>除最后一个分片外，每个分片的大小均为8B的整数倍</li></ol></li></ol><h4 id="ip数据报分片例题">4.2.2.3 IP数据报分片例题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129190407709.png" alt="image-20221129190407709" style="zoom:80%;" /></p><h3 id="ipv4地址">4.2.3 IPv4地址</h3><h4 id="ip编址的历史阶段">4.2.3.1 IP编址的历史阶段</h4><ol type="1"><li>分类的IP地址</li><li>子网的划分</li><li>构成超网：无分类编址方法</li></ol><h4 id="分类的ip地址">4.2.3.2 分类的IP地址</h4><ol type="1"><li><p>IP地址：全世界唯一的<strong>32位/4字节</strong>标识符，标识路由器主机的接口</p></li><li><p>IP地址：{<网络号> <主机号>}<strong>点分十进制表示方法</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129191038841.png" alt="image-20221129191038841" style="zoom:80%;" /></p></li></ol><h4 id="互联网中的ip地址">4.2.3.3 互联网中的IP地址</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129191227138.png" alt="image-20221129191227138" style="zoom:80%;" /></p><ol type="1"><li>同一个局域网中，网络号相同</li><li>网桥不分割广播域：因此通过网桥连接起来的设备仍是一个局域网</li><li>路由器分割广播域：路由器的每一个接口都会有一个不同的IP地址</li><li>绿色的部分：无编号(无名)网络，是逻辑上的网络</li><li>整个图中共有6个逻辑上的网络<ol type="1"><li>橙色部分：3个</li><li>绿色部分：3个</li></ol></li></ol><h4 id="分类的ip地址-1">4.2.3.4 分类的IP地址</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129192446002.png" alt="image-20221129192446002" style="zoom:80%;" /></p><h4 id="特殊的ip地址">4.2.3.5 特殊的IP地址</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129191949926.png" alt="image-20221129191949926" style="zoom:80%;" /></p><h4 id="私有ip地址">4.2.3.6 私有IP地址</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129192023872.png" alt="image-20221129192023872" style="zoom:80%;" /></p><ol type="1"><li>路由器对目的地址是私有IP地址的数据报一律不进行转发</li></ol><h3 id="网络地址转换nat">4.2.4 网络地址转换NAT</h3><p>网络地址转换NAT(Network Address Translation)：</p><ol type="1"><li>在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装NAT软件</li><li>安装了NAT软件的路由器称为<strong>NAT路由器</strong>，它至少有一个有效的<strong>外部全球IP地址</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129193233306.png" alt="image-20221129193233306" style="zoom:80%;" /></p><h3 id="子网划分与子网验码">4.2.5 子网划分与子网验码</h3><h4 id="子网划分">4.2.5.1 子网划分</h4><p>分类IP地址的缺点：</p><ol type="1"><li>IP地址空间的利用率有时很低</li><li>两级IP地址不够灵活</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129193445186.png" alt="image-20221129193445186" style="zoom:80%;" /></p><ol type="1"><li>划分子网后，对外仍<strong>表现为一个网络</strong>，即外单位的网络看不到本单位内的子网划分</li><li>主机号至少要有2位</li><li>主机号不能全0/全1：这两种分别表示当前网络/广播地址</li><li><strong>子网号能否全0/1要看情况</strong></li></ol><h4 id="子网划分的示例">4.2.5.2 子网划分的示例</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129193712879.png" alt="image-20221129193712879" style="zoom:80%;" /></p><h4 id="子网掩码">4.2.5.3 子网掩码</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129194026929.png" alt="image-20221129194026929" style="zoom:80%;" /></p><ol type="1"><li>网络号/子网号对应位置：填1</li><li>主机号对应位置：填0</li><li>子网掩码与IP地址逐位相与，就得到了子网网络的地址</li></ol><h4 id="子网掩码的示例">4.2.5.4 子网掩码的示例</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129194211056.png" alt="image-20221129194211056" style="zoom:80%;" /></p><ol type="1"><li>同一个IP地址，不同子网掩码，求出的网络地址可以是相同的</li><li>但是含义不同，表示子网可划分的主机数不同</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129194517726.png" alt="image-20221129194517726" style="zoom:80%;" /></p><h4 id="使用子网时分组的转发">4.2.5.5 使用子网时分组的转发</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129194827532.png" alt="image-20221129194827532" style="zoom:80%;" /></p><h3 id="无分类编址cidr">4.2.6 无分类编址CIDR</h3><h4 id="cidr的特点及使用方法">4.2.6.1 CIDR的特点及使用方法</h4><p>无分类域间路由选择CIDR：</p><ol type="1"><li>消除了传统的A类，B类和C类地址以及划分子网的概念</li><li>融合了子网地址和子网掩码，方便子网划分</li></ol><p>CIDR的使用方法：</p><ol type="1"><li><p>CIDR记法：IP地址后加上”/”，然后写上网络前缀的位数，如128.14.22.0<strong>/20</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129195328293.png" alt="image-20221129195328293" style="zoom:80%;" /></p></li><li><p>CIDR地址块：<strong>网络前缀都相同</strong>的连续的IP地址</p></li><li><p><strong>CIDR技术中，子网号可以是全0/1的</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129195541159.png" alt="image-20221129195541159" style="zoom:80%;" /></p></li></ol><h4 id="构成超网">4.2.6.2 构成超网</h4><ol type="1"><li><strong>构成超网</strong>：将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合</li><li>方法：将网络前缀缩短</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129200027765.png" alt="image-20221129200027765" style="zoom:80%;" /></p><h4 id="最长前缀匹配">4.2.6.3 最长前缀匹配</h4><ol type="1"><li>使用CIDR时，查找路由表可能得到几个匹配的结果，应该选择具有最长网络前缀的路由</li><li>前缀越长，地址块越小，路由越具体</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129200432306.png" alt="image-20221129200432306" style="zoom:80%;" /></p><h4 id="习题">4.2.6.4 习题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129200628326.png" alt="image-20221129200628326" style="zoom:80%;" /></p><h3 id="arp协议">4.2.7 ARP协议</h3><h4 id="发送数据的过程">4.2.7.1 发送数据的过程</h4><p>同一局域网内，不知道接收方的MAC地址：</p><ol type="1"><li>发送方：发送广播ARP请求分组，广播查询接收方IP3的MAC地址</li><li>接收方：IP3返回单波ARP相应分组</li><li>发送方接收到接收方的回应后，将接收方的MAC地址MAC3填入帧中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129201246544.png" alt="image-20221129201246544" style="zoom:80%;" /></p><p>不在同一局域网内，不知道接收方的MAC地址：</p><ol type="1"><li>发送方：发送广播ARP请求分组，广播查询默认网关IP6的MAC地址</li><li>接收方：IP6返回单波ARP相应分组</li><li>发送方接收到接收方的回应后，将接收方的MAC地址MAC6填入帧中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129201841358.png" alt="image-20221129201841358" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129201908628.png" alt="image-20221129201908628" style="zoom:80%;" /></p><h4 id="arp协议-1">4.2.7.2 ARP协议</h4><ol type="1"><li>产生原因：在实际网络的链路上传送数据顿时，最终必须使用MAC地址</li><li><strong>ARP协议</strong>：完成主机或路由器IP地址到MAC地址的映射。解决下一跳走哪的问题</li><li>ARP协议使用过程：<ol type="1"><li>检查<strong>ARP高速缓存</strong>，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并<strong>广播ARP请求分组</strong></li><li><strong>同一局域网中</strong>所有主机都能收到该请求</li><li>目的主机收到请求后就会向源主机<strong>单播一个ARP响应分组</strong></li><li>源主机收到后将此映射<strong>写入ARP缓存</strong>(10-20min更新一次)</li></ol></li><li>ARP协议4种典型情况：<ol type="1"><li><strong>主机</strong>A发给<strong>本网络</strong>上的主机B：用ARP找到<strong>主机B</strong>的硬件地址</li><li><strong>主机</strong>A发给<strong>另一网络</strong>上的主机B：用ARP找到本网络上一个<strong>路由器(网关)</strong>的硬件地址</li><li><strong>路由器</strong>发给<strong>本网络</strong>的主机A：用ARP找到<strong>主机A</strong>的硬件地址</li><li><strong>路由器</strong>发给<strong>另一网络</strong>的主机B：用ARP找到本网络上的一个<strong>路由器</strong>的硬件地址</li></ol></li><li>ARP协议自动进行</li></ol><h4 id="习题-1">4.2.7.3 习题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129202543897.png" alt="image-20221129202543897" style="zoom:80%;" /></p><h3 id="dhcp协议">4.2.8 DHCP协议</h3><h4 id="主机如何获得ip地址">4.2.8.1 主机如何获得IP地址</h4><ol type="1"><li>静态配置：IP地址、子网掩码、默认网关</li><li>动态配置：</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129203124440.png" alt="image-20221129203124440" style="zoom:80%;" /></p><h4 id="dhcp协议-1">4.2.8.2 DHCP协议</h4><p>动态主机配置协议DHCP：</p><ol type="1"><li>是<strong>应用层</strong>协议，使用<strong>客户/服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，基于<strong>UDP</strong></li><li>DHCP提供<strong>即插即用</strong>联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址</li><li>允许<strong>地址重用</strong>，支持<strong>移动用户加入网络</strong>，支持<strong>在用地址续租</strong></li></ol><p>DHCP协议的过程：</p><ol type="1"><li><strong>主机</strong>广播<strong>DHCP发现报文</strong>：试图找到网络中的服务器，服务器获得一个IP地址</li><li><strong>DHCP服务器</strong>广播<strong>DHCP提供报文</strong>：服务器拟分配给主机一个IP地址及相关配置，先到先得</li><li><strong>主机</strong>广播<strong>DHCP请求报文</strong>：主机向服务器请求提供IP地址</li><li><strong>DHCP服务器</strong>广播<strong>DHCP确认报文</strong>：正式将IP地址分配给主机</li></ol><h3 id="icmp协议">4.2.9 ICMP协议</h3><h4 id="网际控制报文协议icmp">4.2.9.1 网际控制报文协议ICMP</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129203735584.png" alt="image-20221129203735584" style="zoom:80%;" /></p><h4 id="icmp差错报告报文5种">4.2.9.2 ICMP差错报告报文(5种)</h4><ol type="1"><li><strong>终点不可达</strong>：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。<strong>无法交付</strong></li><li><strong>源点抑制</strong>：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。<strong>拥塞丢数据(不再使用)</strong></li><li><strong>时间超过</strong>：当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就<strong>把已收到的数据报片都丢弃</strong>，并向源点发送时间超过报文。<strong>TTL=0</strong></li><li><strong>参数问题</strong>：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。<strong>首部字段有问题</strong></li><li><strong>改变路由(重定向)</strong>：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。<strong>值得更好的路由</strong></li></ol><h4 id="icmp差错报告报文数据字段">4.2.9.3 ICMP差错报告报文数据字段</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129204209685.png" alt="image-20221129204209685" style="zoom:80%;" /></p><h4 id="不应发送icmp差错报文的情况">4.2.9.4不应发送ICMP差错报文的情况</h4><ol type="1"><li>对<strong>ICMP差错报告报文</strong>不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有<strong>后续数据报片</strong>都不发送ICMP差错报告报文</li><li>对具有<strong>组播地址</strong>的数据报都不发送ICMP差错报告报文<ol type="1"><li>组播：一点到多点</li><li>广播：一点到所有点</li></ol></li><li>对具有<strong>特殊地址(如127.0.0.0或0.0.0.0)</strong>的数据报不发送ICMP差错报告报文</li></ol><h4 id="icmp询问报文">4.2.9.5 ICMP询问报文</h4><ol type="1"><li><strong>回送请求和回答报文</strong>：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<strong>测试目的站是否可达以及了解其相关状态</strong></li><li><strong>时间截请求和回答报文</strong>：请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间</strong></li><li>掩码地址请求和回答报文</li><li>路由器询问和通告报文</li></ol><h4 id="icmp的应用">4.2.9.6 ICMP的应用</h4><ol type="1"><li><strong>PING</strong>：测试两个主机之间的连通性，使用了<strong>ICMP回送请求和回答报文</strong></li><li><strong>Traceroute</strong>：跟踪一个分组从源点到终点的路径，使用了<strong>ICMP时间超过差错报告报文</strong></li></ol><h2 id="ipv6">4.3 IPv6</h2><h3 id="为什么有ipv6">4.3.1 为什么有IPv6</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129204933309.png" alt="image-20221129204933309" style="zoom:80%;" /></p><h3 id="ipv6数据报格式">4.3.2 IPv6数据报格式</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129205002582.png" alt="image-20221129205002582" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129205023299.png" alt="image-20221129205023299" style="zoom:80%;" /></p><table><colgroup><col style="width: 19%" /><col style="width: 8%" /><col style="width: 16%" /><col style="width: 54%" /></colgroup><thead><tr><th style="text-align: center;">位置</th><th style="text-align: center;">长度</th><th style="text-align: center;">名称</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr><td style="text-align: center;">第1个4B：00~03</td><td style="text-align: center;">4bit</td><td style="text-align: center;">版本</td><td style="text-align: center;">协议版本，总是6</td></tr><tr><td style="text-align: center;">第1个4B：04~11</td><td style="text-align: center;">8bit</td><td style="text-align: center;">优先级</td><td style="text-align: center;">区分数据报的类别、优先级</td></tr><tr><td style="text-align: center;">第1个4B：12~31</td><td style="text-align: center;">20bit</td><td style="text-align: center;">流标签</td><td style="text-align: center;">表面当前数据报属于哪个“流”</td></tr><tr><td style="text-align: center;">第2个4B：00~15</td><td style="text-align: center;">16bit</td><td style="text-align: center;">有效载荷长度</td><tdstyle="text-align: center;">有效载荷部分(<strong>扩展首部+数据</strong>)的长度</td></tr><tr><td style="text-align: center;">第2个4B：16~23</td><td style="text-align: center;">8bit</td><td style="text-align: center;">下一个首部</td><tdstyle="text-align: center;">标识<strong>下一个扩展首部</strong>/<strong>上层协议首部</strong></td></tr><tr><td style="text-align: center;">第2个4B：24~31</td><td style="text-align: center;">8bit</td><td style="text-align: center;">跳数限制</td><td style="text-align: center;">相当于IPv4的TTL</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">128bit</td><td style="text-align: center;">源地址</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">128bit</td><td style="text-align: center;">目的地址</td><td style="text-align: center;"></td></tr></tbody></table><p>流：</p><ol type="1"><li>互联网上从特定源点到特定终点的一系列数据报</li><li>所有属于同一个流的数据报都具有相同的流标签</li></ol><h3 id="ipv6和ipv4">4.3.2 IPv6和IPv4</h3><ol type="1"><li>IPv6将地址从32位(4B)扩大到<strong>128位(16B)</strong>，更大的地址空间</li><li>IPv6将IPv4的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间</li><li>IPv6将IPv4的可选字段移出首部，变成了<strong>扩展首部</strong>，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率</li><li>IPv6支持<strong>即插即用</strong>(即自动配置) ，不需要DHCP协议</li><li>IPv6首部长度必须是<strong>8B的整数倍</strong>，IPv4首部是4B的整数倍</li><li>IPv6<strong>只能在主机处分片</strong>，IPv4可以在路由器和主机处分片</li><li>ICMPv6：附加报文类型“分组过大”。</li><li>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用</li><li>IPv6取消了协议字段，改成下一个首部字段</li><li>IPv6取消了总长度字段，改用有效载荷长度字段</li><li>IPv6取消了服务类型字段</li></ol><h3 id="ipv6地址表示形式">4.3.4 IPv6地址表示形式</h3><ol type="1"><li><strong>一般形式</strong>：<strong>冒号十六进制记法</strong></li><li><strong>压缩形式</strong>：</li><li><strong>零压缩</strong>：一连串连续的0可以被一对冒号取代，双冒号只能在一个地址中出现一次</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129210458220.png" alt="image-20221129210458220" style="zoom:80%;" /></p><h3 id="ipv6基本地址类型">4.3.5 IPv6基本地址类型</h3><ol type="1"><li><strong>单播</strong>：一对一通信，可以做源地址+目的地址</li><li><strong>多播</strong>：一对多通信，可以做目的地址</li><li><strong>任播</strong>：一对多中的一个通信，可以做目的地址</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129210629760.png" alt="image-20221129210629760" style="zoom:80%;" /></p><h3 id="ipv6向ipv4过渡的策略">4.3.6 IPv6向IPv4过渡的策略</h3><ol type="1"><li>双栈协议<ol type="1"><li>双协议栈技术就是指在一台设备上<strong>同时启用IPv4协议栈和IPv6协议栈</strong></li><li>这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信</li><li>如果这台设备是一个<strong>路由器</strong>：那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络</li><li>如果这台设备是一个<strong>计算机</strong>：那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能</li></ol></li><li>隧道技术<ol type="1"><li>通过使用互联网络的基础设施在网络之间传递数据的方式</li><li>使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包<strong>重新封装</strong>然后通过隧道发送</li></ol></li></ol><h3 id="总结-16">4.3.7 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129210938055.png" alt="image-20221129210938055" style="zoom:80%;" /></p><h2 id="路由算法与路由协议概述">4.4 路由算法与路由协议概述</h2><h3 id="路由算法">4.4.1 路由算法</h3><p>最佳路由：某一种特定要求下得出的较为合理的选择</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129182835879.png" alt="image-20221129182835879" style="zoom:80%;" /></p><h3 id="路由算法的分类">4.4.2 路由算法的分类</h3><ol type="1"><li><strong>静态路由算法</strong>(非自适应路由算法)：管理员手工配置路由信息<ol type="1"><li>优点：<ol type="1"><li>简便、可靠</li><li>在负荷稳定、拓扑变化不大的网络中运行效果很好</li><li>广泛用于高度安全性的军事网络和较小的商业网络</li></ol></li><li>缺点：<ol type="1"><li>路由更新慢，不适用于大型网络</li></ol></li></ol></li><li><strong>动态路由算法</strong>(自适应路由算法)：路由器间彼此交换信息，按照路由算法优化出路由表项<ol type="1"><li>优点：<ol type="1"><li>路由更新快</li><li>适用大型网络</li><li>及时响应链路费用或网络拓扑变化</li></ol></li><li>缺点：<ol type="1"><li>算法复杂，增加网络负担</li></ol></li></ol></li></ol><p>动态路由算法的分类：</p><ol type="1"><li>全局性：链路状态路由算法<strong>OSPF</strong><ol type="1"><li>所有路由器掌握完整的网络拓扑和链路费用信息</li></ol></li><li>分散性：距离向量路由算法<strong>RIP</strong><ol type="1"><li>路由器只掌握物理相连的邻居及链路费用</li></ol></li></ol><h3 id="分层次的路由选择协议">4.4.3 分层次的路由选择协议</h3><p>原因：</p><ol type="1"><li>因特网规模很大</li><li>许多单位不想让外界知道自己的路由选择协议，但还想连入因特网</li></ol><p><strong>自治系统AS</strong>：</p><ol type="1"><li>在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由</li><li>一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通</li></ol><p>路由选择协议：</p><ol type="1"><li>内部网关协议IGP：一个AS内使用的，如<strong>RIP、OSPF</strong></li><li>外部网关协议EGP：AS之间使用的，如<strong>BGP</strong></li></ol><h2 id="路由选择协议">4.5 路由选择协议</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129211300849.png" alt="image-20221129211300849" style="zoom:80%;" /></p><h3 id="rip协议及距离向量算法">4.5.1 RIP协议及距离向量算法</h3><h4 id="rip协议">4.5.1.1 RIP协议</h4><ol type="1"><li>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是简单</li><li>RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong>(即一组距离)</li><li>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此<strong>距离为16表示网络不可达</strong></li><li>RIP协议只适用于<strong>小互联网</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129212207355.png" alt="image-20221129212207355" style="zoom:80%;" /></p><h4 id="rip协议和谁交换多久交换一次交换什么">4.5.1.2RIP协议和谁交换？多久交换一次？交换什么？</h4><ol type="1"><li>仅和<strong>相邻路由器</strong>交换信息</li><li>路由器交换的信息是<strong>自己的路由表</strong></li><li><strong>每30秒</strong>交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表</li><li>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息</li><li>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“<strong>收敛</strong>”</li></ol><h4 id="距离向量算法">4.5.1.3 距离向量算法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129212928474.png" alt="image-20221129212928474" style="zoom:80%;" /></p><ol type="1"><li>修改相邻路由器发来的RIP报文中<strong>所有表项</strong><ol type="1"><li>对地址为x的相邻路由器发来的RIP报文，修改此报文中的所有项目：</li><li>把“下一跳”字段中的地址改为X，并把<strong>所有的“距离”字段+1</strong></li></ol></li><li>对修改后的RIP报文中的每一个项目，进行以下步骤:<ol type="1"><li>R1路由表中若没有Net3，则把该项目填入R1路由表</li><li>R1路由表中若有Net3，则查看下一跳路由器地址<ol type="1"><li>若下一跳是X，则用收到的项目替换源路由表中的项目</li><li>若下一跳不是X，原来距离比从X走的距离远则更新，否则不作处理</li></ol></li></ol></li><li>若<strong>180s</strong>还没收到相邻路由器X的更新路由表，则把x记为不可达的路由器，即把距离设置为16</li><li>返回</li></ol><h4 id="例题">4.5.1.4 例题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213125318.png" alt="image-20221129213125318" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213401526.png" alt="image-20221129213401526" style="zoom:80%;" /></p><h4 id="rip协议的报文格式">4.5.1.5 RIP协议的报文格式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213537077.png" alt="image-20221129213537077" style="zoom:80%;" /></p><ol type="1"><li>RIP是<strong>应用层协议</strong>，使用<strong>UDP</strong>传送数据</li><li>一个RIP报文最多可以包括25个路由，如果超过，则不许再用一个RIP报文传送</li></ol><h4 id="rip协议好消息传得快坏消息传得慢">4.5.1.6RIP协议：好消息传得快，坏消息传得慢</h4><p>RIP的特点：当网络出现故障时，要经过比较长的事件才能将此消息传送到所有的路由器，<strong>慢收敛</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213606257.png" alt="image-20221129213606257" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213808530.png" alt="image-20221129213808530" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213832003.png" alt="image-20221129213832003" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213838273.png" alt="image-20221129213838273" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213849121.png" alt="image-20221129213849121" style="zoom:80%;" /></p><h4 id="总结-17">4.5.1.7 总结</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129213933023.png" alt="image-20221129213933023" style="zoom:80%;" /></p><h3 id="ospf协议与链路状态算法">4.5.2 OSPF协议与链路状态算法</h3><h4 id="ospf协议">4.5.2.1 OSPF协议</h4><p><strong>开放最短路径优先OSPF协议</strong>:</p><ol type="1"><li>“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的</li><li>“最短路径优先”·是因为使用了Dijkstra提出的最短路径算法SPF</li></ol><p>OSPF最主要的特征：</p><ol type="1"><li>使用分布式的<strong>链路状态协议</strong></li></ol><p>OSPF的特点：</p><ol type="1"><li><strong>和谁交换</strong>：使用<strong>洪泛法</strong>向自治系统内<strong>所有路由器</strong>发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。<strong>广播</strong><ol type="1"><li>最终整个区域内所有路由器都得到了这个信息的一个副本</li></ol></li><li><strong>交换什么</strong>：发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>(本路由器和哪些路由器相邻，以及该链路的度量/代价：费用、距离、时延、带宽等)</li><li><strong>多久交换</strong>：只有当<strong>链路状态发生变化</strong>时，路由器才向所有路由器洪泛发送此信息</li><li>最后，所有路由器都能建立一个<strong>链路状态数据库</strong>，即<strong>全网拓扑图</strong></li></ol><h4 id="链路状态算法">4.5.2.2 链路状态算法</h4><ol type="1"><li>每个路由器发现它的邻居结点【<strong>HELLO问候分组</strong>】，并了解邻居节点的网络地址</li><li>设置到它的每个邻居的<strong>成本度量metric</strong></li><li>构造【<strong>DD数据库描述分组</strong>】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>如果DD分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【<strong>LSR链路状态请求分组</strong>】请求自己没有的和比自己更新的信息</li><li>收到邻站的LSR分组后，发送【<strong>LSU链路状态更新分组</strong>】进行更新</li><li>更新完毕后，邻站返回一个【<strong>LSAck链路状态确认分组</strong>】进行确认</li></ol><p>只要一个路由器的链路状态发生变化:</p><ol start="5" type="1"><li>泛洪发送【<strong>LSU链路状态更新分组</strong>】进行更新</li><li>更新完毕后，其他站返回一个【<strong>LSAck链路状态确认分组</strong>】进行确认</li><li>使用Dijkstra根据自己的链路状态数据库<strong>构造到其他节点间的最短路径</strong></li></ol><h4 id="ospf的区域">4.5.2.3 OSPF的区域</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129214835703.png" alt="image-20221129214835703" style="zoom:80%;" /></p><h4 id="ospf分组">4.5.2.4 OSPF分组</h4><ol type="1"><li>OSPF直接使用<strong>IP数据报</strong>传送</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221129214958641.png" alt="image-20221129214958641" style="zoom:80%;" /></p><h4 id="ospf其他特点">4.5.2.5 OSPF其他特点</h4><ol type="1"><li>每隔30min，要刷新一次数据库中的链路状态</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多</li><li>OSPF不存在坏消息传的慢的问题，它的收敛速度很快</li></ol><h3 id="bgp协议">4.5.3 BGP协议</h3><h4 id="bgp协议和谁交换多久交换一次交换什么">4.5.3.1BGP协议和谁交换？多久交换一次？交换什么？</h4><ol type="1"><li><strong>和谁交换</strong>：与其它AS的邻站BGP发言人交换信息</li><li><strong>交换什么</strong>：交换网络可达性的信息，即要到达某个网络所要经过的一系列AS</li><li><strong>多久交换</strong>：发生变化时<strong>更新有变化</strong>的部分</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206155545414.png" alt="image-20221206155545414" style="zoom:80%;" /></p><h4 id="bgp协议交换信息的过程">4.5.3.2 BGP协议交换信息的过程</h4><ol type="1"><li><p>BGP所交换的网络可达性的信息：<strong>要到达某个网络所要经过的一系列AS</strong></p></li><li><p>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的<strong>较好路由</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206155653004.png" alt="image-20221206155653004" style="zoom:80%;" /></p></li><li><p>BGP发言人交换<strong>路径向量</strong>：</p><ol type="1"><li><p>自治系统AS<sub>2</sub>的BGP发言人通知主干网AS<sub>1</sub>的BGP发言人:“要到达网络N1、 N2、N3、N4可经过AS<sub>2</sub>。”</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206155919276.png" alt="image-20221206155919276" style="zoom:80%;" /></p></li><li><p>主干网还可发出通知：“要到达网络N5、N6和N7可沿路径(AS<sub>1</sub>，AS<sub>3</sub>)。”</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206160217081.png" alt="image-20221206160217081" style="zoom:80%;" /></p></li></ol></li></ol><h4 id="bgp协议报文格式">4.5.3.3 BGP协议报文格式</h4><ol type="1"><li>一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就要<strong>先建立TCP连接</strong>，即通过TCP传送，然后在此连接上交换BGP报文以建立BGP会话(session)，利用BGP会话交换路由信息</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206160353750.png" alt="image-20221206160353750" style="zoom:80%;" /></p><h4 id="bgp协议特点">4.5.3.4 BGP协议特点</h4><ol type="1"><li>BGP支持<strong>CIDR</strong>，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</li><li>在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在<strong>发生变化时更新有变化的部分</strong>。这样做对节省网络带宽和减少路由器的处理开销都有好处。</li></ol><h4 id="bgp-4的四种报文">4.5.3.5 BGP-4的四种报文</h4><ol type="1"><li><strong>OPEN(打开)报文</strong>：用来与相邻的另一个BGP发言人建立关系，并认证发送方</li><li><strong>UPDATE(更新)报文</strong>：通告新路径或撤销原路径</li><li><strong>KEEPALIVE(保活)报文</strong>：在无UPDATE时，周期性证实邻站的连通性;也作为OPEN的确认</li><li><strong>NOTIFICATION(通知)报文</strong>：报告先前报文的差错;也被用于关闭连接</li></ol><h3 id="三种路由协议的比较">4.5.4 三种路由协议的比较</h3><table><colgroup><col style="width: 6%" /><col style="width: 33%" /><col style="width: 29%" /><col style="width: 30%" /></colgroup><thead><tr><th style="text-align: center;">协议</th><th style="text-align: center;">RIP</th><th style="text-align: center;">OSPF</th><th style="text-align: center;">BGP</th></tr></thead><tbody><tr><td style="text-align: center;">类型</td><td style="text-align: center;">内部</td><td style="text-align: center;">内部</td><td style="text-align: center;">外部</td></tr><tr><td style="text-align: center;">路由算法</td><td style="text-align: center;">距离-向量</td><td style="text-align: center;">链路状态</td><td style="text-align: center;">路径-向量</td></tr><tr><td style="text-align: center;">传递协议</td><td style="text-align: center;">UDP</td><td style="text-align: center;">IP</td><td style="text-align: center;">TCP</td></tr><tr><td style="text-align: center;">路径选择</td><td style="text-align: center;">跳数最少</td><td style="text-align: center;">代价最低</td><td style="text-align: center;">较好，非最佳</td></tr><tr><td style="text-align: center;">交换节点</td><td style="text-align: center;">和本结点相邻的路由器</td><td style="text-align: center;">网络中的所有路由器</td><td style="text-align: center;">和本结点相邻的路由器</td></tr><tr><td style="text-align: center;">交换内容</td><tdstyle="text-align: center;">当前本路由器知道的全部信息，即自己的路由表</td><tdstyle="text-align: center;">与本路由器相邻的所有路由器的链路状态</td><tdstyle="text-align: center;">首次：整个路由表；非首次：有变化的部分</td></tr></tbody></table><h2 id="ip组播">4.6 IP组播</h2><h3 id="ip数据报的三种传输方式">4.6.1 IP数据报的三种传输方式</h3><ol type="1"><li><p><strong>单播</strong>：单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种<strong>点对点</strong>传输方式</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206192249707.png" alt="image-20221206192249707" style="zoom: 67%;" /></p></li><li><p><strong>广播</strong>：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种<strong>点对多点</strong>传输方式</p></li><li><p><strong>组播(多播)</strong>：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据<strong>到达距离用户端尽可能近的节点后才开始复制和分发</strong>，是一种<strong>点对多点</strong>传输方式</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206192330579.png" alt="image-20221206192330579" style="zoom: 67%;" /></p></li></ol><h3 id="ip组播地址">4.6.2 IP组播地址</h3><ol type="1"><li>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配<strong>一个组播组IP地址</strong>(<strong>一群共同需求主机的相同标识</strong>)</li><li>组播地址范围为224.0.0.0~239.255.255.255(D类地址)，一个D类地址表示一个组播组。只能用作分组的<strong>目标地址</strong>。<strong>源地址总是为单播地址</strong></li></ol><p>组播的特点：</p><ol type="1"><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于<strong>UDP</strong></li><li>对组播数据报不产生ICMP差错报文</li><li>并非所有D类地址都可以作为组播地址，有的地址被定义为永久组播地址</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206192712826.png" alt="image-20221206192712826" style="zoom:80%;" /></p><h3 id="硬件组播">4.6.3 硬件组播</h3><ol type="1"><li>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送顿。</li><li><strong>地址的转换</strong>：组播MAC地址以十六进制值<strong>01-00-5E</strong>打头，余下的6个十六进制位是IP组播组地址的<strong>最后23位</strong></li><li>TCP/IP协议使用的以太网多播地址的范围是：<strong>01-00-5E-00-00-00</strong>到<strong>01-00-5E-7F-FF-FF</strong></li><li></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206193244101.png" alt="image-20221206193244101" style="zoom:80%;" /></p><h3 id="igmp协议与组播路由选择协议">4.6.4IGMP协议与组播路由选择协议</h3><ol type="1"><li><strong>IGMP协议</strong>：判断一个路由器所连的局域网中，是否有主机参加/退出某个组播组</li><li><strong>组播路由选择协议</strong>：路由器之间进行路径选择</li></ol><h4 id="网际组管理协议-igmp">4.6.4.1 网际组管理协议 IGMP</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206193546317.png" alt="image-20221206193546317" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206193641440.png" alt="image-20221206193641440" style="zoom:80%;" /></p><p>IGMP工作的两个阶段：</p><ol type="1"><li>ROUND 1<ol type="1"><li>某主机要加入组播组时，该主机向组播组的<strong>组播地址</strong>发送一个IGMP报文，声明自己要称为该组的成员</li><li>本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器</li></ol></li><li>ROUND 2<ol type="1"><li>本地组播路由器<strong>周期性探询</strong>本地局域网上的主机，以便知道这些主机是否还是组播组的成员</li><li><strong>只要有一个主机</strong>对某个组响应，那么组播路由器就认为这个组是活跃的;如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器</li></ol></li><li><strong>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员</strong>，并不会反应该组播组成员有多少个，因为路由器页不知道</li></ol><h4 id="组播路由选择协议">4.6.4.2 组播路由选择协议</h4><ol type="1"><li><p>目的：找出以源主机为根节点的组播转发树</p></li><li><p>构造树可以避免在路由器之间兜圈子</p></li><li><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206195118352.png" alt="image-20221206195118352" style="zoom:80%;" /></p></li><li><p>三种算法：</p><ol type="1"><li>基于链路状态的路由选择</li><li>基于距离-向量的路由选择</li><li>协议无关的组播(稀疏/密集)</li></ol></li></ol><h3 id="总结-18">4.6.5 总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221206195344098.png" alt="image-20221206195344098" style="zoom:80%;" /></p><h2 id="移动ip">4.7 移动IP</h2><ol type="1"><li>动态IP：通过使用DHCP协议，在一个局域网内部的主机可以动态的获得一个IP地址</li><li>移动IP：物理位置改变，但IP地址不变</li></ol><h3 id="移动ip相关术语">4.7.1 移动IP相关术语</h3><ol type="1"><li>移动IP技术：是移动结点(计算机/服务器等)以<strong>固定的网络IP地址</strong>，实现跨越不同网段的<strong>漫游</strong>功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变</li><li><strong>移动节点</strong>：具有永久IP地址的移动设备</li><li><strong>归属代理(本地代理)</strong>：一个移动结点拥有的就“居所”称为<strong>归属网络</strong>，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理</li><li><strong>外部代理(外地代理)</strong>：在<strong>外部网络</strong>中帮助移动节点完成移动管理功能的实体称为外部代理</li><li><strong>永久地址(归属地址/主地址)</strong>：移动站点在归属网络中的原始地址</li><li><strong>转交地址(辅地址)</strong>：移动站点在外部网络使用的临时地址</li></ol><h3 id="移动ip通信过程">4.7.2 移动IP通信过程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212185925655.png" alt="image-20221212185925655" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212190018543.png" alt="image-20221212190018543" style="zoom:80%;" /></p><h2 id="网络层设备">4.8 网络层设备</h2><h3 id="路由器">4.8.1 路由器</h3><ol type="1"><li>路由器：是一种具有多个输入端口和多个输出端口的专用计算机<ol type="1"><li>任务：转发分组</li></ol></li><li>路由选择：根据所选定的路由选择协议<strong>构造路由表</strong>，同时经常或定期和相邻路由器交换路由信息而不断地<strong>更新和维护路由表</strong></li><li>交换结构：根据<strong>转发表(由路由表得来)</strong>对分组进行转发</li><li>转发 vs 路由选择：<ol type="1"><li>转发：是一个路由器内部，确定数据应该被发向哪个端口</li><li>路由选择：是路由器决定数据下一个应当去往哪个路由器</li></ol></li><li>如果收到RIP/OSPF分组，则把分组送往路由选择处理机；若收到数据分组，则查找转发表并输出</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212190813832.png" alt="image-20221212190813832" style="zoom:80%;" /></p><h4 id="输入端口对线路上收到的分组的处理">4.8.1.1输入端口对线路上收到的分组的处理</h4><p>输入端口中，查找和转发功能在路由器的交换功能中是最重要的</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212190838959.png" alt="image-20221212190838959" style="zoom:80%;" /></p><h4 id="输出端口将交换结构传送来的分组发送到线路">4.8.1.2输出端口将交换结构传送来的分组发送到线路</h4><ol type="1"><li>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃</li><li><strong>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212191008504.png" alt="image-20221212191008504" style="zoom:80%;" /></p><h3 id="三层设备的区别">4.8.2 三层设备的区别</h3><ol type="1"><li><strong>路由器</strong>：可以互联两个不同网络层协议的网段</li><li><strong>网桥</strong>：可以互联两个物理层和链路层不同的网段</li><li><strong>集线器</strong>：不能互联两个物理层不同的网段</li><li><strong>任何层次的设备都能互联它所在的层次以及以下层次不同协议的网段(×，集线器不可以)</strong></li></ol><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">能否隔离冲突域</th><th style="text-align: center;">能否隔离广播域</th></tr></thead><tbody><tr><td style="text-align: center;">物理层设备(中继器、集线器)</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td></tr><tr><td style="text-align: center;">链路层设备(网桥、交换机)</td><td style="text-align: center;">√</td><td style="text-align: center;">×</td></tr><tr><td style="text-align: center;">网络层设备(路由器)</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr></tbody></table><h3 id="路由表与路由转发">4.8.3 路由表与路由转发</h3><ol type="1"><li><strong>路由表</strong>：根据<strong>路由选择算法</strong>得出，主要用于路由选择，总用软件实现</li><li><strong>转发表</strong>：根据<strong>路由表</strong>得出，可以用软件实现，也可以用特殊的硬件来实现。转发表必须包含完成转发功能所必需的信息，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息的映射</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212191556123.png" alt="image-20221212191556123" style="zoom:80%;" /></p><h2 id="补充">4.9 补充</h2><h3 id="网络互联隧道-tunneling">4.9.1 网络互联：隧道 Tunneling</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231174433620.png" alt="image-20221231174433620" style="zoom:80%;" /></p><ol type="1"><li>多个相同类型的网络，通过不同类型的网络进行互联</li></ol><h3 id="包的切割">4.9.2 包的切割</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231174618356.png" alt="image-20221231174618356" style="zoom:80%;" /></p><ol type="1"><li>允许切割<ol type="1"><li>不透明：切完以后不还原，到目的地还原</li><li>透明：切完以后还原</li></ol></li><li>不允许切割<ol type="1"><li>IPv6选择不允许切割，如果包太大，就直接踢回去，让源主机切割</li></ol></li></ol><h3 id="软件定义网络sdnsoftware-defined-networking">4.9.3软件定义网络SDN：Software-Defined Networking</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231174855353.png" alt="image-20221231174855353" style="zoom:80%;" /></p><ol type="1"><li>数据平面：通常是分布式的</li><li>管理平面：通常是集中式的</li><li>SDN：管理平面集中在一个软件控制器中，软件控制器为每个路由计算其路由表，路由从软件控制器中下载路由表使用</li></ol><h3 id="标记交换-label-switching">4.9.4 标记交换 Label Switching</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231175606687.png" alt="image-20221231175606687" style="zoom:80%;" /></p><h1 id="chapter-5传输层-transport-layer">Chapter 5：传输层 TransportLayer</h1><h2 id="传输层概述">5.1 传输层概述</h2><ol type="1"><li>只有主机才有</li><li>为应用层提供通信服务，使用网络层的服务</li><li>传输层的功能：<ol type="1"><li>提供<strong>进程与进程之间</strong>的逻辑通信(网络层提供的是主机之间的逻辑通信)</li><li>复用与分用<ol type="1"><li>复用：不同进程使用同一传输层协议进行传输</li><li>分用：将传来的报文段送交给某个进程</li></ol></li><li>对收到的<strong>报文</strong>进行<strong>差错检测</strong></li></ol></li></ol><h3 id="传输层的两种协议tcpudp">5.1.1 传输层的两种协议：TCP、UDP</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212193149384.png" alt="image-20221212193149384" style="zoom:80%;" /></p><h3 id="传输层的寻址与端口">5.1.2 传输层的寻址与端口</h3><ol type="1"><li><p><strong>复用</strong>：应用层所有的应用进程，都能够通过传输层在传输到网络层</p></li><li><p><strong>分用</strong>：传输层从网络层收到数据后，交付给指明的应用程序</p></li><li><p><strong>端口/逻辑端口/软件端口</strong>：是传输层的SAP，标识主机中的应用进程</p><ol type="1"><li>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的</li><li>端口号长度为16bit，能表示65536个不同的端口号</li></ol></li><li><p>端口号按范围分：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212193708560.png" alt="image-20221212193708560" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212193745221.png" alt="image-20221212193745221" style="zoom:80%;" /></p></li><li><p><strong>套接字Socket = (主机IP地址，端口号)</strong></p><ol type="1"><li>在网络中采用发送方和接收方的套接字组合来识别端点</li><li>套接字唯一标识了网络中的一个主机和它上面的一个进程</li></ol></li></ol><h2 id="udp协议">5.2 UDP协议</h2><ol type="1"><li>UDP在IP数据报服务之上，仅添加了复用分用、差错检测功能</li><li>UDP的主要特点：<ol type="1"><li><strong>无连接</strong>，减小开销和发送数据之前的时延</li><li><strong>不保证可靠交付</strong></li><li><strong>面向报文</strong>，适合一次性传输少量数据，如果太大需要网络层分片</li><li><strong>无拥塞控制</strong>，适合很多实时应用</li><li><strong>首部开销小</strong>，只有8B(TCP为20B)</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212194133114.png" alt="image-20221212194133114" style="zoom:80%;" /></p><h3 id="udp首部格式">5.2.1 UDP首部格式</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212194537991.png" alt="image-20221212194537991" style="zoom:80%;" /></p><ol type="1"><li><strong>源端口号</strong>：可有可无，想要回复则填上</li><li><strong>UDP长度</strong>：整个UDP用户数据报的长度</li><li><strong>UDP检验和</strong>：检测整个UDP</li><li>丢弃情况：<ol type="1"><li>UDP检验和错误，则丢弃报文</li><li>分用时，找不到目的端口号，则丢弃报文，并发送给发送方ICMP”端口不可达”差错报告报文</li></ol></li></ol><h3 id="udp检验">5.2.2 UDP检验</h3><h4 id="伪首部">5.2.2.1 伪首部</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212194907694.png" alt="image-20221212194907694" style="zoom:80%;" /></p><ol type="1"><li>伪IP首部</li><li>只有在计算校验和的时候出现，不向下传送也不向上递交</li><li>17：封装UDP报文的IP数据报首部协议字段是17</li><li>UDP长度：UDP首部8B + 数据部分的长度，不包括伪首部</li></ol><h4 id="校验方式">5.2.2.2 校验方式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212195051240.png" alt="image-20221212195051240" style="zoom:80%;" /></p><ol type="1"><li>发送端：<ol type="1"><li>填上伪首部</li><li>检验和：填充为全0</li><li>数据部分：不足4B的用0补齐</li><li>伪首部 + 首部 + 数据部分 用二进制反码求和(此时校验和全0)</li><li>检验和：将求和结果的反码填入</li><li>删除伪首部，然后发送</li></ol></li><li>接收端：<ol type="1"><li>填上伪首部</li><li>伪首部 + 首部 + 数据部分 用二进制反码求和(此时校验和是有数的)</li><li>结果全为1则无差错，否则丢弃数据报 / 交给应用层并附上差错的警告</li></ol></li></ol><h2 id="tcp协议">5.3 TCP协议</h2><h3 id="tcp协议特点">5.3.1 TCP协议特点</h3><ol type="1"><li>TCP是<strong>面向连接</strong>(虚连接)的传输层协议</li><li>每一条TCP连接只能有2个端点，每一条TCP连接只能是点对点的</li><li>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序抵达：<strong>可靠有序，不丢不重</strong></li><li>TCP提供<strong>全双工通信</strong>：两端均有发送缓存、接收缓存<ol type="1"><li>发送缓存：准备发送的数据 &amp; 已经发送但尚未收到确认的数据</li><li>接收缓存：不按序到达的数据 &amp;按序到达但尚未被应用程序读取的数据</li></ol></li><li>TCP面向<strong>字节流</strong><ol type="1"><li>流：流入到进程 / 从进程流出的数据</li><li>TCP把应用层交下来的数据看成仅仅是一连串的<strong>无结构的字节流</strong></li></ol></li></ol><h3 id="tcp报文段首部格式重点">5.3.2TCP报文段首部格式(<strong>重点</strong>)</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212200021591.png" alt="image-20221212200021591"  /></p><ol type="1"><li><strong>序号seq</strong> 4B：<ol type="1"><li>在一个TCP连接中，传送的字节流中的每一个字节都按顺序编号，本字段表示<strong>本报文段</strong>所发送数据的<strong>第一个字节的序号</strong></li><li>如当前TCP报文发送的是文件的第4、5、6字节，则此处的序号填4</li></ol></li><li><strong>确认号ack</strong> 4B：<ol type="1"><li><strong>期望</strong>收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明0~N-1的所有数据均已正确收到</li></ol></li><li><strong>数据偏移(首部长度) </strong> 4bit：<ol type="1"><li>TCP报文段的数据起始处距离TCP报文段的起始处有多远，<strong>单位为4B</strong></li></ol></li><li><strong>控制位</strong> 6bit：<ol type="1"><li><strong>紧急位URG</strong>：URG=1时，表明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用再缓存里排队。配合紧急指针字段使用（发送端的优先处理）</li><li><strong>确认位ACK</strong>：ACK=1时，确认号有效，在连接建立后，所有传送的报文段都必须把ACK置为1</li><li>推送位PSH：PSH=1时，接收方应尽快交付接收应用进程，不再等到缓存填充满再向上交付（接收端的优先处理）</li><li>复位RST：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输连接</li><li><strong>同步位SYN</strong>：SYN=1时，表明是一个<strong>连接请求/连接接受报文</strong></li><li><strong>终止位FIN</strong>：FIN=1时，表明此报文段发送方数据已发完，要求释放连接</li></ol></li><li><strong>窗口</strong> 2B：<ol type="1"><li>发送方的接收窗口，即现在允许对方发送的数据量</li><li>窗口大小最高为65536</li><li>如果确认号为701，窗口为1000，则发送方的接收窗口的缓存队列应为701~1700</li></ol></li><li><strong>检验和</strong> 2B：<ol type="1"><li>检验首部 +数据，检验时要加上12B的伪首部，伪首部的第四个字段为<strong>6</strong></li></ol></li><li><strong>紧急指针</strong> 2B：<ol type="1"><li>URG=1时才有意义</li><li>指出本报文段中紧急数据的字节数（紧急数据的末尾在报文段中的位置）</li><li>如果紧急指针为50，则0~50均为紧急数据</li></ol></li><li><strong>选项</strong>：<ol type="1"><li>最大报文段长度MSS：每个TCP报文段中数据字段的最大长度</li><li>窗口扩大、时间戳、选择确认</li></ol></li><li><strong>填充</strong>：<ol type="1"><li>TCP首部长度为<strong>4B的整数倍</strong>，一般填充全0</li></ol></li></ol><h3 id="tcp连接管理">5.3.3 TCP连接管理</h3><p>TCP连接传输的三个阶段：</p><ol type="1"><li>连接建立</li><li>数据传输</li><li>连接释放</li></ol><p>TCP连接的建立采用的是<strong>客户服务器方式</strong>：</p><ol type="1"><li>客户：主动发起连接建立的应用进程</li><li>服务器：被动等待连接建立的应用进程</li></ol><h4 id="tcp的连接建立三次握手">5.3.3.1TCP的连接建立(<strong>三次握手</strong>)</h4><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212221059360.png" alt="image-20221212221059360" style="zoom:80%;" /></p></blockquote><p>假设运行在一台主机(客户)上的一个进程想与另一台主机(服务器)上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接：</p><ol type="1"><li>客户端发送<strong>连接请求报文段</strong>，无应用层数据<ol type="1"><li><strong>SYN=1，seq=x(随机数)，ACK=0</strong></li></ol></li><li>服务器端为该TCP连接<strong>分配缓存和变量</strong>，并向服务器端返回<strong>确认报文段</strong>，允许连接，无应用层数据<ol type="1"><li><strong>SYN=1，ACK=1，seq=y(随机数)，ack=x+1</strong></li></ol></li><li>客户端为该TCP连接<strong>分配缓存和变量</strong>，并向服务器端返回确认的确认，可以携带数据<ol type="1"><li><strong>SYN=0，ACK=1，seq=x+1，ack=y+1</strong></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212220257670.png" alt="image-20221212220257670" style="zoom:80%;" /></p><p>SYN洪泛攻击</p><ol type="1"><li>SYN洪泛攻击发生在<strong>OSI第四层</strong>，这种方式利用<strong>TCP协议</strong>的特性，就是<strong>三次握手</strong></li><li>攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者，这样更加会浪费服务器的资源</li><li>攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了</li></ol><p>解决方法：SYN cookie</p><h4 id="tcp的连接释放四次握手">5.3.3.2TCP的连接释放(<strong>四次握手</strong>)</h4><blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212221038391.png" alt="image-20221212221038391" style="zoom:80%;" /></p></blockquote><p>参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”(缓存和变量)将被释放：</p><ol type="1"><li>客户端发送<strong>连接释放报文段</strong>，停止发送数据，主动关闭TCP连接<ol type="1"><li><strong>FIN=1，seq=u(客户端发送到的地方)</strong></li></ol></li><li>服务端回送一个<strong>确认报文段</strong>，<strong>客户到服务端</strong>这个方向的连接就释放了：<strong>半关闭</strong>状态<ol type="1"><li><strong>ACK=1，seq=v(服务器发送到的地方)，ack=u+1</strong></li></ol></li><li>服务器端发完数据，就发出<strong>连接释放报文段</strong>，主动关闭TCP连接<ol type="1"><li><strong>FIN=1，ACK=1，seq=w，ack=u+1</strong></li></ol></li><li>客户端回送一个<strong>确认报文段</strong>，再等到<strong>时间等待计时器</strong>设置的<strong>2MSL(最长报文段寿命)</strong>后，连接彻底关闭<ol type="1"><li><strong>ACK=1，seq=u+1，ack=w+1</strong></li><li>如果服务器无法收到客户端回送的确认报文段，客户端会在2MSL之内收到重传的报文段，客户端然后重传确认，并且重新启动2MSL的计时器</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212220312555.png" alt="image-20221212220312555" style="zoom:80%;" /></p><h3 id="tcp可靠传输">5.3.4 TCP可靠传输</h3><ol type="1"><li>网络层：尽最大努力交付，不可靠传输</li><li>传输层：使用TCP实现可靠传输</li><li><strong>可靠</strong>：保证接收方进程从缓存区中读出的字节流与发送方发出的字节流是完全一样的</li><li>TCP实现可靠传输的机制：<ol type="1"><li>校验：与UDP校验一样，<strong>添加伪首部</strong></li><li>序号</li><li>确认</li><li>重传</li></ol></li></ol><h4 id="序号">5.3.4.1 序号</h4><ol type="1"><li>TCP面向字节流，因此会将字节编号，发送时将多个字节拼在一起形成一个报文段</li><li>一个字节占一个序号</li><li><strong>序号字段</strong>：一个报文段第一个字节的序号</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212221544009.png" alt="image-20221212221544009" style="zoom:80%;" /></p><h4 id="确认">5.3.4.2 确认</h4><ol type="1"><li>接收方发送确认报文段，告诉发送方已经正确接收</li><li>TCP使用累计确认：<ol type="1"><li>正常接收78，但确认报文段表示接收方期待4</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212222154032.png" alt="image-20221212222154032" style="zoom:80%;" /></p><h4 id="重传">5.3.4.3 重传</h4><ol type="1"><li>TCP的发送方在<strong>规定的时间</strong>内没有收到确认，就要重传已发送的报文段：<strong>超时重传</strong>，该时间称为<strong>重传时间</strong></li><li>TCP采用自适应算法，动态改变重传时间<strong>RTTs(加权平均往返时间)</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212222443344.png" alt="image-20221212222443344" style="zoom:80%;" /></p><p><strong>冗余ACK(冗余确认)</strong></p><ol type="1"><li>每当比期望序号大的失序报文段到达时，发送一个<strong>冗余ACK</strong>，指明下一个期待字节的序号<ol type="1"><li>发送方已发送1，2，3，4，5报文段</li><li>接收方收到1，返回给1的确认(确认号为2的第一个字节)</li><li>接收方收到3，返回给1的确认(确认号为2的第一个字节)</li><li>接收方收到4，返回给1的确认(确认号为2的第一个字节)</li><li>接收方收到5，返回给1的确认(确认号为2的第一个字节)</li><li>发送方收到<strong>3个对于报文段1的冗余ACK</strong> →认为报文段2丢失，重传2号报文段</li></ol></li><li>称为<strong>快速重传</strong>机制</li></ol><h3 id="tcp流量控制重点">5.3.5 TCP流量控制(<strong>重点</strong>)</h3><ol type="1"><li>流量控制：让<strong>发送方慢点</strong>，要让接收方来得及接收</li><li>TCP使用<strong>滑动窗口</strong>机制实现流量控制<ol type="1"><li>在通信过程中，接收方根据自己<strong>接收缓存的大小</strong>，动态地调整发送方的发送窗口大小，即<strong>接收窗口rwnd</strong>(接收方设置确认报文段的<strong>窗口字段</strong>来将rwnd通知给发送方)</li><li>发送方的<strong>发送窗口</strong>为：<strong>min{接收窗口rwnd，拥塞窗口cwnd}</strong></li><li>建立连接时，接收方返回的确认报文段中包含自己的接收窗口大小，发送方根据上述公式确定发送窗口</li><li>发送窗口的大小可以动态变化</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212223450799.png" alt="image-20221212223450799" style="zoom:80%;" /></p><blockquote><p>A向B发送数据，连接建立时，B告诉A：“我的rwnd=400B”</p><p>设每一个报文段为100B，报文段序号初始值为1</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212224030365.png"alt="image-20221212224030365" /><figcaption aria-hidden="true">image-20221212224030365</figcaption></figure><p>解决零窗口通知后，新的窗口大小的报文段丢失，导致两个主机相互等待的问题：</p><ol type="1"><li>TCP为每一个连接设有一个<strong>持续计时器</strong>，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器</li><li>若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>。接收方收到探测报文段时给出现在的窗口值</li><li>若窗口仍然是0，那么发送方就重新设置持续计时器</li></ol><h3 id="tcp拥塞控制重点">5.3.6 TCP拥塞控制(<strong>重点</strong>)</h3><ol type="1"><li>出现拥塞的条件：对资源需求的总和 &gt; 可用资源</li><li>网络中有许多资源同时呈现供应不足 → 网络性能变坏 →网络吞吐量将随输入负荷的增大而下降</li><li>拥塞控制：防止过多数据注入网络中<ol type="1"><li><strong>全局性问题</strong></li><li>协调使用资源的所有主机</li><li>发送方发送的数据无法到达接收端</li></ol></li><li>流量控制：<ol type="1"><li><strong>点对点问题</strong></li><li>接收端接收到的数据太多，无法处理</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212224630161.png" alt="image-20221212224630161" style="zoom:80%;" /></p><p>假定：</p><ol type="1"><li>数据单方向传送，另一个方向只传送确认</li><li>接收方总有足够大的缓存空间，因而发送窗口大小取决于拥塞程度<ol type="1"><li><strong>接收窗口</strong>：<strong>接收方</strong>根据接受缓存设置的值，并告知给发送方，反映<strong>接收方容量</strong></li><li><strong>拥塞窗口</strong>：<strong>发送方</strong>根据自己估算的网络拥塞程度而设置的窗口值，反映<strong>网络当前容量</strong></li></ol></li></ol><h4 id="拥塞控制的四种算法慢开始-拥塞避免-tcp-tahoe">5.3.6.1拥塞控制的四种算法：慢开始 &amp; 拥塞避免 (TCP Tahoe)</h4><ol type="1"><li>一个<strong>传输轮次</strong>：<ol type="1"><li>发送了<strong>一批</strong>报文段，并收到它们的确认时间</li><li>一个往返时延<strong>RTT</strong></li><li>开始发送一批拥塞窗口内的报文段，到开始发送下一批拥塞窗口内的报文段的时间</li></ol></li><li><strong>慢开始</strong>：<ol type="1"><li>每经过一个传输轮次，拥塞窗口翻倍，<strong>指数增长</strong></li><li>翻倍的时间：收到报文段的确认之后立即翻倍</li></ol></li><li><strong>拥塞避免</strong>：<ol type="1"><li>当拥塞窗口的大小达到<strong>ssthresh(拥塞窗口门限值)</strong>时，每经过一个传输轮次，拥塞窗口加1，<strong>加法增长</strong></li></ol></li><li>当出现网络拥塞时<ol type="1"><li>将拥塞窗口设置为1</li><li>修改<strong>ssthresh(拥塞窗口门限值)</strong>，新的<code>ssthresh</code>变为原来的一半</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212230102426.png" alt="image-20221212230102426" style="zoom:80%;" /></p><h4 id="拥塞控制的四种算法快重传-快恢复-tcp-reno">5.3.6.2拥塞控制的四种算法：快重传 &amp; 快恢复 (TCP Reno)</h4><ol type="1"><li><strong>快重传</strong>：<ol type="1"><li>收到同一个报文段的4个ACK报文后，立即重传，不用等待计时器</li></ol></li><li><strong>快恢复</strong>：<ol type="1"><li>快重传后，将拥塞窗口的大小降到新的<strong>ssthresh(拥塞窗口门限值)</strong>即可</li><li>新的<strong>ssthresh(拥塞窗口门限值)</strong>：出现快重传时，将当时的拥塞窗口门限值减半</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212230427800.png" alt="image-20221212230427800" style="zoom:80%;" /></p><h4 id="tcp-cubic">5.3.6.3 TCP CUBIC</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231183050251.png" alt="image-20221231183050251" style="zoom:80%;" /></p><h4 id="bbr">5.3.6.4 BBR</h4><ol type="1"><li>测出整个路径上的瓶颈带宽、往返时延</li><li>窗口大小 = 往返时延 * 瓶颈带宽</li></ol><h1 id="chapter-6应用层">Chapter 6：应用层</h1><h2 id="网络应用模型">6.1 网络应用模型</h2><h3 id="应用层概述">6.1.1 应用层概述</h3><ol type="1"><li>应用层对应用程序的通信提供服务</li><li>应用层协议定义：<ol type="1"><li>应用进程交换的报文类型，请求还是响应?</li><li>各种报文类型的语法，如报文中的各个字段及其详细描述</li><li>字段的语义，即包含在字段中的信息的含义</li><li>进程何时、如何发送报文，以及对报文进行响应的规则</li></ol></li><li>应用层功能：<ol type="1"><li>文件传输、访问、管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ol></li><li>应用层的重要协议<ol type="1"><li>FTP</li><li>SMTP、POP3</li><li>HTTP</li><li>DNS</li></ol></li></ol><h3 id="网络应用模型-1">6.1.2 网络应用模型</h3><ol type="1"><li>客户/服务器模型：Client/Server</li><li>P2P模型：Peer-to-Peer</li></ol><h4 id="客户服务器模型">6.1.2.1 客户/服务器模型</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213112452536.png" alt="image-20221213112452536" style="zoom:80%;" /></p><ol type="1"><li>服务器：<strong>提供计算服务</strong>的设备<ol type="1"><li>永久提供服务</li><li>永久性访问地址/域名</li></ol></li><li>客户机：<strong>请求计算服务</strong>的主机<ol type="1"><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可能使用动态IP地址</li><li>不与其它客户机直接通信</li></ol></li><li>应用：Web、FTP、远程登录、电子邮件</li></ol><h4 id="p2p模型">6.1.2.2 P2P模型</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213112651763.png" alt="image-20221213112651763" style="zoom:80%;" /></p><ol type="1"><li>不存在永远在线的服务器</li><li>每个主机既可以<strong>提供服务</strong>，也可以<strong>请求服务</strong></li><li>任意端系统/节点之间可以<strong>直接通讯</strong></li><li>节点间歇性接入网络</li><li>节点可能改变IP地址</li><li>可拓展性好：主机多了，提供服务的也多了，不会受到服务器带宽的限制</li><li>网络健壮性强：一台主机坏了，对于其它主机影响不大，而C/S模型中服务器坏了就都无法使用服务了</li></ol><h2 id="dns系统">6.2 DNS系统</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213113331407.png" alt="image-20221213113331407" style="zoom:80%;" /></p><h3 id="域名">6.2.1 域名</h3><blockquote><ol type="1"><li>通过<strong>.</strong>区分标号，每个标号不能超过63个字符(通常不超过12个字符)</li><li>每一个标号的字符不区分大小写，只能包括字母、数字、-</li><li>越靠右，级别越高</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213124047973.png" alt="image-20221213124047973"  /></p><ol type="1"><li><strong>根</strong>：在顶级域名之后的一个<strong>.</strong></li><li><strong>顶级域名</strong>：<ol type="1"><li>国家顶级域名：<code>cn</code>，<code>us</code>，<code>uk</code></li><li>通用顶级域名：<code>com</code>(公司/企业)，<code>net</code>(提供信息服务)，<code>org</code>(非盈利性组织)，<code>gov</code>(政府)，<code>int</code>(国际组织)，<code>aero</code>(航空)，<code>museum</code>(博物馆)，<code>travel</code>(旅游业)</li><li>基础结构域名/反向域名：<code>arpa</code>(反向域名解析--IP地址解析为域名)</li></ol></li><li><strong>二级域名</strong>：<ol type="1"><li>类别域名：<code>ac</code>(科研机构)，<code>com</code>(公司/企业)，<code>edu</code>(教育)，<code>gov</code>(政府)，<code>mil</code>(中国国防机构)，<code>net</code>(提供信息服务)，<code>org</code>(非盈利性组织)</li><li>行政区域名：用于我国各省、自治区、直辖市，<code>bj</code>、<code>js</code></li><li>自己注册的域名：<code>cctv</code>、<code>cskaoyan</code></li></ol></li><li><strong>三级域名</strong>：</li><li><strong>四级域名</strong>：</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213125200402.png" alt="image-20221213125200402" style="zoom:80%;" /></p><h3 id="域名服务器">6.2.2 域名服务器</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213185014293.png" alt="image-20221213185014293" style="zoom:80%;" /></p><ol type="1"><li>根域名服务器：知道顶级域名服务器所对应的IP地址<ol type="1"><li>因特网一共有13个根域名服务器域名，分别为<code>a.rootservers.net</code>~<code>m.rootservers.net</code></li></ol></li><li>顶级域名服务器：管理该顶级域名服务器注册的所有二级域名</li><li>权限域名服务器：负责一个<strong>区</strong>的域名服务器<ol type="1"><li>区：一台域名服务器所管辖的实际范围</li><li>图中<code>abc.org</code>和<code>y.abc.org</code>是两个平等的区，由两个权限域名服务器控制</li></ol></li><li>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器</li></ol><h3 id="域名解析过程">6.2.3 域名解析过程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213185458020.png" alt="image-20221213185458020" style="zoom:80%;" /></p><ol type="1"><li>递归查询：<strong>靠别人</strong><ol type="1"><li>查询顺序：主机 =&gt; 本地域名服务器 =&gt; 根域名服务器 =&gt;顶级域名服务器 =&gt; 权限域名服务器</li><li>返回顺序：权限域名服务器 =&gt; 顶级域名服务器 =&gt; 根域名服务器=&gt; 本地域名服务器 =&gt; 主机</li></ol></li><li>迭代查询：<strong>靠自己</strong><ol type="1"><li>查询顺序：主机 =&gt; 本地域名服务器 =&gt; 根域名服务器 =&gt;本地域名服务器 =&gt; 顶级域名服务器 =&gt; 本地域名服务器 =&gt;权限域名服务器</li><li>返回顺序：本地域名服务器 =&gt; 主机</li></ol></li><li><strong>高速缓存</strong>：<ol type="1"><li>本机域名服务器/主机中的高速缓存</li><li>存放最近查询到的域名，以及从何处得到的该域名信息的记录</li><li>会定期更新</li></ol></li></ol><h2 id="文件传输协议ftp">6.3 文件传输协议FTP</h2><ol type="1"><li>文件传输协议FTP：File Transfer Protocol<ol type="1"><li>提供不同种类主机系统之间的文件传输能力</li><li>硬件、软件体系等都可以不同</li><li>是一种拷贝：上传 &amp; 下载</li></ol></li><li>简单文件传输协议TFTP：Trivial File Transfer Protocol</li></ol><h3 id="ftp服务器和用户端">6.3.1 FTP服务器和用户端</h3><ol type="1"><li>FTP是基于客户/服务器(C/S)的协议</li><li>用户通过一个客户机程序连接到在远程计算机上运行的服务器端程序</li><li><strong>FTP服务器</strong>：依照FTP协议提供服务，进行文件传输的计算机</li><li><strong>FTP客户端</strong>：连接FTP服务器，遵循FTP协议与服务器传送文件的电脑</li></ol><h3 id="ftp工作原理">6.3.2 FTP工作原理</h3><ol type="1"><li>登陆：<ol type="1"><li>ftp地址<ol type="1"><li>用户名 &amp; 密码</li><li>匿名登陆<ol type="1"><li>互连网中有很大一部分FTP服务器被称为“匿名” (Anonymous) FTP服务器</li><li>这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权</li><li><code>Anonymous</code>(匿名文件传输)能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户</li><li>用户使用特殊的用户名“<code>anonymous</code>"登陆FTP服务，就可访问远程主机上公开的文件</li></ol></li></ol></li></ol></li><li><strong>FTP</strong>使用<strong>TCP</strong>实现可靠传输</li><li>FTP服务器进程<ol type="1"><li>1个主进程：负责接收新的请求<ol type="1"><li>打开服务器的熟知端口<code>21</code></li><li>等待客户程序进行连接请求</li></ol></li><li>n个从属进程：负责与客户程序进行文件传输</li></ol></li><li>控制进程、数据传送进程 均为 从属进程<ol type="1"><li><strong>控制</strong>连接<strong>始终</strong>保持</li><li><strong>数据</strong>连接只保持一会</li><li>是否使用<code>TCP 20</code>端口建立<strong>数据连接</strong>，与<strong>传输模式</strong>有关<ol type="1"><li><strong>主动</strong>方式，使用<code>TCP 20</code>端口</li><li><strong>被动</strong>方式，由服务器与客户端自行协商决定(端口&gt;1024)</li></ol></li></ol></li><li>FTP传输模式<ol type="1"><li>文本模式：ASCII模式，以文本序列传输数据</li><li>二进制模式：Binary模式，以二进制序列传输数据</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213210724859.png" alt="image-20221213210724859" style="zoom:80%;" /></p><h2 id="电子邮件">6.4 电子邮件</h2><h3 id="电子邮件的信息格式">6.4.1 电子邮件的信息格式</h3><ol type="1"><li>电子邮件<ol type="1"><li>信封：<ol type="1"><li>收件人的邮箱，如<code>abc@163.com</code></li><li><code>abc</code>是收件人在网易邮箱服务器中注册的用户名</li><li><code>@163.com</code>表示使用的是网易邮箱服务器</li></ol></li><li>内容：<ol type="1"><li>首部：<ol type="1"><li>发送给谁，如<code>To: abc@163.com</code></li><li>邮件的主题，如<code>Subject: Hello!</code></li><li>会自动生成一部分内容</li></ol></li><li>主体</li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213211407410.png" alt="image-20221213211407410" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231183411062.png" alt="image-20221231183411062" style="zoom:80%;" /></p><h3 id="组成结构">6.4.2 组成结构</h3><ol type="1"><li><strong>用户代理</strong>：电子邮件客户端软件<ol type="1"><li>撰写邮件</li><li>显示邮件</li><li>处理邮件：发送/接收/转发…</li><li>通信：将邮件发送出去</li></ol></li><li><strong>邮件服务器</strong>：<ol type="1"><li>发送&amp;接收邮件</li><li>向发件人报告邮件传送结果</li><li>使用C/S模式，既可以作客户，也可以作服务器</li></ol></li><li><strong>协议</strong>：<ol type="1"><li>SMTP：发送邮件</li><li>POP3、IMAP：接收邮件</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213211750601.png" alt="image-20221213211750601" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213212943898.png" alt="image-20221213212943898" style="zoom:80%;" /></p><h3 id="简单邮件传送协议smtp">6.4.3 简单邮件传送协议SMTP</h3><p><strong>TCP连接、端口号25、C/S模式</strong></p><ol type="1"><li>SMTP规定了：在两个相互通信的<strong>SMTP进程</strong>之间应如何交换信息</li><li><strong>SMTP客户</strong>：负责发送邮件的SMTP进程</li><li><strong>SMTP服务器</strong>：负责接收邮件的进程</li><li>SMTP规定了14条命令(几个字母)和21种应答信息(三位数字代码+简单文字说明)</li></ol><p>SMTP通信的三个阶段：</p><ol type="1"><li><p>连接建立</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213220911757.png" alt="image-20221213220911757" style="zoom:80%;" /></p></li><li><p>邮件传送</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213221648198.png" alt="image-20221213221648198" style="zoom:80%;" /></p></li><li><p>连接释放</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213221701568.png" alt="image-20221213221701568" style="zoom:80%;" /></p></li><li><p>SMTP缺点：</p><ol type="1"><li>SMTP不能传送可执行文件或者其他二进制对象</li><li>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字</li><li>SMTP服务器会拒绝超过一定长度的邮件。</li></ol></li></ol><h3 id="通用因特网邮件扩充mime">6.4.4 通用因特网邮件扩充MIME</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213221912921.png" alt="image-20221213221912921" style="zoom:80%;" /></p><ol type="1"><li>使电子邮件系统可以支持声音、图像、视频、多种国家语言等等</li><li>使得传输内容丰富多彩</li></ol><h3 id="邮局协议pop3">6.4.5 邮局协议POP3</h3><p><strong>TCP连接、端口号110、C/S模式</strong></p><p>接收端邮件服务器 =&gt; 用户代理</p><p>POP3工作方式：</p><ol type="1"><li>下载并保留(在服务器)</li><li>下载并删除</li></ol><h3 id="网际报文存取协议imap">6.4.6 网际报文存取协议IMAP</h3><p>接收端邮件服务器 =&gt; 用户代理</p><ol type="1"><li>IMAP协议比POP协议复杂</li><li>当用户PC上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上</li><li>IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分(先看正文，有WiFi的时候再下载附件)</li></ol><h3 id="基于万维网的电子邮件">6.4.7 基于万维网的电子邮件</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213222250513.png" alt="image-20221213222250513" style="zoom:80%;" /></p><ol type="1"><li>用户代理 =&gt; 邮件服务器：HTTP</li><li>邮件服务器 =&gt; 邮件服务器：SMTP</li><li>邮件服务器 =&gt; 用户代理：HTTP</li></ol><h2 id="万维网-http协议">6.5 万维网 &amp; HTTP协议</h2><h3 id="万维网概述">6.5.1 万维网概述</h3><ol type="1"><li>万维网WWW(World WideWeb)：是一个大规模的、联机式的信息储藏所/<strong>资料空间</strong>，是无数个网络站点和网页的集合</li><li><strong>资源</strong>：文字、音频、视频…</li><li>访问资源的方式：<strong>统一资源定位符URL</strong></li><li>URL的一般形式：<code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code>，URL不区分大小写<ol type="1"><li>协议：http、ftp等</li><li>主机：域名、IP地址</li><li>用户通过点击超链接获取资源，这些资源通过<strong>超文本传输协议HTTP</strong>传送给使用者</li></ol></li><li>万维网以<strong>客户/服务器</strong>方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序</li><li>万维网使用<strong>超文本标记语言HTML</strong>，使得万维网页面设计者可以很方便地从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来</li></ol><h3 id="超文本传输协议http">6.5.2 超文本传输协议HTTP</h3><ol type="1"><li>HTTP协议：定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</li><li>服务器：一个服务器进程监听<code>TCP 80</code>端口</li><li>用户浏览界面的方法：<ol type="1"><li>输入URL</li><li>点击超链接</li></ol></li></ol><h4 id="具体过程">6.5.2.1 具体过程</h4><ol type="1"><li>浏览器分许URL</li><li>浏览器向DNS请求解析IP地址</li><li>DNS解析出IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器响应</li><li>释放TCP连接</li><li>浏览器显示：浏览器可以只下载文本部分，之后再下载音频等内容</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213223009351.png" alt="image-20221213223009351" style="zoom:80%;" /></p><h4 id="http协议的特点">6.5.2.2 HTTP协议的特点</h4><ol type="1"><li>HTTP协议是<strong>无状态</strong>的，不会记录用户的登录信息</li><li>通过使用<strong>Cookie</strong>记录用户的信息<ol type="1"><li>Cookie是存储在用户主机中的文本文件，记录一段时间内某用户(使用识别码识别，如“123456”)的访问记录</li><li>从而可以提供个性化服务</li></ol></li><li>采用<strong>TCP</strong>作为运输层协议，但<strong>HTTP协议本身是无连接的</strong>，通信双方再交换HTTP报文之前不需要先建立HTTP连接</li></ol><h4 id="http的连接方式">6.5.2.3 HTTP的连接方式</h4><ol type="1"><li>持久连接Keep-alive：<ol type="1"><li>非流水线：收到响应之后，才能发送下一个请求</li><li>流水线：可以连续发送请求，服务器依次返回请求</li></ol></li><li>非持久连接Close：</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213223706488.png" alt="image-20221213223706488" style="zoom:80%;" /></p><h4 id="http报文结构">6.5.2.4 HTTP报文结构</h4><p>HTTP报文是<strong>面向文本</strong>的，因此在报文中的每一个字段都是一些ASCII码串</p><p>HTTP报文分为：请求报文、响应报文</p><ol type="1"><li>开始行：请求报文对应请求行，响应报文对应状态行<ol type="1"><li>方法：即命令，被请求的对象应执行什么操作</li></ol></li><li>首部行：说明浏览器、服务器、报文主题的一些信息</li><li>状态码：<ol type="1"><li><code>1xx</code>：表示<strong>通知信息</strong>，如请求收到了或正在处理</li><li><code>2xx</code>：表示<strong>成功</strong>，如接受或知道了<ol type="1"><li>如：<code>202 Accepted</code></li></ol></li><li><code>3xx</code>：表示<strong>重定向</strong>，如要完成请求还必须采取进一步的行动<ol type="1"><li>如：<code>301 Move Permanently</code></li></ol></li><li><code>4xx</code>：表示<strong>客户的差错</strong>，如请求中有错误的语法或不能完成<ol type="1"><li>如：<code>404 Not Found</code></li></ol></li><li><code>5xx</code>：表示<strong>服务器的差错</strong>，如服务器失效无法完成请求</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213224022037.png" alt="image-20221213224022037" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221213224256280.png" alt="image-20221213224256280" style="zoom:80%;" /></p><h2 id="流媒体-streaming-audio-and-video">6.6 流媒体 Streaming Audio andVideo</h2><ol type="1"><li>都是压缩的</li><li>都是边收边发</li></ol><h1 id="chapter-7网络安全">Chapter 7：网络安全</h1><h2 id="网络安全的5个方面">7.1 网络安全的5个方面</h2><p>传统密码学：机密性问题、不可否认性问题、完整性问题、认证问题</p><ol type="1"><li><p>机密性问题：Confidentiality</p><ol type="1"><li>保证发送的数据让非特权用户无法理解</li><li>默认：发送的数据所有人都可以收到</li></ol></li><li><p>不可否认性问题：Nonrepudiation</p><ol type="1"><li>数字签名</li></ol></li><li><p>完整性问题：Integrity</p><ol type="1"><li>保证接收到的数据，与发送的数据相同</li><li>消息摘要</li></ol></li><li><p>认证问题：Authentication</p><ol type="1"><li>证书</li></ol></li><li><p>可用性问题：Availability</p><ol type="1"><li>保证系统可以使用</li></ol></li></ol><h2 id="网络攻击的方式">7.2 网络攻击的方式</h2><h3 id="四个步骤">7.2.1 四个步骤</h3><ol type="1"><li>侦察 Reconnaissance：<ol type="1"><li>传统为扫描，找到攻击的目标</li></ol></li><li>嗅探和窥探 Sniffing and snooping：<ol type="1"><li>嗅探：将网络上的包保存下来</li><li>窥探：冲到系统里面，把里面的数据保存下来</li></ol></li><li>欺骗 Spoofing：<ol type="1"><li>让不应该发到我这里的包，发送到我这里</li><li>修改DNS</li><li>让交换机的转发表溢出，从而让交换机不得不广播数据</li></ol></li><li>破坏 Disruption</li></ol><h3 id="分布式拒绝服务攻击-ddos">7.2.2 分布式拒绝服务攻击 DDoS</h3><ol type="1"><li>TCP的三次握手，会占用服务器较多的资源</li><li>网络攻击的手段：控制多个僵尸网络，同时向服务器发送TCP连接建立请求，然后僵尸网络不回复，通常TCP连接建立的超时时间有2分钟，在这段时间内，服务器会进行等待</li><li>对应手段：SCTP协议<ol type="1"><li>连接建立时，服务器进行数据的加密，做成cookie，放到连接建立请求的确认包中，返回给发送方</li><li>客户端进行二次确认时，要把cookie再送回来</li><li>服务区把送回的数据解密，然后对对应的客户建立服务</li><li>相当于服务器没有维持状态，而是将状态放到包中</li></ol></li></ol><h2 id="防火墙">7.3 防火墙</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231185157942.png" alt="image-20221231185157942" style="zoom:80%;" /></p><ol type="1"><li>目的：避免公网上的火烧到内网</li><li>方式：<ol type="1"><li>对进出的包进行过滤</li><li>对网络通信的行为进行分析，判断连接让进还是不让进</li></ol></li><li>DeMilitarizedzone：非军事区，将内网的一部分内容放在防火墙外面，让公网的人能够访问</li></ol><h2 id="密码学-cryptography">7.4 密码学 Cryptography</h2><h3 id="密码学加密模型">7.4.1 密码学加密模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231192141222.png" alt="image-20221231192141222" style="zoom:80%;" /></p><ol type="1"><li>通信双方：Alice、Bob</li><li>概念<ol type="1"><li>明文 Plaintext：想要发送的原始数据，是保密的</li><li>密文 Ciphertext：加密后的数据，是公开的</li><li>加密函数 Encryption method</li><li>解密函数 Decryption method：两个函数是逆运算</li><li>加密密钥 Encryption key</li><li>解密密钥 Decryption key</li></ol></li><li>Alice会将明文发送给加密函数，进行加密，获得密文</li><li>Bob收到密文后，会将其发送给解密函数，进行解密，获取明文</li><li>加密的目标：敌人得到密文后，得不到对应的明文<ol type="1"><li>两种敌人：<ol type="1"><li>将密文偷偷截取下来</li><li>将密文截取下来后，发送另一个密文</li></ol></li><li>通常，加密和解密的函数都是公开的，甚至是标准化的</li><li>密钥是保密的</li><li>通常，加密密钥和解密密钥是同一个，或者很容易转换</li></ol></li><li>加密系统的强度<ol type="1"><li>加密/解密函数的强度</li><li>密钥不能重复使用，不能容易猜出</li></ol></li></ol><h3 id="加密解密函数">7.4.2 加密/解密函数</h3><ol type="1"><li><p>任何加密/解密函数，都是基于两个操作的迭代</p><ol type="1"><li><p>替换：将一个字母用另一个字母替换</p><ol type="1"><li>单替换可以通过词频统计来破译</li></ol></li><li><p>转置：将明文按照n个一组写成一行一行的，然后交换某些列，得到密文</p><ol type="1"><li>可以通过计算机枚举，获得明文</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231194615466.png" alt="image-20221231194615466" style="zoom:80%;" /></p></li></ol></li></ol><h4 id="des标准the-data-encryption-standard">7.4.2.1 DES标准：The DataEncryption Standard</h4><ol type="1"><li><p>将明文切块，分别进行加密</p><ol type="1"><li>DES的块的大小为8字节</li></ol></li><li><p>IBM的原始设计：每次加密做了16次迭代，128 bit的密钥</p></li><li><p>经过NSA的修正：每次加密做了16次迭代，64bit的密钥，并且不能公开函数的设计的思路</p></li><li><p>Triple DES：将DES做三次，但只有两个密钥</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231195717835.png" alt="image-20221231195717835" style="zoom:80%;" /></p></li></ol><h4 id="aes标准the-advanced-encryption-standard">7.4.2.2 AES标准：TheAdvanced Encryption Standard</h4><ol type="1"><li>密钥长度：128，192，256 bits</li><li>也是分块加密</li></ol><h3 id="密钥不能被猜出来">7.4.3 密钥不能被猜出来</h3><ol type="1"><li>要尽可能随机<ol type="1"><li>伪随机数：通过函数计算出来，在一定时间后一定会发生重复</li><li>发生重复越晚，随机数生成算法更好</li></ol></li><li>不能重复使用</li></ol><h4 id="cipher-mode">7.4.3.1 Cipher Mode</h4><blockquote><p>将P<sub>i</sub>计算出的密文，与P<sub>i+1</sub>异或</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231200230170.png" alt="image-20221231200230170" style="zoom:80%;" /></p><blockquote><p>将刚刚计算出的6个字节的密文再次加密，获得最左边的字节，然后与P<sub>10</sub>进行异或，得到C<sub>10</sub></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231200355111.png" alt="image-20221231200355111" style="zoom:80%;" /></p><blockquote><p>给定初始值和密钥，生成密文，生成的密文会参与下一次的加密计算</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231200527884.png" alt="image-20221231200527884" style="zoom:80%;" /></p><h3 id="传统密码体制-对称密码体制">7.4.4 传统密码体制 /对称密码体制</h3><ol type="1"><li>密钥是对称的、函数也是对称的</li><li>缺点：密钥的分发存在困难</li></ol><h3 id="现代密码体制-公钥体制">7.4.5 现代密码体制 / 公钥体制</h3><p>相同点：</p><ol type="1"><li>加密函数、解密函数仍然是逆运算，也是公开的</li></ol><p>不同点：</p><ol type="1"><li>加密密钥、解密密钥是不同的</li><li>加密密钥：公开的，也叫公钥</li><li>解密密钥：私有的，也叫私钥</li><li>算法上保证公钥推出私钥的难度很大</li><li>公钥体制的计算量很大，一般用于要加密的内容较少的地方/特殊用途</li></ol><h4 id="rsa算法">7.4.5.1 RSA算法</h4><p>算法详情：</p><ol type="1"><li>选择两个质数<span class="math inline">\(p\)</span>和<spanclass="math inline">\(q\)</span></li><li>计算<span class="math inline">\(n=p*q\)</span>，<spanclass="math inline">\(z=(p-1)*(q-1)\)</span></li><li>选择一个与<spanclass="math inline">\(z\)</span>接近的素数，称为<spanclass="math inline">\(d\)</span></li><li>找到满足<span class="math inline">\(e*d=1\ (mod\ z)\)</span>的<spanclass="math inline">\(e\)</span></li></ol><h2 id="反拒认数字签名">7.5 反拒认：数字签名</h2><h3 id="big-brother">7.5.1 Big Brother</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231202218898.png" alt="image-20221231202218898" style="zoom:80%;" /></p><ol type="1"><li>Alice将借条给Big Brother</li><li>Big Brother将借条给Bob</li><li>Bob要债时，Big Brother作为公证人，证明借条的有效性</li></ol><h3 id="公钥数字签名">7.5.2 公钥数字签名</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231202412942.png" alt="image-20221231202412942" style="zoom:80%;" /></p><ol type="1"><li>Alice将借条的明文P，通过Alice的解密函数和私钥进行加密，得到密文D<sub>A</sub>(P)<ol type="1"><li>D<sub>A</sub>(P)即为经过数字签名的借条</li></ol></li><li>Alice还会将D<sub>A</sub>(P)，通过Bob的加密函数和公钥进行加密，得到密文E<sub>B</sub>(D<sub>A</sub>(P))</li><li>E<sub>B</sub>(D<sub>A</sub>(P))在公网上进行传输，发送给Bob</li><li>E<sub>B</sub>(D<sub>A</sub>(P))发送给Bob后，Bob用过Bob的的解密函数和私钥进行解密，得到密文D<sub>A</sub>(P)</li><li>Bob然后通过Alice的加密函数和公钥进行解密，得到借条的明文P</li><li>反拒认：Bob将D<sub>A</sub>(P)给到法官，法官通过Alice的加密函数和公钥进行解密，得到借条的明文<ol type="1"><li>由于Alice的公钥和私钥唯一，且私钥不可知，因此该借条不可能被伪造</li></ol></li></ol><h2 id="数据的完整性防篡改消息摘要">7.6数据的完整性(防篡改)：消息摘要</h2><h3 id="消息摘要">7.6.1 消息摘要</h3><ol type="1"><li>给定P，计算MD(P)</li><li>MD(P)，很难计算P</li><li>如果P有轻微变化，MD(P)会变化非常大</li><li>为了防止摘要被篡改，所有摘要都是有数字签名的</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231213122180.png" alt="image-20221231213122180" style="zoom:80%;" /></p><h2 id="认证问题证书">7.7 认证问题：证书</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231213604914.png" alt="image-20221231213604914" style="zoom:80%;" /></p><ol type="1"><li>保证证书的真实性：找发证书的机构，对证书进行一次摘要，然后附加到证书上</li><li>证书中，除了有该节点的信息，还会该节点的公钥</li></ol><h3 id="x.509">7.7.1 X.509</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231213821030.png" alt="image-20221231213821030" style="zoom:80%;" /></p><ol type="1"><li>发证书的实际机构是：CA</li><li>CA的证书由RA颁发，RA的证书由Root颁发</li><li>一般浏览器会预置一部分根证书，根证书也可以通过自己添加</li></ol><h2 id="基本应用">7.8 基本应用</h2><h3 id="通信安全">7.8.1 通信安全</h3><ol type="1"><li><p>IPsec：将认证信息，添加到IP数据报中</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231214424189.png" alt="image-20221231214424189" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231214403935.png" alt="image-20221231214403935" style="zoom:80%;" /></p></li><li><p>Virtual Private Network：VPN，虚拟私有网</p><ol type="1"><li>是一个叠加网，在公网上建立一个叠加网，添加一些认证方式</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231214510234.png" alt="image-20221231214510234" style="zoom:80%;" /></p></li><li><p>Wireless Security：无线安全</p></li></ol><h3 id="邮件安全">7.8.2 邮件安全</h3><p>PGP：Pretty Good Privacy</p><ol type="1"><li>明文P计算摘要，然后使用Alice的私钥进行签名，计算结果与P结合，形成P1</li><li>将P1压缩，形成P1.Z</li><li>Alice选择一个随机数K<sub>M</sub>，对P1.Z使用AES进行加密</li><li>同时，使用Bob的公钥，对K<sub>M</sub>进行加密，与加密后的P1.Z一起发送给Bob</li><li>最后使用Base64，将内容发送</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231214636769.png" alt="image-20221231214636769" style="zoom:80%;" /></p><h3 id="web安全">7.8.3 WEB安全</h3><ol type="1"><li><p>DNS的安全问题：</p><ol type="1"><li>内容不能被造假</li><li>访问数据属于隐私问题</li></ol></li><li><p>WEB安全</p><ol type="1"><li>HTTP协议没有安全保证</li><li>HTTPS：Secure HTTP</li><li>Security(SSL)：安全套接子层</li><li>TLS：Transport Layer Security</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231215524381.png" alt="image-20221231215524381" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231215605132.png" alt="image-20221231215605132" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221231215619602.png" alt="image-20221231215619602" style="zoom:80%;" /></p></li><li><p>运行代码安全</p><ol type="1"><li>WEB的代码是在客户端本地运行的，可能对客户端产生安全威胁</li><li>使用虚拟机</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2022/09/12/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/09/12/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="chapter-1introduction">Chapter 1：Introduction</h1><h2 id="操作系统在做什么">1.1 操作系统在做什么</h2><h3 id="操作系统的作用">1.1.1 操作系统的作用</h3><p>Operating System的作用：</p><ol type="1"><li>作为用户与计算机硬件交互的中间层</li></ol><p>Operating System的目标：</p><ol type="1"><li>更加容易的执行/实现用户的程序</li><li>更加方便的使用计算机：交互</li><li>更有效率的使用硬件</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220912145316946.png" alt="image-20220912145316946" style="zoom:80%;" /></p><p>Computer System的结构：</p><ol type="1"><li>硬件<strong>Hardware</strong>：提供基础的计算资源<ol type="1"><li>CPU、memory、I/O devices</li></ol></li><li>操作系统<strong>OperatingSystem</strong>：控制在不同程序、不同用户间的硬件的使用</li><li>应用程序<strong>ApplicationPrograms</strong>：定义如何使用系统资源来解决问题<ol type="1"><li>Word processors、compilers、web browsers、database systems、videogames</li></ol></li><li>用户<strong>Users</strong>：<ol type="1"><li>People、machines、other computers</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220912145600410.png" alt="image-20220912145600410" style="zoom:80%;" /></p><h3 id="什么是操作系统">1.1.2 什么是操作系统</h3><h4 id="计算机系统组成角度操作系统是系统软件">1.1.2.1计算机系统组成角度：操作系统是系统软件</h4><ol type="1"><li>计算机系统组成：<ol type="1"><li>软件：应用软件、系统软件(操作系统等)</li><li>硬件：输入/输出(I/O)设备、存储器(内存) 、中央处理器(CPU)</li></ol></li></ol><h4 id="用户角度操作系统是用户与计算机硬件之间接口">1.1.2.2用户角度：操作系统是用户与计算机硬件之间接口</h4><ol type="1"><li>Computer计算机硬件<ol type="1"><li>PC</li><li>mainframe, or minicomputer</li><li>mobile computers</li></ol></li><li>操作系统提供的接口有：<ol type="1"><li>命令级接口<ol type="1"><li>键盘或鼠标等命令。</li><li>Mobile user interfaces such as touch screens, voice recognition</li></ol></li><li>程序级接口<ol type="1"><li>它提供一组系统调用System calls，即操作系统服务，供用户程序和其它程序调用</li></ol></li></ol></li></ol><h4 id="系统角度操作系统是计算机系统资源的管理者">1.1.2.3系统角度：操作系统是计算机系统资源的管理者</h4><ol type="1"><li>OS是资源的分配者<ol type="1"><li>管理所有资源</li><li>处理冲突的需求，有效而公平</li></ol></li><li>OS是一个控制程序<ol type="1"><li>控制程序的执行，阻止错误、不正确的使用</li></ol></li></ol><h4id="软件分层扩充机器的角度操作系统是扩充裸机的第一层系统软件">1.1.2.4软件分层、扩充机器的角度：操作系统是扩充裸机的第一层系统软件</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220912151451846.png" alt="image-20220912151451846" style="zoom:80%;" /></p><h4 id="综合考虑">1.1.2.5 综合考虑</h4><p><strong>操作系统</strong>是一组：有效控制和管理计算机各种硬件和软件资源，合理的组织计算机的工作流程，以及方便用户的程序的集合</p><ol type="1"><li><strong>有效（efficient）</strong>：系统效率高，资源利用率高（如：CPU使用率，内存、外部设备是否忙）</li><li><strong>合理</strong>：公平，如果不公平则会产生“死锁”或“饥饿”</li><li><strong>方便（convenience）</strong>：用户界面，编程接口</li></ol><h2 id="computer-system-organization">1.2 Computer SystemOrganization</h2><h3 id="总线结构">1.2.1 总线结构</h3><p><strong>总线结构</strong>：微型计算机是以总线为纽带来构成计算机系统，中央处理机（CPU）、存储器、I/O设备（包括外存磁盘、磁带）都挂接在总线</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220912152133550.png" alt="image-20220912152133550" style="zoom:80%;" /></p><ol type="1"><li>I/O设备和CPU可以并行运行<strong>execute concurrently</strong></li><li>每一个设备控制器控制一个特定的设备</li><li>每一个设备控制器均有一个存储单元<strong>local buffer</strong></li><li>每一个设备控制器均有一个操作系统的驱动器<strong>devicedriver</strong>，让操作系统管理它</li><li>CPU在内存<strong>mainmemory</strong>和<strong>buffer</strong>之间进行数据的移动</li><li>I/O本质上是<strong>device</strong>到<strong>localbuffer</strong>之间的数据交互</li><li>设备通过提出中断<strong>interrupt</strong>的方式，告诉CPU它已经完成了操作</li></ol><h3 id="计算机启动-startup">1.2.2 计算机启动 Startup</h3><p><strong>bootstrap program</strong></p><ol type="1"><li>存放在<strong>ROM/EEPROM</strong>中，也被称为<strong>firmware</strong></li><li>在电源启动/重启的时候，这个程序被加载到内存中</li><li>会初始化操作系统的必须部分</li><li>然后将操作系统加载到内存中，开始执行</li></ol><h3 id="中断">1.2.3 中断</h3><p><strong>中断(Interrupt)</strong>：指系统发生某个异步/同步事件后，处理器暂停正在执行的程序，转去执行处理该事件程序的过程</p><ol type="1"><li>硬件中断</li><li>软件中断：<strong>陷入(trap)</strong></li></ol><p>操作系统是中断驱动的<strong>interrupt driven</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220912154757435.png" alt="image-20220912154757435" style="zoom:80%;" /></p><p><strong>外部中断(interrupt)，异步中断</strong>：</p><ol type="1"><li>外部设备所发出的I/O请求</li><li>分为可屏蔽的和不可屏蔽的两类，由一些硬件设备产生，<font color = “blue">可以在指令执行的任意时刻产生</font></li></ol><p><strong>异常(exception)，内部中断，同步中断</strong>：</p><ol type="1"><li>由正在执行的进程产生，<font color = “blue">一条指令终止执行后才会发出中断</font></li><li>常见的异常有除零、溢出及页面异常(<strong>fault出错</strong>)等。另一种情况是使用int指令(<strong>trap陷入</strong>)，Linux使用该指令来实现系统调用。fault与trap区别</li></ol><p><strong>中断处理</strong></p><ol type="1"><li>操作系统保存当前CPU状态：存储register、PC(program counter)</li><li>判断发生了哪一种中断：<ol type="1"><li>Polling：轮询</li><li>Vectored interrupt system：向量化中断系统</li></ol></li><li>单独的代码段决定了每种类型的中断应采取的操作(中断服务程序)</li></ol><p><strong>Interrupt Time line</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220915164048443.png" alt="image-20220915164048443" style="zoom:80%;" /></p><h3 id="存储结构">1.2.4 存储结构</h3><p><strong>Main Memory(主存)</strong></p><ol type="1"><li>CPU能够直接访问的最大存储空间</li></ol><p><strong>Secondary Storage(赋存)</strong></p><ol type="1"><li>主存的拓展，提供大量非易失型的存储空间</li></ol><p><strong>Hard Disk Drives(HDD, 硬盘)</strong>：</p><ol type="1"><li>覆盖有磁记录材料的刚性金属或玻璃盘</li><li>磁盘表面按逻辑划分为磁道，磁道又细分为扇区</li><li>磁盘控制器确定设备和计算机之间的逻辑交互</li></ol><p><strong>Caching(高速缓存技术)</strong>：将信息复制到更快的存储系统中</p><ol type="1"><li><strong>Main Memory</strong>可以被视为<strong>SecondaryStorage</strong>的一个缓存(cache)</li><li>重要原理：在计算机（硬件、操作系统、软件）的多个级别执行<ol type="1"><li>正在使用的信息临时从较慢的存储复制到较快的存储</li><li>更快的存储（缓存）首先检查，判断信息是否存在<ol type="1"><li>如果是，则直接从缓存中使用信息（fast）</li><li>如果不是，则将数据复制到缓存并在其中使用</li></ol></li><li>缓存小于正在缓存的存储<ol type="1"><li>缓存管理是一个重要的设计问题</li><li>缓存大小和替换策略</li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220915164955425.png" alt="image-20220915164955425" style="zoom:80%;" /></p><h3 id="io结构">1.2.5 IO结构</h3><p><strong>I/O方式</strong>：</p><ol type="1"><li><p>程序I/O (<strong>Programmed I/O</strong>)</p></li><li><p>中断 I/O (<strong>Interrupt I/O</strong>)</p><ol type="1"><li>同步I/O：IO开始后，控制权只有当IO结束才会返回给程序</li><li>异步I/O：IO开始后，控制权立即返回给程序<ol type="1"><li>设备状态表Device-statustable：包含每个I/O设备的条目，指示其类型、地址和状态</li><li>操作系统索引到I/O设备表中，以确定设备状态并修改表条目以包括中断</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220915171013758.png" alt="image-20220915171013758" style="zoom:80%;" /></p></li><li><p><strong>DMA</strong>方式：Direct Memory AccessStructure直接内存访问</p><ol type="1"><li>用于能够以接近内存速度传输信息的<strong>高速I/O设备</strong></li><li>设备控制器将数据块从缓冲存储器直接传输到主存储器，无需CPU干预</li><li><strong>每个块</strong>只生成一个中断，而不是每个字节一个中断</li></ol></li><li><p>通道方式</p></li></ol><h2 id="computer-system-architecture">1.3 Computer SystemArchitecture</h2><h3 id="单处理器系统">1.3.1 单处理器系统</h3><ol type="1"><li>只有一个CPU和一个计算单元</li></ol><h3 id="多处理器系统">1.3.2 多处理器系统</h3><ol type="1"><li><strong>MultiprocessorSystems</strong>多处理器系统：也称为并行系统parallelsystems、紧密耦合系统tightly-coupled systems</li><li>优点：<ol type="1"><li>增加吞吐量</li><li>规模经济</li><li>提高可靠性——性能下降或容错</li></ol></li><li>两种类型：<ol type="1"><li>非对称多重处理</li><li>对称多重处理</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220915172235110.png" alt="image-20220915172235110" style="zoom:80%;" /></p><p><strong>Multi-processor（多个芯片） andmulticore（多核）</strong></p><ol type="1"><li>System（系统）包含所有的芯片</li><li>Chassis（主板）包含多个独立的处理器</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220915172456054.png" alt="image-20220915172456054" style="zoom:80%;" /></p><h3 id="计算机系统组件的定义">1.3.3 计算机系统组件的定义</h3><ol type="1"><li>CPU：执行指令的硬件</li><li>Processor处理器：包含一个或多个CPU的物理芯片</li><li>Core核：CPU里面最基本的计算单元</li><li>Multicore多核：在一块CPU里面有多个计算单元</li><li>Multiprocessor多处理器：包含多个处理器</li></ol><h3 id="clustered-systems集群系统">1.3.4 Clustered Systems集群系统</h3><ol type="1"><li><p>集群系统(<strong>Cluster</strong>)：是由一组互联的主机（节点）构成统一的计算机资源，通过相应软件协调工作的计算机机群，给人以一台机器的感觉</p></li><li><p>通常通过存储区域网络（storage-areanetwork，<strong>SAN</strong>）共享存储</p></li><li><p>提供高可用性（high-availability）服务，可在故障中生存</p><ol type="1"><li><strong>Asymmetricclustering</strong>（非对称集群）：有一台机器处于热备用模式</li><li><strong>Symmetric clustering</strong> （对称集群）：有多个运行应用程序的节点，相互监视</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220915172909011.png" alt="image-20220915172909011" style="zoom:80%;" /></p></li><li><p>一些集群用于高性能计算（<strong>HPC</strong>，high-performancecomputing)</p><ol type="1"><li>必须编写应用程序以使用<strong>并行化(parallelization)</strong></li></ol></li><li><p>一些具有分布式锁管理器（<strong>DLM</strong>分布式锁管理器)避免冲突操作</p></li><li><p>其他形式的集群：并行集群、WAN上的集群</p></li><li><p>集群技术正在迅速变化</p><ol type="1"><li>一些集群产品支持集群中的数千个系统，以及相隔数英里的集群节点</li><li>Storage-Area Network，<strong>SAN</strong>，存储区域网</li></ol></li></ol><h2 id="operating-system-operations操作系统的执行">1.4 Operating SystemOperations操作系统的执行</h2><ol type="1"><li>硬件驱动的中断</li><li>软件错误或请求创建exception(异常） 或trap(陷入）<ol type="1"><li>除以零，请求操作系统服务</li></ol></li><li>其他进程问题包括无限循环、进程相互修改或操作系统</li></ol><h3 id="两种操作模式">1.4.1 两种操作模式：</h3><ol type="1"><li><strong>User mode(用户态)</strong>：执行用户程序时<ol type="1"><li>只能访问属于它的存储空间和普通寄存器，只能执行普通指令</li><li>用户程序以及操作系统核外服务程序运行在用户态下</li><li>使用用户栈</li><li><strong>非特权指令</strong>：用户程序中所使用的指令</li></ol></li><li><strong>Kernel mode(内核态)</strong>：执行操作系统程序时<ol type="1"><li>也称为：monitor mode管态、system mode系统态、supervisor mode管态、privileged mode特权模式</li><li>能够访问所有系统资源，可以执行特权指令，可以直接操作和管理硬件设备</li><li>操作系统内核程序运行在内核态下</li><li>使用内核栈</li><li><strong>特权指令</strong>：不允许用户程序中直接使用的指令。例如：I/O指令、设置时钟、设置控制寄存器等指令都是特权指令</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220915174344904.png" alt="image-20220915174344904" style="zoom:80%;" /></p><h3 id="timer定时器防止无限循环进程占用资源">1.4.2Timer(定时器)：防止无限循环/进程占用资源</h3><ol type="1"><li>在特定时间段后设置中断</li><li>操作系统递减计数器</li><li>当计数器为零时，生成中断</li><li>在调度进程之前设置，以重新控制或终止超过分配时间的程序</li></ol><h2 id="resource-management资源管理">1.5 ResourceManagement资源管理</h2><ol type="1"><li>进程管理 Process Management</li><li>主存管理 Main Memory Management</li><li>文件系统管理 File-System Management</li><li>大容量储存管理 Mass-Storage Management</li><li>高速缓存管理机制 Caching</li><li>I/O系统管理 I/O System Management</li></ol><h3 id="进程管理">1.5.1 进程管理</h3><ol type="1"><li>进程<strong>Process</strong>：所有处于<strong>执行中</strong>的程序<ol type="1"><li>进程是一个最基本的单元</li><li>不同进程之间可以共享一些数据，但不会相互依赖</li><li>程序是<strong>passiveentity(静态实体)</strong>，进程是<strong>activeentity(活动实体)</strong></li></ol></li><li>进程需要获得一些资源以完成任务<ol type="1"><li>CPU、内存、IO、文件、初始化数据</li></ol></li><li>进程终止需要回收任何可重用资源</li><li>单线程进程(<strong>Single-threaded process</strong>)<ol type="1"><li>有一个程序计数器(<strong>PC，programcounter</strong>)，指定要执行的下一条指令的位置</li><li>进程按顺序执行指令，一次一个，直到完成</li></ol></li><li>多线程进程(<strong>Multi-threaded process</strong>)<ol type="1"><li>每个线程有一个程序计数器(<strong>PC</strong>)</li></ol></li><li>通常，系统有许多进程，一些用户，一些操作系统在一个或多个CPU上并发运行<ol type="1"><li>通过在进程/线程之间<strong>复用CPU(multiplexing)</strong>实现并发(concurrency)</li><li>时间片：多个时钟周期的组合</li><li>轮转的调度方法：每一个进程执行一段时间后，暂停当前进程，执行下一个进程</li><li>每一次切换时，由于需要将当前进程的相关信息保存下来，所有会造成浪费</li></ol></li><li><strong>Process Management</strong>的任务：<ol type="1"><li>创建和删除用户和系统进程</li><li>暂停和恢复进程</li><li>提供进程同步机制</li><li>提供过程通信机制</li><li>提供死锁处理机制</li></ol></li></ol><h3 id="内存管理">1.5.2 内存管理</h3><ol type="1"><li>要执行程序，所有（或部分）<strong>指令</strong>必须在内存中</li><li>程序所需的所有（或部分）<strong>数据</strong>必须在内存中</li><li>内存管理确定内存中的内容和时间<ol type="1"><li>优化CPU利用率和计算机对用户的响应</li></ol></li><li><strong>Memory Management</strong>的任务：<ol type="1"><li>跟踪当前正在使用内存的哪些部分以及由谁使用</li><li>决定哪些进程（或其部分）和数据要移入和移出内存</li><li>根据需要分配和释放内存空间</li></ol></li></ol><h3 id="文件系统管理">1.5.3 文件系统管理</h3><ol type="1"><li>操作系统提供信息存储的统一逻辑视图<ol type="1"><li>将物理属性抽象为逻辑存储单元文件<strong>file</strong></li><li>每个介质由设备（如磁盘驱动器、磁带驱动器）控制<ol type="1"><li>不同的属性包括访问速度、容量、数据传输速率、访问方法（顺序或随机）</li></ol></li></ol></li><li>文件系统管理<ol type="1"><li>文件通常被组织到目录中</li><li>大多数系统上的访问控制，以确定谁可以访问什么</li></ol></li><li><strong>File-system Management</strong>的任务：<ol type="1"><li>创建和删除文件和目录</li><li>用于操作文件和目录的原语primitives</li><li>将文件映射到辅助存储</li><li>将文件备份到稳定（非易失性）存储介质上</li></ol></li></ol><h3 id="大容量储存管理">1.5.4 大容量储存管理</h3><ol type="1"><li>通常，磁盘用于存储不适合主内存的数据或必须保存“长”一段时间的数据</li><li>适当的管理至关重要</li><li>计算机操作的整体速度取决于磁盘子系统及其算法</li><li><strong>Mass-Storage Management</strong>的任务<ol type="1"><li>安装mounting和拆卸unmounting</li><li>空闲空间管理</li><li>存储分配</li><li>磁盘调度</li><li>分区Partition</li><li>保护Protection</li></ol></li><li>有些存储不需要很快<ol type="1"><li>三级存储包括光盘、磁带</li><li>仍然必须由操作系统或应用程序进行管理</li></ol></li></ol><h3 id="高速缓存机制caching">1.5.5 高速缓存机制Caching</h3><ol type="1"><li><p>重要原理，在计算机（硬件、操作系统、软件）的多个级别执行</p></li><li><p>将正在使用的信息临时从较慢的存储复制到较快的存储</p></li><li><p>Faster Storage（cache）首先检查，判断信息是否存在</p><ol type="1"><li>如果存在，则直接从缓存中使用信息（fast）</li><li>如果不存在，则将数据复制到缓存并在其中使用</li></ol></li><li><p>缓存小于正在缓存的存储</p><ol type="1"><li>缓存管理是一个重要的设计问题</li><li>缓存大小和替换策略</li></ol></li><li><p>多任务环境必须小心使用最新的值，无论它存储在存储层次结构中的何处</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220919151453353.png" alt="image-20220919151453353" style="zoom:80%;" /></p></li><li><p>多处理器环境必须在硬件中提供缓存一致性，以便所有CPU在其缓存中都具有最新的值</p></li><li><p>分布式环境情况更加复杂</p><ol type="1"><li>一个基准可以有多个副本</li><li>第19章涵盖的各种解决方案</li></ol></li></ol><h3 id="io子系统">1.5.6 I/O子系统</h3><ol type="1"><li>操作系统的一个目的是向用户隐藏硬件设备的特性</li><li><strong>I/O Subsystem</strong>的任务：<ol type="1"><li>I/O的内存管理，包括缓冲（在传输数据时临时存储数据）、缓存（将部分数据存储在更快的存储中以提高性能）、假脱机（一个作业的输出与其他作业的输入重叠）</li><li>通用设备驱动程序接口</li><li>特定硬件设备的驱动程序</li></ol></li></ol><h2 id="security-and-protection安全和保护">1.6 Security andProtection安全和保护</h2><ol type="1"><li>保护<strong>Protection</strong>：控制进程或用户访问操作系统定义的资源 的机制</li><li>安全性<strong>Security</strong>：防御系统内部和外部攻击<ol type="1"><li>范围广泛，包括拒绝服务(denial-of-service)、蠕虫(worms)、病毒(viruses)、身份盗窃(identitytheft)、服务盗窃(theft of service)</li></ol></li><li>系统通常首先区分用户，以确定谁可以做什么<ol type="1"><li>用户身份(<strong>user IDs、securityIDs</strong>)：包括姓名和相关号码，每个用户一个</li><li>user ID与该用户的所有文件、进程关联，以确定访问控制</li><li>组标识符(<strong>groupID</strong>)：允许定义和管理用户集，然后还可以与每个进程、文件关联</li><li><strong>权限提升Privilegeescalation</strong>：允许用户更改为具有更多权限的有效ID</li></ol></li></ol><h2 id="virtualization虚拟化">1.7 Virtualization虚拟化</h2><ol type="1"><li>允许操作系统在其他操作系统中运行应用程序</li><li><strong>仿真Emulation</strong>：当源CPU类型与目标CPU类型不一样时使用该技术<ol type="1"><li>通常是最慢的方法</li><li>当计算机语言未编译为本机代码时：<strong>Interpretation翻译</strong></li></ol></li><li>虚拟化<strong>Virtualization</strong>：为CPU本机编译的OS，运行本机也编译过的guestOS<ol type="1"><li>考虑运行WinXP客户机的VMware，每个客户机都运行本机WinXP主机操作系统上的应用程序</li><li><strong>VMM</strong>(虚拟机管理器 virtual machineManager)提供虚拟化服务</li></ol></li><li><strong>VMM</strong>可以本地化运行，在这种情况下，它们也是主机<ol type="1"><li>因此，没有通用主机（VMware ESX和Citrix XenServer）</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220919153643248.png" alt="image-20220919153643248" style="zoom:80%;" /></p><h2 id="distribute-system分布式系统">1.8 DistributeSystem分布式系统</h2><ol type="1"><li>分布式计算<ol type="1"><li>独立的、可能异构的、联网在一起的系统的集合</li><li>网络(<strong>Network</strong>)是通信路径，TCP/IP最常见<ol type="1"><li>局域网（LAN）</li><li>广域网（WAN）</li><li>城域网（MAN）</li><li>个人局域网（PAN）</li></ol></li></ol></li><li>网络操作系统(<strong>Network OperatingSystem</strong>)：提供跨网络的系统之间的功能<ol type="1"><li>通信方案允许系统交换消息</li><li>看起来是单一系统</li></ol></li></ol><h2 id="kernel-data-structures内核数据结构">1.9 Kernel DataStructures内核数据结构</h2><ol type="1"><li><p>Linked List</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220919154221402.png" alt="image-20220919154221402" style="zoom:80%;" /></p></li><li><p>Binary Search Tree</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220919154534541.png" alt="image-20220919154534541" style="zoom:80%;" /></p></li><li><p>Hash Map</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220919154737046.png" alt="image-20220919154737046" style="zoom:80%;" /></p></li></ol><h2 id="computing-environments计算环境">1.10 ComputingEnvironments计算环境</h2><h3 id="传统计算-traditional">1.10.1 传统计算 Traditional</h3><ol type="1"><li>独立通用机器</li><li>但由于大多数系统与其他系统（即互联网）互连，因此变得模糊</li><li>门户<strong>Portals</strong>提供对内部系统的web访问</li><li>网络计算机（thin clients）就像Web终端</li><li>移动计算机通过无线网络互连</li><li>网络无处不在，甚至家庭系统也使用防火墙保护家庭计算机免受互联网攻击</li></ol><p><strong>Mainfram Systems大型机系统</strong>：</p><ol type="1"><li><p>Batch System：批处理系统</p><ol type="1"><li><p>Multiprogramming：多道程序，多个作业同时保存在主存中，CPU在其中多路复用</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922162547276.png" alt="image-20220922162547276" style="zoom:50%;" /></p></li></ol></li><li><p>Time-Sharing Systems：分时系统</p><ol type="1"><li><strong>分时</strong>：多个用户分时共享使用同一台计算机<ol type="1"><li>也就是说把计算机的系统资源（尤其是CPU时间）进行时间上分割，即将整个工作时间分成一个个的时间片，每个时间片分给一个用户使用</li><li>这样将CPU工作时间分别提供给多个用户使用，每个用户依次地轮流且使用一个时间片</li></ol></li><li><strong>响应时间</strong>：是分时系统的重要指标，它是用户发出终端命令到系统作出响应的时间间隔。<ol type="1"><li>系统的响应时间主要是根据用户所能接受的等待时间确定的。</li><li>假设分时系统中进程数(用户数)为n，每个进程的运行时间片为q，则系统的最大响应时间为：<spanclass="math inline">\(S=(n-1)×q\)</span></li><li>响应时间仅计算第一次被运行的时间点</li></ol></li></ol></li><li><p>Desktop Systems：桌面系统</p><ol type="1"><li>个人计算机：专用于单个用户的计算机系统</li><li>I/O设备：键盘、鼠标、显示屏、小型打印机</li><li>重点：用户的便利性和响应能力</li><li>可以采用为大型操作系统开发的技术，通常个人只使用计算机，不需要高级CPU利用率的保护功能</li><li>可以运行多种不同类型的操作系统</li></ol></li></ol><h3 id="移动计算-mobile">1.10.2 移动计算 Mobile</h3><ol type="1"><li>手持智能手机、平板电脑等</li><li>它们与“传统”笔记本电脑的功能区别是什么？<ol type="1"><li>附加功能–更多操作系统功能（GPS、gyroscope陀螺仪)</li><li>允许新类型的应用程序，如增强现实</li><li>使用IEEE 802.11无线或蜂窝数据网络进行连接</li></ol></li></ol><p><strong>计算应用领域</strong>：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922163724580.png" alt="image-20220922163724580" style="zoom:80%;" /></p><h3 id="客户机client-服务器server计算">1.10.3客户机Client-服务器Server计算</h3><ol type="1"><li><p>智能PC取代了无人机终端</p></li><li><p>现在许多系统都是服务器，响应客户端生成的请求</p><ol type="1"><li>计算服务器系统compute-serversystem：为客户端提供请求服务（即数据库）的接口</li><li>文件服务器系统file-serversystem：为客户端提供存储和检索文件的接口</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922163943559.png" alt="image-20220922163943559" style="zoom: 80%;" /></p></li></ol><h3 id="点对点计算-peer-to-peer">1.10.4 点对点计算 Peer-to-Peer</h3><ol type="1"><li><p>分布式系统的另一种模型</p></li><li><p>P2P无法区分客户端和服务器</p><ol type="1"><li>相反，所有节点都被视为对等节点</li><li>可以分别充当客户端、服务器或两者<ol type="1"><li>节点必须加入P2P网络</li><li>在网络上向中央查找服务注册其服务，或</li></ol></li><li>广播服务请求并通过发现协议响应服务请求</li></ol></li><li><p>示例包括Napster和Gnutella、Voice overIP（VoIP），如Skype</p></li><li><p>Blockchain technology 区块链技术</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922164125326.png" alt="image-20220922164125326" style="zoom:80%;" /></p></li></ol><h3 id="虚拟化计算-virtualization">1.10.5 虚拟化计算 Virtualization</h3><h3 id="云计算-cloud-computing">1.10.6 云计算 Cloud Computing</h3><ol type="1"><li>通过网络将计算、存储甚至应用程序作为服务提供</li><li>基于虚拟化的虚拟化逻辑扩展<ol type="1"><li>AmazonEC2拥有数千台服务器、数百万台虚拟机、PB存储空间，可在互联网上使用，根据使用情况付费</li></ol></li><li>Many types<ol type="1"><li>Public cloud(公有云)：任何愿意付费的人都可以通过互联网获得</li><li>Private cloud(私有云)：由公司运营供公司自用</li><li>Hybrid cloud(混合云)：包括公共云组件和私有云组件</li><li>Software as a Service (<strong>SaaS</strong>，软件即服务)：通过互联网提供的一个或多个应用程序(即文字处理器)</li><li>Platform as a Service (<strong>PaaS</strong>，平台即服务)：软件堆栈可通过Internet(即数据库服务器)供应用程序使用</li><li>Infrastructure as a Service (<strong>IaaS</strong>，基础设施即服务)：通过Internet可用的服务器或存储(即可用于备份的存储)</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922165454650.png" alt="image-20220922165454650" style="zoom:80%;" /></p><h3 id="实时嵌入式系统-real-time-embedded-systems">1.10.7 实时嵌入式系统Real-Time Embedded Systems</h3><ol type="1"><li>实时嵌入式系统——最流行的计算机形式<ol type="1"><li>各种相当大的、特殊用途的、有限用途的操作系统、实时操作系统</li><li>使用扩展</li></ol></li><li>还有许多其他特殊的计算环境<ol type="1"><li>有些有操作系统，有些在没有操作系统的情况下执行任务</li></ol></li><li>实时操作系统具有<strong>明确定义的固定时间限制</strong>，运行顺序与要求的顺序一定相同<ol type="1"><li>处理必须在约束内完成</li><li>只有在满足约束条件时才能正确操作</li></ol></li><li><strong>嵌入式系统</strong>：是以应用为中心，以计算机技术为基础，采用<strong>可剪裁软硬件</strong>，适用于对功能、可靠性、成本、体积、功耗等有严格要求的<strong>专用计算机系统</strong>，用于实现对其他设备的控制、监视或管理等功能</li><li><strong>嵌入式操作系统</strong>：运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等资源进行统一协调、调度和控制的系统软件</li></ol><h2 id="总结">1.10 总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922170942935.png" alt="image-20220922170942935" style="zoom:80%;" /></p><h1 id="chapter-2operating-system-structures">Chapter2：Operating-System Structures</h1><h2 id="操作系统提供的服务">2.1 操作系统提供的服务</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922171943398.png" alt="image-20220922171943398" style="zoom:80%;" /></p><ol type="1"><li>用户界面<strong>User Interface</strong>：<ol type="1"><li>几乎所有操作系统都有用户界面（UI）</li><li>在命令行界面（CLI）、图形用户界面（GUI）和批处理之间有所不同</li></ol></li><li>程序执行<strong>Program Execution</strong>：<ol type="1"><li>系统必须能够将程序加载到内存并运行该程序，正常或异常结束执行（指示错误）</li></ol></li><li>I/O操作<strong>I/O operations</strong>：<ol type="1"><li>正在运行的程序可能需要I/O，这可能涉及文件或I/O设备</li></ol></li><li>文件系统操作<strong>File-System Manipulation</strong>：<ol type="1"><li>程序需要读取和写入文件和目录，创建和删除它们，搜索它们，列出文件信息，权限管理</li></ol></li><li>通信<strong>Communication</strong>：<ol type="1"><li>进程可以在同一台计算机上或在网络上的计算机之间交换信息</li><li>通信可以通过共享内存或消息传递（数据包由操作系统移动）</li></ol></li><li>错误检测<strong>Error Detection</strong>：<ol type="1"><li>操作系统需要不断意识到可能的错误</li><li>错误可能出现在CPU和内存硬件、I/O设备、用户程序中</li><li>对于每种类型的错误，操作系统都应该采取适当的措施来确保正确和一致的计算</li><li>调试设施可以大大提高用户和程序员有效使用系统的能力</li></ol></li><li>资源分配<strong>Resource allocation</strong>：<ol type="1"><li>当多个用户或多个作业同时运行时，必须将资源分配给每个用户或作业</li><li>许多类型的资源（如CPU周期、主内存和文件存储）可能有特殊的分配代码，其他（如I/O设备）可能有一般的请求和发布代码。</li></ol></li><li><strong>Accounting</strong>：<ol type="1"><li>跟踪哪些用户使用了多少和什么类型的计算机资源</li></ol></li><li>保护和安全<strong>Protection and Security</strong>：<ol type="1"><li>存储在多用户或联网计算机系统中的信息的所有者可能希望控制该信息的使用，并发进程不应相互干扰</li><li>保护包括确保控制对系统资源的所有访问</li><li>来自外部的系统安全需要用户身份验证，扩展到保护外部I/O设备免受无效访问尝试</li><li>如果要保护系统，必须在整个系统中采取预防措施。链条的坚固程度取决于它最薄弱的环节</li></ol></li></ol><h2 id="user-operating-system-interface">2.2 User Operating SystemInterface</h2><ol type="1"><li><strong>Operating System Interface</strong>操作系统的接口：<ol type="1"><li>User Interface （用户接口）</li><li>Program Interface （程序接口，system call）</li></ol></li><li><strong>User interface</strong>：用户接口，Almost all operatingsystems have a user interface (UI)<ol type="1"><li><strong>Command-Line Interface(CLI)</strong>：命令行用户接口，文本界面</li><li><strong>Graphics User Interface (GUI)</strong>：图形用户接口</li><li><strong>Touch-Screen Interface</strong>：触摸屏接口</li><li><strong>Choice of Interface</strong>：语音接口</li></ol></li></ol><h2 id="system-calls">2.3 System Calls</h2><ol type="1"><li><p>系统调用<strong>SystemCall</strong>：操作系统提供的服务的编程接口</p><ol type="1"><li>系统调用：进程和操作系统内核之间的编程接口</li><li>通常用高级语言（C或C++）编写</li><li>通常由程序通过高级应用程序接口(<strong>API</strong>)访问，而不是直接使用系统调用<ol type="1"><li>系统调用过于复杂，不适于编程</li><li>通过<strong>API</strong>将系统调用封装起来，便于编程</li></ol></li><li>三种最常见的API：<ol type="1"><li>用于Windows的Win32 API</li><li>用于基于POSIX的系统的POSIX API（包括几乎所有版本的UNIX、Linux和MacOS X）</li><li>用于Java虚拟机（JVM）的Java API</li></ol></li></ol></li><li><p>API与系统调用的区别</p><ol type="1"><li><p><strong>应用编程接口(API)</strong>：其实是一组函数定义，这些函数说明了如何获得一个给定的服务</p></li><li><p><strong>系统调用</strong>：是通过软中断向内核发出一个明确的请求，每个系统调用对应一个封装例程（wrapperroutine，唯一目的就是发布系统调用），一些API应用了封装例程</p></li><li><p><strong>API还包含各种编程接口</strong>，如：C库函数、OpenGL编程接口等</p></li><li><p><strong>系统调用的实现是在内核完成的，而用户态的函数是在函数库中实现的</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922173955455.png" alt="image-20220922173955455" style="zoom:80%;" /></p></li></ol></li><li><p>参数的传递：</p><ol type="1"><li><p>放到register</p></li><li><p>放到内存中，用register传递指针</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922174933864.png" alt="image-20220922174933864" style="zoom:50%;" /></p></li><li><p>放到栈中，使用时从栈中pop出来</p></li></ol></li><li><p>系统调用的种类</p><ol type="1"><li>Process control：进程控制<ol type="1"><li>创建/终止/结束/中止/加载/执行 进程</li><li>获取/设置 进程属性</li><li>等待 一段时间/某个事件的发生</li><li>分配/释放/出错时转储 内存</li><li>用于确定错误的调试器<strong>Debugger</strong>，单步执行</li><li>用于管理进程之间共享数据访问的锁<strong>Locks</strong></li></ol></li><li>File management：文件管理<ol type="1"><li>创建/删除/打开/关闭/读/写/重定位 文件</li><li>获取/设置 文件属性</li></ol></li><li>Device management：设备管理<ol type="1"><li>访问/释放/读/写/重定位 设备</li><li>获取/设置 设备属性</li><li>逻辑挂载/逻辑接触挂载 设备</li></ol></li><li>Information maintenance：信息维护<ol type="1"><li>获取/设置 时间/日期/系统数据/进程属性/文件属性/设备属性</li></ol></li><li>Communications：通信<ol type="1"><li>创建/删除 通信联系</li><li>如果是<strong>message passingmodel</strong>，则需要发送/接受信息</li><li>如果是<strong>shared-memorymodel</strong>，则需要创建/访问共享空间</li><li>传递状态信息</li><li>远程连接</li></ol></li><li>Protection：安全保护<ol type="1"><li>对资源/文件的访问权限</li><li>用户的权限</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926144126518.png" alt="image-20220926144126518" style="zoom:80%;" /></p></li></ol><h2 id="system-services">2.4 System Services</h2><p>系统程序<strong>Systemprograms</strong>为程序开发和执行提供了方便的环境。它们可以分为：</p><ol type="1"><li>文件操作：创建、删除、复制、重命名、打印、转储、列出并通常操作文件和目录</li><li>状态信息</li><li>文件修改：文本编辑器</li><li>编程语言支持：编译器、汇编器、调试器、解释器</li><li>程序加载和执行：加载/重新加载</li><li>通信：创建进程之间的连接，允许用户对另外一个用户进行传输文件/发送信息/远程控制</li><li>后台服务：启动时启动某些程序，打印错误日志，用户文本操作</li><li>应用程序</li></ol><p>大多数用户对操作系统的认知是由系统程序<strong>Systemprograms</strong>定义的，而不是实际的系统调用<strong>Systemcalls</strong></p><h2 id="linkers-and-loaders">2.5 Linkers and Loaders</h2><ol type="1"><li><p>编译成目标文件的源代码，可加载到任何物理内存位置：可重定位的目标文件<strong>relocatableobject file</strong></p></li><li><p>链接器<strong>Linker</strong>将这些<strong>obj</strong>文件，合并为单个二进制可执行文件<strong>executablefile</strong></p><ol type="1"><li>引入了库</li></ol></li><li><p>程序作为二进制可执行文件加载<strong>load</strong>在辅助存储上</p></li><li><p>必须由要执行的加载程序带入内存</p><ol type="1"><li>重新定位<strong>Relocation</strong>将最终地址分配给程序部件，并调整程序中的代码和数据以匹配这些地址</li></ol></li><li><p>现代操作系统不会将库链接到可执行文件中</p><ol type="1"><li>相反，动态链接库(<strong>DLL</strong>)是根据需要加载的，由所有使用同一版本库的用户共享</li><li>在程序运行时，按照需要加载一次</li></ol></li><li><p>对象，可执行文件具有标准格式，因此操作系统知道如何加载和启动它们</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926150251040.png" alt="image-20220926150251040" style="zoom:80%;" /></p></li></ol><h2 id="为什么应用程序只运行在特定的操作系统上">2.6为什么应用程序只运行在特定的操作系统上</h2><ol type="1"><li>在一个系统上编译的应用程序通常不能在其他操作系统上执行</li><li>每个操作系统都提供自己独特的系统调用、自己的文件格式等</li><li>应用程序可以是多操作系统<ol type="1"><li>用解释语言编写，如Python、Ruby和多个操作系统上可用的解释器</li><li>以包含包含运行应用程序的VM的语言编写的应用程序（如Java）</li><li>使用标准语言（如C），在每个操作系统上分别编译，以便在每个系统上运行</li></ol></li><li>应用程序二进制接口(<strong>Application BinaryInterface，ABI</strong>)：是API的体系结构等价物<ol type="1"><li>定义了二进制代码的不同组件如何在给定的体系结构、CPU等上与给定的操作系统交互</li></ol></li></ol><h2 id="operating-system-design-and-implementation">2.7 Operating-SystemDesign and Implementation</h2><ol type="1"><li>操作系统的设计和实现不是“可解决的”，但一些方法已经证明是成功的</li><li>不同操作系统的内部结构可能有很大差异</li><li>从定义目标和规范开始</li><li>受硬件选择、系统类型的影响</li><li>用户目标和系统目标<ol type="1"><li>用户目标：操作系统应便于使用、易于学习、可靠、安全和快速</li><li>系统目标：操作系统应易于设计、实施和维护，并且灵活、可靠、无错误和高效</li></ol></li></ol><p>操作系统的设计考虑</p><ol type="1"><li>功能设计：操作系统应具备哪些功能</li><li>算法设计：选择和设计满足系统功能的算法和策略，并分析和估算其效能</li><li>结构设计：选择合适的操作系统结构</li><li>按照系统的功能和特性要求，选择合适的结构，使用相应的结构设计方法将系统逐步地分解、抽象和综合，使操作系统结构清晰、简单、可靠、易读、易修改，而且使用方便，适应性强</li></ol><p>具体实现</p><ol type="1"><li>变化很大<ol type="1"><li>早期操作系统：汇编语言</li><li>然后：系统编程语言，如Algol、PL/1</li><li>现在：C，C++</li></ol></li><li>实际上通常是多种语言的混合<ol type="1"><li>组件中的最低级别</li><li>主体用C表示</li><li>用C、C++、脚本语言（如PERL、Python、shell脚本）编写的系统程序</li></ol></li><li>更高级的语言更容易移植到其他硬件，但速度较慢</li><li>仿真可以允许操作系统在非本机硬件上运行</li></ol><h2 id="operating-system-structure">2.8 Operating-System Structure</h2><ol type="1"><li><p>Simple Structure：简单结构</p><ol type="1"><li>MS-DOS：以最少的空间提供最多的功能</li><li>未划分为模块</li><li>虽然MS-DOS有一些结构，但其接口和功能级别没有很好地分离</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926154200710.png" alt="image-20220926154200710" style="zoom:50%;" /></p></li><li><p>Layered Approach：层次化结构</p><ol type="1"><li>操作系统被划分为若干层（级别），每一层都构建在较低层之上</li><li>底层（第0层）是硬件；最高的（N层）是用户界面</li><li>通过模块化，层的选择使得每个层只使用较低层的功能（操作）和服务<ol type="1"><li>上一层只能使用下一层的功能</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926154322875.png" alt="image-20220926154322875" style="zoom:50%;"/></p></li><li><p>Monolithic Kernels Structure：单/宏内核结构</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926154624778.png" alt="image-20220926154624778" style="zoom:80%;" /></p><ol type="1"><li>内核的整个代码都打包到一个文件中</li><li>每个函数都可以访问内核的所有其他部分</li><li>最早和最常见的操作系统体系结构（UNIX）</li><li>操作系统的每个组件都包含在内核中</li><li>示例：OS/360、VMS和Linux</li><li>优点：高效</li><li>缺点：很难定位问题，很难修改和维护，内核会变得越来越大</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220926155006512.png" alt="image-20220926155006512" style="zoom:80%;" /></p></li><li><p>Microkernel：微内核，只保留必要的程序，在内核模式中运行的程序</p><ol type="1"><li><p>只有最基本的功能由内核实现</p></li><li><p>所有其它功能委托给一些独立进程实现，这些进程通过明确定义的通信接口与中心内核通信</p></li><li><p>系统的各个部分彼此都很清楚的划分开来，同时也迫使程序员使用“清洁的”程序设计技术</p></li><li><p>优点：动态可扩展性、在运行时切换重要组件</p></li><li><p>缺点：在各个组件之间支持复杂通信需要额外的CPU时间</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929163127806.png" alt="image-20220929163127806" style="zoom:80%;" /></p></li><li><p>现有的系统多使用微内核结构</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929163258312.png" alt="image-20220929163258312" style="zoom:80%;" /></p></li></ol></li><li><p>Modules：模块</p><ol type="1"><li>大多数现代操作系统实现kernel modules(内核模块）<ol type="1"><li>使用面向对象的方法</li><li>每个核心组件都是独立的</li><li>每个人都通过已知接口与其他人交谈</li><li>每个都可以根据需要在内核中加载</li></ol></li><li>总体而言，与层相似，但更灵活</li></ol></li><li><p>Hybrid Systems：混合结构</p><ol type="1"><li>大多数现代操作系统实际上不是一个纯模型</li><li>Hybrid System结合了多种方法来满足性能、安全性和可用性需求</li></ol></li><li><p>Virtual Machines：虚拟机</p><ol type="1"><li>虚拟机采用分层方法得出其逻辑结论。它将硬件和操作系统内核视为硬件</li><li>虚拟机提供与底层裸硬件相同的接口</li><li>操作系统主机会产生一种错觉，认为进程有自己的处理器和（虚拟内存）</li><li>为每位host提供一份底层计算机的（虚拟）副本</li><li>虚拟机软件：VMWARE、VirtualBox、Microsoft virtual PC</li><li>开放堆栈云计算平台</li></ol></li></ol><h1 id="chapter-3processes">Chapter 3：Processes</h1><h2 id="进程的概念">3.1 进程的概念</h2><h3 id="进程">3.1.1 进程</h3><p>进程：一个正在执行的程序，独立的，有权获取资源的</p><ol type="1"><li>计算机的基本工作单位</li><li>jobs作业=user programs用户程序=tasks任务=process进程</li><li>包含一些资源的指令容器：例如CPU时间（CPU执行指令）、内存、文件、完成其任务的I/O设备</li><li>示例：<ol type="1"><li>编译进程</li><li>字处理进程</li><li>调度程序进程(scheduler processes)：sched、swapper</li><li>守护进程(daemon process)：ftpd、httpd</li></ol></li></ol><h3 id="内存中的进程">3.1.2 内存中的进程</h3><ol type="1"><li>程序代码，也被称为text section</li><li>PC：Program Counter</li><li>Register</li><li>Data section：全局变量</li><li>Stack：临时变量</li><li>Heap：动态开辟的内存</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929172319297.png" alt="image-20220929172319297" style="zoom:80%;" /></p><h3 id="进程状态">3.1.3 进程状态</h3><ol type="1"><li><strong>New</strong>(新)：创建进程，在内存中开辟一段空间给进程</li><li><strong>Running</strong>(运行、执行)： 进程正在使用CPU</li><li><strong>Ready</strong>(就绪)：进程可以使用CPU</li><li><strong>Waiting</strong>(等待、blocked阻塞)：进程等待一些事件的发生</li><li><strong>Terminated</strong>(终止)：进程停止执行</li></ol><h3 id="进程状态的切换">3.1.4 进程状态的切换</h3><ol type="1"><li>程序：系统调用</li><li>操作系统：调度</li><li>外部程序：中断</li><li>只有ready状态才能转换到running状态</li><li>三个基本状态之间可能转换和转换原因如下：<ol type="1"><li>ready→running：当<strong>处理器空闲</strong>时，进程调度程序必将处理机分配给一个处于ready状态的进程，该进程便由ready状态转换为running状态</li><li>running→waiting：处于running状态的进程在运行过程中需要<strong>等待某一事件</strong>发生后（例如因I/O请求等待I/O完成后），才能继续运行，则该进程放弃处理器，从running状态转换为waiting状态</li><li>waiting→ready：处于waiting状态的进程，若其<strong>等待的事件已经发生</strong>，于是进程由waiting状态转换为ready状态。</li><li>running→ready：处于running状态的进程在其运行过程中，因分给它的<strong>处理器时间片已用完</strong>，而不得不让出（被抢占）处理器，于是进程由running态转换为ready态。</li><li>waiting→running，ready→waiting这二种状态转换一般不可能发生</li></ol></li><li>处于running状态进程：如系统有一个处理器，则在任何一时刻，最多只有一个进程处于运行状态。</li><li>处于ready状态进程：一般处于就绪状态的进程按照一定的算法（如先来的进程排在前面，或采用优先权高的进程排在前面）排成一个就绪队列。</li><li>处于waiting状态进程：处于等待状态的进程排在等待队列中。由于等待事件原因不同，等待队列也可以按事件分成几个队列。</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929172953173.png" alt="image-20220929172953173" style="zoom:80%;" /></p><p>例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929174356541.png" alt="image-20220929174356541" style="zoom:80%;" /></p><h3 id="进程与程序的区别">3.1.5 进程与程序的区别</h3><ol type="1"><li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行</li><li><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存</li><li><strong>进程与程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（即进程状态信息）</li><li><strong>进程与程序的对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li></ol><h3 id="pcb-进程控制块">3.1.6 PCB 进程控制块</h3><ol type="1"><li>每个进程在操作系统内用<strong>进程控制块(Process ControlBlock)</strong>来表示，它包含与特定进程相关的许多信息：<ol type="1"><li>Process state：进程状态</li><li>Program counter：当前进程执行到的位置</li><li>CPU registers：CPU中的寄存器</li><li>CPU scheduling information：CPU的调度信息</li><li>Memory-management information：内存管理信息</li><li>Accounting information：统计信息</li><li>File management ：文件管理信息</li><li>I/O status information：输入/输出状态信息</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929174647830.png" alt="image-20220929174647830" style="zoom:80%;" /></p><h2 id="process-scheduling-进程调度">3.2 Process Scheduling进程调度</h2><h3 id="scheduling-queue-调度队列">3.2.1 Scheduling Queue 调度队列</h3><ol type="1"><li><strong>Job queue</strong>作业队列：系统中所有进程的集合</li><li><strong>Readyqueue</strong>就绪队列：驻留在主存中、就绪并等待执行的所有进程的集合</li><li><strong>Device queue</strong>设备队列：等待I/O设备的一组进程</li></ol><blockquote><p>进程会在不同队列之间迁移</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008164644057.png" alt="image-20221008164644057" style="zoom:80%;" /></p><blockquote><p>进程调度的表示</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008165059638.png" alt="image-20221008165059638" style="zoom:80%;" /></p><h3 id="schedulers-调度器">3.2.2 Schedulers 调度器</h3><ol type="1"><li><strong>Long-term scheduler / job scheduler</strong>：长程调度 /作业调度<ol type="1"><li>控制ready queue的长度：选择应加入ready queue的进程</li><li>调用的频率很低，基本上以秒/分钟为单位</li><li>控制多道程序设计<strong>multiprogramming</strong>的程度</li><li>大多数现代操作系统没有长期调度程序（如Windows、UNIX、Linux）</li></ol></li><li><strong>Short-term scheduler / CPU scheduler</strong>：短程调度 /CPU调度<ol type="1"><li>选择ready queue中的哪一个进程能够进入CPU</li><li>调用的频率很好高，基本上以毫秒为单位</li></ol></li><li><strong>Medium-Term Scheduler</strong>：中程调度<ol type="1"><li>将一些进程从内存中临时移出，从而减少调度器须要处理进程的数目</li><li>这样将进程移出内存的机制叫做<strong>换出(Swapping)</strong></li><li>按需调用，可以关闭中程调度</li></ol></li><li>进程可以被分为：<ol type="1"><li>I/O-boundprocess：I/O型进程，需要做很多的I/O操作，有很多的CPU中断</li><li>CPU-bound process：CPU型进程，需要很多的计算</li></ol></li></ol><h3 id="context-switch-上下文切换">3.2.3 Context Switch 上下文切换</h3><ol type="1"><li>当CPU切换到另一个进程时，系统必须保存旧进程的状态，并通过<strong>上下文切换(ContextSwitch)</strong>加载新进程的保存状态</li><li>上下文切换时间开销大；系统在切换时没有任何有用的工作</li><li>时间取决于硬件支持</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008170551322.png" alt="image-20221008170551322" style="zoom:80%;" /></p><h3 id="移动端的多任务">3.2.4 移动端的多任务</h3><ol type="1"><li>由于屏幕的实际情况，iOS的用户界面限制了<ol type="1"><li>单个前台进程：通过用户界面控制</li><li>多个后台进程：内存中、正在运行，但不在显示器上，并且有限制</li><li>限制包括单个、短任务、接收事件通知、特定的长时间运行任务，如音频播放</li></ol></li><li>Android运行前台和后台，限制更少<ol type="1"><li>后台进程使用服务执行任务</li><li>即使后台进程挂起，服务也可以继续运行</li><li>服务没有用户界面，占用内存少</li></ol></li></ol><h2 id="operations-on-process-进程的操作">3.3 Operations on Process进程的操作</h2><h3 id="process-creation-进程创建">3.3.1 Process Creation 进程创建</h3><ol type="1"><li><p>父进程创建子进程，子进程又创建其他进程，形成进程树</p></li><li><p>通常，通过进程标识符(<strong>processidentifier，pid</strong>)识别和管理进程</p></li><li><p>资源共享：</p><ol type="1"><li>父进程和子进程共享所有资源</li><li>子进程共享父进程资源的子集</li><li>父进程和子进程不共享资源</li></ol></li><li><p>执行：</p><ol type="1"><li>父进程和子进程同时执行</li><li>父进程一直等到子进程结束</li></ol></li><li><p>地址空间：</p><ol type="1"><li>子进程是父进程的副本</li><li>子进程已经加载进了一段程序</li></ol></li><li><p>例：UNIX</p><ol type="1"><li><strong>fork()</strong>：系统调用，用于创建一个新的进程<ol type="1"><li>int pid1 = fork();</li><li>父进程使用fork创建子进程时，子进程会生成一份父进程的备份，除了返回值之外，两者完全一样</li><li>从系统调用fork中返回时，两个进程除了返回值pid1不同外，具有完全一样的用户级上下文</li><li><strong>在子进程中，pid1的值为0</strong></li><li><strong>在父进程中， pid1的值为子进程的进程号</strong></li></ol></li><li><strong>exec()</strong>：系统调用，用于在fork之后调用新程序，替换进程的内存空间</li><li><strong>exit()</strong>：系统调用，终止子进程，并给父进程返回参数</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008172736560.png" alt="image-20221008172736560" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008172903009.png" alt="image-20221008172903009" style="zoom:80%;" /></p></li></ol><blockquote><p>C语言代码示例：进程的创建过程</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[ ])</span>&#123; </span><br><span class="line">    <span class="type">int</span> pid1 = fork();  <span class="comment">// fork一个子进程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid1 &lt; <span class="number">0</span>)&#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid1==<span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 子进程执行, 因为子进程的fork返回的是0</span></span><br><span class="line">        execlp(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 父进程执行, 因为父进程的fork返回的是子进程的pid</span></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 阻塞父进程, 直到子进程执行完成</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child Complete&quot;</span>);                      </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="process-termination-进程终止">3.3.2 Process Termination进程终止</h3><ol type="1"><li>引起进程终止的事件<ol type="1"><li>正常结束</li><li>异常结束</li><li>外界干预</li></ol></li><li>进程执行完最后一条指令后，会询问操作系统如何终止它<ol type="1"><li>从子进程向父进程输出数据</li><li>操作系统释放该进程的数据</li></ol></li><li>如果父进程被终止，那么子进程会发生：<ol type="1"><li>有些操作系统不会让子进程继续运行</li><li>子进程通过<strong>cascading termination</strong>终止运行</li><li>子进程被过继到另一个父进程</li></ol></li><li>移动端操作系统<ol type="1"><li>会因为系统资源不够，而终止一些进程</li><li>此时要有一个进程的优先级排序，从重要到不重要，排序如下：<ol type="1"><li>前端进程</li><li>可见进程</li><li>服务进程</li><li>后台进程</li><li>空进程</li></ol></li><li>Android会优先终止最不重的进程</li></ol></li></ol><h2 id="ipcinterprocess-communication-进程通信">3.4 IPC：InterprocessCommunication 进程通信</h2><ol type="1"><li><p><strong>IndependentProcess</strong>：独立进程，不被其它进程的执行影响，也不能影响其它进程的执行</p></li><li><p><strong>CooperatingProcess</strong>：合作进程，可以其它进程的执行影响，也可以影响其它进程的执行</p><ol type="1"><li>优点：<ol type="1"><li>信息共享</li><li>加速计算</li><li>模块化</li><li>更加便捷</li></ol></li><li>需要<strong>IPC</strong>：Interprocess Communication，进程通信</li></ol></li><li><p><strong>IPC</strong>的两种模式</p><ol type="1"><li>共享内存</li><li>消息传递</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008174950771.png" alt="image-20221008174950771" style="zoom:80%;" /></p></li><li><p>通信类型：</p><ol type="1"><li>直接通信<ol type="1"><li><strong>send(P, message)</strong>：直接发消息给进程P</li><li><strong>receive(Q, message)</strong>：直接接收来自进程Q的消息</li></ol></li><li>间接通信<ol type="1"><li><strong>send(A, message)</strong>：发送消息给邮件服务器A</li><li><strong>receive(A, message)</strong>：从邮件服务器A接收消息</li></ol></li></ol></li><li><p>常用通信机制：</p><ol type="1"><li>信号(signal)：进程发送信号</li><li>共享存储区(shared memory)：不同进程共享一段空间，进行通信</li><li>管道(pipe)：进程间通过一种操作将结果传输过去</li><li>消息(message)</li><li>套接字(socket)</li></ol></li></ol><h3 id="linux进程通信机制">3.4.1 Linux进程通信机制</h3><p>Linux实现进程间通信(<strong>IPC</strong> Inter ProcessCommunication)：</p><ol type="1"><li>System V IPC机制:<ol type="1"><li>信号量：保证不同进程得到的信息是一样的</li><li>消息队列、</li><li>共享内存</li></ol></li><li>管道（pipe）、命名管道</li><li>套接字（socket）</li><li>信号( signal )</li><li>文件锁(file lock)</li><li>POSIX线程：<ol type="1"><li>互斥锁(互斥体、互斥量)（mutex）、条件变量(condition variables)</li></ol></li><li>POSIX：<ol type="1"><li>消息队列、信号、共享内存</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221010144032973.png" alt="image-20221010144032973" style="zoom:80%;" /></p><h3 id="windows-进程线程通信机制">3.4.2 Windows 进程线程通信机制</h3><ol type="1"><li>基于文件映射的共享存储区</li><li>无名管道和命名管道<ol type="1"><li>server32pipe.c、client32pipe.c</li><li>启动多个client进程进行通信</li></ol></li><li>邮件槽</li><li>套接字</li><li>剪帖板(Clipboard)</li><li>信号</li><li>其他同步机制</li></ol><h2 id="ipcin-shared-memory-systems">3.5 IPC：in Shared-MemorySystems</h2><ol type="1"><li>希望通信的进程之间共享的内存区域</li><li>通信受用户进程的控制，而不是操作系统的控制</li><li>主要问题是：提供允许用户进程在访问共享内存时同步其操作的机制<ol type="1"><li>在第6、7章会讨论同步</li></ol></li><li>协同进程的并发执行需要允许进程相互通信并同步其操作的机制（第6章）。</li><li>合作过程的共同范式：Producer-ConsumerProblem(生产者-消费者问题）</li><li>生产者进程生成消费者进程使用的信息<ol type="1"><li>unbounded-buffer(无限缓冲区)：对缓冲区的大小没有实际限制。</li><li>bounded-buffer(有限缓冲区)：假设存在固定的缓冲区大小。</li></ol></li></ol><h3 id="bounded-buffershared-memory-solution">3.5.1Bounded-Buffer：Shared-Memory Solution</h3><ol type="1"><li><p><strong>Shared data</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;item;</span><br><span class="line"></span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>为了保证进程对共享空间的正确操作，只能使用<strong>BUFFER_SIZE-1</strong>的空间</p><ol type="1"><li>空间是一个循环队列</li></ol></li><li><p><strong>Producer</strong>：生产者，生成数据</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">item nextProduced;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    produce an item in nextProduced;</span><br><span class="line">    <span class="comment">// buffer中没有空位, 什么都不做</span></span><br><span class="line">    <span class="keyword">while</span> ((in + <span class="number">1</span>) % BUFFER_SIZE == out);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向buffer中添加一个item</span></span><br><span class="line">    buffer[in] = nextProduced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Consumer</strong>：消费者，使用数据</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">item nextConsumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// buffer中没有item, 什么都不做</span></span><br><span class="line">    <span class="keyword">while</span> (in == out);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从buffer中拿走一个item</span></span><br><span class="line">    nextConsumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    consume the item in nextConsumed ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="ipcin-message-passing-systems">3.6 IPC：in Message-PassingSystems</h2><ol type="1"><li>进程通信和同步其操作的机制</li><li>消息系统：流程之间无需借助共享变量即可进行通信</li><li>IPC设施提供两种操作：<ol type="1"><li><strong>send(message)</strong></li><li><strong>receive(message)</strong></li></ol></li><li>message的大小是固定的或可变的</li><li>如果进程P和Q想要沟通，他们需要：<ol type="1"><li>在他们之间建立通信联系</li><li>通过发送/接收交换message</li></ol></li><li>实现的任务：<ol type="1"><li>如何建立链接？</li><li>一个链接可以与两个以上的进程关联吗？</li><li>每对通信进程之间可以有多少个链接？</li><li>链路的容量是多少？</li><li>链接可以容纳的消息大小是固定的还是可变的？</li><li>链路是单向的还是双向的？</li></ol></li><li>通信链路的实现<ol type="1"><li>物理：<ol type="1"><li>共享内存</li><li>硬件总线</li><li>网络</li></ol></li><li>逻辑：<ol type="1"><li>直接或间接</li><li>同步或异步</li><li>自动或显式缓冲</li></ol></li></ol></li></ol><h3 id="direct-communication直接通信">3.6.1 DirectCommunication（直接通信）</h3><ol type="1"><li>进程必须明确命名：<ol type="1"><li><strong>send(P, message)</strong>：向进程P发送消息</li><li><strong>receive(Q, message)</strong>：从进程Q接收消息</li></ol></li><li>通信链路的属性<ol type="1"><li>自动建立链接</li><li>链接只与一对通信进程相关联</li><li>每对之间只有一条链路</li><li>链接可能是单向的，但通常是双向的</li></ol></li></ol><h3 id="indirect-communication间接通信">3.6.2 IndirectCommunication（间接通信）</h3><ol type="1"><li>message从mailbox（也称为port）定向和接收<ol type="1"><li>每个mailbox都有唯一的id</li><li>进程只有在共享mailbox时才能通信</li></ol></li><li>通信链路的属性<ol type="1"><li>仅当进程共享common mailbox时才建立链接</li><li>链接可能与许多进程关联</li><li>每对进程可以共享多个通信链路</li><li>链接可以是单向的或双向的</li></ol></li><li>操作<ol type="1"><li>创建新的mailbox(port)</li><li>通过mailbox发送和接收message</li><li>销毁mailbox</li></ol></li><li>基本操作：<ol type="1"><li><strong>send(A, message)</strong>：将消息发送到邮箱A</li><li><strong>receive(A, message)</strong>：从邮箱A接收消息</li></ol></li></ol><h3 id="synchronization同步">3.6.3 Synchronization同步</h3><ol type="1"><li>消息传递可以是阻塞的或非阻塞的</li><li>Blocking(阻塞)被认为是同步的<ol type="1"><li>Blocking send：发送方被阻止，直到确认消息被收到</li><li>Blocking receive：在消息可用之前，接收器被阻止</li></ol></li><li>Non-blocking(非阻塞)被认为是异步的<ol type="1"><li>Non-blocking send：发送方不断发送消息</li><li>Non-blockingreceive：接收器不断接收消息，可能是有效消息，也可能是Null消息</li></ol></li><li>可能的不同组合<ol type="1"><li>如果发送和接收都被是Blocking，称为完整性过程<strong>have arendezvous</strong></li></ol></li></ol><h3 id="buffering">3.6.4 Buffering</h3><ol type="1"><li>附加到链接的消息队列，以三种方式之一实施<ol type="1"><li>零容量<ol type="1"><li>链路上没有消息排队</li><li>发送方必须等待接收方接收完成后，才能再次发送消息</li></ol></li><li>容量有限<ol type="1"><li>n条消息的有限长度</li><li>如果链接已满，发送方必须等待</li></ol></li><li>无限容量<ol type="1"><li>无限长度</li><li>发送程序从不等待</li></ol></li></ol></li></ol><h3 id="实例">3.6.5 实例</h3><ol type="1"><li>例： 设计一个程序，要求<ol type="1"><li>用函数msgget创建消息队列</li><li>从键盘输入的字符串添加到消息队列</li><li>创建一个进程，使用函数msgrcv读取队列中的消息并在计算机屏幕上输出</li></ol></li><li>分析 ：<ol type="1"><li>程序先调用msgget函数创建、打开消息队列</li><li>接着调用msgsnd函数，把输入的字符串添加到消息队列中</li><li>子进程调用msgrcv函数，读取消息队列中的消息并打印输出</li><li>最后调用msgctl函数，删除系统内核中的消息队列</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//msgfork.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体，定义消息的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msgmbuf</span>&#123;</span><br><span class="line">    <span class="type">long</span> msg_type;<span class="comment">//消息类型</span></span><br><span class="line">    <span class="type">char</span> msg_text[<span class="number">512</span>]; <span class="comment">//消息内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> qid,len;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msgmbuf</span> msg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用ftok函数，根据当前文件的目录，产生标准的key</span></span><br><span class="line">    <span class="keyword">if</span>((key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;a&#x27;</span>)) == <span class="number">-1</span>) &#123;   </span><br><span class="line">     <span class="built_in">perror</span>(<span class="string">&quot;产生标准key出错&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用msgget函数，创建、打开消息队列</span></span><br><span class="line">    <span class="keyword">if</span>((qid = <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;创建消息队列出错&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印输出队列号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建、打开的队列号是：%d\n&quot;</span>,qid);  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程PID=: %d 发送消息\n&quot;</span>,<span class="built_in">getpid</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;请输入要加入队列的消息：&quot;</span>); </span><br><span class="line">        <span class="comment">// 键盘输入的消息存入变量msg_text</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">fgets</span>((&amp;msg)-&gt;msg_text, <span class="number">512</span>, stdin)) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;没有消息&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.msg_type=<span class="built_in">getpid</span>();</span><br><span class="line">        len=<span class="built_in">strlen</span>(msg.msg_text);</span><br><span class="line">        <span class="comment">// 调用msgsnd函数，添加消息到消息队列</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">msgsnd</span>(qid,&amp;msg,len,<span class="number">0</span>))&lt;<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;添加消息出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程PID=：%d 接收消息\n&quot;</span>,<span class="built_in">getpid</span>())</span><br><span class="line">        <span class="comment">// 调用msgrcv函数，从消息队列读取消息</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">msgrcv</span>(qid,&amp;msg,<span class="number">512</span>,<span class="number">0</span>,<span class="number">0</span>))&lt;<span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;读取消息出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 打印输出消息内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取的消息是：%s\n&quot;</span>,(&amp;msg)-&gt;msg_text); </span><br><span class="line">        <span class="comment">// 调用msgctl函数，删除系统中的消息队列</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">msgctl</span>(qid,IPC_RMID,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;删除消息队列出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分成两个独立的程序：msgsnd.c,msgrcv.c。分别编译和运行</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221010154723335.png" alt="image-20221010154723335" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221010154729917.png" alt="image-20221010154729917" style="zoom:80%;" /></p><h2 id="ipcexample">3.7 IPC：example</h2><h3 id="windows">3.7.1 Windows</h3><ol type="1"><li>通过高级本地过程调用（LPC）功能以消息传递为中心<ol type="1"><li>仅在同一系统上的进程之间工作</li><li>使用端口（如邮箱）建立和维护通信通道</li><li>通信工作如下：<ol type="1"><li>客户端打开子系统连接端口对象的句柄</li><li>客户端发送连接请求</li><li>服务器创建两个专用通信端口，并将其中一个端口的句柄返回客户端</li><li>客户端和服务器使用相应的端口句柄发送消息或回调，并侦听回复</li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013162834236.png" alt="image-20221013162834236" style="zoom:80%;" /></p><h3 id="pipe-管道通信">3.7.2 Pipe 管道通信</h3><ol type="1"><li>充当允许两个进程通信的管道</li><li>问题：<ol type="1"><li>通信是单向的还是双向的？</li><li>在双向通信的情况下，是半双工还是全双工？（在工作时是否有一端读或写？）</li><li>沟通过程之间必须存在关系（即父子关系）吗？</li><li>管道可以通过网络使用吗？</li></ol></li><li><strong>Ordinarypipes</strong>普通管道：无法从创建它的流程外部访问。通常，父进程创建个管道，并使用它与它创建的子进程通信。</li><li><strong>Namedpipes</strong>命名管道：可以在没有父子关系的情况下访问。</li></ol><h4 id="ordinary-pipes">3.7.2.1 Ordinary pipes</h4><ol type="1"><li>普通管道允许以标准 <strong>生产者-消费者</strong> 的形式进行通信<ol type="1"><li>生产者写入一端（管道的写入端<strong>write-end</strong>）</li><li>消费者从另一端（管道的读取端<strong>read-end</strong>）读取</li></ol></li><li>因此，普通管道是<strong>单向的</strong></li><li>需要沟通流程之间的<strong>父子关系</strong></li><li>Windows调用这些匿名管道<strong>anoymous pipes</strong></li></ol><h4 id="named-pipes">3.7.2.2 Named pipes</h4><ol type="1"><li>命名管道比普通管道更强大</li><li>通信是<strong>双向的</strong></li><li>沟通过程之间<strong>不需要父子关系</strong></li><li>多个进程可以使用命名管道进行通信</li><li>在UNIX和Windows系统上提供</li></ol><h2 id="communication-in-clientserver-systems">3.8 Communication inClient–Server Systems</h2><h3 id="socket-套接字">3.8.1 Socket 套接字</h3><ol type="1"><li><strong>Socket</strong>被定义为通信的端点</li><li>IP地址和端口串联：消息包开头包含的数字，用于区分主机上的网络服务</li><li><strong>socket</strong><strong>161.25.19.8:1625</strong>指：主机<strong>161.25.119.8</strong>上的端口<strong>1625</strong></li><li>通信由一对<strong>socket</strong>组成</li><li><strong>1024</strong>以下的所有端口都是众所周知的，用于标准服务</li><li>特殊IP地址<strong>127.0.0.1</strong>（loopback），用于指运行进程的系统</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013163733736.png" alt="image-20221013163733736" style="zoom:67%;" /></p><h3 id="remote-procedure-calls-远过程调用">3.8.2 Remote Procedure Calls远过程调用</h3><ol type="1"><li><strong>Remote ProcedureCalls</strong>(<strong>RPC</strong>，远过程调用)：抽象网络系统上进程之间的过程调用<ol type="1"><li>再次使用端口来区分服务</li></ol></li><li>存根<strong>stubs</strong>：服务器上实际过程的客户端代理</li><li>客户端存根<strong>The client-sidestub</strong>：定位服务器并整理(marshalls)参数</li><li>服务器端存根<strong>The server-sidestub</strong>：接收此消息，解压缩编组参数，并在服务器上执行过程</li><li>在Windows上，stub代码根据用Microsoft接口定义语言(<strong>MIDL</strong>)编写的规范编译</li><li>通过外部数据表示(<strong>XDL</strong>，External DataRepresentation)格式处理数据表示，以考虑不同的体系结构<ol type="1"><li>大端和小端</li></ol></li><li>远程通信比本地通信有更多的故障情况<ol type="1"><li>消息只能传递确定的一次，而不能最多传递一次</li></ol></li><li>操作系统通常提供<strong>rendezvous /matchmaker</strong>服务来连接客户端和服务器</li><li>Android RPC的执行过程：</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013164324392.png" alt="image-20221013164324392" style="zoom:80%;" /></p><h1 id="chapter-4threads-concurrency">Chapter 4：Threads &amp;Concurrency</h1><h2 id="overview">4.1 Overview</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013165603587.png" alt="image-20221013165603587" style="zoom:67%;" /></p><p>进程：</p><ol type="1"><li>资源拥有单位：<ol type="1"><li>给每个进程分配一虚拟地址空间</li><li>保存进程映像</li><li>控制一些资源（文件，I/O设备）</li><li>有状态、优先级、调度</li></ol></li><li>调度单位：<ol type="1"><li>进程是由一个或多个程序的一次执行</li><li>可能会与其他进程交替执行</li></ol></li></ol><h3 id="线程thread的概念">4.1.1 线程Thread的概念</h3><ol type="1"><li><strong>进程</strong>：资源的<strong>拥有单元</strong>称为进程 /任务</li><li><strong>线程</strong>：资源的<strong>调度单位</strong>称为线程 /轻型进程(light weight process)<ol type="1"><li>线程只拥有在运行中必不可省的资源(PC、register、stack)</li><li>但它可与同属一个进程的其它线程共享进程拥有的全部资源</li></ol></li></ol><p>线程定义为：进程内一个<strong>执行单元</strong>或一个<strong>可调度实体</strong></p><ol type="1"><li>有执行状态（状态转换）</li><li>不运行时保存上下文</li><li>有一个执行栈</li><li>有一些局部变量的静态存储</li><li>可存取所在进程的内存和其他资源</li><li>可以创建、撤消另一个线程</li></ol><h3 id="线程的特点">4.1.2 线程的特点</h3><ol type="1"><li>不拥有<strong>系统资源</strong>（只拥有少量的资源，资源是分配给进程）</li><li>一个进程中的多个线程可并发执行（进程可创建线程执行同一程序的不同部分）</li><li>系统开销小、切换快。（进程的多个线程都在进程的地址空间活动）</li></ol><h3 id="线程的优点">4.1.3 线程的优点</h3><ol type="1"><li><strong>创建一个新线程</strong>花费时间少（结束亦如此）</li><li><strong>两个线程的切换</strong>花费时间少<ol type="1"><li>如果机器设有 “存储[恢复]所有寄存器”指令，则整个切换过程用几条指令即可完成</li></ol></li><li>因为同一进程内的<strong>线程共享内存和文件</strong>，因此它们之间相互通信无须调用内核</li><li>适合<strong>多处理机</strong>系统</li></ol><h3 id="线程的使用案例">4.1.4 线程的使用案例</h3><ol type="1"><li>LAN中的一个文件服务器，在一段时间内需要处理几个文件请求<ol type="1"><li>有效的方法是：为每一个请求创建一个线程</li><li>在一个SMP机器上：多个线程可以同时在不同的处理器上运行</li></ol></li><li>一个线程显示菜单，并读入用户输入；另一个线程执行用户命令<ol type="1"><li>考虑一个应用：由几个独立部分组成，这几个部分不需要顺序执行，则每个部分可以以线程方式实现</li><li>当一个线程因I/O阻塞时，可以切换到同一应用的另一个线程</li></ol></li></ol><h2 id="多核编程">4.2 多核编程</h2><ol type="1"><li><p>多核系统给程序员带来新的挑战：</p><ol type="1"><li>划分活动</li><li>负载均衡：保证任务的计算量尽量均衡</li><li>数据拆分</li><li>数据依赖性</li><li>测试和调试</li></ol></li><li><p>多线程服务端结构</p><ol type="1"><li>服务端、客户端各自是一个进程</li><li>当有请求时，服务端创建一个线程，处理请求</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013173723379.png" alt="image-20221013173723379" style="zoom:67%;" /></p></li><li><p>多核系统的并行执行：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013173753691.png" alt="image-20221013173753691" style="zoom:67%;" /></p></li></ol><h2 id="multithreading-models">4.3 Multithreading Models</h2><p>线程的实现机制：</p><ol type="1"><li>用户级线程 user-level thread</li><li>内核级线程 kernel-level thread</li><li>两者结合方法</li></ol><h3 id="user-threads-用户级线程">4.3.1 User Threads 用户级线程</h3><ol type="1"><li>用户级线程：<ol type="1"><li>不依赖于OS核心（内核不了解用户线程的存在）</li><li>应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程</li><li>如：数据库系统informix、图形处理Aldus PageMaker</li><li><strong>调度</strong>由<strong>应用软件</strong>内部进行，通常采用非抢先式和更简单的规则，也无需用户态/核心态切换，所以速度特别快</li><li>一个线程发起系统调用而阻塞，则整个进程在等待。</li></ol></li><li>特点：<ol type="1"><li>用户线程的维护由应用进程完成</li><li>内核不了解用户线程的存在</li><li>用户线程切换不需要内核特权</li><li>用户线程调度算法可针对应用优化</li><li>一个线程发起系统调用而阻塞，则整个进程在等待（多对一模型中）</li></ol></li><li>三个主要的线程库(创建用户级线程)<ol type="1"><li>POSIX Pthreads 、 Win32 threads、 Java threads</li></ol></li></ol><h3 id="kernel-threads-内核级线程">4.3.2 Kernel Threads 内核级线程</h3><ol type="1"><li>内核级线程：<ol type="1"><li>依赖于OS内核，由内核的内部需求进行创建和撤销，用来执行一个指定的函数</li><li>一个线程发起系统调用而阻塞，不会影响其他线程</li><li>时间片分配给线程，所以多线程的进程获得更多CPU时间</li></ol></li><li>特点：<ol type="1"><li>内核维护进程和线程的上下文信息</li><li><strong>线程切换由内核完成</strong></li><li>时间片分配给线程，所以多线程的进程获得更多CPU时间<ol type="1"><li>如1个进程拥有10个线程，4个进程各自拥有1个线程，则CPU会对这14个线程进行分配资源</li></ol></li><li>一个线程发起系统调用而阻塞，不会影响其他线程的运行</li></ol></li><li>Examples<ol type="1"><li>Windows XP/2000 及以后</li><li>Solaris</li><li>Linux</li><li>Mac OS X</li></ol></li></ol><h3 id="many-to-one-多个用户线程-一个内核线程">4.3.3 Many-to-One多个用户线程, 一个内核线程</h3><p>多个用户级线程 映射到 单个内核线程</p><ol type="1"><li><p>由用户级运行库实现</p><ol type="1"><li>在用户级别创建、调度和同步线程</li></ol></li><li><p>操作系统不知道用户级线程</p><ol type="1"><li>操作系统认为<strong>每个进程</strong>只包含<strong>一个控制线程</strong></li></ol></li><li><p>示例：</p><ol type="1"><li>Solaris Green Threads</li><li>GNU Portable Threads</li></ol></li><li><p>优点：</p><ol type="1"><li>不需要操作系统支持，全部在用户态模式进行</li><li>可以由用户自己设定调整调度策略，以满足应用程序需求</li><li>由于没有系统调用，因此降低了线程操作的开销</li></ol></li><li><p>缺点：</p><ol type="1"><li>无法利用多处理器，不是没有真正并行，而是在多个用户级线程之间进行轮转</li><li>当一个线程阻塞时，整个进程块也会阻塞</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013174811066.png" alt="image-20221013174811066" style="zoom:50%;" /></p><h3 id="one-to-one-一个用户线程-一个内核线程">4.3.4 One-to-One一个用户线程, 一个内核线程</h3><p>每个用户级线程 都映射到 内核线程</p><ol type="1"><li>操作系统为每个用户级线程提供一个内核线程</li><li>每个内核线程独立调度</li><li>操作系统执行的线程操作（创建、调度、同步）</li><li>示例<ol type="1"><li>Windows NT/XP/2000操作系统</li><li>Linux操作系统</li><li>Solaris 9及更高版本</li></ol></li><li>优点：<ol type="1"><li>每个内核线程在多处理器中，均可平行执行</li><li>当一个线程阻塞时，其它线程还能被正常调度</li></ol></li><li>缺点：<ol type="1"><li>线程间的操作消耗过大</li><li>操作系统会随着线程数目的增加而变大</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017143430515.png" alt="image-20221017143430515" style="zoom: 50%;" /></p><h3 id="many-to-many-多个用户线程-多个内核线程">4.3.5 Many-to-Many多个用户线程, 多个内核线程</h3><p>将多个用户级线程 映射到 多个内核线程</p><ol type="1"><li>允许操作系统创建足够数量的内核线程</li><li>示例：<ol type="1"><li>Solaris版本9之前的版本</li><li>带有ThreadFiber软件包的Windows NT/2000</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017143735468.png" alt="image-20221017143735468" style="zoom:50%;" /></p><h3 id="two-level-model-两级模型">4.3.6 Two-level Model 两级模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017143852109.png" alt="image-20221017143852109" style="zoom:80%;" /></p><ol type="1"><li><strong>Solaris</strong>的多线程是与传统UNIX调度模型相区别的主要特征</li><li><strong>LWP</strong>：每个进程内的内核线程的虚拟执行环境<ol type="1"><li><strong>LWP</strong>允许进程内的内核线程互相独立地进行系统调用</li><li>如果没有<strong>LWP</strong>，一次就只能进行一次系统调用</li><li>每次的系统调用由一个线程来引发，它的寄存器会被放在<strong>LWP</strong>的堆栈里面，等它返回的时候，系统调用返回代码也会被放在<strong>LWP</strong>里面</li></ol></li><li><strong>M-N</strong>的<strong>优点</strong>：<ol type="1"><li>快速的用户线程创建和删除</li><li>线程同步不需要系统调用</li><li>快速的用户线程上下文切换</li></ol></li><li><strong>M-N</strong>的<strong>缺点</strong>：<ol type="1"><li>复杂的编程模型</li><li>信号处理的问题</li></ol></li><li><strong>1-1</strong>模型的<strong>优点</strong>：<ol type="1"><li>每个用户级线程都有一个lwp和一个 kthread 相对应</li><li>只有内核级的线程调度</li><li>线程创建和删除、线程同步的开销大</li><li>线程调度和同步更到位</li></ol></li></ol><h3 id="solaris用户线程内核线程lwp三者之间的关系">4.3.7Solaris用户线程、内核线程、LWP三者之间的关系</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017144240018.png" alt="image-20221017144240018" style="zoom:80%;" /></p><ol type="1"><li>对于一个用户进程来说，它的每个线程分成两个部分，一个部分是用户态下的部分，一个是系统态下的部分，也就是用户线程和内核线程</li><li>一个线程在用户态下执行的时候，运行的是用户线程的代码，而当发生系统调用的时候，就由内核线程来执行内核代码</li><li>在<strong>Solaris</strong>的线程模型中，<strong>每一个用户线程对应一个内核线程</strong>，这种对应通过<strong>lwp</strong>来体现。</li><li>所用的内核线程串成一个双向循环链表，可以通过进程的<strong>proc</strong>结构中的<strong>p_tlist</strong>字段找到这个链表</li><li>每一个<strong>lwp</strong>用<strong>_klwp</strong>数据结构表示，每个内核线程用一个<strong>_kthread</strong>结构表示，<strong>_kthread</strong>结构中有一个字段<strong>t_lwp</strong>指向它所对应的**_klwp**结构。</li><li>用户线程用<strong>ulwp</strong>表示，<strong>ulwp</strong>与**_kthread<strong>的对应不是用指针来表示的，而是通过</strong>线程id**<ol type="1"><li><strong>ulwp</strong>，**_kthread<strong>和</strong>_klwp<strong>中都有一个字段表示</strong>线程的id<strong>，通过</strong>id**它们就可以一一对应起来</li></ol></li></ol><h2 id="thread-libraries-线程库">4.4 Thread Libraries 线程库</h2><ol type="1"><li>线程库为程序员提供了创建和管理线程的API</li><li>实施的两种主要方式<ol type="1"><li><strong>没有内核支持的库</strong>：代码和数据结构都在用户空间，只导致用户空间中本地函数调用（而不是系统调用）</li><li><strong>由操作系统直接支持的内核级库</strong>：代码和数据结构都在内核空间，通常导致系统调用</li></ol></li></ol><h3 id="pthread">4.4.1 Pthread</h3><ol type="1"><li><p>可以作为用户级或内核级提供</p></li><li><p>用于线程创建和同步的<strong>POSIX</strong>(Portable OperatingSystem Interface，便携式操作系统接口)标准（IEEE 1003.1c）API</p><p>http://standards.ieee.org/reading/ieee/stad_public/description/posix</p></li><li><p>API指定线程库的行为，实现取决于库的开发</p></li><li><p>在UNIX操作系统（Solaris、Linux、Mac OS X）中常见</p></li></ol><h3 id="java-threads">4.4.2 Java Threads</h3><ol type="1"><li><strong>Java</strong>线程由<strong>JVM</strong>管理</li><li>通常使用底层OS提供的线程模型实现</li><li><strong>Java线程</strong>可以通过以下方式创建：<ol type="1"><li><strong>extend</strong> 线程类</li><li>实现<strong>Runnable</strong>接口</li></ol></li></ol><h2 id="implicit-threading-隐私多线程">4.5 Implicit Threading隐私多线程</h2><ol type="1"><li>多核系统多线程编程，一个应用程序有可能有几百个甚至上千的线程，这样的程序面临许多挑战<ol type="1"><li>编程挑战：任务分解、任务的工作量平衡、数据分割、数据依赖、测试与调试</li><li>程序执行顺序的正确性问题：同步、互斥</li></ol></li><li><strong>策略</strong>：隐私线程<strong>ImplicitThreading</strong>，当前一种流行趋势<ol type="1"><li>将线程的创建与管理交给编译器和运行时库来完成</li></ol></li><li>几种隐私线程的设计方法：<ol type="1"><li><strong>Thread Pools</strong>：线程池</li><li><strong>Fork Join</strong></li><li><strong>OpenMP</strong>：用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案<ol type="1"><li>OpenMP支持的编程语言包括C、C++和Fortran。</li></ol></li><li><strong>Grand Central Dispatch</strong>(GCD，大中央调度)<ol type="1"><li>Apple for its macOS and iOS operating systems.</li></ol></li><li><strong>Intel Thread Building Blocks</strong>(TBB)：<ol type="1"><li>Intel开发的构建多线程库，open source</li><li>TBB是一个可移植的C++库，能够运行在Windows、Linux、Macintosh以及UNIX等系统上</li></ol></li><li>Java</li></ol></li></ol><h3 id="thread-pool-线程池">4.5.1 Thread Pool 线程池</h3><ol type="1"><li>预先创建出一系列线程，然后分配</li><li>线程池中如果没有空余线程，则需要等待</li></ol><h3 id="fork-join-parallelism">4.5.2 Fork-Join Parallelism</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017145526083.png" alt="image-20221017145526083" style="zoom:80%;" /></p><ol type="1"><li><p>主线程将任务分为多个子任务<strong>fork</strong>，然后再合并到主线程<strong>join</strong></p></li><li><p>伪代码</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017145725008.png" alt="image-20221017145725008" style="zoom:67%;" /></p></li><li><p>这一过程可以递归的进行</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017145747384.png" alt="image-20221017145747384" style="zoom: 67%;" /></p></li><li><p>示例：</p><blockquote><ol type="1"><li>The <strong>ForkJoinTask</strong> is an abstract base class</li><li><strong>RecursiveTask</strong> and <strong>RecursiveAction</strong>classes extend <strong>ForkJoinTask</strong></li><li><strong>RecursiveTask</strong> returns a result (via the returnvalue from the <strong>compute()</strong> method)</li><li><strong>RecursiveAction</strong> does not return a result</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017150037418.png" alt="image-20221017150037418" style="zoom: 67%;" /></p></blockquote><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017145914802.png" alt="image-20221017145914802" style="zoom: 40%;" /></th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017145918468.png" alt="image-20221017145918468" style="zoom: 80%;" /></td></tr></tbody></table></li></ol><h3 id="openmp">4.5.3 OpenMP</h3><ol type="1"><li><p>编译器指令集和C、C++、FORTRAN的API</p></li><li><p>为共享内存环境中的并行编程提供支持</p></li><li><p>标识并行区域–可以并行运行的代码块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/* 串行代码 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">//创建尽可能多的线程</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am a parallel region.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 串行代码 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="grand-central-dispatch">4.5.4 Grand Central Dispatch</h3><ol type="1"><li><p>用于macOS和iOS操作系统的Apple技术</p></li><li><p>C、C++和Objective-C语言、API和运行时库的扩展</p></li><li><p>允许识别平行部分</p></li><li><p>管理线程的大部分细节</p></li><li><p>块位于“^{}”：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">^&#123;<span class="built_in">printf</span>(<span class="string">&quot;I am a block&quot;</span>);&#125;</span><br></pre></td></tr></table></figure></li><li><p>Block放置在调度队列中</p><ol type="1"><li>从队列中移除时，分配给线程池中的可用线程</li></ol></li><li><p>两种类型的调度队列：</p><ol type="1"><li>串行：按<strong>FIFO</strong>的顺序删除块，队列按进程，称为主队列<ol type="1"><li>程序员可以在程序中创建额外的串行队列</li></ol></li><li>并行：按<strong>FIFO</strong>的顺序删除块，但一次可以删除多个</li><li>按服务质量划分的四个全系统队列：<ol type="1"><li>QOS_CLASS_USER_INTERACTIVE</li><li>QOS_CLASS_USER_INITIATED</li><li>QOS_CLASS_USER_UTILITY</li><li>QOS_CLASS_USER_BACKGROUND</li></ol></li></ol></li><li><p>对于Swift语言，任务定义为闭包，类似于块，减去插入符号</p><ol type="1"><li>使用dispatch_async()函数将闭包提交到队列</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> dispatch.get.global.queue(<span class="type">QOS</span>.<span class="type">CLASS</span>.<span class="type">USER</span><span class="operator">/</span><span class="type">INITIATED</span>, <span class="number">0</span>)</span><br><span class="line">dispatch.async(queue, &#123;<span class="built_in">print</span>(<span class="string">&quot;I am a closure.&quot;</span>)&#125; )</span><br></pre></td></tr></table></figure></li></ol><h3 id="intel-threading-building-blocks-tbb">4.5.5 Intel ThreadingBuilding Blocks (TBB)</h3><ol type="1"><li><p>用于设计并行C++程序的模板库</p></li><li><p>简单for循环的串行版本</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">apply</span>(v[i]);</span><br></pre></td></tr></table></figure></li><li><p>使用TBB的<strong>parallel_for</strong>语句编写的for循环：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), n, [=](<span class="type">size_t</span> i)&#123; <span class="built_in">apply</span>(v[i]); &#125; );</span><br></pre></td></tr></table></figure></li></ol><h2 id="threading-issues">4.6 Threading Issues</h2><ol type="1"><li>fork()和exec()系统调用的语义</li><li>目标线程的线程删除<ol type="1"><li>异步或延迟</li></ol></li><li>信号处理</li><li>线程池<ol type="1"><li>线程特定数据</li></ol></li><li>调度器激活</li></ol><h3 id="fork和exec的语义">4.6.1 fork()和exec()的语义</h3><ol type="1"><li>fork()：有的Unix系统有两种形式的fork()，与应用程序有关<ol type="1"><li>复制所有线程：如果调用fork()后不调用exec()，复制所有线程</li><li>只复制调用fork()的线程：如果调用fork()后立即调用exec()，操作系统只需复制调用fork()的线程</li></ol></li><li>exec()：如果一个线程调用exec()，exec()参数指定的程序会替换整个进程（包括所有线程）</li></ol><h3 id="thread的删除">4.6.2 Thread的删除</h3><ol type="1"><li><strong>线程取消</strong>(threadcancellation)：在线程完成之前终止线程的任务，要取消的线程称为<strong>目标线程</strong></li><li>线程取消的两种情况：<ol type="1"><li><strong>异步取消</strong>(asynchronouscancellation)：由一个线程<strong>立即终止</strong>目标线程。<ol type="1"><li>对于异步取消，因为如果在已经给目标线程分配资源或目标线程正在更新与其他线程共享的数据的情况下，操作系统从回收系统资源时不能将所有资源全部回收。</li></ol></li><li><strong>延迟取消</strong>(deferredcancellation)：目标线程<strong>周期性</strong>地检查其是否应该终止，允许目标线程以有序方式终止自己</li></ol></li></ol><h3 id="signal-handling-信号处理">4.6.3 Signal Handling 信号处理</h3><ol type="1"><li>UNIX系统中使用信号通知进程发生了特定事件</li><li>信号处理器用于处理信号<ol type="1"><li>信号由特定事件生成</li><li>信号被传递到进程</li><li>信号已处理</li></ol></li><li>Options：<ol type="1"><li>将信号传递给信号适用的线程</li><li>将信号传递给进程中的每个线程</li><li>将信号传递给进程中的某些线程</li><li>分配特定线程以接收进程的所有信号</li></ol></li><li>信号可分为同步和异步：<ol type="1"><li><strong>同步信号</strong>：被发送到产生信号的同一进程<ol type="1"><li>E.g. 非法访问内存、被0所除</li></ol></li><li><strong>异步信号</strong>：由运行进程之外的事件产生，通常被发送到另一进程<ol type="1"><li>E.g. 使用特殊键、定时器到期</li></ol></li></ol></li></ol><h3 id="thread-pool-线程池-1">4.6.4 Thread Pool 线程池</h3><ol type="1"><li>多线程服务器的潜在问题：<ol type="1"><li>处理请求前创建线程需要时间，线程完成工作后要被丢弃；</li><li>如果允许所有并发请求都用新线程处理，则无法限制系统中并发执行的线程数量，大量消耗系统资源</li></ol></li><li>在等待工作的池中创建多个线程</li><li>优点：<ol type="1"><li>使用现有线程服务请求通常比创建新线程稍快</li><li>允许将应用程序中的线程数绑定到池的大小</li></ol></li></ol><h3 id="thread-specific-data-线程特有数据">4.6.5 Thread Specific Data线程特有数据</h3><ol type="1"><li>允许每个线程拥有自己的数据副本</li><li>当您无法控制线程创建过程时(即使用线程池时)，此功能非常有用</li></ol><h3 id="scheduler-activations-调度器激活">4.6.5 Scheduler Activations调度器激活</h3><ol type="1"><li>M:N和两级模型都需要通信来维护分配给应用程序的适当数量的内核线程<ol type="1"><li>轻量级进程(Lightweight process,<strong>LWP</strong>)：实现多对多模型或二级模型的系统在用户线程和内核线程之间通常设置一种中间数据结构，通常为LWP。</li><li>对于用户线程库，LWP表现为一种应用程序可以调度用户线程来运行的虚拟处理器。每个LWP与内核线程相连，该内核线程被操作系统调度到物理处理器上运行。如果物理处理器上运行的内核线程阻塞，则与其相连的LWP也阻塞，关系链顶端与LWP相连的用户线程也阻塞</li></ol></li><li>调度程序激活提供了向上调用：一种从内核到线程库的通信机制<ol type="1"><li>upcall：内核通知应用程序与其有关的特定事件的过程；</li><li>upcallhandler：upcall处理句柄，在虚拟处理器(<strong>LWP</strong>)上运行。</li></ol></li><li>此通信允许应用程序维护正确数量的内核线程</li></ol><p>调度器激活（scheduleractivation）：一种解决用户线程与内核间通信的方法。</p><ol type="1"><li>工作方式：内核提供一组LWP给应用程序，应用程序可调度用户线程到一个可用的LWP上。</li><li>当一个应用线程将要阻塞时，事件引发内核发送<strong>upcall</strong>到应用程序，通知应用程序线程阻塞并标识特殊线程</li><li>内核分配一个新的LWP给应用程序</li><li>应用程序在该新LWP上运行<strong>upcall handler</strong>：<ol type="1"><li>保存该阻塞线程的状态</li><li>放弃阻塞线程运行的原虚拟处理器</li></ol></li><li><strong>upcallhandler</strong>调度另一个适合在新LWP上运行的线程</li><li>当原先阻塞的线程准备好执行时，内核发送另一个<strong>upcall</strong>到线程库，通知线程库原先阻塞的线程已经能够运行了<ol type="1"><li>内核可能分配一个新的LWP</li><li>或抢占一个用户线程并在其LWP用于运行处理该事件的upcall handler</li></ol></li><li>应用程序将已处于未堵塞状态的线程标记为“能够运行”，调度一条合适的线程到可用LWP上运行</li></ol><h2 id="operating-system-examples">4.7 Operating-System Examples</h2><h3 id="windows-xp-thread">4.7.1 Windows XP Thread</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017153825431.png" alt="image-20221017153825431" style="zoom:80%;" /></p><ol type="1"><li>应用程序以独立进程方式运行，每个进程可包括一个或多个线程</li><li>使用<strong>一对一映射</strong>，也提供对fiber库的支持（多对多模型）</li><li>每个线程包含<ol type="1"><li>线程id</li><li>寄存器集</li><li>独立的用户堆栈和内核堆栈</li><li>专用数据存储区</li></ol></li><li>寄存器集、堆栈和专用存储区域称为线程的上下文</li><li>同属一个进程的每个线程都能访问进程的地址空间</li><li>线程的主要数据结构包括：<ol type="1"><li><strong>ETHREAD</strong>(executive threadblock)：执行线程块，包括指向线程所属进程的指针、线程开始控制的子程序的地址、指向KTHREAD的指针</li><li><strong>KTHREAD</strong>(kernel threadblock)：内核线程块，包括线程的调度和同步信息、指向内核栈的指针、指向TEB的指针</li><li><strong>TEB</strong>(thread environmentblock)：用户空间的数据结构，供线程在用户模式下运行时访问，包含许多其他域、用户模式栈、用于线程特定数据的数组</li></ol></li></ol><h3 id="linux-threads">4.7.2 Linux Threads</h3><ol type="1"><li><p>Linux不区分进程和线程，通常称之为任务（task）</p><ol type="1"><li><strong>Task_struct</strong>：Linux系统中每个任务都有一个唯一的内核数据结构structtask_struct，它并不保存任务本身的数据，而是指向其他存储这些数据的数据结构（e.g.打开文件列表、信号处理信息、虚拟内存等）的指针</li></ol></li><li><p>系统调用fork()提供传统进程复制功能，系统调用clone()提供创建线程功能。</p><ol type="1"><li><p>调用fork()时，所创建的新任务具有父进程所有数据的副本</p></li><li><p>调用clone()时，所创建新任务根据所传递标志集指向父任务的数据结构。</p></li><li><p>调用clone()时传递一组标志，决定父任务与子任务之间发生多少共享</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221017154347587.png" alt="image-20221017154347587" style="zoom:80%;" /></p></li></ol></li></ol><h1 id="chapte-5cpu-scheduling">Chapte 5：CPU Scheduling</h1><h2 id="基础概念-basic-concepts">5.1 基础概念 Basic Concepts</h2><h3 id="cpu调度">5.1.1 CPU调度</h3><ol type="1"><li><p>CPU调度 == 处理器调度 == 进程调度</p></li><li><p>最大化CPU的利用率</p></li><li><p>进程执行的特点：CPU Burst 和 I/O Burst交替进行</p><ol type="1"><li>CPU Burst Time，I/O Burst Time</li><li>CPU-bound program：以CPU计算为主的程序</li><li>I/O-bound program：以I/O为主的程序</li><li>只考虑进程的CPU Burst Time</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020162923271.png" alt="image-20221020162923271" style="zoom: 30%;" /></p></li><li><p>进程的CPU Burst Time的统计规律</p><ol type="1"><li>短时间的CPU Burst Time占据绝大部分</li><li>因此CPU调度是高频调度</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020163157981.png" alt="image-20221020163157981" style="zoom: 50%;" /></p></li></ol><h3 id="cpu调度器-scheduler">5.1.2 CPU调度器 Scheduler</h3><ol type="1"><li>调度器起作用的时机：<ol type="1"><li>进程从running到waiting状态</li><li>进程从running到ready状态</li><li>进程从waiting到ready状态</li><li>进程终止</li></ol></li><li>调度方式：<ol type="1"><li><strong>Nonpreemptive</strong>非抢占式调度：<ol type="1"><li>调度程序一旦把处理器分配给某进程后，它便会一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理器分配给另一个进程</li><li>调度时机：上述1、4</li></ol></li><li><strong>Preemptive</strong>抢占式调度：<ol type="1"><li>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程</li><li>剥夺原则有：优先权原则、短进程优先原则、时间片原则</li><li>调度时机：上述2、3</li></ol></li></ol></li></ol><h3 id="调度程序-dispatcher">5.1.3 调度程序 Dispatcher</h3><ol type="1"><li>实际执行调度的模块，任务如下：<ol type="1"><li>切换上下文</li><li>切换到user mode</li><li>跳转到user program中正确的位置，并且重新启动program</li></ol></li><li><strong>DispatcherLatency</strong>调度延迟：调度程序停止一个进程到启动一个进程所需要的时间</li></ol><h2 id="调度标准-scheduling-criteria">5.2 调度标准 SchedulingCriteria</h2><h3 id="调度算法的选择准则和评价">5.2.1 调度算法的选择准则和评价</h3><ol type="1"><li>面向用户(User-oriented)的准则和评价<ol type="1"><li>周转时间<strong>Turnaroundtime</strong>：进程从<strong>提交</strong>到<strong>完成</strong>所经历的时间。包括：在CPU上执行，就绪列和阻塞队列中等待。<ol type="1"><li>周转时间 <strong>T</strong> = 完成时间 - 提交时间</li><li>平均周转时间 = <span class="math inline">\(\sum\)</span>周转时间/进程数</li><li>带权周转时间<strong>W</strong> =<strong>T</strong>(周转时间)/<strong>t</strong>(CPU执行时间)</li><li>平均带权周转时间 = <span class="math inline">\(\sum\)</span><strong>W</strong>/进程数</li></ol></li><li>响应时间<strong>Responsetime</strong>：从进程<strong>提出请求</strong>到<strong>首次被响应</strong>的时间段<ol type="1"><li>第一次被调度到，而不是输出结果</li><li>在分时系统环境下</li></ol></li><li>等待时间<strong>Waitingtime</strong>：进程在<strong>就绪队列</strong>中<strong>等待</strong>的时间总和</li><li>截止时间：开始截止时间和完成截止时间<ol type="1"><li>实时系统，与周转时间有些相似</li><li>开始截止时间：在某个时间点之前必须开始</li><li>完成截止时间：在某个时间点之前必须完成</li></ol></li><li>公平性：不因作业或进程本身的特性而使上述指标过分恶化<ol type="1"><li>如长进程等待很长时间</li><li>不同进程之间的上述指标不能差异过大</li></ol></li><li>优先级：可以使关键任务达到更好的指标</li></ol></li><li>面向系统的调度性能准则<ol type="1"><li>吞吐量<strong>Throughput</strong>：单位时间内所完成的进程数<ol type="1"><li>跟进程本身特性和调度算法都有关系</li><li>批处理系统</li><li>平均周转时间不是吞吐量的倒数，因为并发执行的进程在时间上可以重叠</li><li>如：在2小时内完成4个进程，而每个周转时间是1小时，则吞吐量是2个进程/小时</li></ol></li><li>处理器利用率<strong>CPU utilization</strong>：使CPU尽可能的忙碌</li><li>各种设备的均衡利用：<ol type="1"><li>如CPU繁忙的进程和I/O繁忙的进程搭配</li><li>大中型主机</li></ol></li></ol></li><li>调度算法本身的调度性能准则</li><li>易于实现</li><li>执行开销比较小</li></ol><h3 id="最优准则-optimization-criteria">5.2.4 最优准则 OptimizationCriteria</h3><ol type="1"><li>最大的CPU利用率 Max CPU utilization　</li><li>最大的吞吐量 Max throughput</li><li>最短的周转时间 Min turnaround time</li><li>最短的等待时间 Min waiting time</li><li>最短的响应时间 Min response time</li><li>公平</li></ol><h2 id="调度算法-scheduling-algorithms-计算">5.3 调度算法 SchedulingAlgorithms (<strong>计算</strong>)</h2><table><thead><tr><th style="text-align: center;">算法名</th><th style="text-align: center;">注释</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>First-Come, First-Served(FCFS)</strong> Scheduling</td><td style="text-align: center;">先来先服务调度</td></tr><tr><td style="text-align: center;"><strong>Shortest-Job-First(SJF)</strong> Scheduling</td><td style="text-align: center;">短作业优先调度</td></tr><tr><td style="text-align: center;"><strong>Priority</strong>Scheduling</td><td style="text-align: center;">优先权调度</td></tr><tr><td style="text-align: center;"><strong>Round Robin</strong> (RR)</td><td style="text-align: center;">时间片轮转调度</td></tr><tr><td style="text-align: center;"><strong>Multilevel Queue</strong>Scheduling</td><td style="text-align: center;">多级队列调度</td></tr><tr><td style="text-align: center;"><strong>Multilevel Feedback</strong>Queue Scheduling</td><td style="text-align: center;">多级反馈队列调度</td></tr></tbody></table><ol type="1"><li>高响应比优先调度算法：<strong>Highest Response RatioNext(HRRN)</strong><ol type="1"><li>响应比<strong>R</strong> = (等待时间 + 要求执行时间) /要求执行时间</li></ol></li></ol><h3 id="先来先服务调度-fcfs">5.3.1 先来先服务调度 FCFS</h3><h4 id="算法内容">5.3.1.1 算法内容</h4><ol type="1"><li><p><strong>FCFS</strong>算法：First-Come, First-ServedScheduling</p><ol type="1"><li>按照<strong>进程或作业提交顺序</strong>形成就绪状态的先后次序，分派CPU</li><li>当前进程或作业占用CPU，直到执行完或阻塞，才出让CPU(<strong>非抢占方式</strong>)</li><li>在进程或作业唤醒后(如I/O完成)，并不立即恢复执行，通常等到当前作业或进程出让CPU</li><li>最简单的算法</li></ol></li><li><p>FCFS的特点</p><ol type="1"><li>比较有利于长进程，而不利于短进程</li><li>有利于CPU Bound的进程，而不利于I/O Bound的进程</li></ol></li></ol><h4 id="示例">5.3.1.2 示例</h4><table><thead><tr><th style="text-align: center;">Process</th><th style="text-align: center;">Burst Time</th></tr></thead><tbody><tr><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">24</td></tr><tr><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">3</td></tr></tbody></table><ol type="1"><li><p><strong>GanttChart</strong>：根据进程的顺序排列，下标画时间点</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020171350881.png" alt="image-20221020171350881" style="zoom: 67%;" /></p></li><li><p><strong>Turnaround Time</strong>：终止时间 - 到达时间</p><ol type="1"><li>P<sub>1</sub> = 24，P<sub>2</sub> = 27，P<sub>3</sub> = 30</li><li>Average Turnaround Time = (24 + 27 + 30) / 3 = 27</li></ol></li><li><p><strong>Waiting Time</strong>：Turnaround Time -实际运行的时间</p><ol type="1"><li>P<sub>1</sub> = 24 - 24 = 0，P<sub>2</sub> = 27 - 3 =24，P<sub>3</sub> = 30 - 3 = 27</li><li>Average Waiting Time = (0 + 24 + 27) / 3 = 17</li></ol></li></ol><h3 id="短作业优先调度-sjf">5.3.2 短作业优先调度 SJF</h3><h4 id="算法内容-1">5.3.2.1 算法内容</h4><ol type="1"><li><p><strong>SJF</strong>算法：Shortest-Job-First (SJF) Scheduling</p><ol type="1"><li>对<strong>预计执行时间</strong>短的作业（进程）优先分派处理器</li><li>又称为“短进程优先”<strong>SPF(Shortest ProcessFirst)</strong>，这是对FCFS算法的改进，其目标是减少平均周转时间</li></ol></li><li><p>两种模式</p><ol type="1"><li>非抢占<strong>nonpreemptive</strong>：一旦CPU被赋予进程，它就不能被抢占，直到完成其CPUBurst</li><li>抢占<strong>preemptive</strong>：如果新进程到达时CPUBurst长度小于当前执行进程的剩余时间，则抢占<ol type="1"><li>该方案被称为最短剩余时间优先（SRTF，Shortest-Remaining-Time-First）</li></ol></li></ol></li><li><p>优点：平均等待时间最小</p></li></ol><h4 id="最短剩余时间优先-srtf">5.3.2.2 最短剩余时间优先 SRTF</h4><ol type="1"><li><p>最短剩余时间优先<strong>SRTF</strong>(Shortest Remaining TimeFirst)：基于抢占的<strong>SJF</strong>算法</p></li><li><p>允许比当前进程剩余时间更短的进程来抢占</p></li></ol><h4 id="最高响应比优先-hrrn">5.3.2.3 最高响应比优先 HRRN</h4><ol type="1"><li>最高响应比优先<strong>HRRN</strong>(Highest Response RatioNext)</li><li>响应比R = (等待时间 + 要求执行时间) / 要求执行时间</li><li>是<strong>FCFS</strong>和<strong>SJF</strong>的折中</li></ol><h4 id="示例-1">5.3.2.4 示例</h4><table><thead><tr><th style="text-align: center;">Process</th><th style="text-align: center;">Arrival Time</th><th style="text-align: center;">Burst Time</th></tr></thead><tbody><tr><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">0</td><td style="text-align: center;">7</td></tr><tr><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">2</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">4</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">P<sub>4</sub></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td></tr></tbody></table><ol type="1"><li><strong>SJF (non-preemptive)</strong>：<ol type="1"><li><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020173141442.png" alt="image-20221020173141442" style="zoom:80%;" /><ol type="1"><li>第0时刻只有P<sub>1</sub>到来，因此先执行P<sub>1</sub></li><li>P<sub>1</sub>结束后为第7时刻，此时的进程有P<sub>2</sub>,P<sub>3</sub>, P<sub>4</sub>，P<sub>3</sub>的BurstTime最短，因此执行P<sub>3</sub></li></ol></li><li><strong>Turnaround Time</strong><ol type="1"><li>P<sub>1</sub> = 7 - 0 = 7，P<sub>2</sub> = 12 - 2 =10，P<sub>3</sub> = 8 - 4 = 4，P<sub>4</sub> = 16 - 5 = 11</li><li>Average Turnaround Time = (7 + 10 + 4 + 11) / 4 = 8</li></ol></li><li><strong>Waiting Time</strong><ol type="1"><li>P<sub>1</sub> = 0 - 0 = 0，P<sub>2</sub> = 8 - 2 = 6，P<sub>3</sub>= 7 - 4 = 3，P<sub>4</sub> = 12 - 5 = 7</li><li>Average Waiting Time = (0 + 6 + 3 + 7) / 4 = 4</li></ol></li></ol></li><li><strong>SJF (preemptive)</strong>：<ol type="1"><li><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020173744162.png" alt="image-20221020173744162" style="zoom:67%;" /><ol type="1"><li>第2时刻，P<sub>2</sub>到来，其时间比P<sub>1</sub>剩余时间短，因此打断P<sub>1</sub>，执行P<sub>2</sub></li><li>第4时刻，P<sub>3</sub>到来，其时间比P<sub>2</sub>剩余时间短，因此打断P<sub>2</sub>，执行P<sub>3</sub></li><li>第5时刻，P<sub>3</sub>结束，此时等待队列如下，因此执行P<sub>2</sub><ol type="1"><li>P<sub>1</sub>：5s</li><li>P<sub>2</sub>：2s</li></ol></li><li>第7时刻，P<sub>2</sub>结束，P<sub>4</sub>到来，此时等待队列如下，因此执行P<sub>4</sub><ol type="1"><li>P<sub>1</sub>：5s</li><li>P<sub>4</sub>：4s</li></ol></li><li>第11时刻，P<sub>4</sub>结束，执行P<sub>1</sub></li></ol></li><li><strong>Turnaround Time</strong><ol type="1"><li>P<sub>1</sub> = 16 - 0 = 16，P<sub>2</sub> = 7 - 2 =5，P<sub>3</sub> = 5 - 4 = 1，P<sub>4</sub> = 11 - 5 = 6</li><li>Average Turnaround Time = (16 + 5 + 1 + 6) / 4 = 7</li></ol></li><li><strong>Waiting Time</strong><ol type="1"><li>P<sub>1</sub> = (0 - 0) + (11 - 2) = 9，P<sub>2</sub> = (2 - 2) + (5- 4) = 1，P<sub>3</sub> = 4 - 4 = 0，P<sub>4</sub> = 7 - 5 = 2</li><li>Average Waiting Time = (9 + 1 + 0 + 2) / 4 = 4</li></ol></li></ol></li></ol><h4 id="预测cpu-burst-time指数平均法">5.3.3.5 预测CPU BurstTime：指数平均法</h4><ol type="1"><li><p>只能估计长度</p></li><li><p>可以通过使用以前CPU突发的长度，使用指数平均来完成</p><ol type="1"><li><span class="math inline">\(t_n\)</span> = 第n次CPUburst的真实值</li><li><span class="math inline">\(\tau_n\)</span> = 第n次CPUburst的预测值</li><li><span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(0 \le \alpha \le 1\)</span></li><li>定义：<span class="math inline">\(\tau_{n+1}=\alphat_n+(1-\alpha)\tau_n\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020174921849.png" alt="image-20221020174921849" style="zoom:67%;" /></p></li><li><p>几种<span class="math inline">\(\alpha\)</span>的取值</p><ol type="1"><li><span class="math inline">\(\alpha=0\)</span>：<spanclass="math inline">\(\tau_{n+1} = \tau_{n}\)</span>，只考虑预测值</li><li><span class="math inline">\(\alpha=1\)</span>：<spanclass="math inline">\(\tau_{n+1} = t_{n}\)</span>，只考虑实际值</li></ol></li><li><p>展开<span class="math inline">\(\tau_{n+1}\)</span> <spanclass="math display">\[\begin{aligned}\tau_{n+1}=    &amp;\ \ \ \ \ \ \alpha t_n \\           &amp;+ (1-\alpha)\ t_{n-1} \\           &amp;+ \ ...\\           &amp;+(1-\alpha)^i\ \alpha t_{n-i} \\           &amp;+ \ ...\\           &amp;+(1-\alpha)^{n+1} \tau_{0}\end{aligned}\]</span></p></li></ol><h3 id="优先级调度-priority-scheduling">5.3.3 优先级调度 PriorityScheduling</h3><h4 id="算法内容-2">5.3.3.1 算法内容</h4><ol type="1"><li>该算法总是把处理机分配给就绪队列中具有<strong>最高优先权</strong>的进程<ol type="1"><li><strong>SJF</strong>是以下一次CPU脉冲长度作为优先数的优先级调度</li></ol></li><li>常用以下两种方法来确定进程的优先权：<ol type="1"><li><strong>静态优先权</strong>：静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型、进程对资源的要求、用户要求的优先权。</li><li><strong>动态优先权</strong>：动态优先权是基于某种原则，使进程的优先权随时间改变而改变。</li></ol></li><li>假定：最小的整数 &lt;=&gt; 最高的优先级.</li><li>两种模式<ol type="1"><li>非抢占式<strong>Non-preemptive priorityscheduling</strong>：将优先级较高的进程置于队列的前端<ol type="1"><li>默认所有进程一起到来</li></ol></li><li>抢占式<strong>Preemptive priorityscheduling</strong>：在较高优先级进程到达时中断并抢占正在运行的进程<ol type="1"><li>默认所有进程的到达时间有前后区别</li></ol></li></ol></li><li>问题：饥饿<strong>Starvation</strong>，低优先级的进程永远不会被执行</li><li>解决方法：老化<strong>Aging</strong>，随着进程运行时间的增长，其优先级会降低</li></ol><h4 id="示例-2">5.3.3.2 示例</h4><blockquote><p><strong>非抢占式</strong>：non-preemptive</p></blockquote><table><thead><tr><th style="text-align: center;">Process</th><th style="text-align: center;">Burst Time</th><th style="text-align: center;">Priority</th></tr></thead><tbody><tr><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">10</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">2</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">P<sub>4</sub></td><td style="text-align: center;">1</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">P<sub>5</sub></td><td style="text-align: center;">5</td><td style="text-align: center;">2</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221024144014656.png" alt="image-20221024144014656" style="zoom:80%;" /></p><ol type="1"><li>平均Turnaround time：(16+1+18+19+6) / 5 = 12</li><li>平均waiting time：(6+0+16+18+1) / 5 = 8.2</li></ol><blockquote><p><strong>抢占式</strong>：preemptive</p></blockquote><table><thead><tr><th style="text-align: center;">Process</th><th style="text-align: center;">Arrival Time</th><th style="text-align: center;">Burst Time</th><th style="text-align: center;">Priority</th></tr></thead><tbody><tr><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">0</td><td style="text-align: center;">10</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">P<sub>4</sub></td><td style="text-align: center;">5</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">P<sub>5</sub></td><td style="text-align: center;">8</td><td style="text-align: center;">5</td><td style="text-align: center;">2</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221024144435400.png" alt="image-20221024144435400" style="zoom:80%;" /></p><ol type="1"><li>平均Turnaround time：(17+1+15+1+5) / 5 = 7.8</li><li>平均waiting time：(7+0+13+0+0) / 5 = 4</li></ol><h3 id="时间片轮转调度-rr">5.3.4 时间片轮转调度 RR</h3><h4 id="算法内容-3">5.3.4.1 算法内容</h4><ol type="1"><li>基本思路：通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率。</li><li><strong>RR</strong>算法：Round Robin<ol type="1"><li>将系统中所有的就绪进程按照<strong>FCFS</strong>原则，排成一个队列</li><li>每次调度时将CPU分派给队首进程，让其执行一个<strong>时间片(timeslice)</strong><ol type="1"><li>时间片的长度从几个ms到几百ms</li></ol></li><li>在一个时间片结束时，发生时钟中断</li><li>调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程</li><li>进程可以未使用完一个时间片，就出让CPU（如阻塞）</li></ol></li><li>每个进程都有一小单位的CPU时间(<strong>timequantum</strong>)，通常为10-100毫秒。经过这段时间后，进程被抢占并添加到就绪队列的末尾</li><li>如果<strong>readyqueue</strong>中有<strong>n</strong>个进程，并且<strong>timequantum</strong>为<strong>q</strong>，那么每个进程一次获得最多为<strong>q</strong>个时间单位的<strong>CPU</strong>时间的<strong>1/n</strong>，进程最大等待<strong>(n-1)q</strong>个时间单位<ol type="1"><li>当q很大时，变为了FIFO</li><li>当q很小时，上下文切换的开销过高</li></ol></li><li>时间片长度的影响因素：<ol type="1"><li>就绪进程的数目：当响应时间一定时，<strong>数目越多，时间片越小</strong></li><li>系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间、平均周转时间、平均带权周转时间过长</li></ol></li><li>优点：response更好</li><li>缺点：比<strong>SJF</strong>的average turnaround time长</li></ol><h4 id="示例-3">5.3.4.2 示例</h4><table><thead><tr><th style="text-align: center;">Process</th><th style="text-align: center;">Burst Time</th></tr></thead><tbody><tr><td style="text-align: center;">P<sub>1</sub></td><td style="text-align: center;">53</td></tr><tr><td style="text-align: center;">P<sub>2</sub></td><td style="text-align: center;">17</td></tr><tr><td style="text-align: center;">P<sub>3</sub></td><td style="text-align: center;">68</td></tr><tr><td style="text-align: center;">P<sub>4</sub></td><td style="text-align: center;">24</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221024150527509.png" alt="image-20221024150527509" style="zoom:80%;" /></p><ol type="1"><li>平均Turnaround time：(134+37+162+121) / 4 = 113.5</li><li>平均waiting time：(81+20+94+97) / 4 = 70.5</li></ol><h4 id="time-quantum-时间片的选择">5.3.4.3 Time Quantum时间片的选择</h4><ol type="1"><li>要求80%的CPU burst time应该小于q</li></ol><h3 id="多级队列调度">5.3.5 多级队列调度</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221024152844819.png" alt="image-20221024152844819" style="zoom: 67%;" /></p><p>本算法引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标</p><ol type="1"><li>根据进程的性质或类型的不同，将Ready队列再分为若干个子队列</li><li>每个作业固定归入一个队列</li><li>各队列的不同处理：不同队列可有不同的优先级、时间片长度、调度策略等<ol type="1"><li>如：系统进程、用户交互进程、批处理进程等</li></ol></li><li>Ready Queue的分类<ol type="1"><li>foreground (interactive) 前台（交互式）— RR，时间片轮转调度</li><li>background (batch) 　　后台 （批处理）— FCFS，先来先服务调度</li></ol></li><li>多级队列算法调度须在队列间进行<ol type="1"><li><strong>固定优先级调度</strong>：即前台运行完后再运行后台<ol type="1"><li>有可能产生饥饿</li></ol></li><li><strong>给定时间片调度</strong>：即每个队列得到一定的CPU时间，进程在给定时间内执行<ol type="1"><li>不同队列的时间片长度不一样</li><li>如，80%的时间执行前台的RR调度，20%的时间执行后台的FCFS调度</li></ol></li></ol></li></ol><h3 id="多级反馈队列">5.3.6 多级反馈队列</h3><ol type="1"><li>多级反馈队列算法：Multilevel Feedback Queue Scheduling<ol type="1"><li>是时间片轮转算法和优先级算法的综合和发展</li><li>同一个进程可以在不同队列之间转移</li></ol></li><li>优点：<ol type="1"><li>为提高系统吞吐量和缩短平均周转时间而照顾短进程</li><li>为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li><li>不必估计进程的执行时间，动态调节</li></ol></li><li>方法：<ol type="1"><li>设置<strong>多个就绪队列</strong>，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定<strong>优先级越低则时间片越长</strong>，如逐级加倍</li><li>新进程进入内存后，<strong>先投入队列1的末尾</strong>，按<strong>FCFS</strong>算法调度；<strong>若按队列1一个时间片未能执行完，则降低投入到队列2的末尾</strong>，同样按<strong>FCFS</strong>算法调度；如此下去，降低到最后的队列，则按"<strong>时间片轮转</strong>"算法调度直到完成</li><li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢占执行新进程，并把被抢占的进程投入原队列的末尾</li></ol></li><li>几点说明：<ol type="1"><li><strong>I/O型进程</strong>：让其进入最高优先级队列，以及时响应I/O交互。通常执行一个小时间片，要求可处理完一次I/O请求的数据，然后转入到阻塞队列</li><li><strong>计算型进程</strong>：每次执行完时间片，进入更低优先级级队列。最终采用最大时间片来执行，减少调度次数</li><li><strong>I/O次数不多，而主要是CPU处理的进程</strong>：在I/O完成后，优先放回I/O请求时离开的队列，以免每次都回到最高优先级队列后再逐次下降</li><li>为适应一个进程在不同时间段的运行特点，<strong>I/O完成时，提高优先级</strong>；<strong>时间片用完时，降低优先级</strong>；</li></ol></li></ol><h2 id="多处理器调度-multiple-processor-scheduling">5.4* 多处理器调度Multiple-Processor Scheduling</h2><ol type="1"><li>当多个CPU可用时，CPU调度更加复杂</li><li>多处理器中的 同构处理器Homogeneous processors<ol type="1"><li>负载分担</li></ol></li><li>非对称多处理Asymmetricmultiprocessing：只有一个处理器访问系统数据结构，减少了数据共享的需要</li></ol><h2 id="线程调度-thread-scheduling">5.5* 线程调度 Thread Scheduling</h2><ol type="1"><li>本地调度：线程库如何决定将哪个线程放入可用的LWP</li><li>全局调度：内核如何决定下一个运行哪个内核线程</li></ol><h2 id="操作系统示例-operating-systems-examples">5.6 操作系统示例Operating Systems Examples</h2><ol type="1"><li>两种算法：Time-sharing、Real-time</li><li>时间共享 Time-sharing<ol type="1"><li>基于credit的优先级：下一步执行拥有最高credit的进程</li><li>触发计时器中断时扣除credit</li><li>当credit=0时，选择另一个进程</li><li>当所有进程的credit均为0时，将重新编辑<ol type="1"><li>基于优先级和历史等因素</li></ol></li></ol></li><li>实时 Real-time<ol type="1"><li>软实时</li><li>Posix.1b compliant：两种<ol type="1"><li>FCFS和RR</li><li>优先级最高的进程总是首先运行</li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027164612041.png" alt="image-20221027164612041" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027164619528.png" alt="image-20221027164619528" style="zoom:67%;" /></p><h2 id="总结-1">5.7 总结</h2><ol type="1"><li>CPU Burst Time 、I/O Burst Time</li><li>CPU-bound program（CPU型程序） 、I/O-bound program（I/O型程序）</li><li>long-term scheduler（长程调度）、medium-termscheduler（中程调度）short-term scheduler（短程调度）</li><li>time slicing（时间片）</li><li>response time（响应时间）、turnaround time（周转时间）、waitingtime（等待时间）、Average Turnaround time（平均周转时间）Average waitingtime（平均等待时间）</li><li>preemptive scheduling（抢占式调度）、Nonpreemptivescheduling（非抢占式调度）</li><li>throughput（吞吐量）：单位时间内完成的任务</li><li>从ready queue中选择一个进程，为它分配CPU</li><li>调度算法<ol type="1"><li>first-come, first served (<strong>FCFS</strong>)</li><li>shortest job first (<strong>SJF</strong>)<ol type="1"><li>provably optimal, but difficult to know CPU burst</li></ol></li><li>general <strong>priority</strong> scheduling<ol type="1"><li>starvation, and aging</li></ol></li><li>round-robin (<strong>RR</strong>)<ol type="1"><li>for time-sharing, interactive system</li><li>problem: how to select the time quantum?</li></ol></li><li><strong>Multilevel queue</strong><ol type="1"><li>different algorithms for different classes of processes</li></ol></li><li><strong>Multilevel feedback queue</strong><ol type="1"><li>allow process to move from one (ready) queue to another</li></ol></li></ol></li></ol><h1 id="chapter-6process-synchronization-进程同步">Chapter 6：ProcessSynchronization 进程同步</h1><h2 id="background">6.1 Background</h2><ol type="1"><li><p>对共享数据的并发访问可能导致数据不一致：datainconsistency</p></li><li><p>维护数据一致性需要有机制来确保合作流程的有序执行</p></li><li><p>有界缓冲区问题的共享内存解决方案(第3章)允许缓冲区中最多有n-1个项。使用所有N个缓冲区的解决方案并不简单</p></li><li><p>假设我们通过添加一个变量counter来修改生产者–消费者代码</p><ol type="1"><li>counter初始化为0，并在每次向缓冲区添加新项时递增</li><li>counter++和counter--必须被原子性的执行</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">. . .</span><br><span class="line">&#125; item;</span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer process(thread):</span></span><br><span class="line">item nextProduced;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (counter == BUFFER_SIZE) ;  <span class="comment">/* do nothing */</span></span><br><span class="line">    buffer[in] = nextProduced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer process (thread):</span></span><br><span class="line">item nextConsumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (counter == <span class="number">0</span>);  <span class="comment">/* do nothing */</span></span><br><span class="line">    nextConsumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="原子操作">6.1.1 原子操作</h3><ol type="1"><li><p><strong>原子操作 Atomicoperation</strong>：是指完整地完成而不中断的操作</p><ol type="1"><li><p>counter++和counter--均会被实现为三条指令：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">register</span> = counter;</span><br><span class="line"><span class="keyword">register</span> = <span class="keyword">register</span> +/- <span class="number">1</span>;</span><br><span class="line">counter = <span class="keyword">register</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果生产者和消费者都试图同时更新缓冲区，汇编语言语句可能会交错</p></li><li><p>交错取决于生产者和消费者流程的安排方式</p></li></ol></li></ol><h3 id="非原子操作冲突示例">6.1.2 非原子操作冲突示例</h3><blockquote><p>有两个进程P1、P2，它们分别执行下面的程序体，其中total是两个进程都能访问的共享变量，初值为0（可理解为共享存储段中的存储单元），count是每个进程的私有变量。假设这两个进程并发执行，并可自由交叉（interleave），则这两个进程都执行完后，变量total可能得到的最小取值是<code>3</code></p><p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P1:&#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">for</span> (count =<span class="number">1</span>; count &lt;= <span class="number">50</span>; count++)</span><br><span class="line">total = total + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br><span class="line">P2: &#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">for</span> (count =<span class="number">1</span>; count &lt;= <span class="number">50</span>; count++)</span><br><span class="line">total = total + <span class="number">2</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ol type="1"><li><p>total = total + 1和total = total + 2经过编译后各为三条指令</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027171738434.png" alt="image-20221027171738434" style="zoom:67%;" /></p></li><li><p>P1和P2并发执行过程中，这些指令会交替运行。如果两个进程按如下顺序执行：</p><table><thead><tr><th style="text-align: center;">操作</th><th style="text-align: center;">对应指令</th><th style="text-align: center;">对应的值</th></tr></thead><tbody><tr><td style="text-align: center;">P1第1次循环</td><td style="text-align: center;">register1 = total</td><td style="text-align: center;">register1 = 0</td></tr><tr><td style="text-align: center;">P1第1次循环</td><td style="text-align: center;">register1 = register1 + 1</td><td style="text-align: center;">register1 = 1</td></tr><tr><td style="text-align: center;">P2循环49次</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">P1第1次循环</td><td style="text-align: center;">total =register1</td><td style="text-align: center;">total =1</td></tr><tr><td style="text-align: center;">P2第50次循环</td><td style="text-align: center;">register2 = total</td><td style="text-align: center;">register2 = 1</td></tr><tr><td style="text-align: center;">P2第50次循环</td><td style="text-align: center;">register2 = register2 + 2</td><td style="text-align: center;">register2 = 3</td></tr><tr><td style="text-align: center;">P1循环48次</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">P1第50次循环</td><td style="text-align: center;">register1 = total</td><td style="text-align: center;">register1 = 49</td></tr><tr><td style="text-align: center;">P1第50次循环</td><td style="text-align: center;">register1 = register1 + 1</td><td style="text-align: center;">register1 =50</td></tr><tr><td style="text-align: center;">P1第50次循环</td><td style="text-align: center;">total = register1</td><td style="text-align: center;">total = 50</td></tr><tr><td style="text-align: center;">P2第50次循环</td><td style="text-align: center;">total = register2</td><td style="text-align: center;">total = 3</td></tr></tbody></table></li><li><p>两个进程运行结束后，变量total的值为3。</p></li></ol><h3 id="race-condition">6.1.3 Race Condition</h3><ol type="1"><li>RaceCondition(竞争条件)：多个进程同时访问和操作共享数据，共享数据的最终值取决于哪个进程最后完成，执行的结果取决于访问发生的特定顺序</li><li>为了防止出现争用情况，必须同步并发进程</li></ol><h3 id="进程同步的概念">6.1.4 进程同步的概念</h3><p>进程之间竞争资源面临三个控制问题：</p><ol type="1"><li><strong>互斥</strong>(mutualexclusion)：指多个进程不能同时使用同一个资源</li><li><strong>死锁</strong>(deadlock)：指多个进程互不相让，都得不到足够的资源<ol type="1"><li>永远得不到资源</li></ol></li><li><strong>饥饿</strong>(starvation)：指一个进程长时间得不到资源(其他进程可能轮流占用资源)<ol type="1"><li>资源分配不公平</li></ol></li></ol><h2 id="the-critical-section-problem重点">6.2 The Critical-SectionProblem(<strong>重点</strong>)</h2><h3 id="问题的定义">6.2.1 问题的定义</h3><ol type="1"><li>n个进程都在竞争使用某些共享数据</li><li>每个流程都有一个代码段，称为关键部分(临界区）,其中访问共享数据。</li><li>问题：确保当一个进程在其关键部分执行时，不允许其他进程在其重要部分执行</li></ol><h3 id="临界区临界资源">6.2.2 临界区&amp;临界资源</h3><ol type="1"><li><strong>临界资源</strong>：一次只允许一个进程使用(访问)的资源<ol type="1"><li>如：硬件打印机、磁带机等，软件的消息缓冲队列、变量、数组、缓冲区等。</li></ol></li><li><strong>临界区</strong>：访问临界资源的那段代码</li><li>对临界区问题的解法必须满足：<ol type="1"><li><strong>Mutual Exclusion</strong>(互斥)<ol type="1"><li>如果进程P<sub>i</sub>正在临界区中执行，则其他进程不能在临界区中执行</li></ol></li><li><strong>Progress</strong>(空闲让进)<ol type="1"><li>如果没有进程在临界区中执行，并且存在一些进程希望进入临界区，则不能无限期地推迟选择下一个将进入临界区的进程</li></ol></li><li><strong>Bounded Waiting</strong>(让权等待)<ol type="1"><li>在一个进程发出进入临界区的请求之后，在该请求被批准之前，其他进程被允许进入临界区的次数必须存在一个界限</li><li>不是必须的</li></ol></li></ol></li></ol><h3 id="一个进程的结构应该是">6.2.3 一个进程的结构应该是</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221031142201362.png" alt="image-20221031142201362" style="zoom:80%;" /></p><h2 id="多进程临界区问题的解决方法软件方法">6.3多进程临界区问题的解决方法：软件方法</h2><h3 id="peterson-solutions两个进程">6.3.1 PetersonSolutions：两个进程</h3><blockquote><ol type="1"><li>Software Solution：通过软件方法解决进程互斥</li><li>针对两个进程之间的同步</li><li>假设Load和Store均是原子操作</li></ol></blockquote><h4 id="算法1">6.3.1.1 算法1</h4><ol type="1"><li><p>只有两个进程P<sub>0</sub>，P<sub>1</sub></p></li><li><p>共享变量</p><ol type="1"><li>int turn = 0</li><li>turn = i：表示轮到P<sub>i</sub>进入临界区，i = 0/1</li></ol></li><li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027173940774.png" alt="image-20221027173940774" style="zoom:80%;" /></p></li><li><p>满足<strong>互斥</strong>，但是不满足<strong>空闲让进</strong></p></li><li><p>缺点：</p><ol type="1"><li><strong>强制轮流</strong>进入临界区，没有考虑进程的实际需要。容易造成资源利用不充分</li><li>在P<sub>i</sub>出让临界区之后，P<sub>j</sub>使用临界区之前，P<sub>i</sub>不可能再次使用临界区</li></ol></li></ol><h4 id="算法2-1">6.3.1.2 算法2-1</h4><ol type="1"><li><p>共享变量</p><ol type="1"><li>bool flag[2] = false</li><li>flag[i] = true：表示P<sub>i</sub>想要进入临界区，i = 0/1</li></ol></li><li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027174338587.png" alt="image-20221027174338587" style="zoom:80%;" /></p></li><li><p>满足<strong>互斥</strong>，但是不满足<strong>空闲让进</strong></p></li><li><p>缺点：</p><ol type="1"><li>P<sub>0</sub>和P<sub>1</sub>可能都进入不了临界区</li><li>当P<sub>0</sub>执行了flag[0] =true后，然后P<sub>1</sub>执行了flag[1] =true，这样两个进程都无法进入临界区</li></ol></li></ol><h4 id="算法2-2">6.3.1.3 算法2-2</h4><ol type="1"><li><p>共享变量</p><ol type="1"><li>bool flag[2] = false</li><li>flag[i] = true：表示P<sub>i</sub>想要进入临界区，i = 0/1</li></ol></li><li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027174706683.png" alt="image-20221027174706683" style="zoom:80%;" /></p></li><li><p>满足<strong>空闲让进</strong>，但是不满足<strong>互斥</strong></p></li><li><p>缺点：</p><ol type="1"><li>P<sub>0</sub>和P<sub>1</sub>可能同时进入临界区</li><li>当flag [0] = flag [1] = false时， P<sub>0</sub>执行了while(flag[1])后，P<sub>1</sub>执行while (flag[0])，这样两个进程同时进入了临界区</li></ol></li></ol><h4 id="peterson算法">6.3.1.4 Peterson算法</h4><ol type="1"><li><p>共享变量</p><ol type="1"><li><strong>int turn = 0</strong></li><li><strong>bool flag[2] = false</strong></li><li>turn = i：表示<strong>轮到P<sub>i</sub></strong>进入临界区，i =0/1</li><li>flag[i] =true：表示<strong>P<sub>i</sub>准备好</strong>进入临界区，i = 0/1</li></ol></li><li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027174954828.png" alt="image-20221027174954828" style="zoom:80%;" /></p></li><li><p>满足了三个要求，但是只能解决2个进程的临界区问题</p></li></ol><h3 id="bakery-algorithmn个进程">6.3.2 Bakery Algorithm：n个进程</h3><p>思想：</p><ol type="1"><li>进入临界区之前，进程会获得一个<strong>number</strong>，拥有最小<strong>number</strong>的进程可以进入临界区</li><li>如果<strong>P<sub>i</sub></strong>和<strong>P<sub>j</sub></strong>的<strong>number</strong>相同，则先执行进程<strong>id</strong>小的进程</li><li>编号方案总是按枚举的递增顺序生成数字，如1,2,3,3,3,3,4,5...</li></ol><p>定义：</p><ol type="1"><li><strong>order</strong>：(a, b)，a为number，b为进程id</li><li><strong>(a, b) &lt; (c, d)</strong>：当且仅当 a&lt;c 或者 a=c,b&lt;d</li></ol><p>共享数据：</p><ol type="1"><li><strong>bool choosing[n] = false;</strong></li><li><strong>int number[n] = 0;</strong></li><li>choosing[i] =true：表示<strong>P<sub>i</sub>正在获取</strong>它的<strong>number</strong></li><li>number[i]：是<strong>P<sub>i</sub>的当前number</strong>。如果值为0，表示P<sub>i</sub>未参加排队，不想获得该资源</li></ol><p>进程P<sub>i</sub>的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="comment">// 获取一个number</span></span><br><span class="line">choosing[i] = <span class="literal">true</span>;</span><br><span class="line">number[i] = <span class="built_in">max</span>(number[<span class="number">0</span>], number[<span class="number">1</span>], ... , number[n<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">choosing[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待其它优先级更高的进程进入临界区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; </span><br><span class="line">        <span class="comment">// 等待进程P[j]获取自己的number</span></span><br><span class="line">        <span class="keyword">while</span>(choosing[j]); </span><br><span class="line">        <span class="comment">// 进程P[j]参与排队, 并且比当前进程优先级高, 则等待P[j]执行完成</span></span><br><span class="line">       <span class="keyword">while</span>((number[j] != <span class="number">0</span>) &amp;&amp; (number[j],j) &lt; (number[i],i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">critical_section</span>();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">number[i] = <span class="number">0</span>;<span class="comment">// 从队列中出来, 不再等待进入临界区</span></span><br><span class="line"><span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="多进程临界区问题的解决方法硬件方法">6.4多进程临界区问题的解决方法：硬件方法</h2><ol type="1"><li>许多系统为关键部分代码提供硬件支持</li><li>单处理器：可以禁用中断<ol type="1"><li>当前运行的代码将在没有抢占的情况下执行</li><li>在多处理器系统上通常效率太低</li><li>使用此功能的操作系统不可广泛扩展</li></ol></li><li>特殊的原子硬件指令：原子 =&gt; 不可中断<ol type="1"><li>从内存中取一个变量并且设置为某个值：test and set</li><li>交换内存中两个变量的内容：swap</li></ol></li></ol><h3 id="test-and-set测试与设置">6.4.1 Test-and-Set：测试与设置</h3><ol type="1"><li><p>返回变量的原始值，并将其赋值为<strong>true</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> &amp;target)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> rv = target;</span><br><span class="line">    target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将其变为一条<strong>原子指令</strong>之后，进程与临界区的交互变为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, 该指令返回false, 并将lock赋值为true</span></span><br><span class="line">    <span class="comment">// 其它进程再执行该指令时, 会由于返回值为true, 而停到这里</span></span><br><span class="line">    <span class="comment">// 进程执行完成后, 将lock赋值为false, 其它进程可以访问临界区</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(lock));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">lock = <span class="literal">false</span>;<span class="comment">// 之后的第一个进程可以进入临界区</span></span><br><span class="line"><span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="swap交换">6.4.2 Swap：交换</h3><ol type="1"><li><p>交换两个变量的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span> <span class="params">(boolean *a, boolean *b)</span>&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将其变为一条<strong>原子指令</strong>之后，进程与临界区的交互变为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, key与lock交换, key变为false, lock变为true</span></span><br><span class="line">    <span class="comment">// 其它进程再执行该指令时, key与lock交换后均为true, 会停到这里</span></span><br><span class="line">    <span class="comment">// 进程执行完成后, 将lock赋值为false, 其它进程可以访问临界区</span></span><br><span class="line">    <span class="keyword">while</span>(key == <span class="literal">true</span>) Swap(&amp;lock, &amp;key);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    critical_section();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">lock = <span class="literal">false</span>;<span class="comment">// 之后的第一个进程可以进入临界区</span></span><br><span class="line">remainder_section();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="硬件方法的优缺点">6.4.3 硬件方法的优缺点</h3><ol type="1"><li><p>优点</p><ol type="1"><li>适用于<strong>任意数目的进程</strong>，在单处理器或多处理器上</li><li><strong>简单</strong>，容易验证其正确性</li><li>可以支持进程内存在<strong>多个临界区</strong>，只需为每个临界区设立一个布尔变量</li></ol></li><li><p>缺点</p><ol type="1"><li>不能实现<strong>让权等待</strong>：<ol type="1"><li>因为等待要耗费CPU时间</li></ol></li><li>可能<strong>饥饿</strong>：<ol type="1"><li>从等待进程中随机选择一个进入临界区，有的进程可能一直选不上</li></ol></li><li>可能<strong>死锁</strong>：<ol type="1"><li>单CPU情况下，P<sub>1</sub>执行特殊指令进入临界区，这时拥有更高优先级P2执行并中断P1</li><li>如果P<sub>2</sub>又要使用P<sub>1</sub>占用的资源，按照资源分配规则拒绝P<sub>2</sub>对资源的要求，P<sub>2</sub>陷入等待循环</li><li>然后P<sub>1</sub>也得不到CPU，因为P<sub>1</sub>比P<sub>2</sub>优先级低</li></ol></li></ol></li><li><p><strong>解决饥饿</strong></p><ol type="1"><li><strong>waiting[i]</strong>：进程P<sub>i</sub>正在等待进入临界区</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> waiting[n] = <span class="literal">false</span>, lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, 将lock变为true, 返回给key为false</span></span><br><span class="line">    <span class="comment">// 之后的进程始终为true, 也就是不能进入临界区</span></span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (waiting[i] &amp;&amp; key) key = <span class="built_in">TestAndSet</span>(lock);</span><br><span class="line">    waiting[i] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择下一个进入临界区的进程(下一个waiting[j] = true)</span></span><br><span class="line">    <span class="comment">// 让waiting[j] = false, 则被选中的进程跳出while循环, 可以进入临界区</span></span><br><span class="line">    <span class="comment">// lock的释放由进程P[j]执行</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = (i + <span class="number">1</span>) % n; j != i; j = (j + <span class="number">1</span>) % n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(waiting[j]) &#123;</span><br><span class="line">            waiting[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有进程等待进入临界区, 则直接释放lock</span></span><br><span class="line">    <span class="keyword">if</span> (j == i)  lock = <span class="literal">false</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>该算法满足所有关键部分的要求。</li><li>证明满足互斥要求：<ol type="1"><li>我们注意到，只有当<strong>waiting[i]=false</strong>或<strong>key=false</strong>时，进程<strong>Pi</strong>才能进入临界区</li><li>只有在执行<strong>TestAndSet</strong>时，<strong>key</strong>的值才能变为<strong>false</strong></li><li>执行<strong>TestAndSet</strong>的第一个进程将发现<strong>key==false</strong>；所有其他人都必须等待</li><li>只有当另一个进程离开临界区时，<strong>waiting[i]</strong>才能变为<strong>false</strong>；只有一个<strong>waiting[i]</strong>设置为<strong>false</strong>，保持互斥要求。</li></ol></li></ol></blockquote></li></ol><h3 id="自旋锁-spinlock">6.4.4 自旋锁 spinlock</h3><ol type="1"><li>Windows、Linux内核用来达到多处理器互斥的机制“自旋锁”，它类同于TestAndSet指令机制。自旋锁是一个与共用数据结构有关的锁定机制。</li><li>自旋锁像它们所保护的数据结构一样，储存在共用内存中。为了速度和使用任何在处理器体系下提供的锁定机构，获取和释放自旋锁的代码是用汇编语言写的。例如在Intel处理器上，Windows使用了一个只在486处理器或更高处理器上运行的指令。</li><li>当线程试图获得自旋锁时，在处理器上所有其它工作将终止。因此拥有自旋锁的线程永远不会被抢占，但允许它继续执行以便使它尽快把锁释放。内核对于使用自旋锁十分小心，当它拥有自旋锁时，它执行的指令数将减至最少。</li></ol><h2 id="semaphores-信号量">6.5 Semaphores 信号量</h2><h3 id="信号量">6.5.1 信号量</h3><p>信号量分类：</p><ol type="1"><li>整型信号量：integer semaphore</li><li>记录型信号量：record semaphore</li><li>AND型信号量，信号量集</li><li>二值信号量：binary semaphore</li></ol><p>信号量的任务：解决<strong>busywaiting</strong>，即之前进程中的while()语句</p><ol type="1"><li><p>整型信号量：<strong>S</strong></p></li><li><p>对S的两个标准操作：<strong>wait()</strong>、<strong>signal()</strong></p><ol type="1"><li>也成为<strong>P()</strong>、<strong>V()</strong></li><li>这两个操作是<strong>原子操作</strong></li></ol></li><li><p>两种信号量</p><ol type="1"><li>计数信号量 Counting semaphore：整数取值范围</li><li>二值信号量 Binary semaphore：只有0/1两个值</li></ol></li></ol><h3 id="用信号量解决冲突">6.5.2 用信号量解决冲突</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">// 共享数据, 初始值表示最多可以有多少个进程同时进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个进程将mutex--, mutex变为0</span></span><br><span class="line">    <span class="comment">// 其它进程会在当前wait(mutex)处等待</span></span><br><span class="line">    <span class="built_in">wait</span> (mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进程执行完成, 将mutex++</span></span><br><span class="line">    <span class="comment">// 其它进程可以通过wait(mutex)指令</span></span><br><span class="line">    <span class="built_in">signal</span> (mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure><ol type="1"><li>必须保证没有两个进程可以在同一信号量上同时执行wait()和signal()</li><li>没有解决busy waiting的问题</li><li>但是将解决临界区问题的代码简化了</li></ol><h3 id="没有busy-waiting的信号量实现">6.5.3 没有busywaiting的信号量实现</h3><ol type="1"><li><p>实现了一个waiting queue，等待队列中的每一个实体有2个元素：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">// S: 记录型信号量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *list;<span class="comment">// 等待队列中的下一个进程</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li><li><p>2个操作</p><ol type="1"><li><strong>block()</strong>：将调用操作的进程放置在适当的等待队列中<ol type="1"><li>进程：running → waiting</li></ol></li><li><strong>wakeup()</strong>：删除等待队列中的一个进程，并将其置于就绪队列中<ol type="1"><li>进程：waiting → ready</li></ol></li></ol></li><li><p>具体实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wait</span>(semaphore * S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 将这个进程加入S-&gt;list</span></span><br><span class="line">        <span class="built_in">block</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(semaphore *S) &#123; </span><br><span class="line">    S-&gt;value++; </span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 将进程P从S-&gt;list中移除</span></span><br><span class="line">        <span class="built_in">wakeup</span>(P); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><h3 id="waitsignal操作讨论">6.5.4 wait、signal操作讨论</h3><ol type="1"><li>通常用信号量表示资源或临界区</li><li>信号量的物理含义<ol type="1"><li><strong>S.value&gt;0</strong>：表示有S.value个资源可用；</li><li><strong>S.value=0</strong>：表示无资源可用或表示不允许进程再进入临界区；</li><li><strong>S.value&lt;0</strong>：则|S.value|表示在等待队列中进程的个数或表示等待进入临界区的进程个数</li></ol></li><li><strong>wait(S)≡P(S)≡down(S)</strong>：表示申请一个资源</li><li><strong>signal(S)≡V(S)≡up(S)</strong>： 表示释放一个资源</li><li>wait、signal操作必须成对出现，有一个wait操作就一定有一个signal操作<ol type="1"><li>当为互斥操作时(控制A, B不会同时访问临界区)，它们同处于同一进程</li><li>当为同步操作时(控制先让A执行, 再让B执行)，则不在同一进程中出现</li></ol></li><li>如果两个wait操作相邻，那么它们的顺序至关重要，而两个相邻的signal操作的顺序无关紧要</li><li>一个同步wait操作与一个互斥wait操作在一起时，同步wait操作在互斥wait操作前</li><li>wait、signal操作的优缺点<ol type="1"><li>优点：简单，而且表达能力强</li><li>缺点：不够安全；wait、signal操作使用不当会出现死锁；实现复杂</li></ol></li></ol><h3 id="信号量用于通用同步操作">6.5.5 信号量用于通用同步操作</h3><ol type="1"><li><p>先执行P<sub>i</sub>中的A操作，再执行P<sub>j</sub>中的B操作</p><ol type="1"><li>信号量<strong>flag初始化为0</strong></li></ol><table><thead><tr><th style="text-align: center;">P[i]</th><th style="text-align: center;">P[j]</th></tr></thead><tbody><tr><td style="text-align: center;">…</td><td style="text-align: center;">…</td></tr><tr><td style="text-align: center;">A</td><td style="text-align: center;">wait(flag)</td></tr><tr><td style="text-align: center;">signal(flag)</td><td style="text-align: center;">B</td></tr><tr><td style="text-align: center;">…</td><td style="text-align: center;">…</td></tr></tbody></table></li><li><p>一组合作进程，执行顺序如图。请用P(wait)、V(signal)操作实现进程间的同步操作</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221103165404062.png" alt="image-20221103165404062" style="zoom: 50%;" /></th><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221103165348103.png" alt="image-20221103165348103" style="zoom: 50%;" /></th></tr></thead><tbody></tbody></table><ol type="1"><li><p>设置8个信号量a~h，初始值均为0</p></li><li><p>各进程的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(a);</span><br><span class="line"><span class="built_in">signal</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(a);</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(c);</span><br><span class="line"><span class="built_in">signal</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P3</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(b);</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(e);</span><br><span class="line"><span class="built_in">signal</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P4</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(c);</span><br><span class="line"><span class="built_in">wait</span>(e);</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P5</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(d);</span><br><span class="line"><span class="built_in">wait</span>(f);</span><br><span class="line">...;</span><br><span class="line"><span class="built_in">signal</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P6</span>()&#123;</span><br><span class="line"><span class="built_in">wait</span>(g);</span><br><span class="line"><span class="built_in">wait</span>(h);</span><br><span class="line">...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>两个进程互斥：信号量初始为1</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221103170050338.png" alt="image-20221103170050338" style="zoom:80%;" /></p></li></ol><h3 id="死锁和饥饿">6.5.6 死锁和饥饿</h3><ol type="1"><li><p>死锁Deadlock：两个或多个进程无限期地等待一个事件，该事件只能由其中一个等待进程引起</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221103170213479.png" alt="image-20221103170213479"  /></p></li><li><p>饥饿Starvation：无限期阻塞。进程可能永远不会从其挂起的信号量队列中删除</p></li><li><p>优先级反转PriorityInversion：低优先级进程持有高优先级进程所需的锁时的调度问题</p></li></ol><h2 id="同步的经典问题">6.6 同步的经典问题</h2><h3 id="有限缓冲区问题bounded-buffer-problem">6.6.1有限缓冲区问题：Bounded-Buffer Problem</h3><ol type="1"><li><p>有限缓冲区问题，也成为生产者-消费者问题，是最著名的同步问题</p><ol type="1"><li>它描述一组生产者(P<sub>1</sub>……P<sub>m</sub>)向一组消费者(C<sub>1</sub>……C<sub>q</sub>)提供消息</li><li>它们共享一个有限缓冲池(bounded buffer pool)</li><li>生产者向其中投放消息，消费者从中取得消息</li><li>生产者-消费者问题是许多相互合作进程的一种抽象</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221103171832558.png" alt="image-20221103171832558" style="zoom:67%;" /></p></li><li><p>N个buffer，每个可以存储1个item</p><ol type="1"><li>信号量<strong>full</strong>：初始化为0，表示已经使用的buffer个数</li><li>信号量<strong>empty</strong>：初始化为N，表示还未使用的buffer个数</li><li>信号量<strong>mutex</strong>：初始化为1，作为互斥信号量</li></ol></li><li><p>需要保证：</p><ol type="1"><li>对同一个buffer的操作是互斥操作</li></ol></li><li><p>生产者进程：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line"><span class="comment">// produce an item in nextp</span></span><br><span class="line">...;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">wait</span>(empty);<span class="comment">// 保证所有生产者插入的数量 &lt; 当前buffer的剩余空间的大小</span></span><br><span class="line"><span class="built_in">wait</span>(mutex);<span class="comment">// 保证互斥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add nextp to buffer</span></span><br><span class="line">...;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(mutex);<span class="comment">// 保证互斥</span></span><br><span class="line">    <span class="built_in">signal</span>(full);<span class="comment">// 声明有一个数据插入到buffer中, 便于消费者的使用</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>消费者进程：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="built_in">wait</span>(full);<span class="comment">// 保证所有消费者使用的数量 &lt; 当前buffer中存在的数据数量</span></span><br><span class="line"><span class="built_in">wait</span>(mutex);<span class="comment">// 保证互斥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove an item from buffer to nextc</span></span><br><span class="line">...;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(mutex);<span class="comment">// 保证互斥</span></span><br><span class="line">    <span class="built_in">signal</span>(empty);<span class="comment">// 声明有一个buffer已经为空, 便于生产者使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// consume the item in nextc</span></span><br><span class="line">...;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="读写问题readers-and-writers-problem">6.6.2 读写问题：Readers andWriters Problem</h3><ol type="1"><li>一个数据集（如文件）如果被几个并行进程所共享：<ol type="1"><li><strong>Reader</strong>：有些进程只要求读数据集内容，它称读者</li><li><strong>Writer</strong>：一些进程则要求修改数据集内容，它称写者</li><li>几个Reader可以同时读些数据集，而不需要互斥</li><li>一个Writer不能和其它进程（不管是写者或读者）同时访问些数据集，它们之间必须互斥</li></ol></li></ol><h4 id="第一readers-writers问题">6.6.2.1 第一Readers-Writers问题</h4><ol type="1"><li><p>读优先，要求：</p><ol type="1"><li>允许多个Reader同时阅读</li><li>同一时间只有一个写入程序可以访问共享数据</li><li>Writer能会挨饿</li></ol></li><li><p>共享数据：</p><ol type="1"><li>Data set</li><li>信号量<strong>mutex</strong>：初始化为1，作为互斥信号量</li><li>信号量<strong>wrt</strong>：初始化为1，作为不同Writer之间的互斥信号量</li><li>整数<strong>readcount</strong>：初始化为0</li></ol></li><li><p>Writer进程：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">wait</span> (wrt);<span class="comment">// 有wrt锁时, Writer不能写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// writing is performed</span></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span> (wrt);<span class="comment">// 释放wrt锁</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>Reader进程：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">wait</span>(mutex);<span class="comment">// 对readcount的互斥锁</span></span><br><span class="line">    readcount++;</span><br><span class="line">    <span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="built_in">wait</span>(wrt); <span class="comment">// 第一个Reader到时</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex);<span class="comment">// 释放对readcount的互斥锁</span></span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reading is performed</span></span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">wait</span>(mutex);<span class="comment">// 对readcount的互斥锁</span></span><br><span class="line">    readcount--;</span><br><span class="line">    <span class="keyword">if</span>(readcount == <span class="number">0</span>) <span class="built_in">signal</span>(wrt);<span class="comment">// 最后一个Reader离开时</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex);<span class="comment">// 释放对readcount的互斥锁</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="第二readers-writers问题">6.6.2.2 第二Readers-Writers问题</h4><ol type="1"><li>要求：<ol type="1"><li>一旦Writer准备好了，Writer就会尽快进行写作</li><li>Reader可能会饿死</li></ol></li></ol><h3 id="哲学家就餐问题dining-philosopher-problem">6.6.3哲学家就餐问题：Dining-Philosopher Problem</h3><blockquote><p>多进程、多资源的同步问题</p></blockquote><ol type="1"><li><p>问题说明：</p><ol type="1"><li>n个哲学家坐在一个圆桌旁</li><li>每个哲学家与邻居共用一根筷子</li><li>每个哲学家都必须有一双筷子才能吃</li><li>邻居不能同时吃饭</li><li>哲学家在思考和吃饭之间交替</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221103174703952.png" alt="image-20221103174703952" style="zoom:67%;" /></p></li><li><p>共享数据：</p><ol type="1"><li>信号量：chopstick[5]，初始值为1</li></ol></li><li><p>哲学家i：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 等待两只筷子的使用</span></span><br><span class="line">    <span class="built_in">wait</span>(chopstick[i]);</span><br><span class="line">    <span class="built_in">wait</span>(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用两只筷子</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">eat</span>();</span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明已经使用完两只筷子</span></span><br><span class="line">    <span class="built_in">signal</span>(chopstick[i]);</span><br><span class="line">    <span class="built_in">signal</span>(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不使用筷子的操作</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">think</span>();</span><br><span class="line">   ...;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>该方法很容易产生死锁</p><ol type="1"><li>原因：两个wait语句并不是原子操作</li><li>例如：每个哲学家均拿起了自己左边的一根筷子</li></ol></li><li><p>避免死锁的方法：</p><ol type="1"><li>同时只允许n-1个哲学家申请资源 ==&gt;至少有一个哲学家拿到了2个筷子</li><li>奇数编号的哲学家先拿左边再拿右边，偶数编号的哲学家先拿右边再拿左边</li><li>把哲学家分为三种状态：思考、饥饿、吃饭，并且一次拿到两只筷子，否则不拿<ol type="1"><li>hungry状态唯有保证自己能够拿到2只筷子，才能进入eat状态</li><li>本质上是保证了两句wait的原子性</li></ol></li><li>每个哲学家拿起第1根筷子一定时间后，若拿不到第2根筷子，再放下第1根筷子<ol type="1"><li>但是可能大家一起拿一起放</li></ol></li></ol></li></ol><h2 id="monitors管程">6.7* Monitors(管程)</h2><p>管程是一种高级同步机制</p><ol type="1"><li>管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程</li><li>管程可以函数库的形式实现</li><li>相比之下，管程比信号量好控制</li></ol><h3 id="信号量同步的缺点">6.7.1 信号量同步的缺点</h3><ol type="1"><li>同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如wait、signal操作的次序错误、重复或遗漏）</li><li>可读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序</li><li>不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局</li><li>正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误</li></ol><h3 id="管程的引入">6.7.2 管程的引入</h3><blockquote><p>1973年，Hoare和Hanson所提出；其基本思想是把信号量及其操作原语封装在一个对象内部。即：将共享变量以及对共享变量能够进行的所有操作集中在一个模块中。</p></blockquote><ol type="1"><li>管程的定义：管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块</li><li>管程可增强模块的独立性：系统按资源管理的观点分解成若干模块，用数据表示抽象系统资源，同时分析了共享资源和专用资源在管理上的差别，按不同的管理方式定义模块的类型和结构，使同步操作相对集中，从而增加了模块的相对独立性</li><li>引入管程可提高代码的可读性，便于修改和维护，正确性易于保证：采用集中式同步机制。一个操作系统或并发程序由若干个这样的模块所构成，一个模块通常较短，模块之间关系清晰</li></ol><h3 id="管程的主要特性">6.7.3 管程的主要特性</h3><ol type="1"><li>模块化：一个管程是一个基本程序单位，可以单独编译</li><li>抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码</li><li>信息封装：管程是半透明的，管程中的外部过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的</li></ol><h3 id="管程的实现要素">6.7.4 管程的实现要素</h3><ol type="1"><li>管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接地访问管程中的共享变量</li><li>为了保证管程共享变量的数据完整性，规定管程互斥进入</li><li>管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作</li></ol><h3 id="管程的的组成">6.7.5 管程的的组成</h3><ol type="1"><li><strong>名称</strong>：为每个共享资源设立一个管程</li><li><strong>数据结构说明</strong>：一组局部于管程的控制变量</li><li><strong>操作原语</strong>：对控制变量和临界资源进行操作的一组原语过程（程序代码），是访问该管程的唯一途径。这些原语本身是互斥的，任一时刻只允许一个进程去调用，其余需要访问的进程就等待</li><li><strong>初始化代码</strong>：对控制变量进行初始化的代码</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">monitor monitor-name&#123;</span><br><span class="line">shared variable declarations;</span><br><span class="line"><span class="function">procedure body <span class="title">P1</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">procedure body <span class="title">P2</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">procedure body <span class="title">Pn</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">initialization code</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107145057689.png" alt="image-20221107145057689" style="zoom:80%;" /></p><h3 id="管程中的多个进程进入">6.7.6 管程中的多个进程进入</h3><ol type="1"><li>当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权；当一个进入管程的进程执行唤醒操作时（如Ｐ唤醒Ｑ），管程中便存在两个同时处于活动状态的进程，如何处理？。</li><li>若进程P唤醒进程Q，则随后可有两种执行方式（进程P、Q都是管程中的进程）<ol type="1"><li>P等待，直到Q离开管程或下一次等待。Hoare采用。</li><li>Q等待，直到P离开管程或下一次等待。1980年，Lampson和Redell采用</li></ol></li><li><strong>入口等待队列(entryqueue)</strong>：因为管程是互斥进入的，所以当一个进程试图进入一个巳被占用的管程时它应当在管程的入口处等待，因而在管程的入口处应当有一个进程等待队列，称作入口等待队列</li><li><strong>紧急等待队列</strong>：如果进程Ｐ唤醒进程Ｑ，则Ｐ等待Ｑ继续，如果进程Ｑ在执行又唤醒进程Ｒ，则Ｑ等待Ｒ继续，...，如此，在管程内部，由于执行唤醒操作，可能会出现多个等待进程（已被唤醒，但由于管程的互斥进入而等待），因而还需要有一个进程等待队列，这个等待队列被称为紧急等待队列。它的优先级应当高于入口等待队列的优先级</li></ol><h3 id="条件变量condition">6.7.7 条件变量(condition)</h3><ol type="1"><li>由于管程通常是用于管理资源的，因而在管程内部，应当存在某种等待机制。当进入管程的进程因资源被占用等原因不能继续运行时使其等待。为此在管程内部可以说明和使用一种特殊类型的变量---条件变量</li><li>每个条件变量表示一种等待原因，并不取具体数值---相当于每个原因对应一个队列</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107145621005.png" alt="image-20221107145621005" style="zoom:80%;" /></p><h3 id="同步操作原语">6.7.8 同步操作原语</h3><ol type="1"><li>同步操作原语wait和signal：针对条件变量x，x.wait()将自己阻塞在x队列中，x.signal()将x队列中的一个进程唤醒</li><li><strong>x.wait()</strong>：如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程排入x队列尾部<ol type="1"><li>紧急等待队列与x队列的关系：紧急等待队列是由于管程的互斥进入而等待的队列，而x队列是因资源被占用而等待的队列</li></ol></li><li><strong>x.signal()</strong>：如果x队列为空，则相当于空操作，执行此操作的进程继续；否则唤醒第一个等待者，执行x.signal()操作的进程排入紧急等待队列的尾部</li></ol><h3 id="用管程解决哲学家问题">6.7.9 用管程解决哲学家问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">monitor dp &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;thinking, hungry, eating&#125; state[<span class="number">5</span>];</span><br><span class="line">    condition self[<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickup</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// 哲学家i拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putdown</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// 哲学家i放下筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// 判断哲学家i是否可以拿起筷子</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化时, 所有哲学家均为thinking</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            state[i] = thinking;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哲学家i拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickup</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">state[i] = hungry;<span class="comment">// 将自己变为hungry状态</span></span><br><span class="line"><span class="built_in">test</span>(i);<span class="comment">// 判断自己是否能够拿起筷子</span></span><br><span class="line"><span class="keyword">if</span> (state[i] != eating)<span class="comment">// 如果不能, 把自己放进wait queue中</span></span><br><span class="line">self[i].<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哲学家i放下筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putdown</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">state[i] = thinking;<span class="comment">// 将自己变为thinking状态, 即释放资源</span></span><br><span class="line"><span class="built_in">test</span>((i+<span class="number">4</span>) % <span class="number">5</span>);<span class="comment">// 判断左邻居是否能够拿起筷子</span></span><br><span class="line"><span class="built_in">test</span>((i+<span class="number">1</span>) % <span class="number">5</span>);<span class="comment">// 判断右邻居是否能够拿起筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哲学家i是否可以拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( (state[(i + <span class="number">4</span>) % <span class="number">5</span>] != eating) &amp;&amp; <span class="comment">// 左边没有eating</span></span><br><span class="line">   (state[i] == hungry) &amp;&amp;<span class="comment">// 自己处于饥饿状态</span></span><br><span class="line">   (state[(i + <span class="number">1</span>) % <span class="number">5</span>] != eating)<span class="comment">// 右边没有eating</span></span><br><span class="line">           ) &#123;</span><br><span class="line">state[i] = eating;</span><br><span class="line">self[i].<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Philosopher i:</span></span><br><span class="line"><span class="keyword">do</span>&#123;  </span><br><span class="line">    dp.<span class="built_in">pickup</span>(i);</span><br><span class="line">    eat;</span><br><span class="line">    dp.<span class="built_in">putdown</span>(i);</span><br><span class="line">    think;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="总结-2">6.8 总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107151133964.png" alt="image-20221107151133964" style="zoom:80%;" /></p><h1 id="chapter-7deadlocks死锁">Chapter 7：Deadlocks死锁</h1><h2 id="system-model">7.1 System Model</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107152551989.png" alt="image-20221107152551989" style="zoom:80%;" /></p><ol type="1"><li><strong>死锁</strong>：<ol type="1"><li>一组被阻塞的进程，每个进程持有一个资源，并等待获取该组中另一个进程持有的资源</li><li>指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</li></ol></li><li>系统模型<ol type="1"><li>资源类型<span class="math inline">\(R_1,R_2,...R_m\)</span><ol type="1"><li>CPU时钟、内存空间、I/O设备</li></ol></li><li>每个资源类型<span class="math inline">\(R_i\)</span>可以有<spanclass="math inline">\(W_i\)</span>个实例<ol type="1"><li>每种资源类型可以有多个实例</li><li>实例对应着实际能够分配的资源类型</li></ol></li><li>进程对资源的使用有以下三种类型<ol type="1"><li>Request 申请</li><li>Use 使用</li><li>Release 释放</li></ol></li></ol></li></ol><h2 id="死锁的特征">7.2 死锁的特征</h2><h3 id="产生死锁的4个必要条件">7.2.1 产生死锁的4个必要条件</h3><ol type="1"><li><strong>Mutual exclusion</strong>互斥：<ol type="1"><li>同一时间只有一个进程能够使用一个资源实例</li></ol></li><li><strong>Hold and wait</strong>占有并等待、请求和保持：<ol type="1"><li>进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放</li></ol></li><li><strong>No preemption</strong>不可抢占、不剥夺：<ol type="1"><li>资源只能由持有该资源的进程在该进程完成任务后自愿释放</li></ol></li><li><strong>Circular wait</strong>循环等待：<ol type="1"><li>存在一组{P<sub>0</sub>，P<sub>1</sub>，…，P<sub>n</sub>}等待进程，使得P<sub>0</sub>正在等待P<sub>1</sub>所持有的资源，P<sub>1</sub>正在等待P<sub>2</sub>持有的资源，…，P<sub>n–1</sub>正在等待P<sub>n</sub>持有的资源，P<sub>n</sub>正在等待P<sub>0</sub>持有的</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107153603565.png" alt="image-20221107153603565" style="zoom: 67%;" /></p><h3 id="资源分配图-resource-allocation-graph">7.2.2 资源分配图Resource-Allocation Graph</h3><ol type="1"><li><p>节点<span class="math inline">\(V\)</span>：</p><ol type="1"><li>进程节点：P = {P<sub>1</sub>, P<sub>2</sub>, …, P<sub>n</sub>}</li><li>资源节点：R = {R<sub>1</sub>, R<sub>2</sub>, …, R<sub>m</sub>}</li></ol></li><li><p>边<span class="math inline">\(E\)</span>：</p><ol type="1"><li>请求边：P<sub>i</sub> → R<sub>j</sub></li><li>分配边：R<sub>j</sub> → P<sub>i</sub></li></ol></li><li><p>节点&amp;边的图例</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107153842238.png" alt="image-20221107153842238" style="zoom: 67%;" /></p></li><li><p>例：</p><ol type="1"><li>P<sub>1</sub>获取了R<sub>2</sub>资源，请求R<sub>1</sub>的资源</li><li>P<sub>2</sub>获取了R<sub>1</sub>、R<sub>2</sub>资源，请求R<sub>3</sub>资源</li><li>P<sub>3</sub>获取了R<sub>3</sub>资源</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107153922149.png" alt="image-20221107153922149" style="zoom:67%;" /></p></li><li><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107154315836.png" alt="image-20221107154315836" style="zoom:80%;" /></p></li><li><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221107154449530.png" alt="image-20221107154449530" style="zoom:80%;" /></p></li><li><p>判断条件</p><ol type="1"><li>如果图中没有环 ==&gt; 没有死锁</li><li>如果图中有环<ol type="1"><li>如果每个资源只有一个实例 ==&gt; 死锁</li><li>如果每个资源拥有多个实例 ==&gt; 有可能死锁，也可能不死锁</li></ol></li></ol></li><li><p>死锁定理：</p><ol type="1"><li><span class="math inline">\(S\)</span>为死锁状态的充分条件是：<spanclass="math inline">\(S\)</span>状态的资源分配图是不可完全简化的</li><li>资源分配图（有向图）的简化：离散数学算法</li></ol></li></ol><h2 id="处理死锁的方法">7.3 处理死锁的方法</h2><ol type="1"><li>保证系统不进入死锁状态<ol type="1"><li>Prevention死锁预防</li><li>Avoidance死锁避免</li></ol></li><li>允许系统进入死锁状态，然后恢复<ol type="1"><li>Detection死锁检测</li><li>Recovery死锁解除</li></ol></li><li>忽略死锁状态，操作系统假装不发生死锁，人为解决死锁状态</li></ol><h2 id="死锁预防-deadlock-prevention">7.4 死锁预防 DeadlockPrevention</h2><ol type="1"><li>不保证相互排斥(<strong>Mutual Exclusion</strong>)<ol type="1"><li>不需要可共享资源；必须保留不可分割的资源</li><li>虚拟化</li></ol></li><li>不保证保持等待(<strong>Hold and Wait</strong>)<ol type="1"><li>必须确保无论进程何时请求资源，它都不会保留任何其他资源</li><li>要求进程在开始执行之前请求并分配其所有资源，或者仅当进程没有资源时才允许进程请求资源</li><li>资源静态预分配方式</li><li>资源利用率低；可能导致饥饿</li></ol></li><li>允许抢占(<strong>No Preemption</strong>)<ol type="1"><li>如果持有某些资源的进程请求另一个无法立即分配给它的资源，那么当前持有的所有资源都将被释放</li><li>抢占的资源将添加到进程正在等待的资源列表中</li><li>只有当进程能够重新获得它的旧资源以及它所请求的新资源时，它才会重新启动</li></ol></li><li>保证不出现循环等待(<strong>Circular Wait</strong>)<ol type="1"><li>给所有资源类型的编号，并要求每个进程以递增的顺序请求资源</li><li>F(磁带驱动器)=1，F(磁盘驱动器)=5，F(打印机)=12</li><li>资源的有序申请破坏了循环等待条件</li></ol></li></ol><h2 id="死锁避免-deadlock-avoidance">7.5 死锁避免 DeadlockAvoidance</h2><ol type="1"><li>要求每个进程声明其可能需要的每种类型的最大资源数量</li><li>死锁避免算法动态检查资源分配状态，以确保永远不会出现循环等待条件</li><li>资源分配状态由可用和已分配资源的数量以及进程的最大需求来定义</li></ol><h3 id="安全状态-safe-state">7.5.1 安全状态 Safe State</h3><ol type="1"><li><p>当进程请求可用资源时，系统必须决定立即分配是否使系统处于安全状态</p></li><li><p>安全状态是指系统的一种状态，在此状态开始系统能按某种顺序（如P<sub>1</sub>、P<sub>2</sub>……P<sub>n</sub>）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。</p><ol type="1"><li>这个序列（P<sub>1</sub>、P<sub>2</sub>…….P<sub>n</sub>）称为安全序列</li><li>若系统此状态不存在一个安全序列，则称系统处于不安全状态</li><li>如果存在所有进程的安全序列，则系统处于安全状态</li></ol></li><li><p>序列（P<sub>1</sub>、P<sub>2</sub>……P<sub>n</sub>）是安全的，满足：对于每个P<sub>i</sub>，P<sub>i</sub>仍然可以请求的资源，可以由<strong>当前可用资源+所有P<sub>j</sub>所持有的资源</strong>来满足，其中<strong>j＜i</strong>。</p><ol type="1"><li>如果P<sub>i</sub>资源需求不立即可用，则P<sub>i</sub>可以等到所有P<sub>j</sub>完成</li><li>当P<sub>j</sub>完成时，P<sub>i</sub>可以获得所需的资源、执行、返回分配的资源并终止</li><li>当P<sub>i</sub>终止时，P<sub>i+1</sub>可以获得其所需的资源，依此类推</li></ol></li><li><p>定理</p><ol type="1"><li>系统处于安全状态 ==&gt; 没有死锁</li><li>系统处于不安全状态 ==&gt; 可能死锁</li><li>死锁避免：保证系统不会进入不安全状态</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110165653047.png" alt="image-20221110165653047" style="zoom:50%;" /></p></li><li><p>避免算法</p><ol type="1"><li>每个资源只有一个实例：resource-allocation graph</li><li>每个资源有多个实例：banker’s algorithm</li></ol></li></ol><h3 id="resource-allocation-graph-algorithm-资源分配图算法">7.5.3Resource-Allocation Graph Algorithm 资源分配图算法</h3><ol type="1"><li><strong>需求边</strong>P<sub>i</sub>→R<sub>j</sub>：P<sub>i</sub>可能会请求资源R<sub>j</sub>，用虚线表示</li><li><strong>需求边</strong>转化为<strong>请求边</strong>：当且仅当该进程请求了该资源</li><li><strong>请求边</strong>转化为<strong>分配边</strong>：当且仅当资源被分配给了这个进程</li><li><strong>分配边</strong>转化为<strong>请求边</strong>：当且仅当资源被进程释放</li><li>资源必须在系统中声明优先级</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110171751275.png" alt="image-20221110171751275" style="zoom:80%;" /></p><ol type="1"><li>算法：假设进程P<sub>i</sub>申请资源R<sub>j</sub>。只有在需求边P<sub>i</sub>→R<sub>j</sub>变成分配边R<sub>j</sub>→P<sub>i</sub>而不会导致资源分配图形成环时，才允许申请。</li><li>用算法循环检测，如果没有环存在，那么资源分配会使系统处于安全状态。如果存在环，资源分配会使系统不安全。进程P<sub>i</sub>必须等待。</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110172013247.png" alt="image-20221110172013247" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110172028197.png" alt="image-20221110172028197" style="zoom:80%;" /></p><h3 id="bankers-algorithm-银行家算法">7.5.3 Banker’s Algorithm银行家算法</h3><ol type="1"><li>每个过程必须事先声明最大使用量</li><li>当进程请求资源时，它可能需要等待</li><li>当一个进程获得其所有资源时，它必须在有限的时间内返回这些资源</li><li>参数定义<ol type="1"><li><strong>n</strong>：进程数目</li><li><strong>m</strong>：资源的种类</li><li><strong>Available</strong>：长度为m的向量。如果Availabe[j]=k，表示R<sub>j</sub>有k个实例可以使用</li><li><strong>Max</strong>：n×m的矩阵。如果Max[i][j]=k，那么P<sub>i</sub>会申请至多k个R<sub>j</sub>资源</li><li><strong>Allocation</strong>：n×m的矩阵。如果Allocation[i][j]=k，那么P<sub>i</sub>已经申请了k个R<sub>j</sub>资源</li><li><strong>Need</strong>：n×m的矩阵。如果Need[i][j]=k，那么P<sub>i</sub>还需要k个R<sub>j</sub>资源来完成任务<ol type="1"><li>Need[i] [j] = Max[i] [j] - Allocation[i] [j]</li></ol></li></ol></li></ol><h4 id="safety-algorithm-安全算法">7.5.3.1 Safety Algorithm安全算法</h4><ol type="1"><li>令<strong>Work</strong>为一个长度为<strong>m</strong>的向量，<strong>Finish</strong>为一个长度为<strong>n</strong>的向量，初始化为：<ol type="1"><li>Work = Availabe</li><li>Finish[i] = { false }</li></ol></li><li>找到一个序号<strong>i</strong>，满足<ol type="1"><li>Finish[i] = false</li><li>Need[i] <span class="math inline">\(\le\)</span> Work</li><li>如果不存在，进入步骤4</li></ol></li><li><strong>Work = Work + Allocation[i]</strong><ol type="1"><li>Finish[i] = true</li><li>返回步骤2</li></ol></li><li>如果<strong>Finish = { true }</strong>，则系统已经在安全状态</li></ol><h4 id="resource-request-algorithm-资源-请求算法">7.5.3.2Resource-Request Algorithm 资源-请求算法</h4><p><strong>Request[i]</strong>：进程P<sub>i</sub>的请求向量，如果Request[i][j]=k，那么P<sub>i</sub>想要申请k个R<sub>j</sub>资源</p><ol type="1"><li><p>如果Request[i] <span class="math inline">\(\le\)</span>Need[i]，则进入步骤2。否则，引发错误条件，因为进程已超过其最大声明</p></li><li><p>如果Request[i] <span class="math inline">\(\le\)</span>Availabe，则进入步骤3。否则，P<sub>i</sub>必须等待，因为资源不能满足需求</p></li><li><p>通过如下修改状态，尝试将请求的资源分配给P<sub>i</sub></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Available = Available - Request[i];</span><br><span class="line">Allocation[i] = Allocation[i] + Request[i];</span><br><span class="line">Need[i] = Need[i] - Request[i];</span><br></pre></td></tr></table></figure><ol type="1"><li>调用<strong>Safety Algorithm</strong></li><li>如果安全，则可以分配给P<sub>i</sub></li><li>如果不安全，则P<sub>i</sub>必须等待，并恢复旧的资源分配状态</li></ol></li></ol><h4 id="例">7.5.3.3 例</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110174813937.png" alt="image-20221110174813937" style="zoom:80%;" /></p><ol type="1"><li><p>系统的状态（是否安全）？</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110174824533.png" alt="image-20221110174824533" style="zoom:80%;" /></th></tr></thead><tbody></tbody></table></li><li><p>P1的请求(1,0,2)是否通过？</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221114144616824.png" alt="image-20221114144616824" style="zoom:80%;" /></th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221114145030851.png" alt="image-20221114145030851" style="zoom: 80%;" /></td></tr></tbody></table></li><li><p>P4的请求(3,3,0)是否通过？</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221114150016856.png" alt="image-20221114150016856" style="zoom:80%;" /></th></tr></thead><tbody></tbody></table></li><li><p>P0的请求(0,2,0)是否通过？</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221114150041457.png" alt="image-20221114150041457" style="zoom:80%;" /></th></tr></thead><tbody><tr><tdstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221114150056267.png" alt="image-20221114150056267" style="zoom:80%;" /></td></tr></tbody></table></li></ol><h2 id="死锁检测-deadlock-detection">7.6 死锁检测 DeadlockDetection</h2><h3 id="每个资源只有一个实例">7.6.1 每个资源只有一个实例</h3><ol type="1"><li>维护一个等待图wait-for-graph：资源分配图的变形<ol type="1"><li>节点：进程</li><li>边：P<sub>i</sub>→P<sub>j</sub>表示P<sub>i</sub>正在等待P<sub>j</sub>释放资源</li></ol></li><li>定期调用检测图中是否存在环的算法</li><li>检测图中是否存在环的算法为O(n<sup>2</sup>)，其中n是图中顶点的数量</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221114151401765.png" alt="image-20221114151401765" style="zoom:80%;" /></p><h3 id="每个资源有多个实例">7.6.2 每个资源有多个实例</h3><ol type="1"><li>数据结构：<ol type="1"><li><strong>Available</strong>：长度为m的向量。如果Availabe[j]=k，表示R<sub>j</sub>有k个实例可以使用</li><li><strong>Allocation</strong>：n×m的矩阵。如果Allocation[i][j]=k，那么P<sub>i</sub>已经申请了k个R<sub>j</sub>资源</li><li><strong>Request</strong>：n×m的矩阵。如果Request[i][j]=k，那么P<sub>i</sub>正在申请k个R<sub>j</sub>资源</li></ol></li><li>检测算法：O(m×n<sup>2</sup>)<ol type="1"><li>令<strong>Work</strong>为一个长度为<strong>m</strong>的向量，<strong>Finish</strong>为一个长度为<strong>n</strong>的向量，初始化为：<ol type="1"><li>Work = Availabe</li><li>Finish[i] = { Allocation[k] [i]==0 ? true : false }</li></ol></li><li>找到一个序号<strong>i</strong>，满足<ol type="1"><li>Finish[i] = false</li><li>Request[i] <span class="math inline">\(\le\)</span> Work</li><li>如果不存在，进入步骤4</li></ol></li><li><strong>Work = Work + Allocation[i]</strong><ol type="1"><li>Finish[i] = true</li><li>返回步骤2</li></ol></li><li>如果存在<strong>Finish[i] ==false</strong>，则系统处于死锁状态，且是P<sub>i</sub>被死锁</li></ol></li></ol><h3 id="示例-4">7.6.3 示例</h3><ol type="1"><li><p>一共5个进程：P<sub>0</sub>~P<sub>4</sub>，3中资源：A(7个示例)、B(2个示例)、C(6个示例)</p></li><li><p>T<sub>0</sub>时的snapshot：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221114152426673.png" alt="image-20221114152426673" style="zoom:80%;" /></p><ol type="1"><li>执行序列：P<sub>0</sub>, P<sub>2</sub>, P<sub>3</sub>,P<sub>1</sub>, P<sub>4</sub></li></ol></li><li><p>T<sub>1</sub>时的snapshot：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221114152613665.png" alt="image-20221114152613665" style="zoom:80%;" /></p><ol type="1"><li>将P<sub>0</sub>执行结束后，无法执行P<sub>1</sub>~P<sub>4</sub>的任意一个进程，系统进入死锁状态</li><li>处于死锁状态的进程为P<sub>1</sub>~ P<sub>4</sub></li></ol></li></ol><h3 id="死锁检测算法的使用">7.6.4 死锁检测算法的使用</h3><ol type="1"><li>死锁检测算法的使用频率，取决于死锁发生的频率、希望有多少进程需要被回滚<ol type="1"><li>死锁发生的频率越高，死锁检测算法的使用频率越高</li><li>希望回滚的进程越少，死锁检测算法的使用频率越高</li></ol></li><li>如果随机调用检测算法，那么资源图中可能会有很多循环，因此我们将无法判断是哪个死锁进程“导致”了死锁</li></ol><h2 id="从死锁中恢复">7.7 从死锁中恢复</h2><ol type="1"><li>检测到死锁后采取措施：<ol type="1"><li>通知系统管理员</li><li>系统自己恢复</li></ol></li><li>打破死锁两种方法：<ol type="1"><li>进程终止</li><li>抢占资源</li></ol></li></ol><h3 id="进程终止-process-termination">7.7.1 进程终止 ProcessTermination</h3><ol type="1"><li>中止所有死锁进程</li><li>一次中止一个进程，直到消除死锁循环</li><li>许多因素可能决定选择哪种进程，包括：<ol type="1"><li>进程的优先级</li><li>这个进程计算了多长时间，还有多长时间才能完成</li><li>进程使用的资源</li><li>资源进程需要完成</li><li>需要终止多少进程</li><li>该进程是交互式的还是批处理的</li></ol></li></ol><h3 id="抢占资源-resource-preemption">7.7.2 抢占资源 ResourcePreemption</h3><ol type="1"><li>选择受害者：将成本降至最低最小化代价</li><li>回滚rollback： 返回到某个安全状态，从该状态重新启动进程。</li><li>饥饿starvation：同样的过程可能总是被选为受害者，包括成本因素中的回滚次数。</li></ol><h1 id="chapter-8main-memory">Chapter 8：Main Memory</h1><h2 id="background-1">8.1 Background</h2><ol type="1"><li>程序必须（从磁盘）放入内存，并放置在进程中才能运行</li><li>CPU只能直接访问主存储器和寄存器</li><li>寄存器访问的时间：1个CPU clock</li><li>主存储器访问的时间：需要很多周期</li><li>cache位于主内存和CPU寄存器之间</li><li>确保正确操作所需的内存保护</li></ol><h3 id="存储架构">8.1.1 存储架构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117163742987.png" alt="image-20221117163742987" style="zoom:80%;" /></p><h3 id="主存">8.1.2 主存</h3><p>基于冯·诺依曼体系结构，数据和程序指令存在于共享内存空间中</p><ol type="1"><li>程序重复执行以下内容：fetch-decode-execute</li><li>执行部分通常需要：数据获取和存储操作</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117163934518.png" alt="image-20221117163934518" style="zoom:80%;" /></p><h3 id="逻辑地址-vs-物理地址">8.1.3 逻辑地址 vs 物理地址</h3><ol type="1"><li><strong>Logicaladdress</strong>(逻辑地址，相对地址，虚地址)：generated by the CPU; alsoreferred to as virtual address<ol type="1"><li>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式。</li><li>其首地址为0，其余指令中的地址都相对于首地址来编址。</li><li>不能用逻辑地址在内存中读取信息。</li></ol></li><li><strong>Physical address</strong>(物理地址，绝对地址，实地址)：address seen by the memory unit<ol type="1"><li>内存中存储单元的地址。物理地址可直接寻址</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117164559398.png" alt="image-20221117164559398" style="zoom:80%;" /></p><h3 id="基址寄存器限长寄存器">8.1.4 基址寄存器、限长寄存器</h3><p>基址寄存器base register、限长寄存器limitregister：定义了逻辑内存空间</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117164654643.png" alt="image-20221117164654643" style="zoom:80%;" /></p><h3 id="将指令和数据与内存绑定">8.1.5 将指令和数据与内存绑定</h3><p>Addressbinding(地址绑定、地址映射、重定位)：指令和数据到内存地址的转换可以在三个不同的阶段进行</p><ol type="1"><li>编译时间：<ol type="1"><li>如果内存位置先验已知，则可以生成绝对代码</li><li>如果开始位置更改，则必须重新编译代码</li></ol></li><li>加载时间：<ol type="1"><li>如果编译时内存位置未知，则必须生成可<strong>重定位代码 relocatablecode</strong></li></ol></li><li>执行时间：<ol type="1"><li>如果进程在执行过程中可以从一个内存段移动到另一个内存，则绑定延迟到运行时</li><li>需要地址映射的硬件支持（如：Base and Limit Registers）</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117165240437.png" alt="image-20221117165240437" style="zoom:67%;" /></p><h3 id="memory-management-unit-mmu">8.1.6 Memory-Management Unit(MMU)</h3><ol type="1"><li>将虚拟地址映射到物理地址的硬件设备</li><li>在MMU方案中，重定位寄存器(relocationregister)中的值被添加到用户进程在发送到内存时生成的每个地址</li><li>用户程序处理逻辑地址；它永远看不到真实的物理地址</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117165947940.png" alt="image-20221117165947940" style="zoom:80%;" /></p><h3 id="dynamic-loading-动态载入">8.1.7 Dynamic Loading 动态载入</h3><ol type="1"><li>使用动态加载，进程启动时不会加载外部库<ol type="1"><li>库以可重定位的形式存储在磁盘上</li><li>仅在需要时将库加载到内存中</li></ol></li><li>更好的内存空间利用率；从未加载未使用的例程</li><li>当需要大量代码来处理不经常发生的情况时很有用</li><li>无需通过程序设计实现操作系统的特殊支持</li></ol><h3 id="dynamic-linking-动态链接">8.1.8 Dynamic Linking 动态链接</h3><ol type="1"><li>使用动态链接，可以将外部库预加载到（共享）内存中<ol type="1"><li>当进程调用库函数时，确定相应的物理地址</li></ol></li><li>一小段代码 (stub) 用于定位适当的内存驻留库例程</li><li>Stub用例程的地址替换自身，并执行例程</li><li>操作系统需要检查例程是否在进程的内存地址中</li><li>动态链接对库的调用特别有用</li><li>这种模式也称为共享库</li><li>Dynamically Linked Library 动态链接库</li></ol><h2 id="swapping-交换技术">8.2 Swapping 交换技术</h2><h3 id="交换技术">8.2.1 交换技术</h3><ol type="1"><li>进程可以临时从内存中交换到后备存储，然后再带回内存中继续执行</li><li>Backingstore备份存储：足够大的快速磁盘，可容纳所有用户的所有内存映像副本；必须提供对这些内存映像的直接访问<ol type="1"><li>Linux、UNIX-交换区</li><li>Windows-交换文件（pagefile.sys）</li></ol></li><li>Roll out，Roll in(调出，调进)<ol type="1"><li>用于基于优先级的调度算法的交换变量</li><li>低优先级进程被交换出去，以便可以加载和执行高优先级进程</li></ol></li><li>交换时间的主要部分是传输时间；总传输时间与交换的内存量成正比</li><li>在许多系统（如UNIX、Linux和Windows）上都可以找到经过修改的交换版本</li><li>系统维护一个准备好运行的进程队列，这些进程在磁盘上具有内存映像</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117171601893.png" alt="image-20221117171601893" style="zoom:80%;" /></p><h3 id="不同操作系统的swapping">8.2.2 不同操作系统的Swapping</h3><ol type="1"><li>UNIX, Linux, and Windows：<ol type="1"><li>正常情况下，禁止交换</li><li>当空闲内存低于某一个阈值时，启用交换换出</li><li>当空闲内存增加一定数量时，停止换出</li></ol></li><li>移动系统不支持交换，Flash memory based：<ol type="1"><li>小空间</li><li>闪存写次数限制</li><li>在移动平台上闪存和CPU之间的吞吐量很低</li></ol></li><li>iOS要求应用程序自愿放弃分配的内存<ol type="1"><li>只读数据从系统中直接删除，已修改数据不会被删除</li><li>OS可以终止任何未能释放足够空间的应用</li></ol></li><li>Android如果空闲内存不足，会终止应用程序，但首先会将应用程序状态写入闪存，以便快速重启</li></ol><h2 id="contiguous-allocation-连续分配">8.3 Contiguous Allocation连续分配</h2><h3 id="连续分配">8.3.1 连续分配</h3><ol type="1"><li>主内存通常分为两个分区(分区):<ol type="1"><li>Resident operatingsystem常驻操作系统：通常保存在具有中断向量的低内存中</li><li>User processes用户进程：保存在高内存中</li></ol></li><li>Relocation registers重新定位寄存器：用于保护用户进程彼此不受影响，以及防止操作系统代码和数据发生变化<ol type="1"><li>Base register基址寄存器：包含最小物理地址的值</li><li>Limitregister限制寄存器：包含逻辑地址范围–每个逻辑地址必须小于限制寄存器</li><li>MMU动态映射逻辑地址</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117172600963.png" alt="image-20221117172600963" style="zoom:67%;" /></p><h3 id="multiple-partition-allocation-多分区分配">8.3.2Multiple-partition allocation 多分区分配</h3><p>分区式管理的基本思想是将内存划分成若干个连续区域，称为分区。每个分区只能存放一个进程</p><h4 id="fixed-partitioning-固定分区">8.3.2.1 Fixed Partitioning固定分区</h4><ol type="1"><li>预先将内存空间切分成多个分区，当进程需要分区时，将一个大小匹配的分区分配给它</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117173040646.png" alt="image-20221117173040646" style="zoom:67%;" /></p><h4 id="dynamic-partitions-动态分区">8.3.2.2 Dynamic Partitions动态分区</h4><ol type="1"><li><p>动态划分内存，在程序装入内存时把可用内存“切出”一个连续的区域分配给该进程，且分区大小正好适合进程的需要</p></li><li><p>操作系统需要维护的信息包括：</p><ol type="1"><li>allocated partitions 已分配的分区</li><li>free partitions (hole) 空闲的分区</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117173241390.png" alt="image-20221117173241390" style="zoom:80%;" /></p></li><li><p>如何满足free holes列表中大小为n的请求</p><ol type="1"><li><p><strong>First-Fit</strong>：找到第一个能够满足要求的hole</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117173822733.png" alt="image-20221117173822733" style="zoom:67%;" /></p></li><li><p><strong>Best-Fit</strong>：找到能够满足要求的、最小的hole</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117173855252.png" alt="image-20221117173855252" style="zoom:67%;" /></p></li><li><p><strong>Worst-Fit</strong>：找到能够满足要求的、最大的hole</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117174055187.png" alt="image-20221117174055187" style="zoom: 67%;" /></p></li><li><p><strong>Next-Fit</strong>：从上次查找结束的地方开始，找到第一个能够满足要求的hole</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117174216889.png" alt="image-20221117174216889" style="zoom:67%;" /></p></li></ol></li></ol><h3 id="fragmentation-碎片">8.3.3 Fragmentation 碎片</h3><ol type="1"><li><p>内存因碎片而浪费，这可能会导致性能问题</p><ol type="1"><li>Internalfragmentation(内碎片、内零头)：在单个进程内存空间中浪费内存</li><li>External fragmentation(外碎片、外零头)：可能会减少可运行进程的数量<ol type="1"><li>总内存剩余空间可以满足要求，但由于内存空间不连续，导致程序不能运行</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117174441628.png" alt="image-20221117174441628" style="zoom:80%;" /></p></li><li><p>通过压缩或整理碎片减少外部碎片(compaction or defragmentation）</p><ol type="1"><li>重新排列内存内容，将所有可用内存块组织在一个大块中</li><li>只有当重新定位是动态的并且在执行时完成时，才能进行压缩</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117174612719.png" alt="image-20221117174612719" style="zoom:80%;" /></p></li></ol><h2 id="paging-分页页式存储管理">8.4 Paging 分页，页式存储管理</h2><h3 id="paging">8.4.1 Paging</h3><ol type="1"><li>进程的物理地址空间可能是不连续的；只要物理内存可用，就为进程分配物理内存</li><li>将<strong>物理内存</strong>划分为固定大小的块，称为<strong>frames</strong>(帧、物理块、页框)<ol type="1"><li>大小为2的整数次幂，介于512 bytes和8192 bytes之间</li><li>Linux、Windows for x86：4K</li></ol></li><li>将<strong>逻辑内存</strong>分成与帧大小相同的块，称为<strong>pages</strong>(页）</li><li>使用paging的模式<ol type="1"><li>跟踪所有空闲帧</li><li>要运行n pages大小的程序，需要找到n个空闲的frames，然后加载程序<ol type="1"><li>如果找不到，可以使用swap技术，将一部分程序放进内存，另一部分程序放入swap区</li></ol></li><li>设置<strong>page table</strong>(页表)，将逻辑地址转换为物理地址<ol type="1"><li>page table 列出了进程的逻辑页与其在主存中的物理帧间的对应关系</li></ol></li></ol></li><li>会存在Internal fragmentation</li></ol><h3 id="noncontiguous-allocation-非连续内存分配">8.4.2 NoncontiguousAllocation 非连续内存分配</h3><ol type="1"><li>当一个进程需要n个page运行时，操作系统会找到n个空闲的frame</li><li>操作系统通过一个page table，跟踪页的使用</li><li>一般情况下，最后一个page都无法用满，但是系统依旧会给它分配一个frame<ol type="1"><li>会导致Internal fragmentation</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121144118808.png" alt="image-20221121144118808" style="zoom:80%;" /></p><h3 id="逻辑和物理内存的分页模型">8.4.3 逻辑和物理内存的分页模型</h3><ol type="1"><li><p>page table将逻辑内存地址映射到物理内存地址</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121144326270.png" alt="image-20221121144326270" style="zoom:67%;" /></p></li><li><p>例：进程<spanclass="math inline">\(P_i\)</span>需要16字节的逻辑内存</p><ol type="1"><li>逻辑内存通过页面表映射到32字节内存，页面大小为4字节</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121144532110.png" alt="image-20221121144532110" style="zoom:67%;" /></p></li></ol><h3 id="address-translation-scheme-地址变换">8.4.4 Address TranslationScheme 地址变换</h3><ol type="1"><li><p>CPU生成的地址分为：</p><ol type="1"><li>pagenumber(p)页号：用作页表的索引，该页表包含物理内存中每个页的基地址</li><li>pageoffset(d)偏移：与基地址相结合以定义发送到存储器单元的物理存储器地址</li></ol></li><li><p>若page size = 2<sup>n</sup>，地址空间为2<sup>m</sup>，则地址可以分为：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121145047525.png" alt="image-20221121145047525" style="zoom:67%;" /></p></li><li><p>Paging Hardware</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121145916777.png" alt="image-20221121145916777" style="zoom: 67%;" /></p></li><li><p>页面大小为4KB，虚地址2362H、1565H的物理地址分别是？页表如下</p><table><thead><tr><th style="text-align: center;">页号</th><th style="text-align: center;">页框 (Page Frame)号</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">101H</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">102H</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">254H</td></tr></tbody></table><ol type="1"><li>4KB=1000H</li><li>逻辑地址2362H对应的页号为2，254000H+362H = 254362H</li><li>逻辑地址1565H对应的页号为1，102000H+565H = 102565H</li></ol></li></ol><h3 id="page-table的实现">8.4.5 Page Table的实现</h3><ol type="1"><li>页表保存在Main Memory中</li><li>页表基寄存器(<strong>PTBR</strong>, Page-table baseregister)：指向页表，x86:cr3</li><li>页表长度寄存器(<strong>PTLR</strong>, Page-table length register)：表示页表的大小</li><li>在该方案中，每个数据/指令访问都需要两次memory访问<ol type="1"><li>一个用于页表</li><li>一个用于数据/指令</li></ol></li><li>两次内存访问可以通过使用cache来加速，该cache被称为联想寄存器、快表<ol type="1"><li>associative memory</li><li>TLB：translation look-aside buffers</li></ol></li><li>一些TLB在每个TLB条目中存储地址空间标识符(ASID, address-spaceidentifiers)：唯一标识每个进程，为该进程提供地址空间保护</li></ol><h3 id="associative-memory">8.4.6 Associative Memory</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121152152896.png" alt="image-20221121152152896" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121152437668.png" alt="image-20221121152437668" style="zoom:67%;" /></p><ol type="1"><li>并行查找：Address translation(p, d)<ol type="1"><li>如果p在Associative Memory中，则取出帧#</li><li>否则，从内存中的页表获取帧#</li></ol></li></ol><h3 id="effective-access-time-有效访问时间">8.4.7 Effective Access Time有效访问时间</h3><ol type="1"><li>快表访问时间：Associative Lookup = <spanclass="math inline">\(\epsilon\)</span> time unit</li><li>内存访问时间：memory cycle time = <spanclass="math inline">\(t\)</span><br /></li><li>命中率：Hit ratio = <span class="math inline">\(\alpha\)</span></li><li>有效访问时间：EAT = <spanclass="math inline">\((t+\epsilon)\alpha+(t+t+\epsilon)(1-\alpha)\)</span></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121153123328.png" alt="image-20221121153123328" style="zoom:80%;" /></p><h3 id="memory-protection-内存保护">8.4.8 Memory Protection内存保护</h3><ol type="1"><li>通过将保护位与每个帧相关联来实现内存保护</li><li>Valid-invalid bit 附加到页表中每个条目：<ol type="1"><li>“valid”表示关联页面位于进程的逻辑地址空间中，因此是合法页面</li><li>“invalid”表示页面不在进程的逻辑地址空间中</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121153531892.png" alt="image-20221121153531892" style="zoom:67%;" /></p><h3 id="共享页面">8.4.9 共享页面</h3><ol type="1"><li>共享代码<ol type="1"><li>进程之间共享的只读代码的一个副本。</li><li><strong>共享代码</strong>必须出现在所有进程的<strong>逻辑地址空间中的同一位置</strong></li></ol></li><li>私有代码和数据<ol type="1"><li>每个进程都保留代码和数据的单独副本</li><li>私有代码和数据的页面可以出现在逻辑地址空间的任何位置</li></ol></li><li>重新输入代码(重入代码)、 纯代码(纯代码)</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121153744348.png" alt="image-20221121153744348" style="zoom:80%;" /></p><h3 id="page-table的数据结构">8.4.10 Page Table的数据结构</h3><h4 id="分级页表-hierarchical-paging">8.4.10.1 分级页表 HierarchicalPaging</h4><ol type="1"><li><p>x86的逻辑地址空间有2<sup>32</sup>Byte，如页面大小为4KB（2<sup>12</sup>Byte），则页表项最多有1M（2<sup>20</sup>）个，每个页表项占用4Byte，故每个进程的页表占用4MB内存空间，还要求是连续的，显然这是不现实的。</p></li><li><p>将逻辑地址空间分解为多个页表</p><ol type="1"><li>一种简单的技术是两级页表</li><li>Linux：四级页表</li><li>Windows：两级页表</li></ol></li><li><p>两级页表</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121154658709.png" alt="image-20221121154658709" style="zoom:67%;" /></p></li><li><p>两级页表示例：</p><ol type="1"><li><p>逻辑地址（在具有4K页面大小的32位机器上）分为：</p><ol type="1"><li>20-bit page number</li><li>12-bit page offset</li></ol></li><li><p>由于页表是分页的，页码进一步分为：</p><ol type="1"><li>10-bit page number</li><li>10-bit page offset</li></ol></li><li><p>因此，逻辑地址如下：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221121154943437.png" alt="image-20221121154943437" style="zoom:50%;" /></p></li><li><p>其中p<sub>1</sub>是outer page table的索引，p<sub>2</sub>是page ofthe page table的偏移量</p></li></ol></li><li><p>地址转换模式：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124162941866.png" alt="image-20221124162941866" style="zoom:67%;" /></p></li><li><p>三级Page</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124163748171.png" alt="image-20221124163748171" style="zoom:67%;" /></p></li></ol><h4 id="哈希页表-hashed-page-tables">8.4.10.2 哈希页表 Hashed PageTables</h4><ol type="1"><li>通常情况下，地址空间&gt;32位</li><li>虚拟页码被hash到页表中<ol type="1"><li>此页表包含hash到同一位置的元素链</li></ol></li><li>在此链中比较虚拟页码以搜索匹配项<ol type="1"><li>如果找到匹配，则提取相应的物理帧</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124164131844.png" alt="image-20221124164131844" style="zoom:80%;" /></p><h4 id="反向反置页表-inverted-page-table">8.4.10.3 反向(反置)页表Inverted Page Table</h4><ol type="1"><li>每个进程均有一个页表，想要让所有进程共享一个页表</li><li>每个进程自己的page number都是从0开始，但是所有进程的pagenumber均会映射到唯一的frame number</li><li>在Inverted Page Table中，索引对应物理内存中的framenumber，值对应进程+virtual number</li><li>进程在找frame时，需要遍历Inverted Page Table，十分耗时</li><li>通过hash table降低遍历所需时间</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124164727384.png" alt="image-20221124164727384" style="zoom:80%;" /></p><h2 id="segmentation-分段段式管理">8.5 Segmentation 分段，段式管理</h2><blockquote><p>将同一类别的数据，放到对应大小的连续的内存空间</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124165904816.png" alt="image-20221124165904816" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124170112955.png" alt="image-20221124170112955" style="zoom:80%;" /></p><h3 id="segmentation-architecture">8.5.1 Segmentation Architecture</h3><ol type="1"><li><p>逻辑地址分为两个部分：段号+段内地址</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124170223059.png" alt="image-20221124170223059" style="zoom:80%;" /></p></li><li><p><strong>Segmenttable</strong>(段表)：映射二维物理地址；每个entry具有：</p><ol type="1"><li><strong>base</strong>：包含段在内存中的起始物理地址</li><li><strong>limit</strong>：指定段的长度</li></ol></li><li><p><strong>Segment-table baseregister(STBR)</strong>段表基址寄存器：指向段表在内存中的位置</p></li><li><p><strong>Segment-table lengthregister(STLR)</strong>段表限长寄存器：指示程序使用的段数；</p><ol type="1"><li>如果<strong>s&lt;STLR</strong>，则段号s合法</li></ol></li><li><p>保护：</p><ol type="1"><li>Segment table中的每一个entry都会包含：<ol type="1"><li>有效位 validation bit：为0时表示该segment无效</li><li>读/写/执行 权限</li></ol></li><li>保护位与段相关；代码共享发生在段级别</li><li>由于段的长度不同，内存分配是一个动态存储分配问题</li><li>下图显示了一个分段示例</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124170509111.png" alt="image-20221124170509111" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124170958507.png" alt="image-20221124170958507" style="zoom:80%;" /></p><h2 id="example-the-intel-pentium">8.6 Example: The Intel Pentium</h2><ol type="1"><li>支持分段和分页分段</li><li>CPU生成逻辑地址<ol type="1"><li>给分段单元<ol type="1"><li>产生线性地址</li></ol></li><li>将线性地址给到paging unit<ol type="1"><li>在主内存中生成物理地址</li><li>paging units相当于MMU</li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124172249080.png" alt="image-20221124172249080" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124172256488.png" alt="image-20221124172256488" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124172318435.png" alt="image-20221124172318435" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124172324503.png" alt="image-20221124172324503" style="zoom:80%;" /></p><h1 id="chapter-9virtual-memory">Chapter 9：Virtual Memory</h1><h2 id="background-2">9.1 Background</h2><h4 id="virtual-memory">9.1.1 Virtual Memory</h4><ol type="1"><li>Virtual Memory：只有运行程序的一部分需要加载到内存中执行<ol type="1"><li>虚拟内存将用户逻辑内存与物理内存分开</li><li>逻辑（或虚拟）地址空间可以大于物理地址空间</li><li>允许多个进程共享物理地址空间</li><li>实现更快的流程创建</li></ol></li><li>Virtual Memory的实现方法：<ol type="1"><li>Demand paging （请求调页，按需调页，请求页式管理）</li><li>0Demand segmentation（请求段式管理）</li></ol></li></ol><h3 id="局部性原理">9.1.2 局部性原理</h3><ol type="1"><li><strong>局部性原理</strong>(principle oflocality)：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。表现为：<ol type="1"><li><strong>时间局部性</strong>：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内</li><li><strong>空间局部性</strong>：当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内</li></ol></li><li><strong>虚拟存储器</strong>是具有请求调入功能和置换功能，能仅把进程的一部分装入内存便可运行进程的存储管理系统，它能从逻辑上对内存容量进行扩充的一种虚拟的存储器系统</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128142639363.png" alt="image-20221128142639363" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128142607160.png" alt="image-20221128142607160" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128142621439.png" alt="image-20221128142621439" style="zoom:80%;" /></p><h2 id="demand-paging按需调页请求调页">9.2 DemandPaging：按需调页、请求调页</h2><h3 id="demand-paging">9.2.1 Demand Paging</h3><ol type="1"><li>仅在需要时将页面放入内存<ol type="1"><li>所需I/O更少</li><li>所需内存更少</li><li>更快的响应</li><li>更多用户</li></ol></li><li>需要页面 → 对它的引用<ol type="1"><li>无效的引用 → abort</li><li>不在内存中 → bring to memory</li></ol></li><li>Lazy swapper：除非需要页面，否则永远不要将页面交换到内存中<ol type="1"><li>处理页面的swapper是一个pager</li></ol></li></ol><blockquote><p>Transfer of a Paged Memory to Contiguous Disk Space</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128142844807.png" alt="image-20221128142844807" style="zoom:80%;" /></p><h3 id="valid-invalid-bit">9.2.2 Valid-Invalid Bit</h3><ol type="1"><li><p>每个页表条目都有一个Valid-Invalid Bit：v → 在内存中，i →不在内存中</p></li><li><p>初始化：所有条目上的Valid-Invalid Bit设置为i</p></li><li><p>页表快照示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128143549825.png" alt="image-20221128143549825" style="zoom:80%;" /></p></li><li><p>在地址转换期间，如果页表条目中的Valid-Invalid Bit为i → pagefault</p></li></ol><blockquote><p>Page Table When Some Pages Are Not in Main Memory</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128143601069.png" alt="image-20221128143601069" style="zoom:80%;" /></p><h3 id="更完整的页表">9.2.3 更完整的页表</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128143658452.png" alt="image-20221128143658452" style="zoom:80%;" /></p><ol type="1"><li>在请求分页系统中的每个页表项如图所示：<ol type="1"><li><strong>状态位P</strong>(存在位)：用于指示该页是否已调入内存，供程序访问时参考</li><li><strong>访问字段A</strong>：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选换出页时参考。</li><li><strong>修改位R/W</strong>：表示该页在调入内存后是否被修改过</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址，供调入该页时使用</li></ol></li></ol><h3 id="page-fault缺页">9.2.4 Page Fault：缺页</h3><p>如果存在对页面的引用，则对该页面的第一次引用将会产生：PageFault(缺页)</p><ol type="1"><li>操作系统查看另一个表以决定：<ol type="1"><li>无效的引用 → abort</li><li>仅仅是不在内存中</li></ol></li><li>获取空帧</li><li>将page交换进frame</li><li>重置表格</li><li>设置Valid-Invalid Bit = v</li><li>重新启动导致页面错误的指令</li></ol><blockquote><p>Steps in Handling a Page Fault</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128144328745.png" alt="image-20221128144328745" style="zoom:80%;" /></p><h3 id="demand-paging-performance">9.2.5 Demand Paging Performance</h3><ol type="1"><li><p><strong>page fault rate</strong> p：</p><ol type="1"><li>p=0.0：没有page fault</li><li>p=1.0：所有page均发生page fault</li><li>通常p很小</li></ol></li><li><p><strong>effective memory-accesstime</strong>：<strong>EAT</strong></p><ol type="1"><li>(1-p) × physical-memory-access + p × page-fault service time</li></ol></li><li><p><strong>page-fault service time</strong>：</p><ol type="1"><li>page-fault-overhead + swap-page-out + swap-page-in +restart-overhead</li></ol></li><li><p>要计算EAT，我们必须知道需要多少时间来处理page fault。pagefault导致以下操作顺序发生：</p><ol type="1"><li>操作系统发生trap</li><li>保存用户寄存器和进程状态</li><li>确定中断是page fault</li><li>检查页面引用是否合法，并确定页面在磁盘上的位置</li><li>向空闲帧发出磁盘读取请求：<ol type="1"><li>在队列中等待设备，直到读取请求得到服务</li><li>等待设备查找时间和延迟时间</li><li>开始将page转移到free frame</li></ol></li><li>等待时，将CPU分配给其他用户（CPU调度，可选）</li><li>从磁盘中断（I/O完成）</li><li>为其他用户保存寄存器和进程状态（如果执行步骤6）</li><li>确定中断来自磁盘</li><li>更正页面表和其他表，以显示所需页面现在已在内存中</li><li>等待CPU再次分配给此进程</li><li>恢复用户寄存器、进程状态和新页表，然后恢复中断指令</li></ol></li><li><p>page-fault service time中的三个主要的部分</p><ol type="1"><li>Service the page-fault interrupt：缺页中断服务时间</li><li>Read in the page：将缺页读入时间</li><li>Restart the process：重新启动进程时间</li></ol></li><li><p>示例：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128145139548.png" alt="image-20221128145139548" style="zoom:80%;" /></p></li></ol><h2 id="process-creation">9.3 Process Creation</h2><ol type="1"><li>虚拟内存在进程创建过程中提供了其他好处：Copy-on-Write写时拷贝</li><li>Copy-on-Write写时拷贝：允许父进程和子进程最初共享内存中的相同页面。如果任何一个进程修改了共享页面，则只复制该页面<ol type="1"><li>COW允许更高效的流程创建，因为只复制修改过的页面</li><li>可用页面是从一个清零页面池中分配的</li><li>Windows、Linux、Solaris</li></ol></li></ol><blockquote><p>Before Process 1 Modifies Page C</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128150404451.png" alt="image-20221128150404451" style="zoom:80%;" /></p><blockquote><p>After Process 1 Modifies Page C</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128150424447.png" alt="image-20221128150424447" style="zoom:80%;" /></p><h2 id="page-replacement-页面置换">9.4 Page Replacement 页面置换</h2><h3 id="page-replacement">9.4.1 Page Replacement</h3><p>如果没有free frame：</p><ol type="1"><li>Page Replacement：在内存中找到一些页面，但没有真正使用，请将其替换<ol type="1"><li>算法</li><li>性能：需要寻找一个可能导致page fault最少的算法</li></ol></li><li>同一页可能会多次进入内存</li><li>通过修改 page-fault service routine以实现页面替换，防止内存过度分配</li><li>使用<strong>modify(dirty)</strong>位减少页面传输的开销：只有修改过的页面才会写入磁盘</li><li>页面替换完成了逻辑内存和物理内存之间的分离：可以在较小的物理内存上提供较大的虚拟内存</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128150907676.png" alt="image-20221128150907676" style="zoom:80%;" /></p><h3 id="页面置换的过程">9.4.2 页面置换的过程</h3><ol type="1"><li>在磁盘上查找所需页面的位置</li><li>查找空闲帧：<ol type="1"><li>如果有空闲帧，请使用它</li><li>如果没有空闲帧，则使用页面替换算法选择victim frame</li><li>将victim page写入磁盘；相应地更改页面和框架表。</li></ol></li><li>将所需页面放入（新的）free frame；更新页面和框架表</li><li>重新启动流程</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128152032875.png" alt="image-20221128152032875" style="zoom:80%;" /></p><h3 id="页面置换的算法">9.4.3 页面置换的算法</h3><ol type="1"><li><p>希望page-fault rate最低</p></li><li><p>通过在一个特定的内存引用字符串(referencestring，引用串)并计算该字符串上的页面错误数，来判断算法的优劣</p></li><li><p>reference string：（每页100字节）</p><blockquote><p>0100, 0432, 0101, 0612, 0102, 0103, 0104, 0611, 0120</p><p>→ 1, 4, 1, 6, 1, 6, 1</p></blockquote></li><li><p>在我们的所有示例中，reference string为：</p><blockquote><p>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</p><p>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</p></blockquote></li><li><p>一般来说，帧数越多，page fault越小</p></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128152212443.png" alt="image-20221128152212443" style="zoom:80%;" /></p><p>页面置换算法：</p><ol type="1"><li>First-In-First-OutAlgorithm：<strong>FIFO</strong>，先进先出算法</li><li>Optimal Algorithm：<strong>OPT</strong>，最佳页面置换算法</li><li>Least Recently UsedAlgorithm：<strong>LRU</strong>，最近最少使用算法</li><li>LRU Approximation Algorithms ：<strong>近似LRU算法</strong><ol type="1"><li>Additional-Reference-Bits Algorithm</li><li>Second-Chance（clock） Algorithm</li><li>Enhanced Second-Chance Algorithm</li></ol></li><li>Counting-Base Page Replacement：<ol type="1"><li>Least Frequently UsedAlgorithm：<strong>LFU</strong>，最不经常使用算法</li><li>Most Frequently UsedAlgorithm：<strong>MFU</strong>，引用最多算法00000000000000000000000000</li></ol></li><li>Page Buffering Algorithm：页面缓冲算法</li></ol><h4 id="fifo算法">9.4.3.1 FIFO算法</h4><ol type="1"><li>先进先出算法</li><li><strong>Belady’s Anomaly</strong>：更多的帧反而导致更多的pagefault</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128152501463.png" alt="image-20221128152501463" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128152640303.png" alt="image-20221128152640303" style="zoom:80%;" /></p><h4 id="optimal-page-replacement">9.4.3.2 Optimal Page Replacement</h4><ol type="1"><li><strong>OPT</strong>(最佳页面置换算法)：选择距离下次使用最远的page进行替换</li><li>理论最优，但是实际情况中很难判断哪个page距离下次使用最远</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128152939195.png" alt="image-20221128152939195" style="zoom:80%;" /></p><h4 id="lru算法">9.4.3.3 LRU算法</h4><ol type="1"><li><p><strong>LRU</strong>(最近最少使用算法)：选择内存中<strong>最久没有引用</strong>的页面被置换</p><ol type="1"><li>这是局部性原理的合理近似，性能接近最佳算法</li><li>但由于需要记录页面使用时间，硬件开销太大</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128153815218.png" alt="image-20221128153815218" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128154107099.png" alt="image-20221128154107099" style="zoom:80%;" /></p></li><li><p>如何获知“多长时间没引用”？</p><ol type="1"><li>counter实现<ol type="1"><li>每个页面条目都有一个计数器；每次通过该条目引用页面时，将clock复制到计数器中</li><li>当需要更改页面时，查看计数器以确定要更改的页面</li></ol></li><li>stack实现：以双向链表形式保存页码堆栈<ol type="1"><li><p>引用的页面：</p><ol type="1"><li>将其移至顶部</li><li>需要更改6个指针</li></ol></li><li><p>不搜索替换</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221128154413987.png" alt="image-20221128154413987" style="zoom:67%;" /></p></li></ol></li></ol></li></ol><h4 id="lru-approximation-algorithms">9.4.3.4 LRU ApproximationAlgorithms</h4><p><strong>Reference bit</strong></p><ol type="1"><li>每个页表条目关联一个位，初始值为0</li><li>当页面被引用时，Reference bit设置为1</li><li>替换Reference bit为0的页（如果存在）</li><li>然而，我们不知道页被访问的顺序</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201163509642.png" alt="image-20221201163509642" style="zoom:80%;" /></p><h5 id="additional-reference-bits-algorithm">9.4.3.4.1Additional-Reference-Bits Algorithm</h5><p>附加引用位算法：</p><ol type="1"><li>为内存中的表中的每一页保留8位字节</li><li>每隔一段时间（每100毫秒），timer中断将控制权转移到OS<ol type="1"><li>OS将每个页面的ReferenceBit移到其8位字节的最高位，将其他位右移1位，丢弃低位</li><li>这些8位字节包含过去8个clock的页面使用历史</li></ol></li><li>如果我们将这些8位字节解释为无符号整数，则编号最低的页面是LRU页面，可以替换</li><li>被访问时左边<strong>最高位置1</strong>，<strong>定期右移</strong>并且最高位补0，于是<strong>寄存器数值最小</strong>的是最久未使用页面。</li></ol><h5 id="second-chance-clock-algorithm">9.4.3.4.2 Second-Chance (clock)Algorithm</h5><p>Second chance(clock算法)：</p><ol type="1"><li>需要Reference Bit</li><li>循环替换</li><li>如果要替换的页面(按顺时钟顺序)的Reference Bit=1，则：<ol type="1"><li>将Reference Bit设置为0</li><li>将页面留在内存中</li><li>替换下一页(按顺时钟顺序)，遵循相同规则</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201164212728.png" alt="image-20221201164212728" style="zoom:80%;" /></p><h5 id="enhanced-second-chance-algorithm">9.4.3.4.3 EnhancedSecond-Chance Algorithm</h5><p>增强二次机会算法（改进型的clock算法）</p><ol start="2" type="1"><li>使用引用位和修改位：引用过或修改过置成1</li><li>(Reference bit, modified bit) ：<ol type="1"><li>(0,0)：最优先需要被替换的页</li><li>(0,1)：也可以被替换，但不如上一种更优</li><li>(1,0)：可能会马上被使用</li><li>(1,1)：最不应该被替换的页</li></ol></li><li>淘汰次序：(0,0) → (0,1) → (1,0) → (1,1)</li></ol><h4 id="counting-algorithm">9.4.3.5 Counting Algorithm</h4><ol type="1"><li>记录每页的引用次数</li><li>LFU(Least Frequently Used) Algorithm(最不经常使用算法)：替换被引用次数最少的页面</li><li>MFU(Most Frequently Used) Algorithm(经常使用算法)：被引用次数最小的页面可能刚刚被引入，尚未被使用</li></ol><h4 id="page-buffering-algorithm-页面缓冲算法">9.4.3.6 Page BufferingAlgorithm 页面缓冲算法</h4><p>页面缓冲算法：通过被置换页面的缓冲，有机会找回刚被置换的页面</p><ol type="1"><li>被置换页面的选择和处理：用FIFO算法选择被置换页，把被置换的页面放入两个链表之一。即：如果页面未被修改，就将其归入到<strong>空闲页面链表</strong>的末尾，否则将其归入到<strong>已修改页面链表</strong></li><li>需要调入新的页面时，将新页面内容读入到空闲页面链表的第一项所指的页面，然后将第一项删除</li><li>空闲页面和已修改页面，仍停留在内存中一段时间，如果这些页面被再次访问，这些页面还在内存中</li><li>当已修改页面达到一定数目后，再将它们一起调出到外存，然后将它们归入空闲页面链表</li></ol><h2 id="allocation-of-frames-帧分配">9.5 Allocation of Frames帧分配</h2><h3 id="fixed-allocation-固定分配">9.5.1 Fixed Allocation 固定分配</h3><ol type="1"><li>Equal allocation 平均分配法：将帧平均分配给每个进程</li><li>Proportional allocation 按比例分配法：根据进程的大小按比例分配</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201170031536.png" alt="image-20221201170031536" style="zoom: 50%;" /></p><h3 id="priority-allocation-优先级分配">9.5.2 Priority Allocation优先级分配</h3><ol type="1"><li>根据进程的优先级，按比例分配</li><li>如果进程P<sub>i</sub>发生了page fault<ol type="1"><li>选择P<sub>i</sub>自己的一个帧进行替换</li><li>选择比P<sub>i</sub>优先级低的一个进程的一个帧进行替换</li></ol></li></ol><h3 id="global-vs.-local-allocation">9.5.3 Global vs. LocalAllocation</h3><p>置换策略：</p><ol type="1"><li>Global replacement全局置换：进程从所有帧的集合中选择替换帧；一个进程可以从另一个进程获取帧</li><li>Local replacement局部置换：每个进程仅从其自己的一组分配帧中进行选择</li></ol><p>分配策略：</p><ol type="1"><li>固定分配</li><li>可变分配</li></ol><h3 id="帧的分配和置换策略">9.5.4 帧的分配和置换策略</h3><p>组合成三种策略：</p><ol type="1"><li>固定分配局部置换策略</li><li>可变分配全局置换策略</li><li>可变分配局部置换策略</li></ol><h2 id="thrashing-颠簸抖动">9.6 Thrashing 颠簸、抖动</h2><ol type="1"><li>如果一个进程没有足够的page，则page-fault rate会很高，会导致：<ol type="1"><li>很低的CPU利用率</li><li>误导OS以为有必要提高多任务的程度</li><li>误导OS装入更多作业，内存中驻留更多进程</li><li>于是，每个进程拥有的页帧数更少</li><li>如此恶性循环，会怎样 ？</li></ol></li><li>Thrashing = a process is busy swapping pages in and out</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201171543293.png" alt="image-20221201171543293" style="zoom:80%;" /></p><h3 id="demand-paging-and-thrashing">9.6.1 Demand Paging andThrashing</h3><ol type="1"><li>为什么会有demand page work：局部性原理<ol type="1"><li>进程从一个位置迁移到另一个位置</li><li>地点可能重叠</li></ol></li><li>为什么会有trash：<spanclass="math inline">\(\sum\)</span>locality的大小 &gt; 总内存大小</li></ol><h3 id="working-set-model">9.6.2 Working-Set Model</h3><ol type="1"><li><strong>workingset(WS)</strong>工作集：在最近Δ次页访问的页的集合</li><li><strong>working-set window</strong>工作集窗口Δ：固定次数的页访问<ol type="1"><li>如：10000 instruction</li></ol></li><li><strong>WSS<sub>i</sub></strong> working set size of ProcessP<sub>i</sub>工作集大小 = 在最近Δ时间内的页访问总次数<ol type="1"><li>如果Δ太小：不能表示整个局部空间</li><li>如果Δ太大：包括了多个局部空间</li><li>如果Δ=∞：包括了整个程序</li></ol></li><li><span class="math inline">\(D = \sumWSS_i\)</span>：总共需要的帧；<spanclass="math inline">\(m\)</span>：总共可用的帧<ol type="1"><li><spanclass="math inline">\(D&gt;m\)</span>时，会出现Thrashing，需要减少进程数目</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201173253855.png" alt="image-20221201173253855" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201173542748.png" alt="image-20221201173542748" style="zoom:80%;" /></p><h3 id="page-fault-frequency-scheme-缺页频率">9.6.3 Page-Fault FrequencyScheme 缺页频率</h3><p>缺页频率应该保证在一个区间</p><ol type="1"><li>如果过低：从进程收回帧</li><li>如果过高：给进程分配帧</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201173547998.png" alt="image-20221201173547998" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201173554956.png" alt="image-20221201173554956" style="zoom:80%;" /></p><h2 id="memory-mapped-files">9.7 Memory-Mapped Files</h2><ol type="1"><li>Memory-Mapped FilesI/O：通过将磁盘块映射到内存中的页面，允许将文件I/O视为例行内存访问</li><li>最初使用请求分页读取文件。文件的页面大小部分从文件系统读取到物理页面中。对文件的后续读/写被视为普通内存访问。</li><li>通过内存而不是read() write()系统调用处理文件I/O，简化了文件访问</li><li>还允许多个进程映射同一文件，从而共享内存中的页面</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201174152851.png" alt="image-20221201174152851" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201174157228.png" alt="image-20221201174157228" style="zoom:80%;" /></p><h2 id="allocating-kernel-memory">9.8 Allocating Kernel Memory</h2><h3 id="allocating-kernel-memory-1">9.8.1 Allocating Kernel Memory</h3><ol type="1"><li>与分配用户空间的方式不同</li><li>通常从空闲内存池分配<ol type="1"><li>内核根据结构，请求不同大小的内存</li><li>某些内核内存需要是连续的</li></ol></li></ol><h3 id="buddy-system">9.8.2 Buddy System</h3><ol type="1"><li>从由物理上连续的页组成固定大小的段，然后分配内存</li><li>使用power-of-2 allocator分配内存<ol type="1"><li>每个单元的大小为2<sup>n</sup></li><li>每次分配内存的请求对齐到2<sup>n</sup>，如请求6，则分配2<sup>3</sup></li><li>当请求的内存比可用的段小时，当前段被分成两个2<sup>n-1</sup>的伙伴<ol type="1"><li>继续，直到大小合适的块可用</li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221205142443883.png" alt="image-20221205142443883" style="zoom:80%;" /></p><h3 id="slab-allocator">9.8.3 Slab Allocator</h3><blockquote><p>另一种内存分配策略</p></blockquote><ol type="1"><li>Slab：是一个或多个物理上连续的页面</li><li>Cache：由一个或多个slab组成</li><li>每个唯一内核数据结构 &lt;==&gt; 一个cache<ol type="1"><li>每个cache都填充了object：数据结构的实例</li></ol></li><li>创建cache时，填充标记为空闲的对象</li><li>存储结构时，对象标记为已使用</li><li>如果slab中充满了已使用的对象，则从空slab中分配下一个对象<ol type="1"><li>如果没有空slab，则分配新的slab</li></ol></li><li>优点：没有碎片、快速满足内存请求</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221205142954698.png" alt="image-20221205142954698" style="zoom:80%;" /></p><h2 id="other-considerations">9.9 Other Considerations</h2><h3 id="prepaging-预调页">9.9.1 Prepaging 预调页</h3><ol type="1"><li>减少进程启动时出现的大量page-faults</li><li>在进程启用之前，预先将一些页调到内存中</li><li>但是如果预调页没有被使用，则会浪费I/O</li><li>假设预调页的页数为<span class="math inline">\(s\)</span>，其中<spanclass="math inline">\(\alpha\)</span>个页被用到<ol type="1"><li>节省的page fault数：<spanclass="math inline">\(s*\alpha\)</span></li><li>浪费的预调页：<span class="math inline">\(s*(1-\alpha)\)</span></li><li>如果<spanclass="math inline">\(\alpha\)</span>接近0，则称为prepaging loses</li></ol></li></ol><h3 id="page-size-页大小">9.9.2 Page Size 页大小</h3><ol type="1"><li>页大小会影响：<ol type="1"><li>碎片的大小 fragmentation：页越大，碎片越大</li><li>页表的大小：页越大，页表越小</li><li>I/O消耗：页越大，I/O消耗越大</li><li>局部性 Locality：如果页小于working set，则page fault会比较大</li></ol></li><li>增加页大小：<ol type="1"><li>会导致碎片的大小增加</li><li>并且并不是所偶有的应用程序都需要一个大的页大小</li></ol></li><li>提供多种页大小：<ol type="1"><li>这使得需要更大页大小的应用程序有机会在不增加碎片的情况下使用它们</li></ol></li></ol><h3 id="tlb范围">9.9.3 TLB范围</h3><ol type="1"><li>TLB Reach：TLB能够到达的内存范围</li><li><strong>TLB Reach = TLB Size × Page Size</strong></li><li>理想情况下，每个进程的working set均存储在TLB中，否则pagefault会比较大</li></ol><h3 id="程序结构">9.9.4 程序结构</h3><ol type="1"><li>遍历二维数组时，先枚举列还是先枚举行</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">128</span>][<span class="number">128</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line">        data[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) </span><br><span class="line">        data[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="io锁定">9.9.5 I/O锁定</h3><ol type="1"><li><strong>I/O Interlock</strong>：页面有时必须锁定在内存中</li><li>考虑I/O：用于从设备复制文件的页面必须被锁定，以防止页面替换算法被选中而替换</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221205145130942.png" alt="image-20221205145130942" style="zoom:67%;" /></p><h2 id="operating-system-examples-1">9.10 Operating System Examples</h2><h3 id="windows-xp">9.10.1 Windows XP</h3><ol type="1"><li>Uses demand paging with <strong>clustering</strong>. Clusteringbrings in pages surrounding the faulting page</li><li>Processes are assigned <strong>working set minimum</strong> and<strong>working set maximum</strong></li><li>Working set minimum is the minimum number of pages the process isguaranteed to have in memory</li><li>A process may be assigned as many pages up to its working setmaximum</li><li>When the amount of free memory in the system falls below athreshold, <strong>automatic working set trimming</strong> is performedto restore the amount of free memory</li><li>Working set trimming removes pages from processes that have pages inexcess of their working set minimum</li></ol><h3 id="solaris">9.10.2 Solaris</h3><ol type="1"><li>Maintains a list of free pages to assign faulting processes</li><li><strong>Lotsfree</strong> – threshold parameter (amount of freememory) to begin paging</li><li><strong>Desfree</strong> – threshold parameter to increasingpaging</li><li><strong>Minfree</strong> – threshold parameter to beingswapping</li><li>Paging is performed by pageout process</li><li>Pageout scans pages using modified clock algorithm</li><li>Scanrate is the rate at which pages are scanned. This ranges fromslowscan to fastscan</li><li>Pageout is called more frequently depending upon the amount of freememory available</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221205145550355.png" alt="image-20221205145550355" style="zoom:80%;" /></p><h1 id="chapter-10file-system-interface">Chapter 10：File-SystemInterface</h1><h2 id="file-concept">10.1 File Concept</h2><ol type="1"><li><p>文件：是存储某种介质上的（如磁盘、光盘、SSD等）并具有文件名的一组相关信息的集合</p></li><li><p>一个文件是在某些硬件设施上的一系列字符</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221205153235071.png" alt="image-20221205153235071" style="zoom:80%;" /></p></li><li><p>类型：</p><ol type="1"><li>数据型：数字型、字符型、二进制型</li><li>程序型</li></ol></li></ol><h3 id="文件属性">10.1.1 文件属性</h3><ol type="1"><li>Name：文件名</li><li>Identifier：文件标识，唯一标记文件系统中的文件</li><li>Type：文件类型，系统用于支持不同类型的文件</li><li>Location：文件在设备中的位置</li><li>Size：当前文件大小</li><li>Protection：控制谁可读/写/执行</li><li>Time, date, and useridentification：用于保护/安全/使用监视的数据</li><li>有关文件的信息保存在磁盘上维护的目录结构中</li></ol><h3 id="文件操作">10.1.2 文件操作</h3><p>文件是一个抽象数据类型</p><ol type="1"><li>create</li><li>write</li><li>read</li><li>reposition within file</li><li>delete</li><li>truncate</li><li>open(F<sub>i</sub>)：在磁盘上的目录结构中搜索entryFi，并将条目的内容移动到内存中</li><li>close(F<sub>i</sub>)：将内存中entryFi的内容移动到磁盘上的目录结构</li></ol><h3 id="打开文件">10.1.3 打开文件</h3><p>用于打开文件的数据信息：</p><ol type="1"><li><strong>Filepointer</strong>：指向文件打开的每个进程的最后一个读/写位置的指针</li><li><strong>File-opencount</strong>：文件打开次数的计数器，允许在最后一个进程关闭时从打开的文件表中删除数据</li><li><strong>Disk location of the file</strong>：数据访问信息缓存</li><li><strong>Access rights</strong>：每个进程访问模式信息</li></ol><h3 id="文件的内部结构">10.1.4 文件的内部结构</h3><ol type="1"><li><strong>None</strong> 流文件结构<ol type="1"><li>一系列word/byte</li></ol></li><li><strong>Simple record structure</strong> 记录文件结构<ol type="1"><li>行</li><li>固定长度</li><li>可变长度</li></ol></li><li><strong>Complex Structures</strong><ol type="1"><li>格式化文档</li><li>可重定位的加载文件</li></ol></li><li>通过插入适当的控制字符，可以使用第一种方法模拟后两种</li><li>Who decides:<ol type="1"><li>操作系统</li><li>对应程序</li></ol></li></ol><h2 id="access-methods">10.2 Access Methods</h2><ol type="1"><li><p>Sequential Access 顺序存取</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208162949263.png" alt="image-20221208162949263" style="zoom: 50%;" /></p></li><li><p>Direct Access 直接存取</p><blockquote><p>使用Direct-access File模拟顺序存取</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208163000966.png" alt="image-20221208163000966" style="zoom:50%;" /></p></li><li><p>Indexed sequential-acess 索引顺序</p><blockquote><p>Index and Relative File</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208163009799.png" alt="image-20221208163009799" style="zoom:50%;" /></p></li></ol><h2 id="directory-structure-目录结构">10.3 Directory Structure目录结构</h2><h3 id="目录结构">10.3.1 目录结构</h3><ol type="1"><li><p>目录：一个节点的集合，包含所有文件的相关信息</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208163356292.png" alt="image-20221208163356292" style="zoom:80%;" /></p></li></ol><h3 id="磁盘结构">10.3.2 磁盘结构</h3><ol type="1"><li>磁盘可以被分割为<strong>partitions(分区)</strong></li><li>磁盘/分区可以作为<strong>RAID</strong>来预防failure</li><li>磁盘/分区可以使用<strong>raw</strong>，即使没有文件系统 或者没有被文件系统格式化过</li><li>分区，也被称为minidisk，slice</li><li>包含文件系统的示例被称为<strong>volume(卷)</strong></li><li>包含文件系统的每个卷还跟踪<strong>设备目录</strong>或<strong>卷目录</strong>中的文件系统信息</li><li>除了<strong>通用文件系统</strong>外，还有许多<strong>专用文件系统</strong>，通常都在同一操作系统或计算机中</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208164020816.png" alt="image-20221208164020816" style="zoom:80%;" /></p><h3 id="目录的操作">10.3.3 目录的操作</h3><ol type="1"><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>列出目录</li><li>重命名文件</li><li>遍历文件系统</li></ol><h3 id="文件目录的组织结构">10.3.4 文件目录的组织结构</h3><p>需要考虑以下问题：</p><ol type="1"><li>查找效率：能够快速定位一个文件</li><li>重名：不同用户是否可以拥有同名文件，相同文件是否可以拥有不同名字</li><li>分组：通过文件的特性对文件分组</li></ol><h4 id="single-level-directory-单级目录">10.3.4.1 Single-Level Directory单级目录</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208164717968.png" alt="image-20221208164717968" style="zoom:67%;" /></p><ol type="1"><li>重名：不同用户不能拥有同名文件，相同文件不能拥有不同名字</li><li>分组：不能按照文件类型进行分组</li></ol><h4 id="two-level-directory-二级目录">10.3.4.2 Two-Level Directory二级目录</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208164843650.png" alt="image-20221208164843650" style="zoom:80%;" /></p><ol type="1"><li>查找效率：使用路径名</li><li>重名：不同用户可以拥有同名文件，相同文件不能拥有不同名字</li><li>分组：不能按照文件类型进行分组</li></ol><h4 id="tree-structured-directories-树型目录">10.3.4.3 Tree-StructuredDirectories 树型目录</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208164916177.png" alt="image-20221208164916177" style="zoom:80%;" /></p><ol type="1"><li><p>查找效率：使用路径名，需要有当前目录的路径（绝对路径/相对路径）</p><ol type="1"><li>cd /spell/mail/prog</li><li>type list</li></ol></li><li><p>重名：不同用户可以拥有同名文件，相同文件不能拥有不同名字</p></li><li><p>分组：可以按照文件类型进行分组</p></li><li><p>删除文件：<code>rm &lt;file-name&gt;</code></p></li><li><p>添加目录：<code>mkdir &lt;dir-name&gt;</code></p></li><li><p>示例：当前路径为<code>/mail</code>，执行<code>mkdir count</code></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208165305078.png" alt="image-20221208165305078" style="zoom:80%;" /></p></li></ol><h4 id="acyclic-graph-directories-有向无环图结构目录">10.3.4.4Acyclic-Graph Directories 有向无环图结构目录</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208165345326.png" alt="image-20221208165345326" style="zoom:80%;" /></p><ol type="1"><li>同一个文件可以有不同的名字</li><li>如果文件被删除了，但是指针没有被删除，则会导致danglingpointer，解决方法：<ol type="1"><li>Backpointers 逆向指针：删除文件时删除所有指针</li><li>Backpointers 使用菊花图的组织方式</li><li>Entry-hold-count solution 表项保留计数</li></ol></li><li>新的目录实体类型<ol type="1"><li>Link：一个已经存在的文件的另一个名字(指针)</li><li>Resolve the link：通过指针定位文件</li></ol></li></ol><h4 id="general-graph-directory-普通图结构目录">10.3.4.5 General GraphDirectory 普通图结构目录</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208165553339.png" alt="image-20221208165553339" style="zoom:80%;" /></p><p>如何保证没有环</p><ol type="1"><li>只允许到文件的link，不允许到目录的链接</li><li>垃圾回收机制<ol type="1"><li>检测自我引用的文件，其引用计数不等于0</li><li>垃圾收集涉及遍历整个文件系统，并标记所有可访问的空间。然后，第二次将所有没有标记的</li><li>部分收集到空闲空间链表上。</li></ol></li><li>每次添加新link时，使用环检测算法(cycle detectionalgorithm)，确定是否可以添加</li></ol><h2 id="文件系统的挂载">10.4 文件系统的挂载</h2><ol type="1"><li>文件系统只有被挂载了(mounted)，才能被使用</li><li>文件系统会被挂载到<strong>挂载点(mount point)</strong>上</li></ol><blockquote><ol type="a"><li>Existing (b) Unmounted Partition</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208171015291.png" alt="image-20221208171015291" style="zoom:80%;" /></p><blockquote><p>mount point 挂载点</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208171021245.png" alt="image-20221208171021245" style="zoom:80%;" /></p><h2 id="文件共享">10.5 文件共享</h2><ol type="1"><li>多用户系统需要实现文件的共享</li><li>共享的文件可能是保护模式</li><li>在分布式系统中，文件可以通过网络共享<ol type="1"><li>通常使用Network File System (NFS) 实现分布式文件共享</li></ol></li></ol><h3 id="文件共享多用户">10.5.1 文件共享：多用户</h3><ol type="1"><li><strong>User IDs</strong>：识别用户，授予每个用户权限和保护</li><li><strong>Group IDs</strong>：允许用户在组中，授予组访问权限</li></ol><h3 id="文件共享远程文件系统">10.5.2 文件共享：远程文件系统</h3><ol type="1"><li>使用网络允许系统之间的文件系统访问<ol type="1"><li>使用<strong>FTP等程序</strong>手动共享</li><li>使用<strong>分布式文件系统distributed filesystems</strong>自动共享</li><li>通过<strong>万维网world wide web</strong>半自动共享</li></ol></li><li>客户端-服务器模型允许客户端从服务器装载远程文件系统<ol type="1"><li>服务器可以为多个客户端提供服务</li><li>客户端和用户对客户端标识不安全或复杂</li><li><strong>NFS</strong>是标准的UNIX客户端-服务器文件共享协议</li><li><strong>CIFS</strong>是标准的Windows协议</li><li>标准操作系统文件调用被转换为远程调用</li></ol></li><li>LDAP、DNS、NIS、ActiveDirectory等分布式信息系统（分布式命名服务）实现了对远程计算所需信息的统一访问</li></ol><h3 id="文件共享错误模式">10.5.3 文件共享：错误模式</h3><ol type="1"><li>由于网络故障、服务器故障，远程文件系统添加了新的故障模式</li><li>故障恢复可能涉及有关每个远程请求状态的状态信息</li><li>无状态协议（如NFS）包含每个请求中的所有信息，允许轻松恢复，但安全性较低</li></ol><h3 id="文件共享一致性问题">10.5.4 文件共享：一致性问题</h3><p><strong>一致性语义Consistencysemantics</strong>：指定多个用户如何同时访问共享文件</p><ol type="1"><li>类似于Ch 7 进程同步算法<ol type="1"><li>由于磁盘I/O和网络延迟，会相对简单一点</li></ol></li><li>Andrew文件系统(AFS)实现了：<ol type="1"><li>复杂的远程文件共享语义</li></ol></li><li>Unix文件系统(UFS)实现了：<ol type="1"><li>写入同一打开文件的其他用户立即可见的打开文件</li><li>共享文件指针以允许多个用户同时读写</li></ol></li><li>AFS具有会话语义</li><li>仅对文件关闭后开始的会话可见的写入</li></ol><h2 id="protection">10.6 Protection</h2><ol type="1"><li>文件的拥有者/创建者需要能够控制：<ol type="1"><li>可以做什么</li><li>谁可以做</li></ol></li><li>操作的类型：<ol type="1"><li>读</li><li>写</li><li>执行</li><li>扩展</li><li>删除</li><li>列表</li></ol></li></ol><h3 id="access-lists-and-groups">10.6.1 Access Lists and Groups</h3><ol type="1"><li>基础操作：读R、写W、执行X</li><li>三种用户<ol type="1"><li>所有者owner</li><li>组group</li><li>公共public</li></ol></li><li>要求管理员创建group、添加用户到group</li><li>对一个特定的文件/子目录，定义访问的权限</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208172500521.png" alt="image-20221208172500521" style="zoom:80%;" /></p><h1 id="chapter-11file-system-implementation">Chapter 11：File SystemImplementation</h1><h2 id="file-systemorganized-structure">11.1 File-System(organized)Structure</h2><ol type="1"><li>文件的结构：<ol type="1"><li>逻辑存储单元</li><li>相关信息的集合</li></ol></li><li>文件系统总是分层结构</li><li>文件系统存储在磁盘上<ol type="1"><li>通过允许轻松地存储、定位和检索数据，提供对磁盘的高效和方便的访问</li><li><strong>文件系统</strong>：是操作系统中以文件方式管理计算机软件资源的软件和被管理的文件和数据结构（如目录和索引表等）的集合</li></ol></li><li><strong>File control block文件控制块</strong>：由文件信息（属性）组成的存储结构</li><li><strong>Device driver 设备驱动</strong>：控制物理设备</li></ol><h3 id="分层设计的文件系统">11.1.1 分层设计的文件系统</h3><ol type="1"><li>应用程序：<ol type="1"><li>发送文件请求的代码</li></ol></li><li>逻辑文件系统<ol type="1"><li>管理<strong>元数据</strong>：文件系统的所有结构数据，而不包括实际数据（或文件内容）</li><li>根据给定符号文件名来管理目录结构</li><li>逻辑文件系统通过文件控制块(FCB)来维护文件结构</li></ol></li><li>文件组织模块<ol type="1"><li>知道文件及其逻辑块和物理块。</li><li>空闲空间管理器</li></ol></li><li>基本文件系统<ol type="1"><li>向合适的设备驱动程序发送一般命令就可对磁盘上的物理块进行读写</li></ol></li><li>I/O控制<ol type="1"><li>由设备驱动程序和中断处理程序组成，实现内存与磁盘之间的信息转移</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208173053023.png" alt="image-20221208173053023" style="zoom:80%;" /></p><h3 id="文件系统的类型">11.1.2 文件系统的类型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208173658221.png" alt="image-20221208173658221" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208173713927.png" alt="image-20221208173713927" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208173728616.png" alt="image-20221208173728616" style="zoom:80%;" /></p><h2 id="文件系统的实现">11.2 文件系统的实现</h2><h3 id="在磁盘中的文件系统结构">11.2.1 在磁盘中的文件系统结构</h3><ol type="1"><li><p>在磁盘上，文件系统可能包括如下信息：</p><ol type="1"><li>如何启动所存储的操作系统</li><li>总的块数</li><li>空闲块的数目和位置</li><li>目录结构以及各个具体文件等</li></ol></li><li><p>磁盘结构包括</p><ol type="1"><li><strong>Boot controlblock</strong>：包含系统从该卷启动OS所需的信息</li><li><strong>Volume(卷)control block</strong>：包含卷详细信息</li><li><strong>Directory structure</strong>：组织文件</li><li>Per-file <strong>File Control Block(FCB，文件控制块)</strong>：包含文件的许多详细信息</li></ol></li><li><p>一个典型的文件控制块如下：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208174042008.png" alt="image-20221208174042008" style="zoom: 50%;" /></p></li></ol><h3 id="在内存中的文件系统结构">11.2.2 在内存中的文件系统结构</h3><ol type="1"><li>An in-memory partition table：分区表</li><li>An in-memory directory structure：目录结构</li><li>The system-wide open-file table：系统打开文件表</li><li>The per-process open-file table：进程打开文件表</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208174329371.png" alt="image-20221208174329371" style="zoom:80%;" /></p><h3 id="虚拟文件系统">11.2.3 虚拟文件系统</h3><ol type="1"><li>虚拟文件系统（VFS）提供了一种实现文件系统的面向对象方法</li><li>VFS允许相同的系统调用接口（API）用于不同类型的文件系统</li><li>API用于VFS接口，而不是任何特定类型的文件系统</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221208174537601.png" alt="image-20221208174537601" style="zoom:67%;" /></p><h2 id="目录实现">11.3 目录实现</h2><h3 id="线性列表">11.3.1 线性列表</h3><ol type="1"><li><strong>Linear list</strong>线性列表：存储文件名、指向数据块的指针<ol type="1"><li>实现简单</li><li>但是访问文件需要线性遍历</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212142011949.png" alt="image-20221212142011949" style="zoom:80%;" /></p><h3 id="哈希表">11.3.2 哈希表</h3><ol type="1"><li><strong>Hash Table</strong>哈希表：<ol type="1"><li>降低了搜索时间</li><li>collision冲突：当两个文件名hash到同一个位置时，会发生冲突</li><li>fixedsize：哈希表的最大困难是其通常固定的大小和哈希函数对大小的依赖性</li></ol></li><li>可以使用两层hash优化</li></ol><h2 id="allocation-methods-文件物理结构">11.4 Allocation Methods,文件物理结构</h2><ol type="1"><li>An allocation method refers to how disk blocks are allocated forfiles:<ol type="1"><li>Contiguous allocation 连续分配</li><li>Linked allocation 链接分配</li><li>Indexed allocation 索引分配</li><li>Unix、Linux直接间接混合分配方法</li></ol></li></ol><h3 id="连续分配-1">11.4.1 连续分配</h3><h4 id="连续分配-2">11.4.1.1 连续分配</h4><ol type="1"><li><p>每个文件占据磁盘上<strong>连续的块</strong></p></li><li><p>简单：只需要知道文件的起始位置(block #)和长度(number ofblocks)</p></li><li><p><strong>Random Access 随机存取</strong></p></li><li><p>如果动态分配的话，会浪费空间</p></li><li><p>文件变动的成本很高</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212143513022.png" alt="image-20221212143513022" style="zoom:67%;" /></p></li><li><p>逻辑地址 =&gt; 物理地址：LA / 512</p><ol type="1"><li>LA：存取文件的逻辑地址</li><li>512：每块的大小</li><li>待访问的块：Q+starting address</li><li>块内偏移量：R</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212143550218.png" alt="image-20221212143550218"  /></p><h4 id="基于扩展的连续分配系统">11.4.1.2 基于扩展的连续分配系统</h4><ol type="1"><li>将程序分为多个段</li><li>每个段是空间中的一片连续的空间</li><li>不同段之间可以不连续</li></ol><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212143829537.png"alt="image-20221212143829537" /><figcaption aria-hidden="true">image-20221212143829537</figcaption></figure><h3 id="链接分配">11.4.2 链接分配</h3><h4 id="链接分配-1">11.4.2.1 链接分配</h4><ol type="1"><li>文件的内容放在内存中不同的块，通过链表将不同块连接起来</li><li>简单：只需要存储链表的起始地址，每个块内部会有指向下一个块的指针</li><li>不会浪费空间</li><li>不能随机访问</li><li>逻辑地址 =&gt; 物理地址：LA / 512</li><li>缺点：如果其中一个块的指针被修改了，那么后面的块均无法访问</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212144327110.png" alt="image-20221212144327110" style="zoom:67%;" /></p><h4 id="链接分配的变种fat文件系统">11.4.2.2链接分配的变种：FAT文件系统</h4><ol type="1"><li><p>File-allocationtable(FAT)：文件分配表，是一个单独的数据结构，存储文件的链表信息</p><ol type="1"><li>原本的链表指针存储在每个数据块中</li><li>FAT表使用单独的空间，存储了整个文件的每一个块的链表指针</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212144730183.png" alt="image-20221212144730183" style="zoom:67%;" /></p></li><li><p>FAT12、FAT16、FAT32</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212144612204.png" alt="image-20221212144612204" style="zoom:80%;" /></p></li><li><p>FAT32引导区记录被扩展为：包括重要数据结构的备份，根目录为一个普通的簇链，其目录项可以放在文件区任何地方</p></li><li><p>FAT32磁盘的结构：</p><ol type="1"><li><strong>主引导记录MBR</strong>：是主引导区的第一个扇区，它由两个部分组成:<ol type="1"><li>第一部分主引导代码，占据扇区的前446个字节，磁盘标识符(FD 4E F214)位于这段代码的未尾</li><li>第二部分是分区表，分区表中每个条目有16字节长，分区表最多有4个条目，第一个分区条目从扇区的偏移量位置是0x01BE</li></ol></li><li><strong>扩展引导记录</strong>：与主引导记录类同，如该扩展分区未装操作系统则第一部分主引导代码为0，标签字也标记一个扩展分区引导区和分区引导区的结束</li><li>计算机系统启动时，首先执行的是<strong>BIOS引导程序</strong>，完成自检，并加载主引导记录和分区表，然后执行<strong>主引导记录</strong>，由它引导激活分区引导记录，再执行<strong>分区引导记录</strong>，加载操作系统，最后执行<strong>操作系统</strong>，配置系统</li></ol></li><li><p>FAT32目录项结构</p><ol type="1"><li>FAT的<strong>每个目录项</strong>为<strong>32个字节</strong></li></ol></li><li><p><strong>FAT32长文件名</strong>的目录项由几个32B表项组成</p><ol type="1"><li>用一个表项存放短文件名和其他属性（包括簇号、文件大小，最后修改时间和最后修改日期、创建时间、创建日期和最后存取日期），短文件名的属性是0x20</li><li>用连续若干个表项存放长文件名，每个表项存放13个字符（使用Unicode编码，每个字符占用2个字节）</li><li>长文件名的表项首字节的二进制数低5位值，分别为00001 、00010 、 00011、……，表示它们的次序，左起第2位为1(也就是在低5位基础上加40H)表示该表项是最后一项。最后项存放13个字符位置多余时，先用2个字节0表示结束，再用FFH填充</li><li>长文件名的属性是0x0F</li><li>长文件名项的第13、27、28字节为0x00，第14字节为短文件名校验和</li><li>长文件名The quickbrown.fox（短文件名为THEQUI~1.FOX）目录项格式如下：</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212145723827.png" alt="image-20221212145723827" style="zoom:80%;" /></p></li></ol><h4 id="ntfs文件系统">11.4.2.3 NTFS文件系统</h4><ol type="1"><li><p>NTFS卷布局：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212145820512.png" alt="image-20221212145820512"  /></p></li><li><p>每个分区均有一个主文件表<strong>Master FileTable(MFT)</strong></p><ol type="1"><li>MFT用数据库记录形式组织，每条记录(MFT表项)长度1K</li><li>MFT由一个个MFT项(也称为文件记录)组成，每个MFT项占用1024字节的空间</li><li>MFT前16个记录用来存放元数据文件的信息，它们占有固定的位置</li><li>每个MFT项的前部几十个字节有着固定的头结构，用来描述本MFT项的相关信息。后面的字节存放着文件属性等</li><li>每个文件或目录的信息都包含在MFT中，每个文件或目录至少有一个MFT项</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212145917582.png" alt="image-20221212145917582" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212150032357.png" alt="image-20221212150032357" style="zoom:80%;" /></p></li></ol><h3 id="索引分配">11.4.3 索引分配</h3><h4 id="索引分配-1">11.4.3.1 索引分配</h4><ol type="1"><li><p>将所有指针统一放到<strong>索引块 index block</strong>中</p></li><li><p>逻辑视图</p></li><li><p>每个文件都使用磁盘上的索引块来包含文件使用的其他磁盘块的地址</p></li><li><p>当写入第<spanclass="math inline">\(i\)</span>个块时，块的地址被放置在索引块的第<spanclass="math inline">\(i\)</span>个位置</p></li><li><p>方法会浪费空间，因为对于小文件，大部分索引块都被浪费了</p><ol type="1"><li>如果索引块太小，我们可以：<ol type="1"><li>将几个链接在一起</li><li>使用多级索引</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212151200110.png" alt="image-20221212151200110" style="zoom:50%;" /></p></li><li><p>需要索引表</p></li><li><p>可以实现随机访问</p></li><li><p>动态分配不会产生额外的碎片，但是会浪费索引块的空间</p></li><li><p>在最大大小为256KB、块大小为512B的文件中从逻辑映射到物理。索引表只需要1个块</p></li></ol><h4 id="链接索引">11.4.3.2 链接索引</h4><ol type="1"><li>将索引表，使用链表连接起来</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212151713695.png" alt="image-20221212151713695" style="zoom:80%;" /></p><h4 id="二级索引">11.4.3.3 二级索引</h4><ol type="1"><li>Two-level index</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212151851581.png" alt="image-20221212151851581" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212152013361.png" alt="image-20221212152013361" style="zoom:80%;" /></p><h3 id="组合模式">11.4.4 组合模式</h3><ol type="1"><li>使用不同索引，适配不同大小的文件<ol type="1"><li>direct blocks：直接指向数据所在的位置</li><li>single indirect：指向一级索引块</li><li>double indirect：指向二级索引块</li></ol></li></ol><blockquote><p>Linux ext2/ext3</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221212152131318.png" alt="image-20221212152131318" style="zoom:80%;" /></p><h2 id="free-space-management-空闲空间管理">11.5 Free-Space Management空闲空间管理</h2><ol type="1"><li><p>Bitmap 位图</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215163231777.png" alt="image-20221215163231777" style="zoom:80%;" /></p><ol type="1"><li><p>对于有n个blocks的空间 <span class="math display">\[bit[i]=\left\{\begin{aligned}  &amp; 0 =&gt; block[i]空闲\\  &amp; 0 =&gt; block[i]被占用\end{aligned} \right.\]</span></p></li><li><p>Bitmap需要额外的空间来记录空闲空间</p></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215163339003.png" alt="image-20221215163339003" style="zoom:67%;" /></p></li><li><p>Free list 空闲列表</p><ol type="1"><li>将空闲的空间连接起来</li><li>没有空间浪费</li><li>但是不能容易的得到连续的空间</li></ol></li><li><p>Grouping 分组</p><ol type="1"><li>可以较为容易的得到一块连续的空间</li><li>如果分组大小为固定的，则难以满足所有程序的需求</li><li>如果分组大学为动态的，则容易产生碎片</li></ol></li><li><p>Counting 空闲表</p></li><li><p>需要保护的内容：</p><ol type="1"><li>指向空闲列表的指针</li><li>Bitmap：<ol type="1"><li>必须保存在磁盘上</li><li>内存和磁盘中的副本可能不同</li><li>不能允许block[i]在内存中的bit[i]=1，而在磁盘上的bit[i]=0</li></ol></li><li>解决方法：<ol type="1"><li>set 磁盘中的 bit[i] = 1</li><li>申请block[i]</li><li>set 内存中的 bit[i] = 1</li></ol></li></ol></li></ol><blockquote><p>Linked Free Space List on Disk</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215164144034.png" alt="image-20221215164144034" style="zoom: 67%;" /></p><h2 id="效率和性能">11.6 效率和性能</h2><ol type="1"><li>效率依赖于：<ol type="1"><li>磁盘分配、目录算法</li><li>文件中目录项的数据的类型</li></ol></li><li>性能：<ol type="1"><li>disk cache：在内存中开辟一块空间，访问磁盘时先访问这块内存</li><li>free-behind andread-ahead：释放时不真正将内存中的内容刷新，读取时提前将相关的block读入内存</li><li>通过将部分内存用作虚拟磁盘或RAM磁盘来提高PC性能</li></ol></li></ol><h3 id="page-cache">11.6.1 Page Cache</h3><ol type="1"><li>Page Cache使用虚拟内存技术缓存页面而不是磁盘块，</li><li>Memory-mapped I/O会使用Page Cache</li><li>通过文件系统的例行I/O使用缓冲区（磁盘）缓存</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215164907603.png" alt="image-20221215164907603" style="zoom:67%;" /></p><h3 id="unified-buffer-cache">11.6.2 Unified Buffer Cache</h3><ol type="1"><li>Unified Buffer Cache统一缓冲区缓存：使用相同的页面缓存来缓存memory-mapped pages和普通文件系统I/O</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215165214104.png" alt="image-20221215165214104" style="zoom:80%;" /></p><h2 id="recovery">11.7 Recovery</h2><ol type="1"><li><strong>Consistency checking</strong>一致性比较：将目录结构中的数据与磁盘上的数据块进行比较，并尝试修复不一致性</li><li><strong>back up</strong>备份：使用系统程序将数据从磁盘备份到其他存储设备（磁带、其他磁盘、光盘）</li><li><strong>restoring</strong>恢复：通过从备份中恢复数据来恢复丢失的文件或磁盘</li></ol><h3 id="log-structured-file-systems">11.7.1 Log Structured FileSystems</h3><ol type="1"><li><strong>Log structured</strong>日志结构(或日志)文件系统：将文件系统的每次更新记录为事务<strong>transaction</strong></li><li>所有事务都写入日志<ol type="1"><li>事务写入日志后即被视为已提交</li><li>但是，文件系统可能尚未更新</li></ol></li><li>日志中的事务将异步写入文件系统<ol type="1"><li>修改文件系统时，事务将从日志中删除</li></ol></li><li>如果文件系统崩溃，则仍必须执行日志中的所有剩余事务</li></ol><h3 id="network-file-system-nfs-网络文件系统">11.7.2 Network File System(NFS) 网络文件系统</h3><h4 id="nfs">11.7.2.1 NFS</h4><ol type="1"><li>NFS：跨LAN/WAN访问远程文件的软件系统的实现和规范</li><li>该实现是使用不可靠数据报协议(UDP/IP协议和以太网)在Sun工作站上运行的Solaris和SunOS操作系统的一部分</li><li>互连工作站被视为一组具有独立文件系统的独立计算机，允许以透明的方式在这些文件系统之间共享<ol type="1"><li>远程目录加载在本地文件系统目录上<ol type="1"><li>加载的目录看起来像本地文件系统的一个完整子树，替换了从本地目录向下的子树(mount的过程)</li></ol></li><li>装载操作的远程目录的规范是不透明的；必须提供远程目录的主机名<ol type="1"><li>然后可以以透明的方式访问远程目录中的文件</li></ol></li><li>根据访问权限认证，可能任何文件系统（或文件系统中的目录）都可以远程安装在任何本地目录的顶部</li></ol></li><li>NFS旨在在不同机器、操作系统和网络架构的异构环境中运行；独立于这些介质的NFS规范<ol type="1"><li>这种独立性是通过使用构建在两个独立于实现的接口之间使用的外部数据表示(ExternalData Representation XDR)协议之上的RPC原语(RPC primitives)实现的</li></ol></li><li>NFS规范区分了装载机制提供的服务和实际的远程文件访问服务</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215171246096.png" alt="image-20221215171246096" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215171336215.png" alt="image-20221215171336215" style="zoom:80%;" /></p><h4 id="nfs-mount-protocol">11.7.2.2 NFS Mount Protocol</h4><ol type="1"><li>在服务器和客户端之间建立初始逻辑连接</li><li>mount操作包括：要装载的远程目录的名称、存储该目录的服务器计算机的名称<ol type="1"><li>mount请求被映射到相应的RPC，并转发到服务器计算机上运行的装载服务器</li><li>Exportlist导出列表：指定服务器导出以进行mount的本地文件系统，以及允许mount它们的计算机的名称</li></ol></li><li>在符合其导出列表的装载请求之后，服务器返回一个文件句柄：一个用于进一步访问的密钥</li><li>文件句柄：一个文件系统标识符和一个inode编号，用于标识导出的文件系统中装载的目录</li><li>装载操作仅更改用户的视图，不会影响服务器端</li></ol><h4 id="nfs-protocol">11.7.2.3 NFS Protocol</h4><ol type="1"><li>为远程文件操作提供一组远程过程调用。程序支持以下操作：<ol type="1"><li>在目录中搜索文件</li><li>读取一组目录条目</li><li>操作链接和目录</li><li>访问文件属性</li><li>读取和写入文件</li></ol></li><li>NFS服务器是无状态<strong>stateless</strong>：每个请求都必须提供一组完整的参数<ol type="1"><li>NFS V4刚刚推出，非常不同，有状态</li></ol></li><li>修改数据时，必须先修改服务器的磁盘，才能将数据返回客户端<ol type="1"><li>保证了同步</li><li>失去缓存的优势</li></ol></li><li>NFS协议不提供并发控制机制</li></ol><h4 id="nfs架构中的三个主要层">11.7.2.4 NFS架构中的三个主要层</h4><ol type="1"><li>UNIX文件系统接口<ol type="1"><li>基于打开、读取、写入和关闭调用以及文件描述符</li></ol></li><li>虚拟文件系统(VFS)层：区分本地文件和远程文件，本地文件根据其文件系统类型进一步区分<ol type="1"><li>VFS根据文件系统类型激活文件系统特定操作以处理本地请求</li><li>为远程请求调用NFS协议过程</li></ol></li><li>NFS服务层：体系结构的底层<ol type="1"><li>实施NFS协议</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215172431386.png" alt="image-20221215172431386" style="zoom:80%;" /></p><h4 id="nfs-path-name-translation">11.7.2.5 NFS Path-NameTranslation</h4><ol type="1"><li>通过将路径拆分为组件名称并对每对组件名称和目录vnode执行单独的NFS查找调用来执行</li><li>为了加快查找速度，客户端的目录名查找缓存保存远程目录名的vnode</li></ol><h4 id="nfs远端操作">11.7.2.6 NFS远端操作</h4><ol type="1"><li>常规UNIX系统调用与NFS协议RPC之间几乎一一对应（打开和关闭文件除外）</li><li>NFS遵循远程服务范式，但为了性能考虑，采用了缓冲和缓存技术</li><li>文件块缓存：打开文件时，内核会与远程服务器检查是否获取或重新验证缓存的属性<ol type="1"><li>仅当相应的缓存属性是最新的时，才使用缓存文件块</li></ol></li><li>文件属性缓存：每当新属性从服务器到达时，都会更新属性缓存</li><li>在服务器确认数据已写入磁盘之前，客户端不会释放延迟的写入块</li></ol><h2 id="示例wafl文件系统">*11.8 示例：WAFL文件系统</h2><ol type="1"><li>用于Network Appliance“Filers”：分布式文件系统设备</li><li>在任何位置写入文件布局</li><li>为NFS、CIFS、http、ftp提供服务</li><li>随机I/O优化，写优化<ol type="1"><li>用于写缓存的NVRAM</li></ol></li><li>类似于Berkeley Fast File System，具有广泛的修改</li></ol><blockquote><p>The WAFL File Layout</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215172923567.png" alt="image-20221215172923567" style="zoom:80%;" /></p><blockquote><p>Snapshots in WAFL</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215172935282.png" alt="image-20221215172935282" style="zoom:80%;" /></p><h1 id="chapter-12mass-storage-systems">Chapter 12：Mass-StorageSystems</h1><h2 id="大容量存储系统-概览">12.1 大容量存储系统 概览</h2><blockquote><p>分层存储体系</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219143646168.png" alt="image-20221219143646168" style="zoom:80%;" /></p><ol type="1"><li>磁盘<code>Magnetic disks</code>：<ol type="1"><li>每秒钟60~200转</li><li>传输速率<code>Transfer Rate</code>：从驱动器到计算机之间的数据传输速率<ol type="1"><li>与磁盘、计算机连接驱动的方式有关</li></ol></li><li>定位时间<code>Positioning Time</code> /<code>Random-access time</code>：分为两部分<ol type="1"><li>将磁盘臂移动到所需柱面的时间（寻道时间<code>seek time</code>）</li><li>所需扇区在磁盘头下旋转的时间（旋转延迟<code>rotational latency</code>）</li></ol></li><li><code>Head Crash</code>：磁头与磁盘相碰，会导致磁盘坏区</li><li>磁盘可以被移除</li><li>驱动通过I/O总线与计算机相连<ol type="1"><li>总线有很多种，如：EIDE, ATA, SATA, USB, Fibre Channel, SCSI</li><li>计算机中的主机控制器使用总线与内置在驱动器或存储阵列中的磁盘控制器通信</li></ol></li></ol></li><li>固态硬盘<code>Solid State Drives</code>：<ol type="1"><li>简称固盘，固态硬盘用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成</li><li>第一只SSD出现在1978年（STK 4305，每MB售价8800美元，DRAM）</li><li>全闪存阵列（AFAS）和混合闪存阵列（HFA）呈爆发式增长</li><li>现在SSD的容量是15.36TB（SAS）</li><li>非易失性、低功耗（只有HDD的三分之一）</li><li>无活动部件、可靠性高：―位误码率(<code>BER</code>)1x10<sup>-17</sup></li><li>读取存取时间：0.2毫秒，存取时间比HDD大概快 50倍</li></ol></li><li>磁带<code>Magnetic tape</code>：<ol type="1"><li>出货的磁带驱动器中超过85%是LTO（Linear Tape Open）</li><li>磁带驱动器的可靠性、数据传输速率和容量已超过磁盘</li><li>磁带的原生容量为10TB，压缩容量超过25TB。(LTO-10:48TB)</li><li>磁带的原生数据传输速率为360MB/s</li><li>LTFS(Liner Tape FileSystem)为磁带提供了一种通用、开放的文件系统</li><li>由于总体拥有成本，云采用磁带解决方案用于归档服务</li><li>对企业级磁带和LTO而言，磁带介质的寿命至少是30年</li></ol></li></ol><h2 id="磁盘结构-1">12.2 磁盘结构</h2><h3 id="磁盘结构-2">12.2.1 磁盘结构</h3><ol type="1"><li>磁盘被划分为逻辑块的一个一维阵列，其中逻辑块是最小的传输单位</li><li>逻辑块的大小通常为512字节</li><li>逻辑块的一维阵列按顺序映射到磁盘的扇区中<ol type="1"><li>扇区0：是最外柱面上，第一个磁道的，第一个扇区</li><li>映射顺序：磁道上的其它扇区 =&gt; 柱面上的其它磁道 =&gt;其它柱面</li></ol></li></ol><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><thstyle="text-align: center;"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219145527826.png" alt="image-20221219145527826"  /></th><th><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219145531858.png" alt="image-20221219145531858" style="zoom:80%;" /></th></tr></thead><tbody></tbody></table><h3 id="host-attached-storage">12.2.2 Host-attached storage</h3><ol type="1"><li><p>主机通过I/O接口与I/O总线进行通信</p></li><li><p><code>IDE</code>：</p><ol type="1"><li>每个I/O bus 最多2个驱动器</li></ol></li><li><p><code>SCSI</code>：</p><ol type="1"><li>SCSI本身是一条总线，一根电缆上最多有16个设备，SCSI启动器请求操作，SCSI目标执行任务</li><li>每个目标最多可以有8个逻辑单元（连接到设备控制器的磁盘）</li></ol></li><li><p><code>FC</code>：Fibre Channel，光纤通道</p><ol type="1"><li>可以是具有24位地址空间的交换结构，这是存储区域网络(SAN, storage areanetworks)的基础，其中许多主机连接到许多存储单元</li><li>可仲裁126个设备的环路（FC-AL）</li></ol></li><li><p><code>NAS</code>：Network-attached storage</p><ol type="1"><li>网络连接存储（NAS）是通过网络而不是通过本地连接（如总线）提供的存储</li><li>NFS和CIFS（通用Internet文件系统）是通用协议</li><li>通过主机和存储之间的远程过程调用（RPC）实现</li><li>新的iSCSI协议使用IP网络来承载SCSI协议</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219150412657.png" alt="image-20221219150412657" style="zoom:80%;" /></p></li><li><p><code>SAN</code>：Storage Area Network</p><ol type="1"><li>在大型存储环境中很常见（而且越来越常见）</li><li>多个主机连接到多个存储阵列—灵活</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219150441725.png" alt="image-20221219150441725" style="zoom:80%;" /></p></li><li><p>存储虚拟化技术：<code>SNIA</code>(Storage Networking IndustryAssociation，存储网络联合会)官方对于<code>Virtualization</code>(存储虚拟化技术)的定义如下：</p><ol type="1"><li>是将存储（子）系统内部功能与具体应用、主机及通用网络资源分离、隐藏及抽象的行为。以期达到存储或数据管理的网络无关性</li><li>对于存储服务及设备的虚拟化应用，以期达到整合设备功能、隐藏复杂细节以及向已经存在的底层存储资源添加新的应用</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219150541740.png" alt="image-20221219150541740" style="zoom: 80%;" /></p></li></ol><h2 id="磁盘调度">12.4 磁盘调度</h2><h3 id="磁盘调度-1">12.4.1 磁盘调度</h3><ol type="1"><li>操作系统负责有效地使用硬件-对于磁盘驱动器，这意味着具有快速的访问时间和磁盘带宽</li><li>访问时间有三个主要组成部分<ol type="1"><li><code>Seek time</code>(寻道时间)：是磁盘将磁头移动到包含所需扇区的气缸的时间</li><li><code>Rotational latency</code>(旋转延迟)：是等待磁盘将所需扇区旋转到磁盘头的额外时间</li><li><code>Transfer time</code>(传输时间)</li></ol></li><li><strong>目标：最小化寻道时间</strong></li><li>seek time ≈ seek distance 寻道时间 ≈ 寻道距离</li><li>磁盘带宽：传输的总字节数 /第一次服务请求和最后一次传输完成之间的总时间</li></ol><blockquote><ol type="1"><li>7200(转／每分钟)的硬盘，每旋转一周所需时间为60×1000（毫秒）÷7200＝8.33毫秒，则平均旋转延迟时间为8.33÷2＝4.17毫秒(平均情况下，需要旋转半圈)。</li><li>7200转机械硬盘的寻道时间一般为12-14毫秒，固态硬盘可以达到0.1毫秒甚至更低</li><li>固态硬盘持续读写速度超过500MB/s</li><li>机械硬盘读写速度超过50~200MB/s（接口不同）</li><li>磁带的原生数据传输速率为360MB/s</li></ol></blockquote><h3 id="磁盘调度算法">12.4.2 磁盘调度算法</h3><p>假设</p><ol type="1"><li>请求队列为：<code>98, 183, 37, 122, 14, 124, 65, 67</code></li><li>磁头目前在：<code>53</code></li></ol><h4 id="fcfs-先来先服务">12.4.2.1 FCFS 先来先服务</h4><blockquote><p>总距离：<code>640</code>个磁道距离</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219152543077.png" alt="image-20221219152543077" style="zoom:67%;" /></p><h4 id="sstf-最短寻道时间优先">12.4.2.2 SSTF 最短寻道时间优先</h4><ol type="1"><li>选择对于当前磁头来说，所需寻道时间最小的请求</li><li>SSTF(Shortest Seek TimeFirst)是SJF的一个变种，可能会导致starvation</li></ol><blockquote><p>总距离：<code>236</code>个磁道距离</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219152910224.png" alt="image-20221219152910224" style="zoom:67%;" /></p><h4 id="scan-扫描">12.4.2.3 SCAN 扫描</h4><ol type="1"><li>磁盘臂从磁盘的一端开始，向另一端移动，当遇到请求的块时，直接读取，直到到达磁盘的另一端</li><li>此时磁头移动方向取反，继续响应途中遇到的请求</li><li>SCAN算法有时称为电梯算法</li><li>SCAN算法的稳定性不高</li></ol><blockquote><p>总距离：<code>236</code>个磁道距离</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219153237456.png" alt="image-20221219153237456" style="zoom:67%;" /></p><h4 id="c-scan">12.4.2.4 C-SCAN</h4><ol type="1"><li>磁盘臂从磁盘的一端开始，向另一端移动，当遇到请求的块时，直接读取，直到到达磁盘的另一端</li><li>此时磁头直接跳转到磁盘的开始端，然后继续向另一端移动</li><li>C-SCAN更加稳定，因为保证了同一时间遇到的请求可以在一次SCAN过程中都取到</li></ol><blockquote><p>总距离：<code>382</code>个磁道距离</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219153555618.png" alt="image-20221219153555618" style="zoom:67%;" /></p><h4 id="look">12.4.2.5 LOOK</h4><ol type="1"><li>SCAN的时候，不一定要到边上，只要到达所有请求的最小/大值处，即可折返</li></ol><blockquote><p>总距离：<code>208</code>个磁道距离</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219154814261.png" alt="image-20221219154814261" style="zoom:67%;" /></p><h4 id="c-look">12.4.2.6 C-LOOK</h4><ol type="1"><li>C-SCAN的时候，不一定要到边上，只要到达所有请求的最小/大值处，即可折返</li></ol><blockquote><p>总距离：<code>322</code>个磁道距离</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221219153956094.png" alt="image-20221219153956094" style="zoom:67%;" /></p><h3 id="选择一种磁盘调度算法">12.4.3 选择一种磁盘调度算法</h3><ol type="1"><li>SSTF很常见，具有自然吸引力</li><li>SCAN和C-SCAN在磁盘负载较大的系统中表现更好</li><li>性能取决于请求的数量和类型</li><li>磁盘服务请求可能会受到文件分配方法的影响</li><li>磁盘调度算法应作为操作系统的一个单独模块来编写，允许在必要时使用不同的算法来替换</li><li>SSTF或LOOK是一种合理的默认算法</li></ol><h2 id="磁盘控制">12.5 磁盘控制</h2><h3 id="磁盘控制-1">12.5.1 磁盘控制</h3><ol type="1"><li>Low-level formatting / physical formatting 低级格式化/物理格式化：<ol type="1"><li>为每个扇区采用特别的数据结构，包括头、数据区域和尾部组成</li><li>头部和尾部包含了一些磁盘控制器所使用的信息，例如扇区号码和纠错代码（ECC）</li><li>当控制器在正常I/O时写入一个扇区数据时，ECC会用一个根据磁盘数据计算出来的值更新</li><li>当读入扇区时，ECC值会重新计算，并与原来存储的值相比较，如果两个值不一样，那么可能表示扇区的数据可能已损坏或扇区可能变坏</li></ol></li><li>要使用磁盘保存文件，操作系统仍需要在磁盘上记录自己的数据结构<ol type="1"><li>Partition分区：<ol type="1"><li>一个分区可以用来存储操作系统的可执行代码，而其他分区用来存储用户数据</li><li>分区可看做一个独立的磁盘</li></ol></li><li>Logical formatting 逻辑格式化：<ol type="1"><li>操作系统将初始的文件系统数据结构存储到磁盘上</li><li>这些数据结构包括空闲和已分配的空间（FAT和inode）和一个初始为空的目录</li></ol></li><li>cluster 簇：<ol type="1"><li>为了提高效率，大多数操作系统将块集中到一大块，叫做簇cluster</li><li>磁盘I/O通过块完成，文件系统I/O通过簇完成，确保I/O可以进行更多的顺序存取和更少的随机存取</li></ol></li></ol></li></ol><h3 id="boot-block-启动块">12.5.2 Boot Block 启动块</h3><ol type="1"><li>Boot block 初始化系统：<ol type="1"><li>引导程序（自举程序）初始化系统从cpu寄存器到设备控制器和内存，接着启动操作系统</li><li>自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，开始操作系统的执行</li></ol></li><li>经典的启动顺序<ol type="1"><li>ROM中的代码（简单引导）<ol type="1"><li>ROM中保留一个很小的自举加载程序，它的作用是进一步从磁盘上调入更为完整的自举程序</li></ol></li><li>Boot Block中的代码（完全引导）<ol type="1"><li>引导加载程序，例如Grub或LILO</li><li>磁盘上的自举程序可以容易地进行修改，拥有启动分区的磁盘称为启动磁盘或系统磁盘</li></ol></li><li>操作系统的整个内核</li></ol></li></ol><h3 id="windows-2000的启动">12.5.3 Windows 2000的启动</h3><blockquote><ol type="1"><li>Windows系统通过运行系统ROM上的代码，开始启动，指示系统从MBR读取引导代码。MBR包含一个硬盘分区列表和一个说明系统引导分区的标志</li><li>引导分区，bootpartition，包含操作系统和设备驱动程序。系统一旦确定引导分区，它读取该分区的第一个扇区，所谓引导扇区，并继续余下的启动过程，包括加载各种子系统和系统服务</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221222164450979.png" alt="image-20221222164450979" style="zoom:80%;" /></p><h3 id="bad-block-坏块">12.5.4 Bad Block 坏块</h3><blockquote><p>有坏块是正常的，出厂的时候就有可能有坏块。对于简单磁盘，Format进行逻辑格式化时找到坏块，就在相应的FAT条目上写上特殊值以通知分配程序不要使用该块。如果在正常使用中块变坏，就必须人工的执行chkdsk来搜索坏块。</p></blockquote><ol type="1"><li>磁盘经常有缺陷块或坏块</li><li>坏块的处理方法</li><li>MS-DOS的处理方法: format，chkdsk命令</li></ol><h2 id="交换空间的管理">12.6 交换空间的管理</h2><ol type="1"><li>交换空间：虚拟内存使用磁盘空间作为主内存的扩展</li><li>交换空间可以有2种形式：<ol type="1"><li>在普通的文件系统中：windows--<code>pagefile.sys文件</code></li><li>在独立的磁盘分区种：linux、unix--<code>SWAP分区</code></li></ol></li><li>交换空间的大小：<ol type="1"><li>交换空间太大容易造成浪费</li><li>交换空间太小容易造成死机现象：中断进程或使整个系统死机</li></ol></li><li>BSD在进程启动时分配交换空间；保存文本段（程序）和数据段<ol type="1"><li>内核使用交换映射来跟踪交换空间的使用</li></ol></li><li>Solaris2仅在页面被强制移出物理内存时才分配交换空间，而不是在首次创建虚拟内存页面时</li></ol><blockquote><p>Data Structures for Swapping on Linux Systems</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221222165445838.png" alt="image-20221222165445838" style="zoom:80%;" /></p><h2 id="raid结构">12.7 RAID结构</h2><h3 id="raid介绍">12.7.1 RAID介绍</h3><ol type="1"><li><strong>RAID</strong>：Redundant Arrays of Inexpensive(Independent)Disks，冗余廉价磁盘阵列<ol type="1"><li>RAID是一种把多块独立的硬盘(物理硬盘)按不同的方式组合起来形成一个硬盘组(逻辑硬盘)，从而提供比单个硬盘更高的存储性能和提供数据备份技术</li><li>Inexpensive =&gt; Independent</li><li>RAID：使用多个磁盘，通过冗余提供可靠性</li><li>增加平均故障时间</li><li>通常与NVRAM组合使用，提升性能</li><li>分为了6个级别</li></ol></li><li>磁盘使用技术的一些改进涉及使用多个磁盘协同工作</li><li>磁盘条带化(striping)：将一组磁盘用作一个存储单元</li><li>RAID方案通过存储冗余数据来提高存储系统的性能和可靠性<ol type="1"><li>镜像(Mirroring)或shadowing(RAID 1)：保留每个磁盘的副本</li><li>条带化镜像(RAID 1+0)或镜像条带(RAID0+1)：提供了高性能和高可靠性</li><li>块交错奇偶校验(RAID 4、5、6)：使用更少的冗余</li></ol></li><li>如果阵列发生故障，存储阵列中的RAID仍可能发生故障，因此阵列之间的数据自动复制很常见</li><li>通常，少数hot-sparedisks不会被分配，自动替换故障磁盘并将数据重建到这些磁盘上</li></ol><h3 id="raid层级">12.7.2 RAID层级</h3><ol type="1"><li><strong>Raid0</strong>：没有冗余性的保证，但是可以将多个磁盘条带化成1个</li><li><strong>Raid 1</strong>：镜像磁盘，是数据的一个完整拷贝</li><li><strong>Raid2</strong>：内存方式的差错纠正代码结构，内存系统中的每个字节都有一个相关奇偶位，以记录字节中置为1的个数是偶数还是奇数</li><li><strong>Raid3</strong>：按位校验，奇偶校验码和其它磁盘的相应扇区或块一起用于恢复出错磁盘的扇区和块</li><li><strong>Raid4</strong>：按块校验，奇偶校验码和其它磁盘的相应扇区或块一起用于恢复出错磁盘的扇区和块</li><li><strong>Raid5</strong>：将数据和奇偶校验分布在所有N+1块磁盘上</li><li><strong>Raid6</strong>：保存了额外的冗余信息以防止多个磁盘出错，每4个位的数据使用了2个位的冗余数据，这样系统可以容忍两个磁盘出错。</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221222171059973.png" alt="image-20221222171059973" style="zoom:80%;" /></p><h3 id="raid01-和-raid10">12.7.3 RAID(0+1) 和 RAID(1+0)</h3><ol type="1"><li>RAID 0+1：<ol type="1"><li>先分散，再镜像</li><li>一组磁盘分散成条，每一条再镜像到另一条</li><li>RAID 0和RAID 1的组合，RAID 0提供性能，RAID 1提供可靠性</li><li>RAID0+1允许坏多个盘，但只能在坏在同一个RAID0中，不允许两个RAID0都有坏盘</li></ol></li><li>RAID 1+0：<ol type="1"><li>先镜像，再分散</li><li>如果单个磁盘不可用，其它镜像仍如其它磁盘一样可用</li><li>RAID1+0允许坏多个盘，只要不是一对磁盘坏就可以</li></ol></li><li>RAID 1+0在整体容错能力和恢复代价上比RAID0+1更有优势，所以更为常用</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221222171500654.png" alt="image-20221222171500654" style="zoom:80%;" /></p><h3 id="拓展">12.7.4 拓展</h3><ol type="1"><li>单独使用RAID无法防止或检测数据损坏或其他错误，只是防止磁盘故障</li><li>Solaris ZFS添加了所有数据和元数据的校验和<ol type="1"><li>与对象指针一起保存的校验和，用于检测对象是否正确以及是否已更改</li><li>可以检测并纠正数据和元数据损坏</li></ol></li><li>ZFS还删除了卷、分区<ol type="1"><li>磁盘分配到pool中</li><li>具有池的文件系统共享该池，使用和释放空间，如“malloc”和“free”内存分配/释放调用</li></ol></li></ol><blockquote><p>ZFS Checksums All Metadata and Data</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221222172044176.png" alt="image-20221222172044176" style="zoom:80%;" /></p><blockquote><p>Traditional and Pooled Storage</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221222172052943.png" alt="image-20221222172052943" style="zoom:80%;" /></p><h1 id="chapter-13io-system">Chapter 13：I/O System</h1><h2 id="overview-1">13.1 Overview</h2><ol type="1"><li>计算机的两个主要工作<ol type="1"><li>I/O</li><li>计算</li></ol></li><li>与计算机相连的设备的控制是操作系统设计者的主要关注点</li><li>I/O设备技术出现两个相矛盾的趋势：<ol type="1"><li>硬件和软件接口日益增长的标准化</li><li>I/O设备日益增长的多样性。</li></ol></li><li>操作系统内核设计成使用设备驱动程序模块的结构</li><li>设备驱动程序为I/O子系统提供了统一接口</li></ol><h2 id="io硬件">13.2 I/O硬件</h2><ol type="1"><li>I/O系统的组成：<ol type="1"><li>PC总线型I/O系统</li><li>大型机I/O系统</li></ol></li><li>通用概念<ol type="1"><li>Port ，端口</li><li>Bus (daisy chain or shared direct access)，总线</li><li>Controller (host adapter)，控制器</li></ol></li><li>I/O instructions控制设备</li><li>寻址方式<ol type="1"><li>直接使用I/O指令</li><li>内存映射I/O</li></ol></li></ol><blockquote><p>PC总线型I/O</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221226143530861.png" alt="image-20221226143530861" style="zoom:80%;" /></p><blockquote><p>Mainframe Systems 大型机(主机)系统</p><ol type="1"><li>这类计算机以存储器为中心，CPU和各种通道都与存储器相连</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221226143547576.png" alt="image-20221226143547576" style="zoom:80%;" /></p><h2 id="io方式">13.3 I/O方式</h2><h3 id="轮询">13.3.1 轮询</h3><ol type="1"><li>CPU查询I/O的状态</li><li>I/O返回当前状态<ol type="1"><li>command-ready</li><li>busy</li><li>error</li></ol></li><li>如果I/O没有准备好，则会返回第1步，进入busy-wait(忙等待)状态</li><li>如果I/O准备好了，则CPU读取I/O的数据，写入内存，然后返回第1步</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221226144148862.png" alt="image-20221226144148862" style="zoom:67%;" /></p><h3 id="interrupt中断">13.3.2 Interrupt中断</h3><ol type="1"><li>CPU硬件有一条<strong>中断请求线（interrupt-request line,IRL）</strong>，由I/O设备触发<ol type="1"><li>设备控制器通过中断请求线发送信号而引起中断，CPU捕获中断并派遣到中断处理程序，中断处理程序通过处理设备来清除中断。</li></ol></li><li>两种中断请求<ol type="1"><li><strong>非屏蔽中断</strong>：主要用来处理如不可恢复内存错误等事件</li><li><strong>可屏蔽中断</strong>：由CPU在执行关键的不可中断的指令序列前加以屏蔽</li></ol></li><li><strong>中断向量</strong></li><li><strong>中断优先级</strong>：能够使CPU延迟处理低优先级中断而不屏蔽所有中断，这也可以让高优先级中断抢占低优先级中断处理。</li><li>中断的用途<ol type="1"><li>中断机制用于处理各种异常，如被零除，访问一个受保护的或不存在的内存地址</li><li>系统调用的实现需要用到中断（软中断）</li><li>中断也可以用来管理内核的控制流</li></ol></li></ol><blockquote><p>中断驱动I/O循环</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221226145032534.png" alt="image-20221226145032534" style="zoom:80%;" /></p><h3 id="直接内存访问dmadirect-memory-access">13.3.3直接内存访问DMA(Direct Memory Access)</h3><ol type="1"><li>用来避免处理大量数据移动时按字节来向控制器送入数据的问题</li><li>需要DMA控制器</li><li>绕过CPU直接在内存与I/O设备之间进行数据传输</li><li>步骤：<ol type="1"><li>硬件告诉设备驱动器：要传输在地址X处的磁盘数据</li><li>设备驱动器告诉磁盘控制器：从磁盘中读取地址X处的C个字节到buffer</li><li>磁盘控制器：初始化DMA传输</li><li>磁盘控制器：传输字节，给到DMA控制器</li><li>DMA控制器：传输字节给到buffer，地址++，C--，直到C=0</li><li>当C=0时，DMA中断CPU，声明传输已经结束</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221226145852776.png" alt="image-20221226145852776" style="zoom: 80%;" /></p><h3 id="应用io接口">13.4 应用I/O接口</h3><ol type="1"><li>I/O系统调用：实现统一的I/O接口</li><li>I/O系统调用将设备行为封装在泛型类中，如块设备I/O系统调用包括磁盘、磁带、光盘等一系列块设备的read、write、seek。</li><li>设备驱动程序(Device-driver)层从内核隐藏I/O控制器之间的差异</li><li>设备在许多方面都有所不同<ol type="1"><li>Character-stream or block 字符流或者块设备</li><li>Sequential or random-access 顺序或随机访问设备</li><li>Synchronous or aSynchronous 同步或异步</li><li>Sharable or dedicated 共享或独占设备</li><li>Speed of operation 操作速度（快速、中速、慢速）</li><li>read-write, read only, or write only 读写、只读、只写设备</li></ol></li></ol><blockquote><ol type="1"><li>大多数操作系统存在后门，允许应用程序将任何命令透明的传给设备控制器</li><li>对UNIX，这个系统调用是ioctl（）<ol type="1"><li>系统调用ioctl能使应用程序访问由设备驱动程序实现的一切功能</li><li>Ioctl有三个参数<ol type="1"><li>第一个文件描述符，引用某一个硬件设备</li><li>第二个是整数，来确定哪个命令</li><li>第三个是内存中的指针，使得应用程序和控制器传输任何必要的命令信息或数据</li></ol></li></ol></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221226151634158.png" alt="image-20221226151634158" style="zoom:80%;" /></p><h3 id="block-and-character-devices-块和字符设备">13.4.1 Block andCharacter Devices 块和字符设备</h3><blockquote><p>read，write，seek描述了块存储设备的基本特点，这样应用程序就不必关注这些设备的底层差别。</p><p>原始I/O或直接I/O文件操作模式</p><ol type="1"><li>原始I/O：将块设备当做一个简单的线性块数组来访问</li><li>直接I/O：文件采用禁止缓存和锁的文件操作模式</li></ol><p>内存映射文件访问是建立在块设备驱动程序之上的。内存映射接口不是提供read和write操作，而是提供通过内存中的字节数组来访问磁盘存储。</p><p>应用程序可以get或put一个字符。在此基础上，可以构造库以提供具有缓冲和编辑功能的按行访问。</p><p>这种访问方式也有助于输出设备，例如打印机、声卡，这些设备适合于线性字节流</p></blockquote><ol type="1"><li>Block devices（块设备） include disk drives<ol type="1"><li>Commands include read, write, seek</li><li>Raw I/O or file-system access</li><li>Memory-mapped file access possible</li></ol></li><li>Character devices （字符设备） include keyboards, mice, serial ports<ol type="1"><li>Commands include get(), put()</li><li>Libraries layered on top allow line editing</li></ol></li></ol><h3 id="network-devices-网络设备">13.4.2 Network Devices 网络设备</h3><ol type="1"><li>网络I/O的性能与访问特点与磁盘I/O相比有很大差别，绝大多数操作系统所提供的网络I/O接口也不同于磁盘的read-write-seek接口</li><li>许多OS所提供的是网络套接字接口<ol type="1"><li>套接字接口还提供了select函数，以管理一组套接字</li><li>调用select可以得知哪个套接字已有接收数据需要处理，哪个套接字已有空间可以接收数据以便发送</li></ol></li></ol><h3 id="clocks-and-timers-时钟和定时器">13.4.3 Clocks and Timers时钟和定时器</h3><ol type="1"><li>提供以下三个基本函数<ol type="1"><li>获取当前时间</li><li>获取已经逝去的时间</li><li>设置定时器以在T时触发操作X</li></ol></li><li>测量逝去时间和触发器操作的硬件称为可编程间隔定时器（programmableinterval timer）<ol type="1"><li>可被设置为等待一定的时间，然后触发中断</li><li>也可设置成做一次或重复多次以产生定时中断</li></ol></li></ol><h3 id="blocking-and-nonblocking-io-阻塞和非阻塞io">13.4.4 Blocking andNonblocking I/O 阻塞和非阻塞I/O</h3><ol type="1"><li>Blocking：进程挂起直到I/O完成为止<ol type="1"><li>很容易使用和理解</li><li>对某些需求是低效的</li></ol></li><li>Nonblocking：I/O调用立刻返回<ol type="1"><li>用户界面</li><li>通过多进程实现</li><li>返回读/写了多少个字节</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221226153141627.png" alt="image-20221226153141627" style="zoom:67%;" /></p><h3 id="asynchronous-异步">13.4.5 Asynchronous 异步</h3><ol type="1"><li>Asynchronous(异步)：进程与I/O同时运行<ol type="1"><li>难以使用</li><li>当I/O完成时，I/O子系统会提醒进程</li></ol></li><li>非阻塞与异步系统调用的<strong>差别</strong>:<ol type="1"><li><strong>非阻塞read调用会马上返回</strong>，其所读取的数据可以等于或少于所要求的，或为零</li><li><strong>异步read调用所要求的传输应完整地执行，其具体执行可以是将来某个特定时间</strong></li></ol></li></ol><h2 id="内核io子系统">13.5 内核I/O子系统</h2><ol type="1"><li>内核与I/O有关服务：<ol type="1"><li>I/O scheduling：I/O调度</li><li>buffering：缓存</li><li>caching：高速缓存</li><li>spooling：假脱机</li><li>device reservation：设备预定</li><li>error handling：错误处理</li></ol></li><li>内核I/O子系统负责：<ol type="1"><li>文件和设备命名空间的管理</li><li>文件和设备访问控制</li><li>操作控制（for example, a modem cannot seek()）</li><li>文件系统空间的分配</li><li>设备分配</li><li>缓冲、高速缓存、假脱机</li><li>I/O调度</li><li>设备状态监控、错误处理、失败恢复</li><li>设备驱动程序的配置和初始化</li></ol></li></ol><h3 id="io调度">13.5.1 I/O调度</h3><ol type="1"><li>I/O调度：调度一组I/O请求就是确定一个好的顺序来执行这些请求<ol type="1"><li>某些I/O需要按设备队列的顺序：先来先服务</li><li>某些操作系统尝试着公平：优先级高者优先</li><li>磁盘I/O调度</li></ol></li><li>实现<ol type="1"><li>OS通过为每个设备维护一个请求队列来实现调度。</li><li>可以试图公平，也可以根据不同的优先级进行I/O调度。</li><li>其他方法：缓冲、高速缓冲、假脱机</li></ol></li></ol><h3 id="缓冲buffer">13.5.2 缓冲buffer</h3><blockquote><p><strong>拷贝语义</strong>：</p><ol type="1"><li>某应用程序需要将缓冲区内的数据写入磁盘，它可以调用write()系统调用</li><li>当系统调用返回时，如果应用程序改变了缓冲区的内容，根据拷贝语义，操作系统保证要写入磁盘的数据就是write()系统调用发生时的版本</li><li>一个简单方法就是操作系统在write()系统调用返回前，将应用程序缓冲区复制到内核缓冲区中</li></ol></blockquote><ol type="1"><li><strong>缓冲Buffering</strong>：用来保存在两设备之间或在设备和应用程序之间所传输数据的内存区域。</li><li>缓冲作用：<ol type="1"><li>解决设备速度不匹配</li><li>解决设备传输块的大小不匹配</li><li>为了维持<strong>拷贝语义“copy semantics”</strong>要求</li></ol></li><li>缓冲区管理：为了解决<strong>CPU与I/O之间速度不匹配的矛盾</strong>，在它们之间配置了缓冲区。这样设备管理程序又要负责管理缓冲区的建立、分配和释放。</li><li>单缓冲、双缓冲、多缓冲、缓冲池</li></ol><h3 id="高速缓冲cacheing">13.5.3 高速缓冲cacheing</h3><ol type="1"><li><p><strong>高速缓存 Caching </strong>：fast memory holding copy ofdata</p><ol type="1"><li><p>缓冲与高速缓存的差别是缓冲只是保留数据仅有的一个现存拷贝，而高速缓存只是提供了一个驻留在其他地方的数据的一个高速拷贝</p></li><li><p>高速缓存和缓冲是两个不同的功能，但有时一块内存区域也可以同时用于两个目的</p></li><li><p>当内核接收到I/O请求时，内核首先检查高速缓存以确定相应文件的内容是否在内存中。如果是，物理磁盘I/O就可以避免或延迟</p></li></ol></li></ol><h3 id="假脱机技术-spooling">13.5.4 假脱机技术 SPOOLing</h3><ol type="1"><li><strong>SPOOLing</strong>（Simultaneous Peripheral Operation OnLine）称为<strong>假脱机</strong>技术：<ol type="1"><li>用来保存设备输出的缓冲，这些设备如打印机不能接收交叉的数据流</li><li>操作系统通过截取对打印机的输出来解决这一问题。应用程序的输出先是假脱机到一个独立的磁盘文件上。当其它应用程序完成打印时，假脱机系统将相应的待送打印机的假脱机文件进行排队</li></ol></li><li>Printing：打印机虽然是独享设备，通过SPOOLing技术，可以将它改造为一台可供多个用户共享的设备</li></ol><h3 id="设备预定-device-reservation">13.5.5 设备预定 Devicereservation</h3><ol type="1"><li><strong>设备预定 Device reservation</strong><ol type="1"><li>提供对设备的独占访问</li><li>分配和再分配的系统调用</li><li>有可能产生死锁</li></ol></li></ol><h3 id="错误处理-error-handling">13.5.6 错误处理 Error Handling</h3><ol type="1"><li><strong>错误处理 Error Handling</strong><ol type="1"><li>操作系统可以恢复磁盘读，设备无效，暂时的失败</li><li>当I/O失败时，大多数返回一个错误码</li><li>系统日志记录了出错报告</li></ol></li></ol><h3 id="io保护">13.5.7 I/O保护</h3><ol type="1"><li>用户进程可能通过非法的I/O指令，来恶意打破一些正常操作<ol type="1"><li>所有I/O指令被特权化</li><li>I/O必须通过系统调用</li><li>内存映射和I/O端口内存位置也必须受到保护</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229162906570.png" alt="image-20221229162906570" style="zoom:67%;" /></p><h3 id="内核数据结构">13.5.8 内核数据结构</h3><ol type="1"><li>内核需要保存I/O组件使用的<strong>状态信息</strong>，包括打开文件表，网络连接，字符设备状态等</li><li>许多复杂的数据结构用来跟踪缓冲，内存分配，及“脏”块</li><li>某些OS用面向对象的方法和消息传递的方法来实现I/O</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229163949586.png" alt="image-20221229163949586" style="zoom:80%;" /></p><h2 id="io-requests-to-hardware-operations">13.6 I/O Requests toHardware Operations</h2><p>进程从磁盘中读取一个文件：</p><ol type="1"><li>确定保存文件的设备</li><li>转换名字到设备的表示法</li><li>把数据从磁盘读到缓冲区中</li><li>通知请求进程数据现在是有效的</li><li>把控制权返回给进程</li></ol><blockquote><p>一次I/O请求的生命周期</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229164104537.png" alt="image-20221229164104537" style="zoom:80%;" /></p></blockquote><h2 id="streams">13.7 STREAMS</h2><ol type="1"><li>STREAMS：Unix SystemV及更高版本中用户级进程与设备之间的全双工通信信道</li><li>流包括：<ol type="1"><li>STREAM头与用户进程接口</li><li>驱动端与设备接口——它们之间没有或多个STREAM模块。</li></ol></li><li>每个模块包含一个读队列和一个写队列</li><li>消息传递用于队列之间的通信</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229164309121.png" alt="image-20221229164309121" style="zoom:67%;" /></p><h2 id="性能">13.8 性能</h2><ol type="1"><li>I/O是系统性能的一个主要因素：<ol type="1"><li>要求CPU执行设备驱动程序、内核I/O代码</li><li>中断导致的上下文切换</li><li>数据复制</li><li>网络流量尤其紧张</li></ol></li><li>提高性能的方法：<ol type="1"><li>减少上下文开关的数量</li><li>减少数据拷贝</li><li>通过使用大型传输、智能控制器和轮询减少中断</li><li>使用DMA</li><li>平衡CPU、内存、总线和I/O性能，实现最高吞吐量</li></ol></li></ol><blockquote><p>计算机之间的通信</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221229164358578.png" alt="image-20221229164358578" style="zoom:80%;" /></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发</title>
      <link href="/2022/08/29/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/Android%E5%BC%80%E5%8F%91/"/>
      <url>/2022/08/29/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/Android%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript"src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="day1-android简介">Day1 Android简介</h1><h2 id="快捷键">快捷键</h2><h3 id="运行">运行</h3><ol type="1"><li>运行：<strong>Shift+F10</strong></li><li>终止：<strong>Ctrl+F2</strong></li></ol><h3 id="日志">日志</h3><ol type="1"><li>生成<strong>TAG</strong>常量：<strong>在方法外输入logt +TAB</strong></li><li>打印不同级别的日志：<strong>在方法内输入logd/logi/logw/loge +TAB</strong></li></ol><h2 id="第一章-开始启程--你的第一行android代码">第一章开始启程--你的第一行Android代码</h2><h3 id="android的四大组件">1.1 Android的四大组件</h3><ol type="1"><li>活动(<strong>Activity</strong>) ：<ol type="1"><li>活动是所有Android应用程序的门面，凡是在应用中你看得到的东西 ，都是放在活动中的</li></ol></li><li>服务(<strong>Service</strong>)：<ol type="1"><li>你无法看到它，但它会一自在后台默默地运行</li><li>即使用户退出了应用，服务仍然是可以继续运行的。</li></ol></li><li>广播接收器(<strong>BroadcastReceiver</strong>) ：<ol type="1"><li>广播接收器允许你的应用接收来自 各处的广播消息，比如电话、短信等</li><li>当然你的应用同样也可以向外发出广播消息</li></ol></li><li>内容提供器(<strong>ContentProvider</strong>)：<ol type="1"><li>内容提供器则为应用程序之间共享数据提供了可能</li><li>比如你想要读取系统电话部中的联系人，就需要通过内容提供器来实现。</li></ol></li></ol><h3 id="项目目录">1.2 项目目录</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830143913960.png" alt="image-20220830143913960" style="zoom:80%;" /></p><h4 id="gradle和idea">1.2.1 .gradle和idea</h4><ol type="1"><li>这两个目录下放置的都是Android Studio自动生成的一些文件</li><li>我们无须关心、 也不要去手动编辑</li></ol><h4 id="app">1.2.2 app</h4><ol type="1"><li>项目中的<strong>代码、资源</strong>等内容几乎都是放置在这个目录下的、我们后面的开发工作也基本都是在这个目录下进行的，待会儿还会对这个目录单独展开进行讲解</li></ol><h4 id="build">1.2.3 build</h4><ol type="1"><li>这个目录你也不需要过多关心，它主要包含了一些在编译时自动生成的文件</li></ol><h4 id="gradle">1.2.4 gradle</h4><ol type="1"><li>这个目录下包含了<strong>gradle wrapper</strong>的配置文件</li><li>使用gradlewrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle</li><li>Android Studio默认没有启用gradlewrapper的方式，如果需要打开，可以点击<strong>AndroidStudio导航栏|File|Settings|Build, Execution, Deployment |Gradle</strong>，进行配置更改。</li></ol><h4 id="gitignore">1.2.5 . gitignore</h4><ol type="1"><li>这个文件是用来将指定的目录或文件排除在版本控制之外的</li></ol><h4 id="build.gradle">1.2.6 build.gradle</h4><ol type="1"><li>这是项目全局的<strong>gradle构建脚本</strong> ，通常这个义件中的内容是不需要修改的</li></ol><h4 id="gradle.properties">1.2.7 gradle.properties</h4><ol type="1"><li>这个文件是全局的<strong>gradle配置文件</strong>，存这里配置的屈性将会影响到项目中所有的gradle编译脚本</li></ol><h4 id="gradlew和gradlew.bat">1.2.8 gradlew和gradlew.bat</h4><ol type="1"><li>这两个文件是用来在命令行界面中执行gradle命令的</li><li>其中gradlew是在Linux或Mac系统中使用时，gradJew.bat是在Windows系统中使用的</li></ol><h4 id="helloworld.iml">1.2.9 HelloWorld.iml</h4><ol type="1"><li>iml文件是所有lntelliJ IDEA项目都会自动生成的一个文件(AndroidStudio是基T lntelliJ IDEA开发的）</li><li>用于标识这是一个lntelliJ IDEA顶目</li><li>我们不需要修改这个文件中的任何内容</li></ol><h4 id="local.properties">1.2.10 local.properties</h4><ol type="1"><li>这个文件用于指定<strong>本机中的Android SDK路径</strong></li><li>通常内容都是自动生成的， 我们并不需要修改，除非你本机中的AndroidSOK位置发生了变化 ，那么就将这个文件中的路径改成新的位置即可</li></ol><h4 id="settings.gradle">1.2.11 settings.gradle</h4><ol type="1"><li>这个文件用于指定项目中<strong>所有引入的模块</strong></li><li>由于HelloWorld项目中就只有一个app模块，因此该文件中也就只引入了app这一个模块</li><li>通常情况下模块的引入都是自动完成的，需要我们手动去修改这个文件的场景可能比较少</li></ol><h3 id="app目录">1.3 app目录</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830144532751.png" alt="image-20220830144532751" style="zoom:80%;" /></p><h4 id="build-1">1.3.1 build</h4><ol type="1"><li>这个目录和外层的build目录类似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容会更多更杂，我们不需要过多关心</li></ol><h4 id="libs">1.3.2 libs</h4><ol type="1"><li>如果你的项目中使用到了<strong>第三方jar包</strong>，就需要把这些jar包都放在libs目录下</li><li>放在这个目录下的jar包都会被自动添加到构建路径里去。</li></ol><h4 id="androidtest">1.3.3 androidTest</h4><ol type="1"><li>此处是用来编写<strong>Android Test测试用例</strong>的，可以对项目进行一些<strong>自动化测试</strong></li></ol><h4 id="java">1.3.4 java</h4><ol type="1"><li>毫无疑问，java目录是放置我们<strong>所有Java代码</strong>的地方</li><li>展开该目录，你将看到我们刚才创建的HelloWorldActivity文件就在里面。</li></ol><h4 id="res">1.3.5 res</h4><p>Android布局下的res文件夹：<img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830150114123.png" alt="image-20220830150114123" style="zoom:80%;" /></p><p>项目目录下的res文件夹：<img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830150302717.png" alt="image-20220830150302717" style="zoom:80%;" /></p><ol type="1"><li>项目中使用到的所有<strong>图片、布局、字符串等资源</strong>都要存放在这个目录下。</li><li>当然这个目录下还有很多子目录，所以你不用担心会把整个res目录弄得乱糟糟的<ol type="1"><li><strong>drawable</strong>目录：图片，多个文件夹用于适用不同设备的分辨率</li><li><strong>layout</strong>目录：布局</li><li><strong>mipmap</strong>目录：应用图标，多个文件夹用于适用不同设备的分辨率</li><li><strong>values</strong>目录：字符串、样式、颜色等配置</li></ol></li></ol><h4 id="androidmanifest.xml">1.3.6 AndroidManifest.xml</h4><ol type="1"><li>这是你<strong>整个Android项目的配置文件</strong></li><li>你在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。</li><li>由于这个文件以后会经常用到，我们用到的时候再做详细说明</li></ol><h4 id="test">1.3.7 test</h4><ol type="1"><li>此处是用来编写<strong>UnitTest测试用例</strong>的，是对项目进行自动化测试的另一种方式</li></ol><h4 id="gitignore-1">1.3.8 .gitignore</h4><ol type="1"><li>这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的．gitignore文件类似</li></ol><h4 id="app.iml">1.3.9 app.iml</h4><ol type="1"><li>IntelliJ IDEA项目自动生成的文件，我们不需要关心或修改这个文件中的内容。</li></ol><h4 id="build.gradle-1">1.3.10 build.gradle</h4><ol type="1"><li>这是<strong>app模块的gradle构建脚本</strong>，这个文件中会指定很多项目构建相关的配置</li></ol><h4 id="proguard-rules.pro">1.3.11 proguard-rules.pro</h4><ol type="1"><li>这个文件用于指定<strong>项目代码的混淆规则</strong></li><li>当代码开发完成后打成安装包文件，如果不希望代码被别入破解，通常会将代码进行混淆， 从而让破解者难以阅读</li></ol><h3 id="项目的运行">1.4 项目的运行</h3><h4 id="androidmanifest.xml注册活动">1.4.1AndroidManifest.xml：注册活动</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.hw2_activity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Hw2_Activity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对资源文件的引用--&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这两句话表示, MainActivity是本项目的主活动, 在手机上点击应用图标, 首先应该启动这个活动--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="mainactivity.java">1.4.2 MainActivity.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"><span class="comment">//AppCompatActivity是一种向下兼容的Activity</span></span><br><span class="line"><span class="comment">//可以将Activity在各个系统版本中增加的特性和功能最低兼容到Android 2.1版本</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="comment">//活动被创建时必须执行的方法</span></span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//给当前活动引入了一个activity_main布局</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="activity_main.xml">1.4.3 activity_main.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--用于显示文字的一个控件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="resvaluesstrings.xml">1.4.4 res/values/strings.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>hw2_Activity<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><ol type="1"><li>定义了一个应用程序名的字符串</li><li>引用方式：<ol type="1"><li>在代码中：<strong>R.string.app_name</strong></li><li>在XML中：<strong><span class="citation"data-cites="string/app_name">@string/app_name</span></strong></li></ol></li><li><strong>string</strong>可以换成<strong>drawable、mipmap、layout</strong>等，用于引用其它文件夹内的资源</li></ol><h4 id="build.gradle-2">1.4.5 build.gradle</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830210700816.png" alt="image-20220830210700816" style="zoom:80%;" /></p><p>外层的<strong>build.gradle</strong>文件</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span> version <span class="string">&#x27;7.2.2&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">    id <span class="string">&#x27;com.android.library&#x27;</span> version <span class="string">&#x27;7.2.2&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">    <span class="comment">//构件中可能会使用到的插件的声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>app/build.gradle</strong>文件</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">    <span class="comment">//使用插件</span></span><br><span class="line">    <span class="comment">//.application表示是应用程序模块</span></span><br><span class="line">    <span class="comment">//.library表示是库模块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdk <span class="number">32</span> <span class="comment">//指定项目的编译版本</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123; <span class="comment">//项目的更多细节配置</span></span><br><span class="line">        applicationId <span class="string">&quot;com.example.hw2_activity&quot;</span> <span class="comment">//指定项目的包名</span></span><br><span class="line">        minSdk <span class="number">21</span><span class="comment">//最低兼容的Android系统版本</span></span><br><span class="line">        targetSdk <span class="number">32</span><span class="comment">//在该目标版本上已经做过充分的测试,系统会为程序启用该版本的最新功能和特性</span></span><br><span class="line">        versionCode <span class="number">1</span><span class="comment">//指定项目的版本号</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span><span class="comment">//指定项目的版本名</span></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123; <span class="comment">//生成正式版安装文件的配置</span></span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 是否对项目的代码进行混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">            <span class="comment">//混淆时使用的规则文件</span></span><br><span class="line">            <span class="comment">//proguard-android-optimize.txt是所有项目通用的混淆规则, 在Android SDK目录下</span></span><br><span class="line">            <span class="comment">//proguard-rules.pro当前有项目特有的混淆规则, 在当前项目的根目录下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; <span class="comment">//项目的所有依赖关系</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.android.material:material:1.4.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span></span><br><span class="line">    </span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种依赖关系：</p><ol type="1"><li>本地依赖：可以对<strong>本地的Jar包或目录</strong>添加依赖关系</li><li>库依赖：可以对<strong>项目中的库模块</strong>添加依赖关系</li><li>远程依赖：可以对<strong>jcenter库上的开源项目</strong>添加依赖关系<ol type="1"><li><strong>com.google.android.material</strong>：域名</li><li><strong>:material</strong>：组名</li><li><strong>:1.4.0</strong>：版本号</li></ol></li></ol><h3 id="日志工具log">1.5 日志工具Log</h3><h4 id="日志工具类的使用">1.5.1 日志工具类的使用</h4><p>Android中的日志工具类是<strong>Log (android.util.Log)</strong>．这个类中提供如下5个方法来供我们打印日志</p><ol type="1"><li><strong>Log.v()</strong>：用于打印那些最为琐碎的意义最小的日志信息。对应级别<strong>verbose</strong>，是Android日志里面级别最低的一种</li><li><strong>Log.d()</strong>：用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别<strong>debug</strong>，比verbose高一级</li><li><strong>Log.i()</strong>：用于打印一些比较重要的数据，这些数据应该是你非常想看到的，可以帮你分析用户行为数据。对应级别<strong>info</strong>, 比debug高一级</li><li><strong>Log.w()</strong>：用于打印一些警告信息，提示程序在这个地力可能会有潜在的风险，最好去修复一下这些出现瞥告的地方。对应级别<strong>warn</strong>，比info高一级</li><li><strong>Log.e()</strong>：用于打印程序中的错误信息，一般都代表程序出现严重问题了，必须尽快修复。对应级别<strong>error</strong>，比warn高一级</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;onCreate execute&quot;</span>);</span><br><span class="line">    <span class="comment">//第一个参数为tag, 一般传入当前类名</span></span><br><span class="line">    <span class="comment">//第二个参数为msg, 为想要打印的具体内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="logcat的使用">1.5.2 Logcat的使用</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830154354724.png" alt="image-20220830154354724" style="zoom:80%;" /></p><ol type="1"><li><p>过滤器：<img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830154410752.png" alt="image-20220830154410752" style="zoom:80%;" /></p></li><li><p>自定义过滤器：在上述图标下拉栏中，选择<strong>Edit FilterConfiguration</strong></p><ol type="1"><li>Log Tag：按照日志的TAG过滤</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830154509417.png" alt="image-20220830154509417" style="zoom:80%;" /></p></li><li><p>按照日志的级别过滤：只会显示高于选中级别的日志</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830154655780.png" alt="image-20220830154655780" style="zoom:80%;" /></p></li></ol><h1 id="day2-android基础ui开发">Day2 Android基础UI开发</h1><h2 id="第二章-先从看得到的入手--探究活动">第二章先从看得到的入手--探究活动</h2><h3 id="活动的基本用法">2.1 活动的基本用法</h3><h4 id="手动创建活动">2.1.1 手动创建活动</h4><ol type="1"><li><p>在下图目录下，<strong>右击|新建|Activity|EmptyActivity</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830162047076.png" alt="image-20220830162047076" style="zoom:80%;" /></p></li><li><p>不要勾选</p><ol type="1"><li>Generate a Layout File：自动创建一个对应的布局文件</li><li>LancherActivity：自动将创建的活动MainActivity设置为当前项目的主活动</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830162335459.png" alt="image-20220830162335459" style="zoom:80%;" /></p></li></ol><h4 id="创建和加载布局">2.1.2 创建和加载布局</h4><ol type="1"><li><p>在下图目录下，<strong>右击|新建|Layout Resource File</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830162420500.png" alt="image-20220830162420500" style="zoom:80%;" /></p></li><li><p>布局文件的首字母要小写</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830162517505.png" alt="image-20220830162517505" style="zoom:80%;" /></p></li><li><p><strong>first_layout.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--match_parent表示让当前元素和父元素一样宽--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--wrap_content表示当前元素的高度只要能刚好包含里面的内容就可以--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@+表示在xml中定义一个id--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>FirstActivity.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">    <span class="comment">//给当前活动加载一个布局</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="在androidmainfest文件中注册">2.1.3在AndroidMainfest文件中注册</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.hw2_activity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Hw2_Activity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">&quot;This is the first activity&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--注意android:exported必须为true--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--android:label是当前活动的标题--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在活动中使用toast">2.1.4 在活动中使用Toast</h4><ol type="1"><li><p>Toast是Android系统提供的一种非常好的提醒方式</p></li><li><p>在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间，</p></li><li><p>我们现在就尝试一下如何在活动中使用Toast：通过Button触发Toast，修改<strong>FirstActivity.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line"></span><br><span class="line">        <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> (Button) findViewById(R.id.button);</span><br><span class="line">        <span class="comment">// 通过button的id,获取其实例</span></span><br><span class="line">        <span class="comment">// 这个值是在first_layout.xml中通过android:id属性指定的</span></span><br><span class="line">        <span class="comment">// findViewById返回的是View对象, 需要将其向下转化为Button对象</span></span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="comment">// 获得按钮实例后, 通过调用setOnClickListener()方法为按钮注册一个监听器</span></span><br><span class="line">            <span class="comment">// 点击按钮时, 就会执行监听器中的onClick()方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                Toast.makeText(FirstActivity.<span class="built_in">this</span>, <span class="string">&quot;You clicked Button &quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="comment">// 通过静态方法makeText()创建一个Toast对象, 然后调用show()方法将其显示出来即可</span></span><br><span class="line">                <span class="comment">// makeText()的三个参数:</span></span><br><span class="line">                <span class="comment">// context: Toast要求的上下文, 由于活动本身就是一个Context对象, 因此这里直接传入this</span></span><br><span class="line">                <span class="comment">// text: Toast显示的文本内容</span></span><br><span class="line">                <span class="comment">// Toast显示的时长, 有两个选择: Toast.LENGTH_SHORT/Toast.LENGTH_LONG</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="在活动中使用menu">2.1.5 在活动中使用Menu</h4><ol type="1"><li><p>在<strong>res</strong>目录下，新建一个目录<strong>menu</strong></p></li><li><p><strong>右击menu文件夹|新建|Menu ResourceFile</strong>，文件名输入<strong>main</strong></p></li><li><p>修改<strong>main.xml</strong>文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_item&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Add&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/remove_item&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Remove&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;item&gt;标签就是用来创建具体的某一个菜单项--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--android:id表示唯一标识符--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--android:title给这个菜单项指定一个名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改<strong>FirstActivity.java</strong>文件，重写<strong>onCreateOptionMenu()</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">    <span class="comment">// 通过getMenuInflater()方法能够得到MenuInflater对象</span></span><br><span class="line">    <span class="comment">// 再调用它的inflate()方法就可以给当前活动创建菜单了</span></span><br><span class="line">    <span class="comment">// inflate的两个参数:</span></span><br><span class="line">    <span class="comment">// 第一个: 指定通过哪一个资源文件来创建菜单</span></span><br><span class="line">    <span class="comment">// 第二个: 指定我们的菜单项将添加到哪一个Menu对象中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 返回true: 表示允许创建的菜单显示出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义菜单响应事件：重写<strong>onOptionsItemSelected</strong>函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(<span class="meta">@NonNull</span> MenuItem item)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId())&#123; <span class="comment">// 判断点击的是哪一个菜单项</span></span><br><span class="line">        <span class="keyword">case</span>  R.id.add_item:</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;You clicked Add&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;You clicked Remove&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="销毁一个活动">2.1.6 销毁一个活动</h4><ol type="1"><li><p>调用<strong>Activity</strong>类的<strong>finish()</strong>方法即可，修改<strong>Button</strong>监听器中的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        Toast.makeText(FirstActivity.<span class="built_in">this</span>, <span class="string">&quot;You clicked Button &quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用intent在活动之间穿梭">2.2 使用Intent在活动之间穿梭</h3><h4 id="使用显式intent">2.2.1 使用显式Intent</h4><ol type="1"><li><p><strong>右击com.example.hw2_Activity包|新建|Activity|EmptyActivity</strong>，创建一个新活动</p></li><li><p>这次勾选<strong>Generate LayoutFile</strong>，并将布局文件起名为<strong>second_layout</strong>，但是不要勾选<strong>LauncherActivity</strong></p></li><li><p>进入布局文件，新建一个<strong>Button</strong>控件</p></li><li><p>注意：所有Activity都需要在<strong>AndroidManifest.xml</strong>中注册，这里系统已经帮我们注册好了</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册SecondActivity--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注册FirstActivity--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:label</span>=<span class="string">&quot;This is the first activity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用显式Intent启动活动：修改<strong>FirstActivity.java</strong>中的按钮点击事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">        <span class="comment">// 第一个参数: 启动活动的上下文</span></span><br><span class="line">        <span class="comment">// 第二个参数: 目标活动</span></span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="使用隐式intent">2.2.2 使用隐式Intent</h4><ol type="1"><li><p>相比于显式Intent，隐式Intent则含蓄了许多，它并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。</p></li><li><p>什么叫作合适的活动呢？简单来说就是可以响应我们这个隐式Intent的活动。</p></li><li><p>修改<strong>AndroidManifest.xml</strong>，让<strong>SecondActivity</strong>能够响应<strong>隐式Intent</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册SecondActivity--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.hw2_activity.ACTION_START&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指明当前活动可以响应com.example.hw2_activity.ACTION_START这个action--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指明当前活动能够响应的Intent中还可能带有的category--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只有&lt;action&gt;和&lt;category&gt;同时匹配上Intent中指定的action和category时,这个活动才能响应该Intent--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改<strong>FirstActivity.java</strong>中的按钮点击事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.hw2_activity.ACTION_START&quot;</span>);</span><br><span class="line">        intent.addCategory(<span class="string">&quot;com.example.hw2_activity.MY_CATEGORY&quot;</span>);</span><br><span class="line">        <span class="comment">// 每个Intent只能有一个Action, 但是可以有多个Category</span></span><br><span class="line">        <span class="comment">// 只有当Activity同时匹配上Action和所有的Category时, 才会响应Intent</span></span><br><span class="line">        startActivity(intent);</span><br><span class="line">        <span class="comment">// android.intent.category.DEFAULT是默认category</span></span><br><span class="line">        <span class="comment">// 在调用startActivity()方法时会自动将这个category添加到Intent中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="更多隐式intent的用法">2.2.3 更多隐式Intent的用法</h4><ol type="1"><li><p><strong>打开网页</strong>：修改<strong>FirstActivity.java</strong>中的按钮点击事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW);</span><br><span class="line">        <span class="comment">// Intent.ACTION_VIEW是Android系统内置的动作</span></span><br><span class="line">        <span class="comment">// 其常量值为android.intent.action.VIEW</span></span><br><span class="line">        intent.setData(Uri.parse(<span class="string">&quot;http://www.baidu.com&quot;</span>));</span><br><span class="line">        <span class="comment">// 使用Uri.parse()方法,将一个网址字符串解析成一个Uri对象</span></span><br><span class="line">        <span class="comment">// 调用Intent的setData()方法, 将这个Uri对象传递进去</span></span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>setData()</strong>方法：指定当前Intent正在操作的数据</p><ol type="1"><li>与此对应,我们还可以在<strong>&lt; intent-filter&gt;</strong>标签中再配置一个<strong>&lt; data&gt;</strong>标签，用于更精确地指定当前活动能够响应什么类型的数据。<strong>&lt;data &gt;</strong>标签中主要可以配置以下内容。<ol type="1"><li><strong>android:scheme</strong>：用于指定数据的协议部分，如上例中的http部分</li><li><strong>android:host</strong>：用于指定数据的主机名部分,如上例中的www.baidu.com部分</li><li><strong>android:port</strong>：用于指定数据的端口部分，一般紧随在主机名之后</li><li><strong>android:path</strong>：用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容</li><li><strong>android:mimeType</strong>：用于指定可以处理的数据类型，允许使用通配符的方式进行指定。</li></ol></li><li>只有<strong>&lt; data&gt;</strong>标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该Intent</li><li>不过一般在<strong>&lt; data &gt;</strong>标签中都不会指定过多的内容<ol type="1"><li>如上面浏览器示例中，其实只需要指定<strong>android:scheme为http</strong>，就可以响应所有的http协议的Intent了</li></ol></li></ol></li><li><p>写一个能够<strong>响应打开网页</strong>的活动</p><ol type="1"><li>新建一个活动<strong>ThirdActivity</strong></li><li>修改<strong>AndroidManifest.xml</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注册ThirdActivity --&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">android:name=<span class="string">&quot;.ThirdActivity&quot;</span></span><br><span class="line">android:exported=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=<span class="string">&quot;android.intent.action.VIEW&quot;</span>/&gt;</span><br><span class="line">&lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br><span class="line">&lt;data android:scheme=<span class="string">&quot;http&quot;</span>/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>拨打电话</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_DIAL);</span><br><span class="line">        intent.setData(Uri.parse(<span class="string">&quot;tel:10086&quot;</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="向下一个活动传递数据">2.2.4 向下一个活动传递数据</h4><ol type="1"><li><p>给出数据：<strong>putExtra()</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Hello SecondActivity&quot;</span>;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;extra_data&quot;</span>, data);</span><br><span class="line">        <span class="comment">// 第一个参数是键, 第二个参数是传递的数据</span></span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>接收数据：<strong>getStringExtra()</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.second_layout);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;extra_data&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串型数据就是getStringExtra, 整型数据就是getIntExtra</span></span><br><span class="line">        Log.d(<span class="string">&quot;SecondActivity&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="返回数据给上一个活动">2.2.5 返回数据给上一个活动</h4><ol type="1"><li><p>需要返回数据的启动新活动：<strong>startActivityForResult()</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">        startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>返回数据：<strong>setResult()</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button2.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">        intent.putExtra(<span class="string">&quot;data_return&quot;</span>, <span class="string">&quot;Hello FirstActivity&quot;</span>);</span><br><span class="line">        setResult(RESULT_OK, intent);</span><br><span class="line">        <span class="comment">// 第一个参数: 向上一个活动返回处理结果, 一般只使用RESULT_OK/RESULT_CANCELED</span></span><br><span class="line">        <span class="comment">// 第二个参数: 带有数据的Intent</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>获取返回数据：<strong>onActivityResult()</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> &#123;</span><br><span class="line">    <span class="comment">// requestCode: 启动新活动是传入的请求码</span></span><br><span class="line">    <span class="comment">// resultCode: 返回数据时传入的处理结果</span></span><br><span class="line">    <span class="comment">// data: 携带着返回数据的Intent</span></span><br><span class="line">    <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span>(resultCode == RESULT_OK)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">returnedData</span> <span class="operator">=</span> data.getStringExtra(<span class="string">&quot;data_return&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;FirstActivity&quot;</span>, returnedData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按返回键返回：<strong>onBackPressed()</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBackPressed</span><span class="params">()</span> &#123; <span class="comment">// 按返回键返回</span></span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">    intent.putExtra(<span class="string">&quot;data_return&quot;</span>, <span class="string">&quot;Hello FirstActivity&quot;</span>);</span><br><span class="line">    setResult(RESULT_OK, intent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="活动的生命周期">2.3 活动的生命周期</h3><h4 id="返回栈-back-stack">2.3.1 返回栈 Back Stack</h4><ol type="1"><li>其实Android是使用任务(Task)来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(<strong>BackStack</strong>)</li><li>栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下Back键或调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置</li><li>系统总是会显示处于栈顶的活动给用户</li></ol><h4 id="活动状态">2.3.2 活动状态</h4><ol type="1"><li><strong>运行状态</strong>：活动位于返回栈栈顶</li><li><strong>暂停状态</strong>：活动不在栈顶，但是仍然可见</li><li><strong>停止状态</strong>：活动不在栈顶，且不可见</li><li><strong>销毁状态</strong>：活动不在返回栈中</li></ol><h4 id="活动的生命周期-1">2.3.3 活动的生命周期</h4><h5 id="对应的7个回调方法">2.3.3.1 对应的7个回调方法</h5><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830192712259.png" alt="image-20220830192712259" style="zoom:80%;" /></p><ol type="1"><li><strong>onCreate()</strong>：它会在活动<strong>第一次被创建</strong>的时候调用。<ol type="1"><li>你应该在这个方法中完成活动的<strong>初始化操作</strong>，比如说加载布局、绑定事件等</li></ol></li><li><strong>onStart()</strong>：这个方法在活动由<strong>不可见变为可见</strong>的时候调用</li><li><strong>onResume()</strong>：这个方法在活动准备好和用户进行交互的时候调用。<ol type="1"><li>此时的活动一定<strong>位于返回栈的栈顶</strong>，并且处于运行状态</li></ol></li><li><strong>onPause()</strong>：这个方法在系统准备去<strong>启动或者恢复另一个活动</strong>的时候调用。<ol type="1"><li>我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据</li><li>但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用</li></ol></li><li><strong>onStop()</strong>：这个方法在活动<strong>完全不可见</strong>的时候调用。<ol type="1"><li>它和<strong>onPause()</strong>方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么<strong>onPause()</strong>方法会得到执行，而<strong>onStop()</strong>方法并不会执行</li></ol></li><li><strong>onDestroy()</strong>：这个方法在活动<strong>被销毁</strong>之前调用，之后活动的状态将变为销毁状态</li><li><strong>onRestart()</strong>：这个方法在活动由<strong>停止状态变为运行状态</strong>之前调用，也就是活动被重新启动了</li></ol><h5 id="将活动注册为对话框">2.3.3.2 将活动注册为对话框</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;.DialogActivity&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.AppCompat.Dialog&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="活动被回收了怎么办">2.3.4 活动被回收了怎么办</h4><ol type="1"><li><p>存储临时数据：<strong>onSaveInstanceState()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Bundle outState, <span class="meta">@NonNull</span> PersistableBundle outPersistentState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onSaveInstanceState(outState, outPersistentState);</span><br><span class="line">    <span class="type">String</span> <span class="variable">temoData</span> <span class="operator">=</span> <span class="string">&quot;Something you just Typed&quot;</span>;</span><br><span class="line">    outState.putString(<span class="string">&quot;data_key&quot;</span>, temoData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>恢复临时数据：<strong>onCreate()</strong>中的<strong>savedInstanceState</strong>参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(savedInstanceState != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tempData</span> <span class="operator">=</span> savedInstanceState.getString(<span class="string">&quot;data_key&quot;</span>);</span><br><span class="line">        Log.d(TAG, tempData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="活动的启动模式">2.4 活动的启动模式</h3><ol type="1"><li>可以在<strong>AndroidManifest.xml</strong>中，通过给<strong>&lt;activity&gt;</strong>标签指定<strong>android:launchMode</strong>属性，来指定启动模式</li></ol><h4 id="standard">2.4.1 standard</h4><ol type="1"><li>默认启动模式</li><li>不检查栈中有是否已有这个Activity，总会<strong>创建⼀个新Activity</strong>，并push到栈顶</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830195908952.png" alt="image-20220830195908952" style="zoom:80%;" /></p><h4 id="singletop">2.4.2 singleTop</h4><ol type="1"><li><strong>检查栈顶</strong>判断是否需要新建Activity</li><li>⾮栈顶的元素不会检查，所以当FirstActivity不位于栈顶时，再次startActivity(FirstActivity)还会再创建⼀个FirstActivity</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830200014909.png" alt="image-20220830200014909" style="zoom:80%;" /></p><h4 id="singletask">2.4.3 singleTask</h4><ol type="1"><li>每次启动该活动时系统⾸先会<strong>在返回栈中检查是否存在该Activity的实例</strong></li><li>如果发现已经存在则直接使⽤该实例，并把在这个Activity之上的所有Activity统统出栈</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830200117581.png" alt="image-20220830200117581" style="zoom:80%;" /></p><h4 id="singleinstance">2.4.4 singleInstance</h4><ol type="1"><li><p>会<strong>启用一个新的返回栈</strong>来管理指定为<strong>singleInstance</strong>的<strong>Activity</strong></p></li><li><p>使⽤场景：跨进程（app）间的Activity实例共享，不管是哪个应⽤程序来访问这个Activity，都共⽤同⼀个返回栈</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830200531526.png" alt="image-20220830200531526" style="zoom:80%;" /></p></li></ol><h3 id="活动的最佳实践">2.5 活动的最佳实践</h3><h4 id="知晓当前是在哪一个活动">2.5.1 知晓当前是在哪一个活动</h4><ol type="1"><li><p>首先，新建一个<strong>BaseActivity</strong>类，继承自<strong>AppCompatActivity</strong></p></li><li><p>重写<strong>OnCreate()</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(<span class="string">&quot;BaseActivity&quot;</span>, getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让<strong>BaseActivity</strong>称为<strong>hw2_activity</strong>项目中所有活动的父类</p><ol type="1"><li>修改<strong>FirstActivity、SecondActivity、ThirdActivity</strong>，让他们不再继承于<strong>AppCompatActivity</strong>，而是继承自<strong>BaseActivity</strong></li></ol></li></ol><h4 id="随时随地退出程序">2.5.2 随时随地退出程序</h4><ol type="1"><li><p>新建一个类<strong>ActivityCollector</strong>作为活动管理器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityCollector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Activity&gt; activities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addActivity</span><span class="params">(Activity activity)</span>&#123;</span><br><span class="line">        activities.add(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeActivity</span><span class="params">(Activity activity)</span>&#123;</span><br><span class="line">        activities.remove(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">finishAll</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ActivityCollector&quot;</span>, <span class="string">&quot;finishAll&quot;</span>+activities.size());</span><br><span class="line">        <span class="keyword">for</span>(Activity activity : activities)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!activity.isFinishing())</span><br><span class="line">                activity.finish();</span><br><span class="line">        &#125;</span><br><span class="line">        activities.clear();</span><br><span class="line"></span><br><span class="line">        android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">        <span class="comment">// 只能杀掉当前进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改<strong>BaseActivity</strong>中的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(<span class="string">&quot;BaseActivity&quot;</span>, getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        ActivityCollector.addActivity(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        ActivityCollector.removeActivity(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>ThirdActivity</strong>界面中点击按钮直接退出程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdActivity</span> <span class="keyword">extends</span> <span class="title class_">BaseActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.third_layout);</span><br><span class="line"></span><br><span class="line">        <span class="type">Button</span> <span class="variable">button3</span> <span class="operator">=</span> (Button) findViewById(R.id.button3);</span><br><span class="line">        button3.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;ThirdActivity&quot;</span>, <span class="string">&quot;onClick: &quot;</span>);</span><br><span class="line">                ActivityCollector.finishAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="启动进程的最佳写法">2.5.3 启动进程的最佳写法</h4><ol type="1"><li><p>启动<strong>Secondary</strong>进程时，我们可能并不知道它需要哪些参数，要么去问负责这个活动的同学，要么自己去看代码</p></li><li><p>我们只需要在<strong>Secondary</strong>中封装一个方法<strong>actionStart</strong>，即可方便的告诉大家，<strong>Secondary</strong>启动时需要哪些参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondActivity</span> <span class="keyword">extends</span> <span class="title class_">BaseActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">actionStart</span><span class="params">(Context context, String data1, String data2)</span>&#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(context, SecondActivity.class);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;param1&quot;</span>, data1);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;param2&quot;</span>, data2);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="第三章-软件也要拼脸蛋--ui开发的点点滴滴">第三章软件也要拼脸蛋--UI开发的点点滴滴</h2><h3 id="控件与布局">3.1 控件与布局</h3><ol type="1"><li>UI控件：<strong>TextView</strong>, <strong>ImageView</strong>,<strong>Button</strong>, <strong>ProgressBar</strong></li><li>UI布局：<strong>LinearLayout</strong>,<strong>RelativeLayout</strong>, <strong>FrameLayout</strong>,</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830204018378.png" alt="image-20220830204018378" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830204024868.png" alt="image-20220830204024868" style="zoom:80%;" /></p><h3 id="常用控件">3.2 常用控件</h3><h4 id="textview">3.2.1 TextView</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830204858307.png"alt="image-20220830204858307" /><figcaption aria-hidden="true">image-20220830204858307</figcaption></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830204911012.png" alt="image-20220830204911012" style="zoom:80%;" /></p><ol type="1"><li><strong>layout_width</strong>：控件的宽</li><li><strong>layout_height</strong>：控件的⾼</li><li><strong>wrap_content</strong>：表示和⾃身内容⼀样的⻓度</li><li><strong>match_parent</strong>：表示和⽗组件⼀样的⻓度</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830204243973.png" alt="image-20220830204243973" style="zoom:80%;" /></p><h4 id="pxdpdpidensity-与-sp">3.2.2 px、dp、dpi、density 与 sp</h4><ol type="1"><li><strong>px</strong>：pixel，1px代表屏幕上的⼀个物理像素点</li><li><strong>dpi</strong>：dots perinch，对角线每英寸的像素点的个数；该值越大表示屏幕越清，<spanclass="math inline">\(dpi=\frac{\sqrt{ {height}^2+{width}^2}}{size}\)</span>。</li><li><strong>density</strong>：<spanclass="math inline">\(density=\frac{dpi}{60}\)</span>。</li><li><strong>dp/dip</strong>：density-independentpixel，设备无关像素，<spanclass="math inline">\(dp=\frac{px}{density}\)</span>。</li><li><strong>sp</strong>：scale-independent pixel，与缩放⽆关的抽象像素<ol type="1"><li>与dp近似，但除了受屏幕密度影响外，还受到⽤户字体大小影响（正相关）</li></ol></li></ol><h4 id="edittext">3.2.3 EditText</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830204922564.png" alt="image-20220830204922564" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830204836168.png" alt="image-20220830204836168" style="zoom:80%;" /></p><ol type="1"><li>监听输⼊内容变化：<strong>TextWatcher</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830205018365.png" alt="image-20220830205018365" style="zoom: 80%;" /></p><h4 id="imageview">3.2.4 ImageView</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830205158604.png" alt="image-20220830205158604" style="zoom:80%;" /></p><ol type="1"><li><p>静态设置</p><ol type="1"><li><strong>android:src</strong>：指定<strong>drawable</strong>(本地图片)或<strong>bitmap</strong>资源(网络图片)</li><li><strong>android:background</strong>：指定ImageView背景（如color）</li><li><strong>android:scaleType</strong>：设置图片如何缩放以适应ImageView大小；<ol type="1"><li>参数如center，centerCrop等</li></ol></li></ol></li><li><p>动态设置</p><ol type="1"><li><p><strong>setImageResource</strong>：添加资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mImageView.setImageResource(R.drawable.icon_search);</span><br></pre></td></tr></table></figure></li><li><p>解析成bitmap后，setRotate设置旋转等</p></li></ol></li><li><p><strong>svg</strong>和<strong>png</strong>相比有何优势</p><ol type="1"><li>抗拉伸</li><li>适配分辨率友好</li><li>占⽤空间小</li></ol></li></ol><h4 id="dialogs自学内容">3.2.5 Dialogs(自学内容)</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830205419562.png" alt="image-20220830205419562" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830205454275.png" alt="image-20220830205454275" style="zoom:80%;" /></p><ol type="1"><li>https://developer.android.com/guide/topics/ui/dialogs</li><li>如何生成，展示，隐藏⼀个Dialog？</li><li>如何⾃定义Dialog样式，添加Button和Listener？</li></ol><h3 id="基本布局">3.3 基本布局</h3><h4 id="linearlayout">3.3.1 LinearLayout</h4><ol type="1"><li><p><strong>android:orientation</strong>：表示线性布局排列⽅向</p><ol type="1"><li>可选<strong>vertical</strong>或<strong>horizontal</strong></li></ol></li><li><p><strong>android:layout_gravity</strong>：表示指定控件在layout中的对⻬⽅式</p><ol type="1"><li><strong>center_vertical</strong>只在orientation=“<strong>horizontal</strong>”时⽣效</li><li><strong>center_horizontal</strong>只在orientation=“<strong>vertical</strong>”时⽣效</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830205626934.png" alt="image-20220830205626934" style="zoom:80%;" /></p></li><li><p><strong>android:layout_weight</strong>：使用<strong>比例</strong>的方式指定控件的大小</p><ol type="1"><li>每个控件在排列⽅向上尺寸占比为：<strong>self weight / totalweight</strong></li><li>如下图两个View的weight都为1，则两个View的宽度与屏幕宽度⽐均为<spanclass="math inline">\(\frac{1}{1+1}=\frac{1}{2}\)</span></li><li>两个View的layout_width的规范写法为0dp</li><li>如果⼀些控件未指定weight，则这些控件按指定width或height展示。其余指定weight的控件对剩余屏幕宽度或高度进行分割</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830210035726.png" alt="image-20220830210035726" style="zoom:80%;" /></p></li></ol><h4 id="relativelayout">3.3.2 RelativeLayout</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830210142687.png" alt="image-20220830210142687" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830210118803.png" alt="image-20220830210118803" style="zoom:80%;" /></p><h4 id="padding-与-margin">3.3.3 padding 与 margin</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830210223617.png" alt="image-20220830210223617" style="zoom:80%;" /></p><h4 id="framelayout自学内容">3.3.4 FrameLayout（自学内容）</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830210319103.png" alt="image-20220830210319103" style="zoom:80%;" /></p><h4 id="constraintlayout">3.3.5 ConstraintLayout</h4><ol type="1"><li><p>对View A在水平和垂直两个方向上指定限制，每⼀方向上⾄少指定⼀个限制，限制标的可以是其他View或父View</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830210417516.png" alt="image-20220830210417516" style="zoom:80%;" /></p></li><li><p>如果对ViewB同时添加了app:layout_constraintRight_toRightOf=“<spanclass="citation" data-cites="id/viewA">@id/viewA</span>”和app:layout_constraintLeft_toLeftOf=“<span class="citation"data-cites="id/viewA">@id/viewA</span>”表示什么含义？</p></li><li><p>ConstraintLayout的使⽤场景（拓展）</p><ol type="1"><li>N等分布局</li><li>角度布局</li><li>超长限制优化</li></ol><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation <span class="string">&quot;androidx.constraintlayout:constraintlayout:2.1.4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="自定义控件">3.3.6 自定义控件</h4><ol type="1"><li><p>可继承任意Android控件，在此基础上添加或重写功能</p></li><li><p>更好的封装</p><ol type="1"><li><p>举例：六个可输入方格、选中框、光标等</p></li><li><p>⼀种实现：作为⼀个<strong>EditText</strong>，⾃定义<strong>View(SixWordEditText)</strong>继承<strong>EditText</strong></p><ol type="1"><li><p><strong>OverrideTextView</strong>的<strong>onDraw</strong>⽅法，绘制每个方格样式和⽂字</p></li><li><p><strong>TextWatcher</strong>监听<strong>afterTextChanged</strong></p></li><li><p><strong>SixWorkEdtiText</strong>在<strong>XML</strong>中引⽤</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.ss.meetx.roomui.widget.SixWordEditText</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/accessCodeEditText&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>提高复用性</p><ol type="1"><li><p>如何在XML中实现下面的UI？使⽤什么布局和控件？层级是怎样的？</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830211137204.png" alt="image-20220830211137204" style="zoom:80%;" /></p><ol type="1"><li><p><strong>input_view.xml</strong></p></li><li><p>构造<strong>SearchTextLayout</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SearchTextLayout</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">LayoutInflater.from(context).inflate(R.layout.input_view, <span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用<strong>SearchTextLayout</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.ss.meetx.roomui.widget.input.SearchTextLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">“@+id/inputViewSearch</span>&quot;</span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">“0dp</span>&quot;</span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">“52dp</span>&quot;/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="recyclerview">3.4 RecyclerView</h3><h4 id="基本布局scrollview">3.4.1 基本布局：ScrollView</h4><ol type="1"><li><p>滚动布局，默认垂直方向滑动，也⽀持水平方向滑动HorizontalScrollView</p></li><li><p>直接<strong>子View只能有⼀个</strong></p></li><li><p>如果⽤<strong>ScrollView</strong>实现右侧的滑动列表应该怎么做？</p></li><li><p>开发上有什么不便？性能上有什么弊端？</p><ol type="1"><li>重复写n个View，动态添加View比较复杂</li><li>初始化时会将所有数据项全部加载出来，没有回收和复同；导致内存占用大和OOM</li><li>用户体验是加载速度慢，卡顿</li></ol></li></ol><h4 id="recyclerview-1">3.4.2 RecyclerView</h4><ol type="1"><li><p>核心：<strong>View Holder</strong>，<strong>Adapter</strong>，<strong>Recycler View</strong></p></li><li><p><strong>ItemDecorator</strong>：Item之间Divider（分割线）</p></li><li><p><strong>Item Animator</strong>：添加删除Item的动画</p></li></ol><h4 id="layoutmanager">3.4.3 LayoutManager</h4><ol type="1"><li><p><strong>LinearLayoutManager</strong>(左图）</p><ol type="1"><li>线性造型，类似ListView的功能</li><li>支持上下或左右滑动，每⼀行或⼀列上仅有⼀个item</li></ol></li><li><p><strong>GridLayoutManager</strong>(中图）</p><ol type="1"><li>网格造型，每个item在滑动方向上的尺寸相同</li><li>可以通过setSpanSizeLookup和getSpanSize，指定条件（如item中text宽度，item的position等），来控制该item占几个位置（即每⼀行有几个item）</li></ol></li><li><p><strong>StaggeredGridLayoutManager</strong>(右图)</p><ol type="1"><li>瀑布流造型，每个item的尺寸可不相同，错落式布局</li><li>在其constructor中可指定滑动方向和行数（或列数）</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830211927154.png" alt="image-20220830211927154" style="zoom:80%;" /></p></li><li><p><strong>自定义LayoutManager</strong>（拓展）</p><ol type="1"><li>继承<strong>LayoutManager</strong>类</li><li>重写<strong>generateDefaultLayoutParams</strong>⽅法，直接返回⼀个⻓宽都为<strong>WRAP_CONTENT</strong>的<strong>LayoutParams</strong>即可；</li><li>重写<strong>onLayoutChildren</strong>⽅法，在这⾥⾯布局<strong>Items</strong>（显示出来）；具体包括分离和回收有效items（detachAndScrapAttachedViews），获取需要布局的items（可见的），再通过addView将这些item添加回去。然后对其测量（measureChild）确定View的宽高，</li><li>使⽤<strong>layoutDecorated</strong>确定View摆放的位置，并设置跟随滑动放缩比例</li><li>重写<strong>canScrollHorizontally</strong>和<strong>canScrollVertically</strong>方法，使它⽀持⽔平或垂直滚动；</li><li>重写<strong>scrollHorizontallyBy</strong>和<strong>scrollVerticallyBy</strong>，并在这里处理滚动工作；</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830212145783.png" alt="image-20220830212145783" style="zoom:80%;" /></p></li></ol><h4 id="recyclerview使用示例">3.4.4 RecyclerView使用示例</h4><h5 id="添加依赖">3.4.4.1 添加依赖</h5><blockquote><ol type="1"><li>在<strong>app/build.gradle</strong>中，添加<strong>RecyclerView</strong>的依赖</li></ol></blockquote><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.recyclerview:recyclerview:1.1.0&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="添加相关内容表示recyclerview中每一个独立的item">3.4.4.2添加相关内容，表示RecyclerView中每一个独立的item</h5><blockquote><ol type="1"><li>创建<strong>Java</strong>类<strong>ItemData</strong>，表示每一个<strong>item</strong>存储的数据</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String link;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ItemData</span><span class="params">(String title, String link)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = <span class="string">&quot;  &quot;</span> + title;</span><br><span class="line">        <span class="built_in">this</span>.link = link;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLink</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> link;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="2" type="1"><li>创建<strong>layout</strong>布局文件<strong>recyclerview_item.xml</strong>，表示每一个<strong>item</strong>的布局</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/text_view_shape&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/RecyclerView_Item&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawableBottom</span>=<span class="string">&quot;@drawable/text_view_shape&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fontFamily</span>=<span class="string">&quot;sans-serif-thin&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:maxLines</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;文章的标题&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAlignment</span>=<span class="string">&quot;viewStart&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#000000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:typeface</span>=<span class="string">&quot;sans&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ol start="3" type="1"><li>创建<strong>Java</strong>类<strong>MyViewHolder</strong>，用于存储每个<strong>item</strong>的控件，控件都有哪些，在<strong>recyclerview_item.xml</strong>中定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder&#123;</span><br><span class="line">    <span class="keyword">public</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewHolder</span><span class="params">(View itemView)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(itemView);</span><br><span class="line">        <span class="built_in">this</span>.textView = itemView.findViewById(R.id.recyclerview_item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加recyclerview的adapter">3.4.4.3添加RecyclerView的Adapter</h5><blockquote><ol type="1"><li>创建<strong>Java</strong>类<strong>MyRecyclerViewAdapter</strong>，为<strong>RecyclerView</strong>控件的<strong>Adapter</strong><ol type="1"><li>这个类继承自<strong>RecyclerView.Adapter&lt; MyViewHolder&gt;</strong></li><li>这个类会重写<strong>View.OnClickListener</strong></li></ol></li><li>类中包含了<strong>Adapter</strong>所在的<strong>Context</strong>，每个<strong>item</strong>包含的数据<ol type="1"><li>这些是在构造函数中需要传入的</li></ol></li><li>创建一个方法<strong>setItem(int position, ItemDataitem)</strong>，表示修改<strong>position</strong>地方的数据<ol type="1"><li>先修改<strong>itemList</strong>中的数据</li><li>然后调用<strong>this.notifyItemChanged(position)</strong>方法，修改<strong>item</strong>的控件</li></ol></li><li>重写多个方法，实现<strong>Adapter</strong>的功能<ol type="1"><li><strong>onCreateViewHolder()</strong>：<strong>item</strong>框创立时,调用该方法<ol type="1"><li>根据<strong>item</strong>对应的<strong>layout</strong>文件<strong>recyclerview_item.xml</strong>，创建每个<strong>item</strong>对应的<strong>View</strong>视图</li><li>给<strong>View</strong>视图设置<strong>Listener</strong></li><li>从<strong>itemView</strong>中获取<strong>MyViewHolder</strong>并返回</li></ol></li><li><strong>onAttachedToRecyclerView()</strong>：将<strong>RecycleView</strong>附加到<strong>Adapter</strong>上时,调用该方法<ol type="1"><li>设置当前<strong>Adapter</strong>负责的<strong>RecyclerView</strong></li></ol></li><li><strong>onDetachedFromRecyclerView()</strong>：将<strong>RecycleView</strong>从<strong>Adapter</strong>解除时,调用该方法<ol type="1"><li>设置当前<strong>Adapter</strong>负责的<strong>RecyclerView</strong></li></ol></li><li><strong>onBindViewHolder()</strong>：<strong>item</strong>显示时,调用该方法<ol type="1"><li>根据<strong>item</strong>的位置，设置当前<strong>item</strong>的每个组件的值</li></ol></li><li><strong>getItemCount()</strong>：<strong>item</strong>的数量</li></ol></li><li>重写<strong>onClick()</strong>方法，处理<strong>RecyclerView</strong>的点击事件<ol type="1"><li>添加自定义接口<strong>OnItemClickListener</strong>，处理<strong>item</strong>的点击事件<ol type="1"><li>需要实现的方法：<strong>void onItemClick(RecyclerView parent, Viewview, int position, ItemData data);</strong></li></ol></li><li>通过<strong>recyclerView.getChildAdapterPosition()</strong>方法，获取当前点击的<strong>item</strong>的位置</li><li>执行具体实现的<strong>onItemClick()</strong>方法</li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRecyclerViewAdapter</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;MyViewHolder&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前Activity/Fragment</span></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="comment">// 每个item包含的数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ItemData&gt; itemList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个item的控件</span></span><br><span class="line">    <span class="keyword">private</span> View itemView;</span><br><span class="line">    <span class="comment">// 被附加到Adapter上的RecyclerView控件</span></span><br><span class="line">    <span class="keyword">private</span> RecyclerView recyclerView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRecyclerViewAdapter</span><span class="params">(Context context, List&lt;ItemData&gt; itemList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">        <span class="built_in">this</span>.itemList = itemList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItem</span><span class="params">(<span class="type">int</span> position, ItemData item)</span>&#123;</span><br><span class="line">        itemList.set(position, item);</span><br><span class="line">        <span class="built_in">this</span>.notifyItemChanged(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// item框创立时, 调用该方法</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据layout文件, 创建View视图</span></span><br><span class="line">        itemView = LayoutInflater.from(context).inflate(R.layout.recyclerview_item, parent, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给View视图设置Listener</span></span><br><span class="line">        itemView.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从itemView中获取MyViewHolder并返回</span></span><br><span class="line">        <span class="type">MyViewHolder</span> <span class="variable">myViewHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyViewHolder</span>(itemView);</span><br><span class="line">        <span class="keyword">return</span> myViewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将RecycleView附加到Adapter上时, 调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAttachedToRecyclerView</span><span class="params">(<span class="meta">@NonNull</span> RecyclerView recyclerView)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">        <span class="built_in">this</span>.recyclerView = recyclerView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将RecycleView从Adapter解除时, 调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDetachedFromRecyclerView</span><span class="params">(<span class="meta">@NonNull</span> RecyclerView recyclerView)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDetachedFromRecyclerView(recyclerView);</span><br><span class="line">        <span class="built_in">this</span>.recyclerView = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// item显示时, 调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> MyViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据item位置的数据, 设置当前item的每个组件的值</span></span><br><span class="line">        <span class="type">ItemData</span> <span class="variable">data</span> <span class="operator">=</span> itemList.get(position);</span><br><span class="line">        holder.textView.setText(data.getTitle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// item的数量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 RecyclerView 的 Adapter 中定义单击事件的回调接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnItemClickListener</span>&#123;</span><br><span class="line">        <span class="comment">//参数: 父组件, 当前单击的View, 单击的View的位置, 数据</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onItemClick</span><span class="params">(RecyclerView parent, View view, <span class="type">int</span> position, ItemData data)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> OnItemClickListener onItemClickListener;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnItemClickListener</span><span class="params">(OnItemClickListener onItemClickListener)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onItemClickListener = onItemClickListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RecyclerView被点击时, 调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="comment">//根据RecyclerView获得当前View的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> recyclerView.getChildAdapterPosition(view);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//程序执行到此，会去执行具体实现的onItemClick()方法</span></span><br><span class="line">        <span class="keyword">if</span>(onItemClickListener != <span class="literal">null</span>)&#123;</span><br><span class="line">            onItemClickListener.onItemClick(recyclerView, view, position, itemList.get(position));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="在activity中对recyclerview控件进行相关的设置">3.4.4.4在Activity中对RecyclerView控件进行相关的设置</h5><blockquote><ol type="1"><li>在<strong>onCreate()</strong>中调用自定义方法<strong>setRecyclerView()</strong></li><li>在<strong>setRecyclerView()</strong>中进行<strong>RecyclerView</strong>控件的初始化操作<ol type="1"><li>设置所有<strong>item</strong>的默认数据</li><li>设置<strong>RecyclerView</strong>控件的<strong>Adapter</strong></li><li>设置<strong>RecyclerView</strong>控件的<strong>LayoutManager</strong></li><li>设置<strong>RecyclerView</strong>控件的<strong>Adapter</strong>的点击事件响应方法<strong>OnItemClickListener()</strong></li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONTENT_ACTIVITY_RequestCode</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RecyclerView recyclerView;</span><br><span class="line">    <span class="keyword">private</span> MyRecyclerViewAdapter adapter;</span><br><span class="line">    <span class="keyword">private</span> LinearLayoutManager layoutManager;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ItemData&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化界面的相关操作</span></span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.lab5_main_layout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化RecyclerView</span></span><br><span class="line">        networkResult = findViewById(R.id.recyclerView);</span><br><span class="line">        setRecyclerView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化RecyclerView</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setRecyclerView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 设置recyclerView中所有item的数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            <span class="type">ItemData</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemData</span>(<span class="string">&quot;第 &quot;</span> + i +<span class="string">&quot; 篇文章标题为:&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            itemList.add(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置Adapter</span></span><br><span class="line">        adapter = <span class="keyword">new</span> <span class="title class_">MyRecyclerViewAdapter</span>(<span class="built_in">this</span>, itemList);</span><br><span class="line">        recyclerView.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置LayoutManager</span></span><br><span class="line">        layoutManager = <span class="keyword">new</span> <span class="title class_">LinearLayoutManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        layoutManager.setOrientation(RecyclerView.VERTICAL);</span><br><span class="line">        recyclerView.setLayoutManager(layoutManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置click事件响应</span></span><br><span class="line">        adapter.setOnItemClickListener(<span class="keyword">new</span> <span class="title class_">MyRecyclerViewAdapter</span>.OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemClick</span><span class="params">(RecyclerView parent, View view, <span class="type">int</span> position, ItemData data)</span> &#123;</span><br><span class="line">                <span class="comment">// 使用WebView Activity打开网页</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">urlString</span> <span class="operator">=</span> data.getLink();</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, WebViewActivity.class);</span><br><span class="line">                intent.putExtra(<span class="string">&quot;url&quot;</span>, urlString);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">                </span><br><span class="line">                 <span class="comment">// 修改Adapter中的itemID处的文本</span></span><br><span class="line">                    adapter = (MyRecyclerViewAdapter) recyclerView.getAdapter();</span><br><span class="line">                    <span class="type">ItemData</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemData</span>(<span class="string">&quot;item &quot;</span> + itemID + <span class="string">&quot; 已完成&quot;</span>);</span><br><span class="line">                    adapter.setItem(itemID, item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回收复用机制">3.4.5 回收复用机制</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220830212638148.png" alt="image-20220830212638148" style="zoom:80%;" /></p><h1 id="day3-ui进阶">Day3 UI进阶</h1><h2 id="一fragment">一、Fragment</h2><h3 id="fragment的基本用法和生命周期">1.1Fragment的基本用法和生命周期</h3><h4 id="fragment的优点">1.1.1 Fragment的优点</h4><ol type="1"><li>将Activity模块化，将功能分散到小的Fragment中</li><li>一个Activity可以有多个Fragment，一个Fragment也可以有多个Fragment</li><li>可以重用、灵活</li><li>相比View，带有声明周期的概念</li></ol><h4 id="静态添加fragment">1.1.2 静态添加Fragment</h4><ol type="1"><li><p>定义<strong>fragment布局文件</strong>：<strong>fragment_hello_layout.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/black&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--显示一行文字: Hello--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_hello&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;32sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/white&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义<strong>fragment类</strong>：<strong>HelloFragment.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_hello_layout, container, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// inflate方法的主要作用: 将xml转换成一个View对象, 用于动态的创建布局</span></span><br><span class="line">        <span class="comment">// 参数说明</span></span><br><span class="line">        <span class="comment">// 1.int resource:          布局的资源id</span></span><br><span class="line">        <span class="comment">// 2.ViewGroup root:        填充的根视图</span></span><br><span class="line">        <span class="comment">// 3.boolean attachToRoot:  是否将载入的视图绑定到根视图中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <strong>activity布局文件</strong>中嵌入<strong>fragment</strong>：</p><p><strong>activity_main.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_hello&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.demo.HelloFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>MainActivity.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="动态添加删除fragment">1.1.3 动态添加/删除Fragment</h4><ol type="1"><li><p>在<strong>Activity布局文件</strong>中定义<strong>Fragment容器</strong>：<strong>activity_main.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_hello&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.demo.HelloFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Fragment容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--后续实现跳转逻辑的一个Button--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_replace&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Replace&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义⼀个新的<strong>MainFragment</strong>：</p><p><strong>fragment布局文件</strong>：<strong>fragment_main_layout.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#66CCFF&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置背景色: android:background=&quot;#66CCFF&quot;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--显示一行文字: Replace success--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_replace&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Replace success&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;32sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>fragment类</strong>：<strong>MainFragment.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_main_layout, container, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<strong>FragmentManager</strong>添加<strong>Fragment</strong>：<strong>MainActivity.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Button mReplaceButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mReplaceButton = findViewById(R.id.btn_replace);</span><br><span class="line">        mReplaceButton.setOnClickListener(v-&gt;&#123;</span><br><span class="line">            <span class="type">FragmentManager</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line">            <span class="comment">// 获取一个系统提供的FragmentManager</span></span><br><span class="line"></span><br><span class="line">            fragmentManager.beginTransaction().commit()</span><br><span class="line"></span><br><span class="line">            fragmentManager.beginTransaction()</span><br><span class="line">                    .remove(fragmentManager.findFragmentById(R.id.fragment_hello))</span><br><span class="line">                    .add(R.id.fragment_container, <span class="keyword">new</span> <span class="title class_">MainFragment</span>())</span><br><span class="line">                    .commit();</span><br><span class="line">            <span class="comment">// FragmentManager使用事务机制管理所有的Fragment</span></span><br><span class="line">            <span class="comment">// .beginTransaction(): 开始事务, 返回类型为FragmentTransaction</span></span><br><span class="line">            <span class="comment">// .remove(Fragment): 移除一个Fragment, 返回类型为FragmentTransaction</span></span><br><span class="line">            <span class="comment">// .add(id, Fragment): 添加一个Fragment, 返回类型为FragmentTransaction</span></span><br><span class="line">            <span class="comment">// .commit(): 将当前执行的操作提交, 返回类型为int</span></span><br><span class="line"></span><br><span class="line">            mReplaceButton.setVisibility(View.GONE);</span><br><span class="line">            <span class="comment">// setVisibility(): 设置组件的是否可见</span></span><br><span class="line">            <span class="comment">// 有三个参数可供选择</span></span><br><span class="line">            <span class="comment">// VISIBLE:0  意思是可见的</span></span><br><span class="line">            <span class="comment">// INVISIBILITY:4 意思是不可见的，但还占着原来的空间</span></span><br><span class="line">            <span class="comment">// GONE:8  意思是不可见的，不占用原来的布局空间</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="fragment-生命周期">1.1.4 Fragment 生命周期</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831095802196.png"alt="image-20220831095802196" /><figcaption aria-hidden="true">image-20220831095802196</figcaption></figure><ol type="1"><li><strong>onAttach/onDetach</strong>：Fragment与Activity绑定/解除绑定</li><li><strong>onCreate/onDestroy</strong>：进行与View无关的初始化才做</li><li><strong>onCreateView/onDestroyView</strong>：渲染出视图布局，进行与View有关的初始化才做</li><li><strong>onActivityCreated</strong>：宿主Activity执行onCreate后调用该方法</li><li><strong>onStart/onStop</strong>：可见/不可见</li><li><strong>onResume/onPause</strong>：可交互/不可交互</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831100204861.png" alt="image-20220831100204861" style="zoom:80%;" /></p><h4 id="fragment添加到返回栈">1.1.5 Fragment添加到返回栈</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831100403525.png" alt="image-20220831100403525" style="zoom:67%;" /></p><ol type="1"><li><p><strong>addToBackStack</strong>：将新的Fragment添加至返回栈，<strong>MainActivity.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Button mReplaceButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mReplaceButton = findViewById(R.id.btn_replace);</span><br><span class="line">        mReplaceButton.setOnClickListener(v-&gt;&#123;</span><br><span class="line">            <span class="type">FragmentManager</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line"></span><br><span class="line">            fragmentManager.beginTransaction()</span><br><span class="line">                            .add(R.id.fragment_container, <span class="keyword">new</span> <span class="title class_">MainFragment</span>())</span><br><span class="line">                            .addToBackStack(<span class="literal">null</span>)</span><br><span class="line">                            .commit();</span><br><span class="line">            <span class="comment">// .addToBackStack(String name): 将Fragment加入到回退栈</span></span><br><span class="line">            <span class="comment">// 是否使用 取决于 是否要在回退的时候显示上一个Fragment</span></span><br><span class="line"></span><br><span class="line">            mReplaceButton.setVisibility(View.GONE);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="结合-viewpager-创建多-tab-界">1.2 结合 ViewPager 创建多 Tab界⾯</h3><h4 id="viewpager的作用">1.2.1 ViewPager的作用</h4><ol type="1"><li>常用于实现<strong>可滑动的多个视图</strong></li><li>容器，类似于<strong>RecyclerView</strong></li><li>需要通过 <strong>Adapter</strong> 配置内容</li><li>内容⼀般通过 <strong>Fragment</strong> 实现</li><li>可配置 <strong>TabLayout</strong> 或三⽅库添加<strong>Title</strong></li></ol><h4 id="viewpager-fragment">1.2.2 ViewPager + Fragment</h4><ol type="1"><li><p>在<strong>布局xml</strong> 中添加<strong>ViewPager</strong>：<strong>fragment_main_layout.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--线性布局的对齐方式: android:orientation--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加一个ViewPager2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.viewpager2.widget.ViewPager2</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/view_pager_main&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义<strong>Fragment</strong></p><p><strong>fragment_view_animation.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--显示文本: values/string.xml中名为first_text的变量的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/first_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;28sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>fragment_object_animation.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#34C724&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--显示文本: values/string.xml中名为second_text的变量的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/second_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;28sp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>fragment_lottie_animation.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#ff0000&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--显示文本: values/string.xml中名为third_text的变量的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/third_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;28sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义配置页面<strong>Fragment</strong>的<strong>Adapter</strong>：<strong>HelloFragmentViewPagerAdapter.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloFragmentViewPagerAdapter</span> <span class="keyword">extends</span> <span class="title class_">FragmentStateAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FRAGMENTS_Count</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FRAGMENT_View_Animation</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FRAGMENT_Object_Animation</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FRAGMENT_Lottie_Animation</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloFragmentViewPagerAdapter</span><span class="params">(<span class="meta">@NonNull</span> Fragment fragment)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据position的值, 判断创建哪一个Fragment</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fragment <span class="title function_">createFragment</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (position)&#123;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT_View_Animation:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ViewAnimationFragment</span>();</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT_Object_Animation:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjectAnimationFragment</span>();</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT_Lottie_Animation:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LottieAnimationFragment</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fragment</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前ViewPager有多少个Fragment</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FRAGMENTS_Count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为<strong>ViewPager</strong>设置<strong>Adapter</strong>：<strong>MainFragment.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    ViewPager2 mViewPager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment_main_layout, container, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        mViewPager = view.findViewById(R.id.view_pager_main);</span><br><span class="line">        mViewPager.setAdapter(<span class="keyword">new</span> <span class="title class_">HelloFragmentViewPagerAdapter</span>(<span class="built_in">this</span>));</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="viewpager-tablayout">1.2.3 ViewPager + TabLayout</h4><ol type="1"><li><p>在<strong>布局 xml</strong> 中继续添加<strong>TabLayout</strong>：<strong>fragment_main_layout.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--线性布局的对齐方式: android:orientation--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.tabs.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tab_layout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabIndicatorColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabIndicatorHeight</span>=<span class="string">&quot;2dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabIndicatorFullWidth</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabIndicatorGravity</span>=<span class="string">&quot;bottom&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabGravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/divider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;2dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#1A000000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加一个ViewPager2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.viewpager2.widget.ViewPager2</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/view_pager_main&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在代码中<strong>对 ViewPager 和 TabLayout建立关联</strong>：<strong>MainFragment.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TITLE_View_Animation</span> <span class="operator">=</span> <span class="string">&quot;视图动画&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TITLE_Object_Animation</span> <span class="operator">=</span> <span class="string">&quot;属性动画&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TITLE_Lottie_Animation</span> <span class="operator">=</span> <span class="string">&quot;Lottie动画&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] tabTitles = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">private</span> ViewPager2 mViewPager;</span><br><span class="line">    <span class="keyword">private</span> TabLayout mTabLayout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment_main_layout, container, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置ViewPager的Adapter</span></span><br><span class="line">        mViewPager = view.findViewById(R.id.view_pager_main);</span><br><span class="line">        mViewPager.setAdapter(<span class="keyword">new</span> <span class="title class_">HelloFragmentViewPagerAdapter</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标题</span></span><br><span class="line">        tabTitles[HelloFragmentViewPagerAdapter.FRAGMENT_View_Animation] = TITLE_View_Animation;</span><br><span class="line">        tabTitles[HelloFragmentViewPagerAdapter.FRAGMENT_Object_Animation] = TITLE_Object_Animation;</span><br><span class="line">        tabTitles[HelloFragmentViewPagerAdapter.FRAGMENT_Lottie_Animation] = TITLE_Lottie_Animation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置TabLayout的监听器</span></span><br><span class="line">        mTabLayout = view.findViewById(R.id.tab_layout);</span><br><span class="line">        <span class="type">TabLayoutMediator</span> <span class="variable">tabLayoutMediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TabLayoutMediator</span>(</span><br><span class="line">                mTabLayout,</span><br><span class="line">                mViewPager,</span><br><span class="line">                <span class="literal">true</span>,</span><br><span class="line">                <span class="literal">false</span>,</span><br><span class="line">                (tab, position) -&gt; tab.setText(tabTitles[position]));</span><br><span class="line">        tabLayoutMediator.attach();</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="fragmentactivity-之间的通信">1.3 Fragment/Activity之间的通信</h3><ol type="1"><li>构造 Fragment 时传递参数（setArguments/getArguments）</li><li>通过接口和回调</li></ol><h4 id="fragment与activity之间的通信">1.3.1Fragment与Activity之间的通信</h4><h5 id="传参">1.3.1.1 传参</h5><ol type="1"><li><p>在<strong>activity_main.xml</strong>中添加一个文本框，用于测试</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_hello&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.demo.HelloFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Fragment容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--后续实现跳转逻辑的一个Button--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_replace&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Replace&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--用于测试传参的文本框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_tabs_count&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">&quot;gone&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;32sp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过传参为Fragment指定⼀个背景色：<strong>ViewAnimationFragment.java</strong></p><ol type="1"><li><strong>Fragment</strong>中提供实例化自身对象的静态方法</li><li><strong>onCreate</strong>中处理传递的参数</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewAnimationFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARAM_Color</span> <span class="operator">=</span> <span class="string">&quot;param_color&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mColor</span> <span class="operator">=</span> Color.WHITE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewAnimationFragment</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ViewAnimationFragment <span class="title function_">newInstance</span><span class="params">(<span class="type">int</span> color)</span>&#123;</span><br><span class="line">        <span class="type">ViewAnimationFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewAnimationFragment</span>();</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        args.putInt(PARAM_Color, color);</span><br><span class="line">        fragment.setArguments(args);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (getArguments() != <span class="literal">null</span>) &#123;</span><br><span class="line">            mColor = getArguments().getInt(PARAM_Color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment_view_animation, container, <span class="literal">false</span>);</span><br><span class="line">        view.setBackgroundColor(mColor);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="listener">1.3.1.2 Listener</h5><ol type="1"><li><p><strong>宿主Activity</strong>通过<strong>Listener</strong>回调获取当前已创建的<strong>tab数量</strong>：<strong>MainFragment.java</strong>(省略部分见之前的MainFragment.java)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fragment 中定义⼀个接⼝以及接⼝类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MainFragmentListener</span> <span class="variable">mListener</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MainFragmentListener</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onMultiTabsViewCreated</span><span class="params">(<span class="type">int</span> tabsCount)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onAttach 中获取接⼝实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAttach</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onAttach(context);</span><br><span class="line">        mListener = (MainFragmentListener) context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建view, 见之前的MainFragment...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按需调⽤改接⼝⽅法进⾏通信</span></span><br><span class="line">        <span class="keyword">if</span>(mListener != <span class="literal">null</span>)&#123;</span><br><span class="line">            mListener.onMultiTabsViewCreated(adapter.getItemCount());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>宿主Activity</strong>中实现接口方法，执行相关处理：<strong>MainActivity.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">MainFragment</span>.MainFragmentListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMultiTabsViewCreated</span><span class="params">(<span class="type">int</span> tabsCount)</span> &#123;</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> findViewById(R.id.tv_tabs_count);</span><br><span class="line">        tv.setText(tabsCount + <span class="string">&quot; tabs created&quot;</span>);</span><br><span class="line">        tv.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="master-detail自学">1.3.2 Master Detail(自学)</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831104220441.png"alt="image-20220831104220441" /><figcaption aria-hidden="true">image-20220831104220441</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831104235895.png"alt="image-20220831104235895" /><figcaption aria-hidden="true">image-20220831104235895</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831104243620.png"alt="image-20220831104243620" /><figcaption aria-hidden="true">image-20220831104243620</figcaption></figure><h3 id="总结">1.4 总结</h3><ol type="1"><li>Fragment: 灵活，可重⽤，迷你 Activity</li><li>生命周期、静态/动态添加⽤法</li><li>ViewPager &amp; Fragment</li><li>和 Activity 通信：Argument、Listener</li></ol><h2 id="二animation">二、Animation</h2><h3 id="视图动画">2.1 视图动画</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831104443434.png"alt="image-20220831104443434" /><figcaption aria-hidden="true">image-20220831104443434</figcaption></figure><h4 id="示例">2.1.1 示例</h4><ol type="1"><li><p>Java方式设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ROTATE_Duration</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROTATE_Start_Degree</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROTATE_End_Degree</span> <span class="operator">=</span> <span class="number">360f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROTATE_Pivot</span> <span class="operator">=</span> <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">    mRotateAnimation = <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(</span><br><span class="line">        ROTATE_Start_Degree, ROTATE_End_Degree,</span><br><span class="line">        Animation.RELATIVE_TO_SELF, ROTATE_Pivot, <span class="comment">//x轴旋转中心</span></span><br><span class="line">        Animation.RELATIVE_TO_SELF, ROTATE_Pivot  <span class="comment">//y轴旋转中心</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置动画的持续时间, 重复次数, 重复模式</span></span><br><span class="line">    mRotateAnimation.setDuration(ROTATE_Duration);</span><br><span class="line">    mRotateAnimation.setRepeatCount(Animation.INFINITE);</span><br><span class="line">    mRotateAnimation.setRepeatMode(Animation.REVERSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置监听器</span></span><br><span class="line">    mRotateAnimation.setAnimationListener(<span class="keyword">new</span> <span class="title class_">Animation</span>.AnimationListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationStart</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onAnimationStart&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationEnd</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onAnimationEnd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationRepeat</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onAnimationRepeat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配合XML方式设置</p><p><strong>fragment_view_animation.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--显示一张图片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/iv_robot&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>ViewAnimationFragment.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewAnimationFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;ViewAnimationFragment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARAM_Color</span> <span class="operator">=</span> <span class="string">&quot;param_color&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ROTATE_Duration</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROTATE_Start_Degree</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROTATE_End_Degree</span> <span class="operator">=</span> <span class="number">360f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROTATE_Pivot</span> <span class="operator">=</span> <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mColor</span> <span class="operator">=</span> Color.WHITE;</span><br><span class="line">    <span class="keyword">private</span> ImageView mRobot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画部分: 旋转动画</span></span><br><span class="line">    <span class="keyword">private</span> RotateAnimation mRotateAnimation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewAnimationFragment</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ViewAnimationFragment <span class="title function_">newInstance</span><span class="params">(<span class="type">int</span> color)</span>&#123;</span><br><span class="line">        <span class="type">ViewAnimationFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewAnimationFragment</span>();</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        args.putInt(PARAM_Color, color);</span><br><span class="line">        fragment.setArguments(args);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">args</span> <span class="operator">=</span> getArguments();</span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">givenColor</span> <span class="operator">=</span> args.getInt(PARAM_Color);</span><br><span class="line">            mColor = (givenColor != <span class="number">0</span>) ? givenColor : mColor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment_view_animation, container, <span class="literal">false</span>);</span><br><span class="line">        view.setBackgroundColor(mColor);</span><br><span class="line">        mRobot = view.findViewById(R.id.iv_robot);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        <span class="comment">// 启动动画</span></span><br><span class="line">        initAnimation();</span><br><span class="line">        <span class="keyword">if</span>(mRobot != <span class="literal">null</span>)&#123;</span><br><span class="line">            mRobot.startAnimation(mRotateAnimation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        <span class="comment">// 动画不为空, 且动画已经启动, 则停止动画</span></span><br><span class="line">        <span class="keyword">if</span>(mRotateAnimation != <span class="literal">null</span> &amp;&amp; mRotateAnimation.hasStarted())&#123;</span><br><span class="line">            mRotateAnimation.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        mRotateAnimation = <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(</span><br><span class="line">                ROTATE_Start_Degree, ROTATE_End_Degree,</span><br><span class="line">                Animation.RELATIVE_TO_SELF, ROTATE_Pivot, <span class="comment">//x轴旋转中心</span></span><br><span class="line">                Animation.RELATIVE_TO_SELF, ROTATE_Pivot  <span class="comment">//y轴旋转中心</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置动画的持续时间, 重复次数, 重复模式</span></span><br><span class="line">        mRotateAnimation.setDuration(ROTATE_Duration);</span><br><span class="line">        mRotateAnimation.setRepeatCount(Animation.INFINITE);</span><br><span class="line">        mRotateAnimation.setRepeatMode(Animation.REVERSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置监听器</span></span><br><span class="line">        mRotateAnimation.setAnimationListener(<span class="keyword">new</span> <span class="title class_">Animation</span>.AnimationListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationStart</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onAnimationStart&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationEnd</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onAnimationEnd&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationRepeat</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onAnimationRepeat&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="视图动画的属性">2.1.2 视图动画的属性</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831105228934.png"alt="image-20220831105228934" /><figcaption aria-hidden="true">image-20220831105228934</figcaption></figure><h3 id="属性动画">2.2 属性动画</h3><h4 id="属性动画-vs-视图动画">2.2.1 属性动画 vs 视图动画</h4><ol type="1"><li>属性动画：<strong>android.animation</strong><ol type="1"><li>基于属性的动画</li><li>⼀切可以连续变化的属性都是动画的元素</li><li>实现⼀种复杂动画，就是将动画拆解成不同属性组合的过程</li></ol></li><li>视图动画：<strong>android.view.animation</strong><ol type="1"><li>只能对 View 做动画</li><li>只能对 View 的某些绘制属性做动画</li><li>只是视觉效果</li></ol></li></ol><h4 id="属性动画的角色构成">2.2.2 属性动画的角色构成</h4><ol type="1"><li><strong>Property</strong>：alpha, scaleX, scaleY, rotation,translationX, translationY</li><li><strong>参数</strong>：StartValue, EndValue, Duration</li><li><strong>RepeatCount</strong>：number, infinite</li><li><strong>RepeatMode</strong>：restart, reverse</li><li><strong>TypeEvaluator</strong>：IntEvaluator, ArgbEvaluator</li><li><strong>Interpolator</strong>：linear/accelerate/decelerate</li></ol><h4 id="animator单个属性动画">2.2.3 Animator：单个属性动画</h4><h5 id="fragment_object_animation.xml">2.2.3.1fragment_object_animation.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#34C724&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--显示一张图片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/iv_robot&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="objectanimationfragment.java">2.2.3.2ObjectAnimationFragment.java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectAnimationFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARAM_Color</span> <span class="operator">=</span> <span class="string">&quot;param_color&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mColor</span> <span class="operator">=</span> Color.WHITE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImageView mRobot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性动画类</span></span><br><span class="line">    <span class="keyword">private</span> ObjectAnimator mAnimator;</span><br><span class="line">    <span class="comment">// 当前播放的时哪一个动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mAnimationType</span> <span class="operator">=</span> ALPHA_Animation_Type;</span><br><span class="line">    <span class="comment">// 每个动画的重复次数, 持续时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ANIMATION_Repeat_Count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ANIMATION_Duration</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">// 透明度动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ALPHA_Animation_Type</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ALPHA_Start</span> <span class="operator">=</span> <span class="number">1f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ALPHA_End</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectAnimationFragment</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ObjectAnimationFragment加载视图时调用</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment_view_animation, container, <span class="literal">false</span>);</span><br><span class="line">        mRobot = view.findViewById(R.id.iv_robot);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ObjectAnimationFragment可交互时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        startAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建动画类,并开始动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 如果图片不存在, 则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(mRobot == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        initAlphaAnimation();</span><br><span class="line">        mAnimator.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化动画类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAlphaAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 设置属性动画的相关参数</span></span><br><span class="line">        mAnimator = ObjectAnimator.ofFloat(</span><br><span class="line">                mRobot, <span class="string">&quot;alpha&quot;</span>,</span><br><span class="line">                ALPHA_Start, ALPHA_End, ALPHA_Start);</span><br><span class="line"></span><br><span class="line">        mAnimator.setDuration(ANIMATION_Duration);</span><br><span class="line">        mAnimator.setRepeatCount(ANIMATION_Repeat_Count);</span><br><span class="line">        mAnimator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewAnimationFragment不可交互时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        cancelAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将所有动画类删除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 动画不为空, 且动画已经启动, 则停止动画</span></span><br><span class="line">        <span class="keyword">if</span>(mAnimator != <span class="literal">null</span> &amp;&amp; mAnimator.isRunning())&#123;</span><br><span class="line">            mAnimator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="animatorset多个属性动画之间的切换">2.2.4AnimatorSet：多个属性动画之间的切换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectAnimationFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARAM_Color</span> <span class="operator">=</span> <span class="string">&quot;param_color&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mColor</span> <span class="operator">=</span> Color.WHITE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImageView mRobot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性动画类</span></span><br><span class="line">    <span class="keyword">private</span> AnimatorSet mAnimatorSet;</span><br><span class="line">    <span class="comment">// 当前播放的时哪一个动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mAnimationType</span> <span class="operator">=</span> ROTATE_Animation_Type;</span><br><span class="line">    <span class="comment">// 每个动画的重复次数, 持续时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ANIMATION_Repeat_Count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ANIMATION_Duration</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">// 透明度动画</span></span><br><span class="line">    <span class="keyword">private</span> ObjectAnimator mAlphaAnimator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ALPHA_Animation_Type</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ALPHA_Start</span> <span class="operator">=</span> <span class="number">1f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ALPHA_End</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line">    <span class="comment">// 旋转动画</span></span><br><span class="line">    <span class="keyword">private</span> ObjectAnimator mRotateAnimator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ROTATE_Animation_Type</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROTATE_Start_Degree</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROTATE_End_Degree</span> <span class="operator">=</span> <span class="number">360f</span>;</span><br><span class="line">    <span class="comment">// 移动动画</span></span><br><span class="line">    <span class="keyword">private</span> ObjectAnimator mTranslateXAnimator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSLATE_Animation_Type</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">TRANSLATE_XDelta_Start</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">TRANSLATE_XDelta_End</span> <span class="operator">=</span> <span class="number">100f</span>;</span><br><span class="line">    <span class="comment">// 缩放视图动画</span></span><br><span class="line">    <span class="keyword">private</span> ObjectAnimator mScaleXAnimator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SCALE_Animation_Type</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">SCALE_X_Start</span> <span class="operator">=</span> <span class="number">1f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">SCALE_X_End</span> <span class="operator">=</span> <span class="number">1.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectAnimationFragment</span><span class="params">()</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ObjectAnimationFragment加载视图时调用</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment_view_animation, container, <span class="literal">false</span>);</span><br><span class="line">        mRobot = view.findViewById(R.id.iv_robot);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ObjectAnimationFragment可交互时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        startAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建AnimatorSet,并开始动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 如果图片不存在, 则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(mRobot == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 创建动画类</span></span><br><span class="line">        initAlphaAnimation();</span><br><span class="line">        initRotateAnimation();</span><br><span class="line">        initTranslateXAnimation();</span><br><span class="line">        initScaleXAnimation();</span><br><span class="line">        <span class="comment">// 创建AnimatorSet</span></span><br><span class="line">        mAnimatorSet = <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();</span><br><span class="line">        mAnimatorSet.playSequentially(mAlphaAnimator, mRotateAnimator, mTranslateXAnimator, mScaleXAnimator);</span><br><span class="line">        mAnimatorSet.start();</span><br><span class="line">        mAnimatorSet.addListener(<span class="keyword">new</span> <span class="title class_">Animator</span>.AnimatorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationStart</span><span class="params">(Animator animator)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationEnd</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">                <span class="comment">// 动画序列结束后, 重新开始播放动画序列</span></span><br><span class="line">                mAnimatorSet.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationCancel</span><span class="params">(Animator animator)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationRepeat</span><span class="params">(Animator animator)</span> &#123; &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化动画类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAlphaAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 设置属性动画的相关参数</span></span><br><span class="line">        mAlphaAnimator = ObjectAnimator.ofFloat(</span><br><span class="line">                mRobot, <span class="string">&quot;alpha&quot;</span>,</span><br><span class="line">                ALPHA_Start, ALPHA_End, ALPHA_Start);</span><br><span class="line"></span><br><span class="line">        mAlphaAnimator.setDuration(ANIMATION_Duration);</span><br><span class="line">        mAlphaAnimator.setRepeatCount(ANIMATION_Repeat_Count);</span><br><span class="line">        mAlphaAnimator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">        mAlphaAnimator.setInterpolator(<span class="keyword">new</span> <span class="title class_">LinearInterpolator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initRotateAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        mRotateAnimator = ObjectAnimator.ofFloat(</span><br><span class="line">                mRobot, <span class="string">&quot;rotation&quot;</span>,</span><br><span class="line">                ROTATE_Start_Degree, ROTATE_End_Degree, ROTATE_Start_Degree);</span><br><span class="line"></span><br><span class="line">        mRotateAnimator.setDuration(ANIMATION_Duration);</span><br><span class="line">        mRotateAnimator.setRepeatCount(ANIMATION_Repeat_Count);</span><br><span class="line">        mRotateAnimator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">        mRotateAnimator.setInterpolator(<span class="keyword">new</span> <span class="title class_">LinearInterpolator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initTranslateXAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        mTranslateXAnimator = ObjectAnimator.ofFloat(</span><br><span class="line">                mRobot, <span class="string">&quot;translationX&quot;</span>,</span><br><span class="line">                TRANSLATE_XDelta_Start, TRANSLATE_XDelta_End, TRANSLATE_XDelta_Start);</span><br><span class="line"></span><br><span class="line">        mTranslateXAnimator.setDuration(ANIMATION_Duration);</span><br><span class="line">        mTranslateXAnimator.setRepeatCount(ANIMATION_Repeat_Count);</span><br><span class="line">        mTranslateXAnimator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">        mTranslateXAnimator.setInterpolator(<span class="keyword">new</span> <span class="title class_">LinearInterpolator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initScaleXAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        mScaleXAnimator = ObjectAnimator.ofFloat(</span><br><span class="line">                mRobot, <span class="string">&quot;scaleX&quot;</span>,</span><br><span class="line">                SCALE_X_Start, SCALE_X_End, SCALE_X_Start);</span><br><span class="line"></span><br><span class="line">        mScaleXAnimator.setDuration(ANIMATION_Duration);</span><br><span class="line">        mScaleXAnimator.setRepeatCount(ANIMATION_Repeat_Count);</span><br><span class="line">        mScaleXAnimator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">        mScaleXAnimator.setInterpolator(<span class="keyword">new</span> <span class="title class_">LinearInterpolator</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewAnimationFragment不可交互时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        cancelAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将所有动画类删除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 动画不为空, 且动画已经启动, 则停止动画</span></span><br><span class="line">        mAnimatorSet.cancel();</span><br><span class="line">        <span class="keyword">if</span>(mAlphaAnimator != <span class="literal">null</span> &amp;&amp; mAlphaAnimator.isRunning())&#123;</span><br><span class="line">            mAlphaAnimator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mRotateAnimator != <span class="literal">null</span> &amp;&amp; mRotateAnimator.isRunning())&#123;</span><br><span class="line">            mRotateAnimator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mTranslateXAnimator != <span class="literal">null</span> &amp;&amp; mTranslateXAnimator.isRunning())&#123;</span><br><span class="line">            mTranslateXAnimator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mScaleXAnimator != <span class="literal">null</span> &amp;&amp; mScaleXAnimator.isRunning())&#123;</span><br><span class="line">            mScaleXAnimator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831105922891.png"alt="image-20220831105922891" /><figcaption aria-hidden="true">image-20220831105922891</figcaption></figure><h4 id="特点xml语法">2.2.5 特点，xml语法</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831110102106.png"alt="image-20220831110102106" /><figcaption aria-hidden="true">image-20220831110102106</figcaption></figure><h4 id="属性动画核心---valueanimator">2.2.6 属性动画核心 -ValueAnimator</h4><ol type="1"><li>控制某个数值，在某个时间内，在某个区间内进行规律变化</li></ol><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831110150134.png"alt="image-20220831110150134" /><figcaption aria-hidden="true">image-20220831110150134</figcaption></figure><h4 id="属性动画原理">2.2.7 属性动画原理</h4><ol type="1"><li><p>插值器：决定变化的规律</p></li><li><p>估值器：决定变化的具体数值</p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831110445532.png"alt="image-20220831110445532" /><figcaption aria-hidden="true">image-20220831110445532</figcaption></figure></li><li><p>常用系统内置插值器</p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831110540996.png"alt="image-20220831110540996" /><figcaption aria-hidden="true">image-20220831110540996</figcaption></figure></li></ol><h4 id="属性动画---注意">2.2.8 属性动画 - 注意</h4><ol type="1"><li>使用ObjectAnimator 时，⽬标属性必须同时具备getter()及setter()⽅法</li><li>ObjectAnimator操作对象宿主⻚⾯退出前台或销毁时，需保证动画任务得到妥善处理，防⽌内存泄漏</li></ol><h4 id="属性动画---自定义属性">2.2.9 属性动画 - 自定义属性</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831110723890.png"alt="image-20220831110723890" /><figcaption aria-hidden="true">image-20220831110723890</figcaption></figure><h3 id="activity-切换动画">2.3 Activity 切换动画</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831110751260.png"alt="image-20220831110751260" /><figcaption aria-hidden="true">image-20220831110751260</figcaption></figure><h4 id="示例-fadeinout">2.3.1 示例 FadeInOut</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831110823317.png"alt="image-20220831110823317" /><figcaption aria-hidden="true">image-20220831110823317</figcaption></figure><h3 id="逐帧动画drawable-动画">2.4 逐帧动画/Drawable 动画</h3><ol type="1"><li>逐帧动画可以被当作⼀种特殊的drawable对象</li><li>逐帧动画会按次序播放⼀系列图⽚</li><li>逐帧动画会⼀次性将所有图⽚加载到内存中，会有OOM⻛险</li></ol><h4 id="示例-animationdrawable">2.4.1 示例 AnimationDrawable</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831110933304.png"alt="image-20220831110933304" /><figcaption aria-hidden="true">image-20220831110933304</figcaption></figure><h3 id="lottie">2.5 Lottie</h3><ol type="1"><li>airbnb公司的开源库</li><li>可以直接导入AE制作的动画素材</li><li>本质是将所有动画元素抽象成绘制属性</li></ol><h4 id="示例-1">2.5.1 示例</h4><ol type="1"><li><p>在<strong>app/build.gradle</strong>中，添加依赖</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">implementation <span class="string">&#x27;com.airbnb.android:lottie:3.4.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加资源<strong>raw/lottie_raw_rocket.json</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220831173539488.png" alt="image-20220831173539488" style="zoom:80%;" /></p></li><li><p>修改<strong>fragment_lottie_animation.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#ff0000&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/lottieView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:lottie_rawRes</span>=<span class="string">&quot;@raw/lottie_raw_rocket&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:lottie_autoPlay</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:lottie_loop</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改<strong>LottieAnimationFragment.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LottieAnimationFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARAM_Color</span> <span class="operator">=</span> <span class="string">&quot;param_color&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LottieAnimationFragment</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_lottie_animation, container, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="day4-复杂应用组件">Day4 复杂应用组件</h1><h2 id="一进程与线程">一、进程与线程</h2><h3 id="进程线程">1.1 进程、线程</h3><ol type="1"><li>进程：资源分配的最小单位 ==&gt; 一个软件<ol type="1"><li>如一辆列车</li></ol></li><li>线程：CPU调度的最小单位 ==&gt; 一个软件的各个功能<ol type="1"><li>如一辆列车的列车长</li></ol></li><li>主要区别：<ol type="1"><li>一个进程可以有多个线程</li><li>同一个进程的多个线程，共享进程的资源</li></ol></li></ol><h3 id="android中的主线程">1.2 Android中的主线程</h3><ol type="1"><li>启动应用时，系统会为该应用创建⼀个称为“main”（主线程）的执行线程。这个线程负责所有和UI界⾯有关的显示、以及响应UI事件监听任务，因此又称座UI线程。</li><li>划重点：所有跟<strong>ui相关的操作</strong>都必须放在<strong>主线程</strong></li></ol><h3 id="anr-拓展">1.3 ANR 拓展</h3><p><strong>ANR</strong>：Application Not Responding</p><ol type="1"><li>程序中所有的组件都会运行在UI线程中，所以必须保证该线程的⼯作效率</li><li>UI线程⼀旦出现问题，就会降低⽤户体验</li><li>如在UI线程中进行耗时操作，如下载文件、查询数据库等就会阻塞UI线程，长时间⽆法响应UI交互操作，给用户带来“卡屏”、“死机”的感觉</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901095158122.png" alt="image-20220901095158122" style="zoom:80%;" /></p><h2 id="二handler机制">二、Handler机制</h2><h3 id="handler机制">2.1 Handler机制</h3><p>Handler机制为Android系统解决了以下两个问题：</p><ol type="1"><li>任务调度</li><li>线程通信</li></ol><h3 id="handler的使用场景">2.2 Handler的使用场景</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901095534573.png" alt="image-20220901095534573" style="zoom:80%;" /></p><h3 id="handler机制简介">2.3 Handler机制简介</h3><p>本质是消息机制，负责消息的分发以及处理</p><ol type="1"><li>通俗点来说，每个线程都有⼀个“流⽔线”，我们可往这条流⽔线上放“消息”，流⽔线的末端有⼯作⼈员会去处理这些消息。因为流⽔线是单线的，所有消息都必须按照先来后到的形式依次处理</li><li>放什么消息以及怎么处理消息，是需要我们去⾃定义的。Handler机制相当于提供了这样的⼀套模式，我们只需要“放消息到流⽔线上”，“编写这些消息的处理逻辑”就可以了，流⽔线会源源不断把消息运送到末端处理。</li><li>最后注意重点：每个线程只有⼀个“流⽔线”，他的基本范围是线程，负责线程内的通信以及线程间的通信。</li><li><strong>每个线程可以看成⼀个厂房，每个厂房只有⼀个生产线。</strong></li></ol><h3 id="handler原理ui线程与消息队列机制">2.4Handler原理：UI线程与消息队列机制</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901095712103.png" alt="image-20220901095712103" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901095732246.png" alt="image-20220901095732246" style="zoom:80%;" /></p><ol type="1"><li><strong>Message</strong>：消息，由MessageQueue统⼀队列，然后交由Handler处理</li><li><strong>MessageQueue</strong>：消息队列，⽤来存放Handler发送过来Message，并且按照先⼊先出的规则执⾏</li><li><strong>Handler</strong>：处理者，负责发送和处理Message每个Message必须有⼀个对应的Handler</li><li><strong>Looper</strong>：消息轮询器，不断的从MessageQueue中抽取Message并执⾏</li></ol><h3 id="handler常用方法">2.5 Handler常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⽴即发送消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(Message msg)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable r)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时发送消息: 马上发送消息, 但是会延迟处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(Message msg, <span class="type">long</span> delayMillis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">postDelayed</span><span class="params">(Runnable r, <span class="type">long</span> delayMillis)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时发送消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(Message msg, <span class="type">long</span> uptimeMillis)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">postAtTime</span><span class="params">(Runnable r, <span class="type">long</span> uptimeMillis)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">postAtTime</span><span class="params">(Runnable r, Object token, <span class="type">long</span> uptimeMillis)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeCallbacks</span><span class="params">(Runnable r)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeMessages</span><span class="params">(<span class="type">int</span> what)</span>; <span class="comment">// what字段:给消息的命名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeCallbacksAndMessages</span><span class="params">(Object token)</span>; <span class="comment">// token=null: 表示移除所有消息</span></span><br></pre></td></tr></table></figure><h3 id="handler的使用">2.6 Handler的使用</h3><ol type="1"><li><strong>调度Message</strong>：<ol type="1"><li>建⼀个<strong>Handler</strong>，实现<strong>handleMessage()</strong>⽅法</li><li>在适当的时候给上面的Handler发送消息</li></ol></li><li><strong>调度Runnable</strong>：<ol type="1"><li>建⼀个<strong>Handler</strong>，然后直接调度<strong>Runnable</strong>即可</li></ol></li><li><strong>取消调度</strong>：<ol type="1"><li>通过<strong>Handler取消</strong>已经发送过的<strong>Message/Runnable</strong></li></ol></li></ol><h3 id="handler的使用举例">2.7 Handler的使用举例</h3><h4 id="发送runnable对象">2.7.1 发送Runnable对象</h4><blockquote><ol type="1"><li>新建一个<strong>Handler</strong>对象：new Handler()</li><li>新建一个<strong>Runnable</strong>对象 1.重写<strong>run()</strong>方法，表示该<strong>Runnable</strong>对象要做什么事情</li><li>调用<strong>Handler</strong>对象的<strong>post()</strong>方法，将<strong>Runnable</strong>对象发送出去</li></ol></blockquote><p>启动今日头条app的时候，展示了一个开屏广告，默认播放3秒；在3秒后，需跳转到主界面</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901101255260.png" alt="image-20220901101255260" style="zoom:80%;" /></p><p>如果用户点击了跳过，则应该直接进入主界面</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901101341933.png" alt="image-20220901101341933" style="zoom:80%;" /></p><h4 id="发送message对象">2.7.2 发送Message对象</h4><blockquote><ol type="1"><li>新建一个<strong>Handler</strong>对象：newHandler(Looper.getMainLopper()) 1.重写<strong>handlerMessage()</strong>方法，表示收到不同<strong>Message</strong>时做出的反应</li><li>调用<strong>Handler</strong>对象的<strong>post()</strong>方法，将<strong>Message</strong>对象发送出去1. 可以直接发送msg.what，来代表一个msg</li></ol></blockquote><p>用户在抖音App中，点击下载视频，下载过程中需要弹出Loading窗，下载结束后提示用户下载成功/失败</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901101208647.png" alt="image-20220901101208647" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901101419103.png" alt="image-20220901101419103" style="zoom:80%;" /></p><h4 id="辨析runnable与message">2.7.3 辨析Runnable与Message</h4><ol type="1"><li>Runnable会被打包成Message，所以实际上Runnable也是Message</li><li>没有明确的界限，取决于使⽤的⽅便程度</li></ol><p>以下两段代码等价</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901101512752.png" alt="image-20220901101512752" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901101518680.png" alt="image-20220901101518680" style="zoom:80%;" /></p><h3 id="handler总结">2.8 Handler总结</h3><ol type="1"><li><strong>Handler</strong>就是<strong>Android</strong>中的消息队列机制的⼀个应用，可理解为是⼀种⽣产者消费者的模型，解决了<strong>Android</strong>中的线程内&amp;线程间的任务调度问题</li><li><strong>Handler</strong>机制的本质就是⼀个死循环，待处理的<strong>Message</strong>加到队列⾥⾯，<strong>Looper</strong>负责轮询执⾏</li><li>掌握<strong>Handler</strong>的基本⽤法：立即/延时/定时发送消息、取消消息</li></ol><h2 id="三android中的多线程">三、Android中的多线程</h2><h3 id="thread">3.1 Thread</h3><blockquote><ol type="1"><li>新建一个类，继承<strong>Thread</strong>，重写其<strong>run()</strong>方法</li><li>调用时，先新建一个实例 1.可以传入一个String参数，表示线程的名字</li><li>调用<strong>tread.start()</strong>方法，开启线程</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901103023437.png" alt="image-20220901103023437" style="zoom:80%;" /></p><h3 id="threadpool">3.2 ThreadPool</h3><h4 id="为什么要使用线程池">3.2.1 为什么要使用线程池</h4><ol type="1"><li>线程的创建和销毁的开销都比较⼤，降低资源消耗</li><li>线程是可复用的，提⾼响应速度</li><li>对多任务多线程进行管理，提高线程的可管理性</li></ol><h4 id="几种常用的线程池">3.2.2 几种常用的线程池</h4><ol type="1"><li>单个任务处理时间比较短且任务数量很大（多个线程的线程池）：<ol type="1"><li><strong>FixedThreadPool</strong> 定长线程池</li><li><strong>CachedThreadPool</strong> 可缓存线程池</li></ol></li><li>执行定时任务（定时线程池）：<ol type="1"><li><strong>ScheduledThreadPool</strong> 定时任务线程池</li></ol></li><li>特定单项任务（单线程线程池）：<ol type="1"><li><strong>SingleThreadPool</strong> 只有⼀个线程的线程池</li></ol></li></ol><h4 id="使用示例">3.2.3 使用示例</h4><ol type="1"><li>接口<strong>Java.util.concurrent.ExecutorService</strong>表述了异步执行的机制，并且可以让任务在⼀组线程内执行</li><li>重要函数：<ol type="1"><li><strong>execute(Runnable)</strong>：向线程池提交⼀个任务</li><li><strong>submit(Runnbale/Callable)</strong>：有返回值（Future），可以查询任务的执行状态和执行结果</li><li><strong>shutdown()</strong> ：关闭线程池</li></ol></li></ol><blockquote><ol type="1"><li>创建一个线程池<strong>ExecutorService</strong>的示例</li><li>创建一个<strong>Runnable</strong>对象，并编写其业务逻辑</li><li>通过<strong>service.execute()</strong>方法，向线程池提交任务</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901103647564.png" alt="image-20220901103647564" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901103714432.png" alt="image-20220901103714432" style="zoom:80%;" /></p><h3 id="asynctask已弃用">3.3 AsyncTask(已弃用)</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901103805640.png" alt="image-20220901103805640" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901103822913.png" alt="image-20220901103822913" style="zoom:80%;" /></p><h3 id="handlerthread">3.4 HandlerThread</h3><ol type="1"><li><strong>HandlerThread</strong>的本质：继承<strong>Thread</strong>类&amp; 封装<strong>Handler</strong>类<ol type="1"><li>试想⼀款股票交易App：<ol type="1"><li>由于因为股票的行情数据都是实时变化的</li><li>所以我们软件需要每隔⼀定时间向服务器请求行情数据</li></ol></li><li>该轮询调度需要放到<strong>子线程</strong>，由Handler +Looper去处理和调度</li></ol></li><li><strong>HandlerThread</strong>是AndroidAPI提供的⼀个⽅便、便捷的类，使用它我们可以快速的创建⼀个<strong>带有Looper的线程</strong>。<strong>Looper</strong>可以用来创建Handler实例</li></ol><blockquote><ol type="1"><li>创建一个<strong>HandlerThread</strong>对象</li><li>使用<strong>handlerThread.start()</strong>方法，运行线程</li><li>通过<strong>handlerThread.getLooper()</strong>方法，获取该线程的<strong>Looper</strong></li><li>通过<strong>Looper</strong>实例创建<strong>Handler</strong>，将<strong>Handler</strong>与该线程关联</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901104305510.png" alt="image-20220901104305510" style="zoom:80%;" /></p><blockquote><p><strong>HandlerThread</strong>的源码</p><ol type="1"><li><strong>onLooperPrepared()</strong>：</li><li><strong>run()</strong>：运行该线程</li><li><strong>getThreadHandler()</strong>：</li><li><strong>quit()</strong>和<strong>quitSafely()</strong>：停止该线程</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901104612875.png" alt="image-20220901104612875" style="zoom:80%;" /></p><h3 id="intentservice不常用-自学">3.5 IntentService(不常用, 自学)</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901104842002.png" alt="image-20220901104842002" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901104852833.png" alt="image-20220901104852833" style="zoom:80%;" /></p><h3 id="android多线程总结">3.6 Android多线程总结</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901104924134.png" alt="image-20220901104924134" style="zoom:80%;" /></p><h2 id="四自定义view">四、自定义View</h2><h3 id="view绘制的三个重要步骤">4.1 View绘制的三个重要步骤</h3><ol type="1"><li><strong>Measure</strong>：测量宽高</li><li><strong>Layout</strong>：确定位置</li><li><strong>Draw</strong>：绘制形状</li><li>举例说明：<ol type="1"><li>首先画⼀个100 x100的照片框，需要尺子测量出宽高的长度（measure过程）</li><li>然后确定照片框在屏幕中的位置（layout过程）</li><li>最后借助尺子用手画出我们的照片框（draw过程）</li></ol></li></ol><h3 id="绘制流程">4.2 绘制流程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105430782.png" alt="image-20220901105430782" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105457172.png" alt="image-20220901105457172" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105516634.png" alt="image-20220901105516634" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105526514.png" alt="image-20220901105526514" style="zoom:80%;" /></p><h3 id="自定义view重写ondraw">4.3 自定义View：重写onDraw</h3><ol type="1"><li><strong>Canvas</strong>：画布</li><li><strong>Paint</strong>：画笔</li><li><strong>坐标轴</strong>：<img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105711985.png" alt="image-20220901105711985" style="zoom:50%;" /></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105602114.png" alt="image-20220901105602114" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105630075.png" alt="image-20220901105630075" style="zoom:80%;" /></p><h4 id="画点">4.3.1 画点</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105822943.png" alt="image-20220901105822943" style="zoom:80%;" /></p><h4 id="画线">4.3.2 画线</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105938514.png" alt="image-20220901105938514" style="zoom:80%;" /></p><h4 id="画圆">4.3.3 画圆</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105928257.png" alt="image-20220901105928257" style="zoom:80%;" /></p><h4 id="填充">4.3.4 填充</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105917656.png" alt="image-20220901105917656" style="zoom:80%;" /></p><h4 id="不规则图形">4.3.5 不规则图形</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901105954866.png" alt="image-20220901105954866" style="zoom:80%;" /></p><h4 id="画文本">4.3.6 画文本</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901110009241.png" alt="image-20220901110009241" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220901110022511.png" alt="image-20220901110022511" style="zoom:80%;" /></p><h3 id="自定义view总结">4.4 自定义View总结</h3><ol type="1"><li>重要绘制流程：<ol type="1"><li><strong>Measure</strong>：测量</li><li><strong>Layout</strong>：布局</li><li><strong>Draw</strong>：绘制</li></ol></li><li>以及几个重要函数：<ol type="1"><li><strong>invalidate</strong></li><li><strong>requestLayout</strong></li></ol></li><li>理解<strong>ViewTree</strong> 及 <strong>ViewGroup</strong>的<strong>Measure / Layout / Draw</strong>的流程</li><li>View自定义绘制：<ol type="1"><li>绘制图形：点、线、圆形、椭圆、矩形、圆⻆矩形</li><li>绘制文字</li></ol></li></ol><h1 id="day5-android中的网络">Day5 Android中的网络</h1><h2 id="一网络基础知识">一、网络基础知识</h2><h3 id="网络分层模型">1.1 网络分层模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902093714465.png" alt="image-20220902093714465" style="zoom:80%;" /></p><ol type="1"><li>应用层<strong>Application Layer</strong>：互联网上的各种应用<ol type="1"><li>如：看网页、发邮件</li><li>如：HTTP/FTP/SMTP协议</li></ol></li><li>传输层<strong>Transport Layer</strong></li><li>网络层<strong>Internet Layer</strong></li></ol><h3 id="http协议">1.2 HTTP协议</h3><ol type="1"><li><p>HTTP是一个<strong>client-server</strong>协议，只能由<strong>client</strong>主动发起请求，<strong>server</strong>进行响应</p><ol type="1"><li>用户发出请求，服务端进行相应</li></ol></li><li><p>一个HTTP请求一定要包含<strong>Method</strong>和<strong>URL</strong></p><ol type="1"><li><strong>Method</strong>：要做什么，如GET、PUT、HEAD、POST、DELETE、TRACE、OPTIONS、CONNETC</li><li><strong>URL</strong>：</li></ol></li><li><p><strong>Request</strong>格式：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902094648685.png" alt="image-20220902094648685" style="zoom:80%;" /></p></li><li><p><strong>Response</strong>格式：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902094717700.png" alt="image-20220902094717700" style="zoom:80%;" /></p></li><li><p><strong>HTTP</strong>状态码：</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902094756612.png" alt="image-20220902094756612" style="zoom:80%;" /></p><ol type="1"><li><strong>4XX</strong>：服务器正常，但客户段出错</li><li><strong>404</strong>：服务器正常，但服务不存在</li><li><strong>5XX</strong>：服务器不正常，无法处理请求(请求过多)</li></ol></li></ol><h3 id="restful-api">1.3 RESTful API</h3><h4 id="api">1.3.1 API</h4><p><strong>API</strong>：Application Programming Interface应用程序接口</p><ol type="1"><li><strong>用户端</strong>使用固定的方式发起请求</li><li><strong>服务端</strong>提供服务，响应该请求</li><li>使用一个固定的方式，保证不同模块之间进行通信，提高兼容性</li><li>略去不同模块之间的区别，找到共同的部分</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902095511020.png" alt="image-20220902095511020" style="zoom:80%;" /></p><h4 id="restful-api-1">1.3.2 RESTful API</h4><p><strong>RESTful API</strong>：Resource Epresentational State Transfer(资源)表现层状态转换</p><ol type="1"><li>API是面向资源的，资源表达的形式可以是json或者xml，它的url中不包含动词，而是通过HTTP动词表达想要的动作</li><li>资源：一段文本、一张图片、一首歌曲</li><li>表现形式：json、xml</li><li>状态变化：通过HTTP动词实现</li><li>目的：看 URL 就知道要什么，看HTTP method 就知道干什么</li></ol><blockquote><p><strong>RESTful</strong> 只是一种规范，并不是标准</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902100654244.png" alt="image-20220902100654244" style="zoom:80%;" /></p><h3 id="数据传输格式">1.4 数据传输格式</h3><blockquote><p>后端与前端/客户端需要约定数据传输的格式，以json为例</p><ol type="1"><li>每一组数据都是键值对</li><li>{}括起的数据：单个值</li><li>[]括起的数据：数组值</li></ol></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;中国&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;provinces&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;黑龙江&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cities&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;哈尔滨&quot;</span><span class="punctuation">,</span> <span class="string">&quot;大庆&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;广东&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cities&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;广州&quot;</span><span class="punctuation">,</span> <span class="string">&quot;深圳&quot;</span><span class="punctuation">,</span> <span class="string">&quot;珠海&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="json解析器gson">1.4.1 JSON解析器：gson</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902104328367.png" alt="image-20220902104328367" style="zoom: 80%;" /></p><blockquote><p>常用<strong>API</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将对象转化成Json</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; toJson(Object src);</span><br><span class="line"><span class="comment">// 从Json中提取对象</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; fromJson(String json, Class&lt;T&gt; classOfT);</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; fromJson(Reader json, Type typeOfT);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902104903235.png" alt="image-20220902104903235" style="zoom:80%;" /></p><h4 id="下划线命名-vs-驼峰命名">1.4.2 下划线命名 vs 驼峰命名</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902105446240.png" alt="image-20220902105446240" style="zoom:80%;" /></p><h3 id="实用工具">1.5 实用工具</h3><h4 id="json相关">1.5.1 JSON相关</h4><ol type="1"><li><a href="https://www.sojson.com/">JSON 在线辅助网站</a>：转JavaBean；合法性校验；压缩；优化预览</li><li>GsonFormatPlus：IDEA 插件，JSON 转 JavaBean</li><li>JSON：维基百科，了解 JSON 的来⻰去脉</li></ol><h4 id="抓包工具-charles">1.5.2 抓包工具 Charles</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902105219265.png" alt="image-20220902105219265" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902105234415.png" alt="image-20220902105234415" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902105347441.png" alt="image-20220902105347441" style="zoom:80%;" /></p><h4 id="抓包工具-postman轻松创建请求">1.5.3 抓包工具Postman–轻松创建请求</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902105519456.png" alt="image-20220902105519456" style="zoom:80%;" /></p><h2 id="二android网络通信基础实现">二、Android网络通信基础实现</h2><h3 id="添加网络权限">2.1 添加网络权限</h3><blockquote><p>在<strong>AndroidManifest.xml</strong>中，添加网络权限<strong>uses-permission</strong></p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取网络中的数据">2.2 获取网络中的数据</h3><blockquote><ol type="1"><li>新建一个线程<strong>HandlerThread</strong>，用于执行与网络有关的任务</li><li>新建一个任务<strong>Handler</strong>，用于从<strong>url</strong>中获取数据<ol type="1"><li>在<strong>run()</strong>方法中</li><li>调用自定义的<strong>getDataFromNetwork()</strong>方法，获取数据</li><li>然后根据得到的数据，调用自定义的<strong>showDataFromNetwork()</strong>方法，刷新界面</li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化界面的相关操作</span></span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.lab5_main_layout);</span><br><span class="line">    networkResult = findViewById(R.id.Lab5_NetworkResult);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行从网络中获取数据的操作</span></span><br><span class="line">    runGetDataFromNetwork(<span class="string">&quot;https://www.wanandroid.com/article/list/0/json/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建线程, 执行从网络中获取数据的操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runGetDataFromNetwork</span><span class="params">(String urlString)</span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个线程, 用于执行与网络有关的任务</span></span><br><span class="line">    <span class="type">HandlerThread</span> <span class="variable">handlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;Networking&quot;</span>);</span><br><span class="line">    handlerThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个Handler, 用于从url中获取数据</span></span><br><span class="line">    <span class="type">Handler</span> <span class="variable">networkingHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(handlerThread.getLooper());</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">networkingRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;run networking Runnable: 从url中获取数据&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用getDataFromNetwork()方法, 获取数据</span></span><br><span class="line">            ArrayList&lt;Lab5_NetworkData&gt; result = getDataFromNetwork(urlString);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据得到的数据, 刷新界面</span></span><br><span class="line">            <span class="keyword">if</span>(result != <span class="literal">null</span> &amp;&amp; !result.isEmpty())&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;run networking Runnable: 从url中获取数据为:&quot;</span> + <span class="string">&quot;not null&quot;</span>);</span><br><span class="line">                showDataFromNetwork(result);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;run networking Runnable: 从url中获取数据为:&quot;</span> + <span class="string">&quot;null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    networkingHandler.post(networkingRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>获取数据：<strong>getDataFromNetwork(String urlString)</strong>方法<ol type="1"><li>将传入的<strong>urlString</strong>转化为<strong>URL</strong></li><li>使用<strong>HttpURLConnection</strong>建立连接<ol type="1"><li>创建实例<strong>connection</strong></li></ol></li><li>从<strong>connection</strong>中获取数据<ol type="1"><li>先获取为<strong>InputStream</strong></li><li>然后转化为<strong>BufferedReader</strong></li><li>最后，通过<strong>BufferedReader.readLine()</strong>方法，将其中的数据转化为<strong>JSONObject</strong></li></ol></li><li>解析<strong>JSON</strong>：从<strong>JSONObject</strong>中，读取出所有<strong>data.datas[].title/link</strong><ol type="1"><li>根据目标<strong>JSON</strong>文件的结构，反复调用<strong>getJSONObject()</strong>、<strong>getJSONArray()</strong>方法</li><li>如果当前到达了最低层，则调用<strong>getString()</strong>方法，获取<strong>String</strong>类型的数据</li><li>将数据存放入一个<strong>ArrayList</strong>中</li></ol></li><li>将读取到的<strong>ArrayList</strong>返回</li></ol></li><li>注意要使用<strong>try</strong>，防止操作出现异常</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从网络中获取数据</span></span><br><span class="line"><span class="comment">// 返回一个List, 存放解析出的Json数据</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Lab5_NetworkData&gt; <span class="title function_">getDataFromNetwork</span><span class="params">(String urlString)</span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;getDataFromNetwork: 从网络中获取数据, 返回List&quot;</span>);</span><br><span class="line">    ArrayList&lt;Lab5_NetworkData&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Lab5_NetworkData&gt;();</span><br><span class="line">    <span class="comment">// 通过try, 防止获取数据出现问题</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 将urlString转化为URL</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlString);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用HttpURLConnection建立连接</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        connection.setConnectTimeout(<span class="number">6000</span>);</span><br><span class="line">        connection.connect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据, 并将其转化为JSONObject</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> connection.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">resultJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(reader.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从JSONObject中, 读取出所有data.datas[].title/link</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> resultJson.getJSONObject(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">datas</span> <span class="operator">=</span> data.getJSONArray(<span class="string">&quot;datas&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; datas.length(); index++)&#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">item</span> <span class="operator">=</span> datas.getJSONObject(index);</span><br><span class="line">            <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> item.getString(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">link</span> <span class="operator">=</span> item.getString(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">Lab5_NetworkData</span>(title, link));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭BufferedReader, InputStream, 取消HttpURLConnection的连接</span></span><br><span class="line">        reader.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        connection.disconnect();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用webview打开网页">2.3 使用WebView打开网页</h3><blockquote><ol type="1"><li>新建一个<strong>Activity</strong>，其中有<strong>WebView</strong>控件</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.Lab5_WebViewActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;WebView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/Lab5_WebView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><blockquote><ol start="2" type="1"><li>切换至<strong>WebViewActivity</strong>时，将<strong>urlString</strong>作为参数，添加进<strong>intent</strong>中</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用单个从网络中获取的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useDataFromNetwork</span><span class="params">(Lab5_NetworkData data)</span>&#123;</span><br><span class="line">    <span class="comment">// 使用WebView Activity打开网页</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">urlString</span> <span class="operator">=</span> data.getLink();</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, Lab5_WebViewActivity.class);</span><br><span class="line">    intent.putExtra(<span class="string">&quot;url&quot;</span>, urlString);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="3" type="1"><li>在<strong>WebViewActivity</strong>初始化时，获取<strong>urlString</strong>参数，打开网页<ol type="1"><li>由于现在的网页包含的内容过多，因此要进行一系列设置，才能正常读取页面的数据</li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lab5_WebViewActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line">    <span class="keyword">private</span> WebSettings webSettings;</span><br><span class="line">    <span class="keyword">private</span> String urlString;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.lab5_webview_layout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取WebView控件, 传入的url字符串, WebSettings属性</span></span><br><span class="line">        webView = findViewById(R.id.Lab5_WebView);</span><br><span class="line">        urlString = getIntent().getStringExtra(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        webSettings = webView.getSettings();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置WebView的属性</span></span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line">        webSettings.setSupportZoom(<span class="literal">true</span>);</span><br><span class="line">        webSettings.setBuiltInZoomControls(<span class="literal">true</span>);</span><br><span class="line">        webSettings.setLoadWithOverviewMode(<span class="literal">true</span>);</span><br><span class="line">        webSettings.setAppCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">        webSettings.setDomStorageEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用WebView控件, 打开对应网页</span></span><br><span class="line">        webView.loadUrl(urlString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三进阶实现retrofit自学">三、进阶实现：Retrofit(自学)</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902112806576.png" alt="image-20220902112806576" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902112756408.png" alt="image-20220902112756408" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902112746043.png" alt="image-20220902112746043" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902112736535.png" alt="image-20220902112736535" style="zoom:80%;" /></p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220902112726704.png"alt="image-20220902112726704" /><figcaption aria-hidden="true">image-20220902112726704</figcaption></figure><h1 id="day6-android存储">Day6 Android存储</h1><h2 id="一存储空间概览">一、存储空间概览</h2><h3 id="存储空间的区分">1.1 存储空间的区分</h3><ol type="1"><li><strong>InternalStorage</strong>：是系统分配给应用的专属内部存储空间<ol type="1"><li>APP专有的</li><li>用户不可以直接读取(root用户除外)</li><li>应用卸载时自动清空</li><li>有且仅有一个</li></ol></li><li><strong>External Storage</strong>：是系统外部存储空间，如 SD卡<ol type="1"><li>所有用户均可访问</li><li>不保证可用性(可挂载/物理移除)</li><li>可以卸载后仍保留</li><li>可以有多个</li></ol></li></ol><h3 id="存储目录">1.2 存储目录</h3><ol type="1"><li><p><strong>Internal Storage</strong>：/</p><ol type="1"><li>APP专用：<ol type="1"><li>data/data/{your.package.name}/ files、cache、db...</li></ol></li></ol></li><li><p><strong>External Storage</strong>：</p><ol type="1"><li>APP专用：<ol type="1"><li>/storage/emulated/0/Android/data/{your.package.name}/files、cache</li></ol></li><li>公共文件夹：./<ol type="1"><li> --- Standard: DCIM、Download、Movies</li><li> --- Others</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905093948124.png" alt="image-20220905093948124" style="zoom:80%;" /></p></li></ol><h3 id="internal目录的获取">1.3 Internal目录的获取</h3><ol type="1"><li>file目录：<strong>context.getFilesDir()</strong></li><li>cache目录：<strong>context.getCacheDir()</strong></li><li>自定义目录：<strong>context.getDir(name, mode_private)</strong></li></ol><h3 id="external目录的获取">1.4 External目录的获取</h3><h4 id="获取授权">1.4.1 获取授权</h4><blockquote><p><strong>AndroidManifest.xml</strong>中声明权限</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>请求授权（<strong>Android 6.0</strong>及以上）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">CODE_REQUEST_PERMISSION</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.READ_CALENDAR) </span><br><span class="line">!= PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">ActivityCompat.requestPermissions(<span class="built_in">this</span>, </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>[] &#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, </span><br><span class="line">CODE_REQUEST_PERMISSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 <strong>Activity</strong> 的<strong>onRequestPermissionsResult</strong> 方法中获取授权结果</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="type">int</span>[] grantResults)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (requestCode == CODE_REQUEST_PERMISSION) &#123;</span><br><span class="line"><span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"><span class="comment">// ⽤户已授权</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ⽤户拒绝了授权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="environment-apis">1.4.2 Environment APIs</h4><blockquote><p>提供了访问<strong>环境变量</strong>的方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Environment</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;&#125;;</span><br><span class="line">android.os.Environment;</span><br></pre></td></tr></table></figure><h4 id="检查外置存储器的可用性">1.4.3 检查外置存储器的可用性</h4><blockquote><p>通过<strong>Environment.getExternalStorageState();</strong>调⽤获取当前外部存储的状态，并以此判断外部存储是否可⽤</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905100752309.png" alt="image-20220905100752309" style="zoom:80%;" /></p><h4 id="external目录的获取-1">1.4.4 External目录的获取</h4><ol type="1"><li>应用私有目录：<ol type="1"><li><strong>file</strong>目录：<strong>context.getExternalFilesDir(Stringtype)</strong></li><li><strong>cache</strong>目录：<strong>context.getExternalCacheDir()</strong></li></ol></li><li>公共目录：<ol type="1"><li>标准目录：<strong>Environment.getExternalStoragePublicDirectory(Stringtype)</strong></li><li>根目录：<strong>Environment.getExternalStorageDirectory()</strong></li></ol></li><li>标准目录：<ol type="1"><li><strong>DIRECTORY_ALARMS</strong></li><li><strong>DIRECTORY_DCIM</strong></li><li><strong>DIRECTORY_DOCUMENTS</strong></li><li><strong>DIRECTORY_DOWNLOADS</strong></li><li><strong>DIRECTORY_MOVIES</strong></li></ol></li></ol><h3 id="注意事项">1.5 注意事项</h3><ol type="1"><li>如果用户卸载应⽤，系统会移除保存在应⽤专属存储空间中的⽂件</li><li>由于这⼀行为，不应使用此存储空间保存⽤户希望独例于应用而保留的任何内容<ol type="1"><li>例如，如果应用允许用户拍摄照片，用户会希望即使卸载应⽤后仍可访问这些照⽚</li><li>因此，应改为使用共享存储空间将此类文件保存到适当的媒体集合中。</li></ol></li></ol><p>更多信息可参考：https://developer.android.com/guide/topics/data?hl=zh-cn</p><h2 id="二键值对">二、键值对</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905094425569.png" alt="image-20220905094425569" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905094434425.png" alt="image-20220905094434425" style="zoom:80%;" /></p><h2 id="三sharedpreferences">三、SharedPreferences</h2><h3 id="介绍">3.1 介绍</h3><ol type="1"><li><strong>SharedPreference</strong> 就是 <strong>Android</strong>提供的数据持久化的⼀个方式，适合单进程，小批量的数据存储和访问。基于<strong>XML</strong>进行实现，本质上还是⽂件的读写，<strong>API</strong> 相较<strong>File</strong> 更简单。</li><li>以“键-值”对的方式保存数据的<strong>xml</strong>⽂件，其文件保存在<strong>/data/data/[packageName]/shared_prefs</strong>目录下</li></ol><h3 id="获取sharedpreferences">3.2 获取SharedPreferences</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905094610997.png"alt="image-20220905094610997" /><figcaption aria-hidden="true">image-20220905094610997</figcaption></figure><h3 id="读取sharedpreferences">3.3 读取SharedPreferences</h3><blockquote><p>通过<strong>getxxx()</strong>方法获取，需要传入(<strong>key</strong>，<strong>defaultValue</strong>)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SP_NAME</span> <span class="operator">=</span> <span class="string">&quot;Lab6_SharedPreference&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SAVE_KEY</span>  <span class="operator">=</span> <span class="string">&quot;Lab6_Text&quot;</span>;</span><br><span class="line"><span class="comment">// 从内存中读取EditText的文本</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">readTextFromStorage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> Lab6_SharedPreference.<span class="built_in">this</span>.getSharedPreferences(SP_NAME, Context.MODE_PRIVATE);</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> sp.getString(SAVE_KEY,<span class="string">&quot;记录一些文字&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905094626044.png"alt="image-20220905094626044" /><figcaption aria-hidden="true">image-20220905094626044</figcaption></figure><h3 id="写sharedpreferences">3.4 写SharedPreferences</h3><blockquote><p>通过<strong>Editor</strong>类来提交修改</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SP_NAME</span> <span class="operator">=</span> <span class="string">&quot;Lab6_SharedPreference&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SAVE_KEY</span>  <span class="operator">=</span> <span class="string">&quot;Lab6_Text&quot;</span>;</span><br><span class="line"><span class="comment">// 将当前EditText的文本保存到内存中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveTextToStorage</span><span class="params">(String text)</span>&#123;</span><br><span class="line">    <span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> Lab6_SharedPreference.<span class="built_in">this</span>.getSharedPreferences(SP_NAME, Context.MODE_PRIVATE);</span><br><span class="line">    SharedPreferences.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sp.edit();</span><br><span class="line">    editor.putString(SAVE_KEY, text);</span><br><span class="line">    editor.commit();</span><br><span class="line">    <span class="comment">// 或者调用apply方法</span></span><br><span class="line">    <span class="comment">// editor.apply();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sharedpreferences的原理">3.5 SharedPreferences的原理</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905094927561.png"alt="image-20220905094927561" /><figcaption aria-hidden="true">image-20220905094927561</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905094941985.png"alt="image-20220905094941985" /><figcaption aria-hidden="true">image-20220905094941985</figcaption></figure><h3 id="注意事项-1">3.6 注意事项</h3><ol type="1"><li>SharedPreference 适合场景：小数据</li><li>SharedPreference 每次写入均为全量写入</li><li>禁止大数据存储在 SharedPreference 中，导致 ANR</li></ol><p>官方推荐的DataStore：https://developer.android.com/topic/libraries/architecture/datastore</p><h2 id="四文件file">四、文件File</h2><h3 id="流">4.1 流</h3><p>都是相对调用者而言的</p><ol type="1"><li>按流向分为：<ol type="1"><li>输⼊流</li><li>输出流</li></ol></li><li>按传输单位分为：<ol type="1"><li>字节流：<strong>InputStream</strong> 和<strong>OutputStream</strong> 基类</li><li>字符流：<strong>Reader</strong> 和 <strong>Writer</strong> 基类</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905095449287.png" alt="image-20220905095449287"  /></p><h3 id="api-1">4.2 API</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905095310212.png" alt="image-20220905095310212" style="zoom:80%;" /></p><h3 id="文件操作">4.3 文件操作</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905095407452.png"alt="image-20220905095407452" /><figcaption aria-hidden="true">image-20220905095407452</figcaption></figure><h3 id="文件io读写操作示例">4.4 文件IO读写操作示例</h3><blockquote><ol type="1"><li>创建 File 对象，通过构造函数：<ol type="1"><li><strong>new File()</strong></li></ol></li><li>创建输⼊输出流对象：<ol type="1"><li><strong>new FileReader()</strong></li><li><strong>new FileWriter()</strong></li></ol></li><li>读取 or 写⼊<ol type="1"><li><strong>read</strong> 方法</li><li><strong>write</strong> f昂发</li></ol></li><li>关闭资源<ol type="1"><li>有借有还，再借不难</li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lab6_FileIO</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;Lab6_FileIO&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SAVE_FILE_NAME</span> <span class="operator">=</span> <span class="string">&quot;Lab6_FileIO&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SAVE_KEY</span>  <span class="operator">=</span> <span class="string">&quot;Lab6_Text&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> EditText editText;</span><br><span class="line">    <span class="keyword">private</span> Button saveButton;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.lab6_text_memo);</span><br><span class="line"></span><br><span class="line">        fileName = getFilesDir().getAbsolutePath() + File.separator + SAVE_FILE_NAME;</span><br><span class="line"></span><br><span class="line">        editText = findViewById(R.id.Lab6_EditText);</span><br><span class="line">        readTextFromStorage();</span><br><span class="line"></span><br><span class="line">        saveButton = findViewById(R.id.Lab6_Save_Button);</span><br><span class="line">        saveButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                saveTextToStorage(editText.getText().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存中读取EditText的文本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readTextFromStorage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">                <span class="comment">// 文件不存在, 则新建一个文件</span></span><br><span class="line">                <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">                        <span class="keyword">if</span>(!isSuccess) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;create file exception&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">&quot;readTextFromStorage: 创建文件失败&quot;</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 文件存在</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建文件输入流</span></span><br><span class="line">                    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                    <span class="comment">// 读取数据, 存入buffer中</span></span><br><span class="line">                    <span class="keyword">while</span> (inputStream.read(bytes) != -<span class="number">1</span>)&#123;</span><br><span class="line">                        buffer.append(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在UI线程中修改editText的值</span></span><br><span class="line">                    runOnUiThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> buffer.toString();</span><br><span class="line">                            text = text.trim();</span><br><span class="line">                            <span class="keyword">if</span>(text.equals(<span class="string">&quot;&quot;</span>)) text = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;记录一些文字&quot;</span>);</span><br><span class="line">                            editText.setText(text);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">&quot;readTextFromStorage: 文件读取失败&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前EditText的文本保存到内存中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveTextToStorage</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">                <span class="comment">// 文件不存在, 则新建一个文件</span></span><br><span class="line">                <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">                        <span class="keyword">if</span>(!isSuccess) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;create file exception&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">&quot;saveTextToStorage: 创建文件失败&quot;</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 文件存在</span></span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">                    outputStream.write(text.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">&quot;saveTextToStorage: 创建文件失败&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123; <span class="comment">// 将文件输出流关闭</span></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(outputStream != <span class="literal">null</span>)</span><br><span class="line">                            outputStream.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">&quot;saveTextToStorage: 文件输出流关闭失败&quot;</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展okio">4.7 拓展：OkIO</h3><ol type="1"><li>是在<strong>JavaIO</strong>基础上再次进行封装的<strong>IO</strong>框架</li><li>https://square.github.io/okio/</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906142429416.png" alt="image-20220906142429416" style="zoom:80%;" /></p><h2 id="五数据库">五、数据库</h2><h3 id="使用场景">5.1 使用场景</h3><ol type="1"><li>重复的数据</li><li>结构化的数据</li><li>关系型数据</li></ol><h3 id="数据库的设计">5.2 数据库的设计</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103427035.png" alt="image-20220905103427035"  /></p><h3 id="sql">5.3 SQL</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103449215.png"alt="image-20220905103449215" /><figcaption aria-hidden="true">image-20220905103449215</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103454598.png"alt="image-20220905103454598" /><figcaption aria-hidden="true">image-20220905103454598</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103500886.png"alt="image-20220905103500886" /><figcaption aria-hidden="true">image-20220905103500886</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103506146.png"alt="image-20220905103506146" /><figcaption aria-hidden="true">image-20220905103506146</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103512495.png"alt="image-20220905103512495" /><figcaption aria-hidden="true">image-20220905103512495</figcaption></figure><h3 id="使用示例todo-list-app">5.4 使用示例：Todo List App</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906142203738.png" alt="image-20220906142203738" style="zoom:80%;" /></p><h4 id="定义contract类">5.4.1 定义Contract类</h4><blockquote><p>定义表结构、SQL语句</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103926681.png"alt="image-20220905103926681" /><figcaption aria-hidden="true">image-20220905103926681</figcaption></figure><h4 id="继承sqliteopenhelper">5.4.2 继承SQLiteOpenHelper</h4><blockquote><p>执行<strong>Create</strong> 和 <strong>Delete</strong> 操作</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103718927.png"alt="image-20220905103718927" /><figcaption aria-hidden="true">image-20220905103718927</figcaption></figure><h4 id="获取sqllitedatabase">5.4.3 获取SQLLiteDatabase</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906142245189.png" alt="image-20220906142245189" style="zoom:80%;" /></p><h4 id="insert">5.4.4 Insert</h4><blockquote><p>通过<strong>ContentValues</strong>进行插⼊操作</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905103913631.png"alt="image-20220905103913631" /><figcaption aria-hidden="true">image-20220905103913631</figcaption></figure><h4 id="query">5.4.5 Query</h4><blockquote><p>调用<strong>query()</strong>方法，返回 <strong>Cursor</strong>，对应查询结果集合</p><p>当<strong>moveToNext</strong>返回 -1时，遍历结束</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906142305525.png" alt="image-20220906142305525" style="zoom:80%;" /></p><h4 id="delete">5.4.6 Delete</h4><blockquote><p>删除数据库中对应 id 的数据</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905104044993.png"alt="image-20220905104044993" /><figcaption aria-hidden="true">image-20220905104044993</figcaption></figure><h4 id="update">5.4.7 Update</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905104116815.png"alt="image-20220905104116815" /><figcaption aria-hidden="true">image-20220905104116815</figcaption></figure><h4 id="debug">5.4.8 Debug</h4><blockquote><p>adb + sqlite3：http://www.sqlite.org/cli.html</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906142351296.png" alt="image-20220906142351296" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906142357145.png" alt="image-20220906142357145" style="zoom:80%;" /></p><h4 id="注意事项-2">5.4.8 注意事项</h4><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905104435654.png"alt="image-20220905104435654" /><figcaption aria-hidden="true">image-20220905104435654</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905104450504.png"alt="image-20220905104450504" /><figcaption aria-hidden="true">image-20220905104450504</figcaption></figure><h3 id="room-library">5.5 Room Library</h3><p>https://developer.android.com/jetpack/androidx/releases/room</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905104524950.png" alt="image-20220905104524950" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906142120880.png" alt="image-20220906142120880" style="zoom: 80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906142128136.png" alt="image-20220906142128136" style="zoom:80%;" /></p><h2 id="六content-provider">六、Content Provider</h2><h3 id="定义">6.1 定义</h3><ol type="1"><li>当我们需要在应⽤间共享数据时，<strong>ContentProvider</strong>就是⼀个非常值得使用的组件</li><li>四大组件之⼀，<strong>ContentProvider</strong> 是⼀种<strong>Android</strong>数据共享机制，无论其内部数据以什么样的方式组织，对外都是提供统⼀的接口</li><li>通过<strong>ContentProvider</strong>可以获取系统的媒体、联系⼈、⽇程等数据</li></ol><p>https://developer.android.com/reference/android/content/ContentProvider</p><h3 id="content-provider架构">6.2 Content Provider架构</h3><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905104930570.png"alt="image-20220905104930570" /><figcaption aria-hidden="true">image-20220905104930570</figcaption></figure><h3 id="优点">6.3 优点</h3><ol type="1"><li>跨应用分享数据<ol type="1"><li>系统的 <strong>providers</strong> 有联系人等</li></ol></li><li>是对数据层的良好抽象</li><li>支持精细的权限控制</li></ol><h2 id="七uri">七、URI</h2><h3 id="uri介绍">7.1 URI介绍</h3><p><strong>URI</strong>：Uniform ResourceIndentifier，唯一标识ContentProvider的数据</p><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905105150461.png"alt="image-20220905105150461" /><figcaption aria-hidden="true">image-20220905105150461</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905105158051.png"alt="image-20220905105158051" /><figcaption aria-hidden="true">image-20220905105158051</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220905105248202.png"alt="image-20220905105248202" /><figcaption aria-hidden="true">image-20220905105248202</figcaption></figure><h3 id="uri使用示例">7.2 URI使用示例</h3><h4 id="查询获取联系人数据">7.2.1 查询：获取联系人数据</h4><blockquote><ol type="1"><li><strong>AndroidManifest</strong> 权限声明</li></ol></blockquote><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission <span class="attr">android:</span>name=<span class="string">&quot;android.permission.READ_CONTACTS&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><ol start="2" type="1"><li>在程序中动态请求权限</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.READ_CONTACTS)</span><br><span class="line">    != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    ActivityCompat.requestPermissions(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">        Manifest.permission.READ_CONTACTS</span><br><span class="line">    &#125;, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="3" type="1"><li>通过<strong>ContentResolver</strong>查询对应的<strong>ContentProvider</strong></li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 ContentResolver 对象</span></span><br><span class="line"><span class="type">ContentResolver</span> <span class="variable">contentResolver</span> <span class="operator">=</span> <span class="built_in">this</span>.getContentResolver();</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span>contentResolver.query(ContactsContract.Contacts.CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><blockquote><ol start="4" type="1"><li>遍历<strong>cursor</strong>，获取对应字段的值</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906141831356.png" alt="image-20220906141831356" style="zoom:80%;" /></p><h4 id="查询获取系统相册中的视频文件">7.2.2查询：获取系统相册中的视频文件</h4><blockquote><ol type="1"><li><strong>AndroidManifest</strong> 权限声明</li></ol></blockquote><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission <span class="attr">android:</span>name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><ol start="2" type="1"><li>在程序中动态请求权限</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">    != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    ActivityCompat.requestPermissions(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">        Manifest.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">    &#125;, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="3" type="1"><li>通过<strong>ContentResolver</strong>查询</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 ContentResolver 对象</span></span><br><span class="line"><span class="type">ContentResolver</span> <span class="variable">contentResolver</span> <span class="operator">=</span> <span class="built_in">this</span>.getContentResolver();</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> contentResolver.query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906141600052.png" alt="image-20220906141600052" style="zoom:80%;" /></p><h4 id="读取uri对应的图片到imageview中">7.2.3读取URI对应的图片到ImageView中</h4><blockquote><ol type="1"><li><strong>AndroidManifest</strong> 权限声明</li></ol></blockquote><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission <span class="attr">android:</span>name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><ol start="2" type="1"><li>在程序中动态请求权限</li><li>重写<strong>onRequestPermissionsResult()</strong>方法，定义授权后的操作</li><li>重写<strong>onActivityResult()</strong>方法，定义选择图片之后的操作</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span><br><span class="line"><span class="params">                         Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment_my_settings, container, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    userIcon = view.findViewById(R.id.icon_my_setting_user_info);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行一个判断，是否已经有访问权限，如果没有先获取</span></span><br><span class="line">    <span class="keyword">if</span>(ContextCompat.checkSelfPermission(getContext(), Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">       != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">        </span><br><span class="line">        ActivityCompat.requestPermissions(getActivity(), </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        Toast.makeText(getActivity(),<span class="string">&quot;请授予权限&quot;</span>, Toast.LENGTH_SHORT);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 已经有权限了, 直接执行操作</span></span><br><span class="line">        readImageFromStorage();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    userIcon.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">            <span class="comment">// 点击后打开本地图库选择照片</span></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_PICK, <span class="literal">null</span>);</span><br><span class="line">            intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="string">&quot;image/*&quot;</span>);</span><br><span class="line">            startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(api = Build.VERSION_CODES.O)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="type">int</span>[] grantResults)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">if</span>(requestCode == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">            readImageFromStorage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Toast.makeText(getActivity(), <span class="string">&quot;授权失败&quot;</span>, Toast.LENGTH_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">if</span>(requestCode == <span class="number">1</span> &amp;&amp; resultCode == RESULT_OK)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> data.getData();</span><br><span class="line">            userIcon.setImageURI(uri);</span><br><span class="line">            saveImageToStorage(uri);</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;onActivityResult: 设置图片的路径为&quot;</span> + uri.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4" type="1"><li>自定义<strong>readImageFromStorage()</strong>方法通过URI读取图片</li><li>自定义<strong>saveImageToStorage()</strong>方法保存URI</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="comment">// 本地用户的图标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_ICON_SAVE_SP</span> <span class="operator">=</span> <span class="string">&quot;USER_ICON&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_ICON_SAVE_KEY</span> <span class="operator">=</span> <span class="string">&quot;user_icon&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(api = Build.VERSION_CODES.O)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readImageFromStorage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> getActivity().getSharedPreferences(Constants.USER_ICON_SAVE_SP, Context.MODE_PRIVATE);</span><br><span class="line">    <span class="type">String</span> <span class="variable">uriString</span> <span class="operator">=</span> sp.getString(Constants.USER_ICON_SAVE_KEY, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span>(uriString == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(uriString);</span><br><span class="line">    userIcon.setImageURI(uri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveImageToStorage</span><span class="params">(Uri uri)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uriString</span> <span class="operator">=</span> uri.toString();</span><br><span class="line">    <span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> getActivity().getSharedPreferences(Constants.USER_ICON_SAVE_SP, Context.MODE_PRIVATE);</span><br><span class="line">    SharedPreferences.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sp.edit();</span><br><span class="line">    editor.putString(Constants.USER_ICON_SAVE_KEY, uriString);</span><br><span class="line">    editor.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="day7-android多媒体基础">Day7 Android多媒体基础</h1><h2 id="一图片基础">一、图片基础</h2><h3 id="图片基础颜色空间">1.1 图片基础：颜色空间</h3><p>RGB色彩空间(R=Red, G=Green, B=Blue, A=Alpha)</p><ol type="1"><li><strong>ALPHA_8</strong>：A = 8位，1字节</li><li><strong>RGB_565</strong>：R = 5位 G = 6位 B = 5位，2字节</li><li><strong>ARGB_4444</strong>：A = 4位 R = 4位 G = 4位 B =4位，2字节</li><li><strong>ARGB_8888</strong>：A = 8位 R = 8位 G = 8位 B =8位，4字节</li></ol><h3 id="图片存储位图">1.2 图片存储：位图</h3><ol type="1"><li><p>位图以像素(方格点)构成图像，放大时会失真</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906195359445.png" alt="image-20220906195359445" style="zoom:80%;" /></p></li></ol><h3 id="图片格式压缩标准方案">1.3 图片格式：压缩标准方案</h3><p><strong>JPEG</strong>：Joint Photographic Experts Group有损压缩方案</p><ol type="1"><li>去除冗余的图像和彩色数据</li><li>压缩比相对较⾼，⽂件大小相对较小</li><li>不支持透明图和动态图</li></ol><p><strong>PNG</strong>：全称Portable Network Graphics</p><ol type="1"><li>高压缩比的<strong>无损压缩</strong>，⽂件大小比jpeg⾼些</li><li>最多⽀持48位⾊彩</li><li>支持<strong>α通道</strong>数据(透明度)</li><li>是Android开发上常用的图片格式，例如图标</li></ol><p><strong>WebP</strong>是谷歌提供的⼀种⽀持有损压缩和无损压缩的图片文件格式</p><ol type="1"><li>比JPEG或PNG更好的压缩</li><li>在Android 4.0(API level 14)中支持有损的WebP图像</li><li>在Android 4.3(API level 18)和更高版本中支持无损和透明的WebP图像</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906195738520.png" alt="image-20220906195738520" style="zoom:80%;" /></p><h3 id="图片存储矢量图">1.4 图片存储：矢量图</h3><ol type="1"><li>矢量图使用线段和曲线描述图像，由数学向量构成图形图像</li><li>可以被无限放大而不影响质量</li></ol><h2 id="二android图片加载">二、Android图片加载</h2><h3 id="graphics包安卓平台2d图形绘制的基础">2.1Graphics包：安卓平台2D图形绘制的基础</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906200013440.png" alt="image-20220906200013440" style="zoom:80%;" /></p><h3 id="android-bitmap一种存储像素的数据结构">2.2 AndroidBitmap：一种存储像素的数据结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906200257970.png" alt="image-20220906200257970" style="zoom:80%;" /></p><h3 id="图片加载">2.3 图片加载</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906200618941.png" alt="image-20220906200618941" style="zoom:80%;" /></p><h3 id="加载超大图片">2.4 加载超大图片</h3><p>加载的图片过大，可能会出现<strong>OOM(Out of Memory)</strong></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906201121241.png" alt="image-20220906201121241" style="zoom:80%;" /></p><h3 id="大图分块加载">2.5 大图分块加载</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906201932153.png" alt="image-20220906201932153" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906201944970.png" alt="image-20220906201944970" style="zoom:80%;" /></p><h3 id="图片自适应ninepatchdrawable">2.6图片自适应：NinePatchDrawable</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906202051154.png" alt="image-20220906202051154" style="zoom:80%;" /></p><h3 id="imageview-1">2.7 ImageView</h3><ol type="1"><li><p>ImageView：显示图片的组件</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906202112375.png" alt="image-20220906202112375" style="zoom:80%;" /></p><p>https://developer.android.com/reference/android/widget/ImageView.ScaleType</p></li><li><p><strong>ImageView.ScaleType</strong>：主要值设置所显示的图片如何缩放或移动以适应ImageView的大小</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906202606810.png" alt="image-20220906202606810" style="zoom:80%;" /></p></li></ol><h3 id="drawable">2.8 Drawable</h3><ol type="1"><li><p><strong>Drawable</strong>在 <strong>View 2D</strong>绘画里是⼀个很重要的抽象类，抽象出了怎么画，画什么的⼀个概念</p></li><li><p>有很多子类</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906202902180.png" alt="image-20220906202902180" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906202830183.png" alt="image-20220906202830183" style="zoom:80%;" /></p></li></ol><h3 id="常见图片库">2.9 常见图片库</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906203019084.png" alt="image-20220906203019084" style="zoom:80%;" /></p><h3 id="glide">2.10 Glide</h3><h4 id="glide的基础使用">2.10.1 Glide的基础使用</h4><ol type="1"><li><strong>Glide</strong>是⼀个快速高效的<strong>Android</strong>图片加载库，提供了易用的<strong>API</strong>，高性能、可扩展的图⽚解码管道</li></ol><blockquote><p>在<strong>build.grade</strong>里面添加引用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;com.github.bumptech.glide:glide:4.9.0&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>在代码中使用<strong>Glide</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">.load(uri)</span><br><span class="line">.into(imageView);</span><br></pre></td></tr></table></figure><h4 id="glide流程">2.10.2 Glide流程</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906203447657.png" alt="image-20220906203447657" style="zoom:80%;" /></p><h4 id="glide-requestbuilder">2.10.3 Glide RequestBuilder</h4><ol type="1"><li><strong>RequestBuilder</strong>是Glide中请求的骨架，负责携带请求的<strong>url</strong>和你的设置项来开始⼀个新的加载过程。使用<strong>RequestBuilder</strong> 可以指定:<ol type="1"><li>你想加载的资源类型(<strong>Bitmap</strong>,<strong>Drawable</strong>, 或其他)</li><li>你要加载的资源地址(<strong>url</strong>/<strong>model</strong>)</li><li>你想最终加载到的<strong>View</strong></li><li>任何你想应用的(⼀个或多个)<strong>RequestOption</strong> 对象</li><li>任何你想应用的(⼀个或多个)<strong>TransitionOption</strong>对象</li><li>任何你想加载的缩略图 <strong>thumbnail</strong>()</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestBuilder&lt;Drawable&gt; requestBuilder = Glide.with(fragment).asDrawable();</span><br><span class="line"></span><br><span class="line">RequestBuilder&lt;Drawable&gt; requestBuilder = Glide.with(fragment).load(url);</span><br></pre></td></tr></table></figure><h4 id="glide-requestoptions">2.10.4 Glide RequestOptions</h4><p><strong>Glide</strong>中的很多设置项都可以通过<strong>RequestOptions</strong> 类和 <strong>apply()</strong>方法来应用到程序中</p><p>使用<strong>Request Options</strong>可以实现(包括但不限于):</p><ol type="1"><li>转换(Transformations)</li><li>缓存策略(Caching Strategies)</li><li>组件特有的设置项，例如编码质量，或Bitmap的解码配置等</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RequestOptions</span> <span class="variable">cropOptions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestOptions</span>();</span><br><span class="line">cropOptions.circleCrop(); </span><br><span class="line">Glide.with(ImageActivity.<span class="built_in">this</span>)</span><br><span class="line">    .load(uri3)</span><br><span class="line">    .apply(cropOptions)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure><h3 id="图片缓存策略">2.11 图片缓存策略</h3><p>为了提升用户体验，图片展示的目标</p><ol type="1"><li>每次以最快的速度打开图片</li><li>减少网络流量的消耗</li><li>都缓存在内存，容易出现OOM</li></ol><p>如何控制缓存大小：<strong>LRU</strong>(Least Recently Used)</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906204038719.png" alt="image-20220906204038719" style="zoom:80%;" /></p><h2 id="三音视频播放">三、音视频播放</h2><h3 id="视频帧">3.1 视频帧</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906204329793.png" alt="image-20220906204329793" style="zoom:80%;" /></p><h3 id="视频编码">3.2 视频编码</h3><p>视频编码：通过特定的压缩技术，将某个视频内容数据转换成另⼀种特定格式文件的方式</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906204620020.png" alt="image-20220906204620020" style="zoom:80%;" /></p><h3 id="视频封装格式">3.3 视频封装格式</h3><p>PC和移动设备上都离不开视频播放，涉及的视频格式也比较多，不同扩展名实际上使用了不同的视频和音频编码</p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906204714348.png" alt="image-20220906204714348" style="zoom:80%;" /></p><h3 id="视频播放">3.4 视频播放</h3><ol type="1"><li>视频解码播放的⼤部分流程，整个视频播放的流程如右图所示</li><li>视频文件都会有特定的封装格式、比特率、时长等信息</li><li>视频解封装之后，对应视频流和⾳频流。</li><li>解复用之后的⾳视频有自己独立的参数，包括<ol type="1"><li>编码方式、采样率、画面大小等</li><li>音频参数包括采样率、编码方式和声道数等</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906205043235.png" alt="image-20220906205043235" style="zoom:80%;" /></p><h3 id="android音频播放">3.5 Android音频播放</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906205244255.png" alt="image-20220906205244255" style="zoom:80%;" /></p><h3 id="media-player">3.6 Media Player</h3><blockquote><p><strong>Android</strong>音视频播放相关类：<strong>MediaPlayer</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906205319512.png" alt="image-20220906205319512" style="zoom:80%;" /></p><h3 id="mediaplayer播放视频">3.7 MediaPlayer播放视频</h3><blockquote><p><strong>MediaPlayer</strong>需要配合<strong>SurfaceHolder</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906205555970.png" alt="image-20220906205555970" style="zoom:80%;" /></p><h3 id="videoview播放视频">3.8 VideoView播放视频</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906205647513.png" alt="image-20220906205647513" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906205709970.png" alt="image-20220906205709970" style="zoom:80%;" /></p><h3 id="第三方播放器">3.9 第三方播放器</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220906205730172.png" alt="image-20220906205730172" style="zoom:80%;" /></p><h1 id="day8-android多媒体进阶">Day8 Android多媒体进阶</h1><h2 id="一视频介绍">一、视频介绍</h2><h3 id="视觉成像的基础原理">1.1 视觉成像的基础原理</h3><h4 id="视网膜视锥细胞">1.1.1 视网膜：视锥细胞</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907165815403.png" alt="image-20220907165815403" style="zoom:80%;" /></p><h4 id="rgbred-green-blue">1.1.2 RGB：Red, Green, Blue</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907114039455.png" alt="image-20220907114039455" style="zoom:80%;" /></p><h4 id="yuvluma-chroma">1.1.3 YUV：Luma &amp; Chroma</h4><ol type="1"><li><strong>Luma</strong>：黑白值，人眼对其比较敏感</li><li><strong>Chroma</strong>：彩度</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907114118012.png" alt="image-20220907114118012" style="zoom:80%;" /></p><h4 id="chroma下采样yuv420">1.1.4 Chroma下采样：YUV420</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907115145731.png" alt="image-20220907115145731" style="zoom:80%;" /></p><h3 id="视频是什么">1.2 视频是什么</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907115216486.png" alt="image-20220907115216486" style="zoom:80%;" /></p><h3 id="分辨率帧率码率">1.3 分辨率、帧率、码率</h3><ol type="1"><li><p><strong>分辨率</strong>：图像内像素的数量，通常使用宽*高表示</p><ol type="1"><li><strong>HD</strong>：全高清，1920*1080</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907115255261.png" alt="image-20220907115255261" style="zoom:80%;" /></p></li><li><p><strong>帧率</strong>：每秒钟播放的图片数量，单位是<strong>FPS</strong></p><ol type="1"><li>帧率越高，视频越连续</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907170259982.png" alt="image-20220907170259982" style="zoom:80%;" /></p></li><li><p><strong>码率</strong>：视频文件在单位时间内使用的数据流量，单位是<strong>kbps</strong>(千位每秒)</p><ol type="1"><li><strong>视频大小 = duration时长(s) × kbps 千位每秒 / 8 =xxMB</strong></li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907170420352.png" alt="image-20220907170420352" style="zoom:80%;" /></p></li></ol><h3 id="视频编码-1">1.4 视频编码</h3><h4 id="原理">1.4.1 原理</h4><ol type="1"><li><strong>空间冗余</strong>：图像相邻像素之间有较强的相关性</li><li><strong>时间冗余</strong>：视频序列的相邻图像之间内容相似，可以压缩成⼀个关键帧+变化差值</li><li><strong>感知冗余</strong>：在人在观看视频时，人眼无法察觉的信息</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907170520111.png" alt="image-20220907170520111" style="zoom:67%;" /></p><h4 id="ibp帧">1.4.2 I/B/P帧</h4><ol type="1"><li><strong>I帧</strong>：关键帧，去除<strong>空间冗余</strong>信息</li><li><strong>P帧</strong>：前向预测帧，去除<strong>时间冗余</strong>信息</li><li><strong>B帧</strong>：双向预测帧，去除<strong>时间冗余</strong>信息</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907170655294.png" alt="image-20220907170655294" style="zoom:80%;" /></p><h4 id="编码格式">1.4.3 编码格式</h4><ol type="1"><li>⽬前主要使用的编码格式有<strong>H264</strong>和<strong>H265</strong><ol type="1"><li><strong>H264</strong>可以达到百倍的压缩率</li><li><strong>H265</strong>比<strong>H264</strong>的压缩率增加⼀倍</li></ol></li></ol><h4 id="封装格式">1.4.4 封装格式</h4><ol type="1"><li>把视频码流和音频码流按照⼀定的格式存储在⼀个文件中</li><li>与编码格式无关</li><li>常用的格式有<strong>MP4</strong>，<strong>AVI</strong>，<strong>FLV</strong>，<strong>RMVB</strong>等</li></ol><h2 id="二相机拍照">二、相机拍照</h2><h3 id="调起系统相机">2.1 调起系统相机</h3><blockquote><p>打开系统相机</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907171037772.png" alt="image-20220907171037772" style="zoom:80%;" /></p><blockquote><p>接收数据，拿到返回的<strong>bitmap</strong>，并显示在屏幕上</p><ol type="1"><li>接收到的<strong>bitmap</strong>，默认会被进行压缩</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907171112102.png" alt="image-20220907171112102" style="zoom:80%;" /></p><h3 id="自定义存储路径">2.2 自定义存储路径</h3><blockquote><p>申请存储权限</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907171301200.png" alt="image-20220907171301200" style="zoom:80%;" /></p><blockquote><p>创建文件</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907171320818.png" alt="image-20220907171320818" style="zoom:80%;" /></p><blockquote><p>获取<strong>content:// URI</strong></p><ol type="1"><li><strong>7.0</strong>以上手机不允许使用<strong>file://URI</strong>跳出应⽤</li><li><strong>android:authorities</strong>：需要是唯一的字符串，后面会用到</li><li><strong>android:resource</strong>：<span class="citation"data-cites="xml/file_paths打开是下面的代码">@xml/file_paths打开是下面的代码</span></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907171847367.png" alt="image-20220907171847367" style="zoom:80%;" /></p><blockquote><p><strong><span class="citation"data-cites="xml/file_paths">@xml/file_paths</span></strong></p><ol type="1"><li>通过<strong>external-files-path</strong>的方式，保证路径是<strong>Android/data/com.bytedance.camera.demo/files/Pictures</strong></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907171905455.png" alt="image-20220907171905455" style="zoom:80%;" /></p><blockquote><p>设置存储地址</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907172107027.png" alt="image-20220907172107027" style="zoom:80%;" /></p><h3 id="显示图片">2.3 显示图片</h3><blockquote><p>防止内存溢出：</p><ol type="1"><li>获取<strong>view</strong>的宽高</li><li>获取图片的宽高<ol type="1"><li>使用<strong>Options.inJustDecodeBounds =true</strong>，不返回实际的<strong>bitmap</strong>文件，只获取其属性</li></ol></li><li>计算缩放比例</li><li>获取<strong>bitmap</strong></li><li>显示在屏幕上</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907172323198.png" alt="image-20220907172323198" style="zoom:80%;" /></p><h3 id="显示效果">2.4 显示效果</h3><blockquote><ol type="1"><li>读取的图片旋转角度<ol type="1"><li>通过<strong>ExitInterface.getAttributeInt()</strong>获取旋转角度</li></ol></li><li>在<strong>matrix</strong>中设置要旋转的角度</li><li>旋转图片</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907172904808.png" alt="image-20220907172904808" style="zoom:80%;" /></p><h2 id="三简单录制">三、简单录制</h2><h3 id="调起系统相机-1">3.1 调起系统相机</h3><blockquote><p>调起相机的录像界面</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907173337047.png" alt="image-20220907173337047" style="zoom:80%;" /></p><h3 id="显示录制视频">3.2 显示录制视频</h3><blockquote><p>获取拍摄的视频，并显示在界面上，开始播放</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907173403949.png" alt="image-20220907173403949" style="zoom:80%;" /></p><h3 id="将视频存储到自定义存储路径中">3.3将视频存储到自定义存储路径中</h3><p>与<strong>2.2</strong>类似</p><h3 id="查看数据">3.4 查看数据</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907173502070.png" alt="image-20220907173502070" style="zoom:80%;" /></p><h2 id="四自定义录制">四、自定义录制</h2><h3 id="获取camera实例">4.1 获取Camera实例</h3><blockquote><p>申请权限</p></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907173635705.png" alt="image-20220907173635705" style="zoom:80%;" /></p><blockquote><p>可用摄像头的数量</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Camera.getNumberOfCameras</span><br></pre></td></tr></table></figure><blockquote><p>获取后置摄像头</p><ol type="1"><li>使用<strong>camera.setDisplayOrientation()</strong>方法，旋转预览图片</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907173717133.png" alt="image-20220907173717133" style="zoom:80%;" /></p><h3 id="摄像头数据实时显示">4.2 摄像头数据实时显示</h3><blockquote><p>使用控件：</p><ol type="1"><li><strong>SurfaceView</strong></li></ol><p>关键类：</p><ol type="1"><li><strong>Camera</strong>：使用的摄像头</li><li><strong>SurfaceView</strong>：预览类<ol type="1"><li>一个<strong>SurfaceView</strong>通常有两个<strong>Surface</strong>：双缓冲区</li></ol></li><li><strong>SurfaceHolder</strong>：<strong>Surface</strong>的持有者<ol type="1"><li>通过<strong>SurfaceHolder</strong>对Surface进行生命周期的管理</li></ol></li><li><strong>SurfaceHolder.Callback</strong>：</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907173808801.png" alt="image-20220907173808801" style="zoom:80%;" /></p><h3 id="surfaceview">4.3 SurfaceView</h3><ol type="1"><li>拥有独立绘图层的特殊View</li><li>双缓冲机制</li><li>通过在Window上面“挖洞”（设置透明区域）进行显示</li></ol><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907174336816.png" alt="image-20220907174336816" style="zoom:80%;" /></p><h3 id="处理activity的声明周期对预览的影响">4.4处理Activity的声明周期对预览的影响</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907174458829.png" alt="image-20220907174458829" style="zoom:80%;" /></p><h3 id="拍摄一张实时图片">4.5 拍摄一张实时图片</h3><blockquote><p>使用<strong>Camera API</strong>拍照</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mCamera.takePicture(<span class="literal">null</span>,<span class="literal">null</span>,mPicture);</span><br></pre></td></tr></table></figure><blockquote><p>拍照后继续预览</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907174611358.png"alt="image-20220907174611358" /><figcaption aria-hidden="true">image-20220907174611358</figcaption></figure><h3 id="mediarecorder">4.6 MediaRecorder</h3><h4 id="mediarecorder的状态机">4.6.1 MediaRecorder的状态机</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907174802680.png" alt="image-20220907174802680" style="zoom:80%;" /></p><h4 id="开始录制按部就班">4.6.2 开始录制（按部就班）</h4><blockquote><ol type="1"><li>解锁<strong>Camera</strong></li><li>设置音频、视频源</li><li>设置视频的编码格式、输出效果</li><li>设置视频文件的保存位置</li><li>设置<strong>Surface</strong></li><li>让<strong>MediaRecorder</strong>处于prepare状态</li><li>开启<strong>MediaRecorder</strong></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907174909098.png" alt="image-20220907174909098" style="zoom:80%;" /></p><h4 id="结束录制按部就班">4.6.3 结束录制（按部就班）</h4><blockquote><ol type="1"><li>停止<strong>MediaRecorder</strong></li><li>重置<strong>MediaRecorder</strong></li><li>释放<strong>MediaRecorder</strong></li><li>锁定<strong>Camera</strong></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220907174933063.png" alt="image-20220907174933063" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 专业课学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
