<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/30-unicorn.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/30-unicorn.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="操作系统学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2022/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="华风夏韵">
<meta property="og:description" content="操作系统学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220912145316946.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220912145600410.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220912151451846.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220912152133550.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220912154757435.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220915164048443.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220915164955425.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220915171013758.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220915172235110.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220915172456054.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220915172909011.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220915174344904.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220919151453353.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220919153643248.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220919154221402.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220919154534541.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220919154737046.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922162547276.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922163724580.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922163943559.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922164125326.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922165454650.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922170942935.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922171943398.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922173955455.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220922174933864.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220926144126518.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220926150251040.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220926154200710.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220926154322875.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220926154624778.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220926155006512.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220929163127806.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220929163258312.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220929172319297.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220929172953173.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220929174356541.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20220929174647830.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221008164644057.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221008165059638.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221008170551322.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221008172736560.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221008172903009.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221008174950771.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221010144032973.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221010154723335.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221010154729917.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221013162834236.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221013163733736.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221013164324392.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221013165603587.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221013173723379.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221013173753691.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221013174811066.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017143430515.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017143735468.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017143852109.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017144240018.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017145526083.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017145725008.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017145747384.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017150037418.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017145914802.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017145918468.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017153825431.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221017154347587.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221020162923271.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221020163157981.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221020171350881.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221020173141442.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221020173744162.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221020174921849.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221024144014656.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221024144435400.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221024150527509.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221024152844819.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221027164612041.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221027164619528.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221027171738434.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221031142201362.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221027173940774.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221027174338587.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221027174706683.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221027174954828.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221103165404062.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221103165348103.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221103170050338.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221103170213479.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221103171832558.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221103174703952.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107145057689.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107145621005.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107151133964.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107152551989.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107153603565.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107153842238.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107153922149.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107154315836.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221107154449530.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221110165653047.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221110171751275.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221110172013247.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221110172028197.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221110174813937.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221110174824533.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221114144616824.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221114145030851.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221114150016856.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221114150041457.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221114150056267.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221114151401765.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221114152426673.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221114152613665.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117163742987.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117163934518.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117164559398.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117164654643.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117165240437.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117165947940.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117171601893.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117172600963.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117173040646.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117173241390.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117173822733.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117173855252.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117174055187.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117174216889.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117174441628.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221117174612719.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121144118808.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121144326270.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121144532110.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121145047525.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121145916777.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121152152896.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121152437668.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121153123328.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121153531892.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121153744348.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121154658709.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221121154943437.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124162941866.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124163748171.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124164131844.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124164727384.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124165904816.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124170112955.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124170223059.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124170509111.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124170958507.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124172249080.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124172256488.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124172318435.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221124172324503.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128142639363.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128142607160.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128142621439.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128142844807.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128143549825.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128143601069.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128143658452.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128144328745.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128145139548.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128150404451.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128150424447.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128150907676.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128152032875.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128152212443.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128152501463.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128152640303.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128152939195.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128153815218.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128154107099.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221128154413987.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201163509642.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201164212728.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201170031536.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201171543293.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201173253855.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201173542748.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201173547998.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201173554956.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201174152851.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221201174157228.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221205142443883.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221205142954698.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221205145130942.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221205145550355.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221205153235071.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208162949263.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208163000966.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208163009799.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208163356292.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208164020816.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208164717968.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208164843650.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208164916177.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208165305078.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208165345326.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208165553339.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208171015291.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208171021245.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208172500521.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208173053023.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208173658221.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208173713927.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208173728616.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208174042008.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208174329371.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221208174537601.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212142011949.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212143513022.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212143550218.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212143829537.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212144327110.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212144730183.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212144612204.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212145723827.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212145820512.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212145917582.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212150032357.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212151200110.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212151713695.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212151851581.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212152013361.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221212152131318.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215163231777.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215163339003.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215164144034.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215164907603.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215165214104.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215171246096.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215171336215.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215172431386.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215172923567.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221215172935282.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219143646168.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219145527826.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219145531858.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219150412657.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219150441725.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219150541740.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219152543077.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219152910224.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219153237456.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219153555618.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219154814261.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221219153956094.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221222164450979.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221222165445838.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221222171059973.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221222171500654.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221222172044176.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221222172052943.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221226143530861.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221226143547576.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221226144148862.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221226145032534.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221226145852776.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221226151634158.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221226153141627.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221229162906570.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221229163949586.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221229164104537.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221229164309121.png">
<meta property="og:image" content="http://example.com/images/AssetMarkdown/image-20221229164358578.png">
<meta property="article:published_time" content="2022-09-12T06:15:00.000Z">
<meta property="article:modified_time" content="2023-07-13T13:54:56.687Z">
<meta property="article:author" content="华丰夏">
<meta property="article:tag" content="专业课">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/AssetMarkdown/image-20220912145316946.png">

<link rel="canonical" href="http://example.com/2022/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | 华风夏韵</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
      <a target="_blank" rel="noopener" href="https://github.com/unicorn2022" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">华风夏韵</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="华丰夏">
      <meta itemprop="description" content="一切都是上天最好的安排">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华风夏韵">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-12 14:15:00" itemprop="dateCreated datePublished" datetime="2022-09-12T14:15:00+08:00">2022-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-13 21:54:56" itemprop="dateModified" datetime="2023-07-13T21:54:56+08:00">2023-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">专业课学习笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>88k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:20</span>
            </span>
            <div class="post-description">操作系统学习笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <script type="text/javascript"
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<h1 id="chapter-1introduction">Chapter 1：Introduction</h1>
<h2 id="操作系统在做什么">1.1 操作系统在做什么</h2>
<h3 id="操作系统的作用">1.1.1 操作系统的作用</h3>
<p>Operating System的作用：</p>
<ol type="1">
<li>作为用户与计算机硬件交互的中间层</li>
</ol>
<p>Operating System的目标：</p>
<ol type="1">
<li>更加容易的执行/实现用户的程序</li>
<li>更加方便的使用计算机：交互</li>
<li>更有效率的使用硬件</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220912145316946.png" alt="image-20220912145316946" style="zoom:80%;" /></p>
<p>Computer System的结构：</p>
<ol type="1">
<li>硬件<strong>Hardware</strong>：提供基础的计算资源
<ol type="1">
<li>CPU、memory、I/O devices</li>
</ol></li>
<li>操作系统<strong>Operating
System</strong>：控制在不同程序、不同用户间的硬件的使用</li>
<li>应用程序<strong>Application
Programs</strong>：定义如何使用系统资源来解决问题
<ol type="1">
<li>Word processors、compilers、web browsers、database systems、video
games</li>
</ol></li>
<li>用户<strong>Users</strong>：
<ol type="1">
<li>People、machines、other computers</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220912145600410.png" alt="image-20220912145600410" style="zoom:80%;" /></p>
<h3 id="什么是操作系统">1.1.2 什么是操作系统</h3>
<h4 id="计算机系统组成角度操作系统是系统软件">1.1.2.1
计算机系统组成角度：操作系统是系统软件</h4>
<ol type="1">
<li>计算机系统组成：
<ol type="1">
<li>软件：应用软件、系统软件(操作系统等)</li>
<li>硬件：输入/输出(I/O)设备、存储器(内存) 、中央处理器(CPU)</li>
</ol></li>
</ol>
<h4 id="用户角度操作系统是用户与计算机硬件之间接口">1.1.2.2
用户角度：操作系统是用户与计算机硬件之间接口</h4>
<ol type="1">
<li>Computer计算机硬件
<ol type="1">
<li>PC</li>
<li>mainframe, or minicomputer</li>
<li>mobile computers</li>
</ol></li>
<li>操作系统提供的接口有：
<ol type="1">
<li>命令级接口
<ol type="1">
<li>键盘或鼠标等命令。</li>
<li>Mobile user interfaces such as touch screens, voice recognition</li>
</ol></li>
<li>程序级接口
<ol type="1">
<li>它提供一组系统调用System calls
，即操作系统服务，供用户程序和其它程序调用</li>
</ol></li>
</ol></li>
</ol>
<h4 id="系统角度操作系统是计算机系统资源的管理者">1.1.2.3
系统角度：操作系统是计算机系统资源的管理者</h4>
<ol type="1">
<li>OS是资源的分配者
<ol type="1">
<li>管理所有资源</li>
<li>处理冲突的需求，有效而公平</li>
</ol></li>
<li>OS是一个控制程序
<ol type="1">
<li>控制程序的执行，阻止错误、不正确的使用</li>
</ol></li>
</ol>
<h4
id="软件分层扩充机器的角度操作系统是扩充裸机的第一层系统软件">1.1.2.4
软件分层、扩充机器的角度：操作系统是扩充裸机的第一层系统软件</h4>
<p><img src="/images/AssetMarkdown/image-20220912151451846.png" alt="image-20220912151451846" style="zoom:80%;" /></p>
<h4 id="综合考虑">1.1.2.5 综合考虑</h4>
<p><strong>操作系统</strong>是一组：有效控制和管理计算机各种硬件和软件资源，合理的组织计算机的工作流程
，以及方便用户的程序的集合</p>
<ol type="1">
<li><strong>有效（efficient）</strong>：系统效率高，资源利用率高（如：CPU使用率，内存、外部设备是否忙）</li>
<li><strong>合理</strong>：公平，如果不公平则会产生“死锁”或“饥饿”</li>
<li><strong>方便（convenience）</strong>：用户界面，编程接口</li>
</ol>
<h2 id="computer-system-organization">1.2 Computer System
Organization</h2>
<h3 id="总线结构">1.2.1 总线结构</h3>
<p><strong>总线结构</strong>：微型计算机是以总线为纽带来构成计算机系统，中央处理机（CPU）、存储器、
I/O设备（包括外存磁盘、磁带）都挂接在总线</p>
<p><img src="/images/AssetMarkdown/image-20220912152133550.png" alt="image-20220912152133550" style="zoom:80%;" /></p>
<ol type="1">
<li>I/O设备和CPU可以并行运行<strong>execute concurrently</strong></li>
<li>每一个设备控制器控制一个特定的设备</li>
<li>每一个设备控制器均有一个存储单元<strong>local buffer</strong></li>
<li>每一个设备控制器均有一个操作系统的驱动器<strong>device
driver</strong>，让操作系统管理它</li>
<li>CPU在内存<strong>main
memory</strong>和<strong>buffer</strong>之间进行数据的移动</li>
<li>I/O本质上是<strong>device</strong>到<strong>local
buffer</strong>之间的数据交互</li>
<li>设备通过提出中断<strong>interrupt</strong>的方式，告诉CPU它已经完成了操作</li>
</ol>
<h3 id="计算机启动-startup">1.2.2 计算机启动 Startup</h3>
<p><strong>bootstrap program</strong></p>
<ol type="1">
<li>存放在<strong>ROM/EEPROM</strong>中，也被称为<strong>firmware</strong></li>
<li>在电源启动/重启的时候，这个程序被加载到内存中</li>
<li>会初始化操作系统的必须部分</li>
<li>然后将操作系统加载到内存中，开始执行</li>
</ol>
<h3 id="中断">1.2.3 中断</h3>
<p><strong>中断(Interrupt)</strong>：指系统发生某个异步/同步事件后，处理器暂停正在执行的程序，转去执行处理该事件程序的过程</p>
<ol type="1">
<li>硬件中断</li>
<li>软件中断：<strong>陷入(trap)</strong></li>
</ol>
<p>操作系统是中断驱动的<strong>interrupt driven</strong></p>
<p><img src="/images/AssetMarkdown/image-20220912154757435.png" alt="image-20220912154757435" style="zoom:80%;" /></p>
<p><strong>外部中断(interrupt)，异步中断</strong>：</p>
<ol type="1">
<li>外部设备所发出的I/O请求</li>
<li>分为可屏蔽的和不可屏蔽的两类，由一些硬件设备产生，<font color = “blue">可以在指令执行的任意时刻产生</font></li>
</ol>
<p><strong>异常(exception)，内部中断，同步中断</strong>：</p>
<ol type="1">
<li>由正在执行的进程产生，<font color = “blue">一条指令终止执行后才会发出中断</font></li>
<li>常见的异常有除零、溢出及页面异常(<strong>fault出错</strong>)等。另一种情况是使用int指令(<strong>trap陷入</strong>)，Linux使用该指令来实现系统调用。
fault与trap区别</li>
</ol>
<p><strong>中断处理</strong></p>
<ol type="1">
<li>操作系统保存当前CPU状态：存储register、PC(program counter)</li>
<li>判断发生了哪一种中断：
<ol type="1">
<li>Polling：轮询</li>
<li>Vectored interrupt system：向量化中断系统</li>
</ol></li>
<li>单独的代码段决定了每种类型的中断应采取的操作(中断服务程序)</li>
</ol>
<p><strong>Interrupt Time line</strong></p>
<p><img src="/images/AssetMarkdown/image-20220915164048443.png" alt="image-20220915164048443" style="zoom:80%;" /></p>
<h3 id="存储结构">1.2.4 存储结构</h3>
<p><strong>Main Memory(主存)</strong></p>
<ol type="1">
<li>CPU能够直接访问的最大存储空间</li>
</ol>
<p><strong>Secondary Storage(赋存)</strong></p>
<ol type="1">
<li>主存的拓展，提供大量非易失型的存储空间</li>
</ol>
<p><strong>Hard Disk Drives(HDD, 硬盘)</strong>：</p>
<ol type="1">
<li>覆盖有磁记录材料的刚性金属或玻璃盘</li>
<li>磁盘表面按逻辑划分为磁道，磁道又细分为扇区</li>
<li>磁盘控制器确定设备和计算机之间的逻辑交互</li>
</ol>
<p><strong>Caching(高速缓存技术)</strong>：将信息复制到更快的存储系统中</p>
<ol type="1">
<li><strong>Main Memory</strong>可以被视为<strong>Secondary
Storage</strong>的一个缓存(cache)</li>
<li>重要原理：在计算机（硬件、操作系统、软件）的多个级别执行
<ol type="1">
<li>正在使用的信息临时从较慢的存储复制到较快的存储</li>
<li>更快的存储（缓存）首先检查，判断信息是否存在
<ol type="1">
<li>如果是，则直接从缓存中使用信息（fast）</li>
<li>如果不是，则将数据复制到缓存并在其中使用</li>
</ol></li>
<li>缓存小于正在缓存的存储
<ol type="1">
<li>缓存管理是一个重要的设计问题</li>
<li>缓存大小和替换策略</li>
</ol></li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220915164955425.png" alt="image-20220915164955425" style="zoom:80%;" /></p>
<h3 id="io结构">1.2.5 IO结构</h3>
<p><strong>I/O方式</strong>：</p>
<ol type="1">
<li><p>程序I/O (<strong>Programmed I/O</strong>)</p></li>
<li><p>中断 I/O (<strong>Interrupt I/O</strong>)</p>
<ol type="1">
<li>同步I/O：IO开始后，控制权只有当IO结束才会返回给程序</li>
<li>异步I/O：IO开始后，控制权立即返回给程序
<ol type="1">
<li>设备状态表Device-status
table：包含每个I/O设备的条目，指示其类型、地址和状态</li>
<li>操作系统索引到I/O设备表中，以确定设备状态并修改表条目以包括中断</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220915171013758.png" alt="image-20220915171013758" style="zoom:80%;" /></p></li>
<li><p><strong>DMA</strong>方式：Direct Memory Access
Structure直接内存访问</p>
<ol type="1">
<li>用于能够以接近内存速度传输信息的<strong>高速I/O设备</strong></li>
<li>设备控制器将数据块从缓冲存储器直接传输到主存储器，无需CPU干预</li>
<li><strong>每个块</strong>只生成一个中断，而不是每个字节一个中断</li>
</ol></li>
<li><p>通道方式</p></li>
</ol>
<h2 id="computer-system-architecture">1.3 Computer System
Architecture</h2>
<h3 id="单处理器系统">1.3.1 单处理器系统</h3>
<ol type="1">
<li>只有一个CPU和一个计算单元</li>
</ol>
<h3 id="多处理器系统">1.3.2 多处理器系统</h3>
<ol type="1">
<li><strong>Multiprocessor
Systems</strong>多处理器系统：也称为并行系统parallel
systems、紧密耦合系统tightly-coupled systems</li>
<li>优点：
<ol type="1">
<li>增加吞吐量</li>
<li>规模经济</li>
<li>提高可靠性——性能下降或容错</li>
</ol></li>
<li>两种类型：
<ol type="1">
<li>非对称多重处理</li>
<li>对称多重处理</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220915172235110.png" alt="image-20220915172235110" style="zoom:80%;" /></p>
<p><strong>Multi-processor（多个芯片） and
multicore（多核）</strong></p>
<ol type="1">
<li>System（系统）包含所有的芯片</li>
<li>Chassis（主板）包含多个独立的处理器</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220915172456054.png" alt="image-20220915172456054" style="zoom:80%;" /></p>
<h3 id="计算机系统组件的定义">1.3.3 计算机系统组件的定义</h3>
<ol type="1">
<li>CPU：执行指令的硬件</li>
<li>Processor处理器：包含一个或多个CPU的物理芯片</li>
<li>Core核：CPU里面最基本的计算单元</li>
<li>Multicore多核：在一块CPU里面有多个计算单元</li>
<li>Multiprocessor多处理器：包含多个处理器</li>
</ol>
<h3 id="clustered-systems集群系统">1.3.4 Clustered Systems集群系统</h3>
<ol type="1">
<li><p>集群系统(<strong>Cluster</strong>)
：是由一组互联的主机（节点）构成统一的计算机资源，通过相应软件协调工作的计算机机群，给人以一台机器的感觉</p></li>
<li><p>通常通过存储区域网络（storage-area
network，<strong>SAN</strong>）共享存储</p></li>
<li><p>提供高可用性（high-availability）服务，可在故障中生存</p>
<ol type="1">
<li><strong>Asymmetric
clustering</strong>（非对称集群）：有一台机器处于热备用模式</li>
<li><strong>Symmetric clustering</strong> （对称集群）：
有多个运行应用程序的节点，相互监视</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220915172909011.png" alt="image-20220915172909011" style="zoom:80%;" /></p></li>
<li><p>一些集群用于高性能计算（<strong>HPC</strong>，high-performance
computing)</p>
<ol type="1">
<li>必须编写应用程序以使用<strong>并行化(parallelization)</strong></li>
</ol></li>
<li><p>一些具有分布式锁管理器（<strong>DLM</strong>分布式锁管理器)
避免冲突操作</p></li>
<li><p>其他形式的集群：并行集群、WAN上的集群</p></li>
<li><p>集群技术正在迅速变化</p>
<ol type="1">
<li>一些集群产品支持集群中的数千个系统，以及相隔数英里的集群节点</li>
<li>Storage-Area Network，<strong>SAN</strong>，存储区域网</li>
</ol></li>
</ol>
<h2 id="operating-system-operations操作系统的执行">1.4 Operating System
Operations操作系统的执行</h2>
<ol type="1">
<li>硬件驱动的中断</li>
<li>软件错误或请求创建exception(异常） 或trap(陷入）
<ol type="1">
<li>除以零，请求操作系统服务</li>
</ol></li>
<li>其他进程问题包括无限循环、进程相互修改或操作系统</li>
</ol>
<h3 id="两种操作模式">1.4.1 两种操作模式：</h3>
<ol type="1">
<li><strong>User mode(用户态)</strong>：执行用户程序时
<ol type="1">
<li>只能访问属于它的存储空间和普通寄存器，只能执行普通指令</li>
<li>用户程序以及操作系统核外服务程序运行在用户态下</li>
<li>使用用户栈</li>
<li><strong>非特权指令</strong>：用户程序中所使用的指令</li>
</ol></li>
<li><strong>Kernel mode(内核态)</strong>：执行操作系统程序时
<ol type="1">
<li>也称为：monitor mode管态、system mode系统态、supervisor mode管态
、privileged mode特权模式</li>
<li>能够访问所有系统资源，可以执行特权指令，可以直接操作和管理硬件设备</li>
<li>操作系统内核程序运行在内核态下</li>
<li>使用内核栈</li>
<li><strong>特权指令</strong>：不允许用户程序中直接使用的指令。例如：I/O指令、设置时钟、设置控制寄存器等指令都是特权指令</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220915174344904.png" alt="image-20220915174344904" style="zoom:80%;" /></p>
<h3 id="timer定时器防止无限循环进程占用资源">1.4.2
Timer(定时器)：防止无限循环/进程占用资源</h3>
<ol type="1">
<li>在特定时间段后设置中断</li>
<li>操作系统递减计数器</li>
<li>当计数器为零时，生成中断</li>
<li>在调度进程之前设置，以重新控制或终止超过分配时间的程序</li>
</ol>
<h2 id="resource-management资源管理">1.5 Resource
Management资源管理</h2>
<ol type="1">
<li>进程管理 Process Management</li>
<li>主存管理 Main Memory Management</li>
<li>文件系统管理 File-System Management</li>
<li>大容量储存管理 Mass-Storage Management</li>
<li>高速缓存管理机制 Caching</li>
<li>I/O系统管理 I/O System Management</li>
</ol>
<h3 id="进程管理">1.5.1 进程管理</h3>
<ol type="1">
<li>进程<strong>Process</strong>：所有处于<strong>执行中</strong>的程序
<ol type="1">
<li>进程是一个最基本的单元</li>
<li>不同进程之间可以共享一些数据，但不会相互依赖</li>
<li>程序是<strong>passive
entity(静态实体)</strong>，进程是<strong>active
entity(活动实体)</strong></li>
</ol></li>
<li>进程需要获得一些资源以完成任务
<ol type="1">
<li>CPU、内存、IO、文件、初始化数据</li>
</ol></li>
<li>进程终止需要回收任何可重用资源</li>
<li>单线程进程(<strong>Single-threaded process</strong>)
<ol type="1">
<li>有一个程序计数器(<strong>PC，program
counter</strong>)，指定要执行的下一条指令的位置</li>
<li>进程按顺序执行指令，一次一个，直到完成</li>
</ol></li>
<li>多线程进程(<strong>Multi-threaded process</strong>)
<ol type="1">
<li>每个线程有一个程序计数器(<strong>PC</strong>)</li>
</ol></li>
<li>通常，系统有许多进程，一些用户，一些操作系统在一个或多个CPU上并发运行
<ol type="1">
<li>通过在进程/线程之间<strong>复用CPU(multiplexing)</strong>实现并发(concurrency)</li>
<li>时间片：多个时钟周期的组合</li>
<li>轮转的调度方法：每一个进程执行一段时间后，暂停当前进程，执行下一个进程</li>
<li>每一次切换时，由于需要将当前进程的相关信息保存下来，所有会造成浪费</li>
</ol></li>
<li><strong>Process Management</strong>的任务：
<ol type="1">
<li>创建和删除用户和系统进程</li>
<li>暂停和恢复进程</li>
<li>提供进程同步机制</li>
<li>提供过程通信机制</li>
<li>提供死锁处理机制</li>
</ol></li>
</ol>
<h3 id="内存管理">1.5.2 内存管理</h3>
<ol type="1">
<li>要执行程序，所有（或部分）<strong>指令</strong>必须在内存中</li>
<li>程序所需的所有（或部分）<strong>数据</strong>必须在内存中</li>
<li>内存管理确定内存中的内容和时间
<ol type="1">
<li>优化CPU利用率和计算机对用户的响应</li>
</ol></li>
<li><strong>Memory Management</strong>的任务：
<ol type="1">
<li>跟踪当前正在使用内存的哪些部分以及由谁使用</li>
<li>决定哪些进程（或其部分）和数据要移入和移出内存</li>
<li>根据需要分配和释放内存空间</li>
</ol></li>
</ol>
<h3 id="文件系统管理">1.5.3 文件系统管理</h3>
<ol type="1">
<li>操作系统提供信息存储的统一逻辑视图
<ol type="1">
<li>将物理属性抽象为逻辑存储单元文件<strong>file</strong></li>
<li>每个介质由设备（如磁盘驱动器、磁带驱动器）控制
<ol type="1">
<li>不同的属性包括访问速度、容量、数据传输速率、访问方法（顺序或随机）</li>
</ol></li>
</ol></li>
<li>文件系统管理
<ol type="1">
<li>文件通常被组织到目录中</li>
<li>大多数系统上的访问控制，以确定谁可以访问什么</li>
</ol></li>
<li><strong>File-system Management</strong>的任务：
<ol type="1">
<li>创建和删除文件和目录</li>
<li>用于操作文件和目录的原语primitives</li>
<li>将文件映射到辅助存储</li>
<li>将文件备份到稳定（非易失性）存储介质上</li>
</ol></li>
</ol>
<h3 id="大容量储存管理">1.5.4 大容量储存管理</h3>
<ol type="1">
<li>通常，磁盘用于存储不适合主内存的数据或必须保存“长”一段时间的数据</li>
<li>适当的管理至关重要</li>
<li>计算机操作的整体速度取决于磁盘子系统及其算法</li>
<li><strong>Mass-Storage Management</strong>的任务
<ol type="1">
<li>安装mounting和拆卸unmounting</li>
<li>空闲空间管理</li>
<li>存储分配</li>
<li>磁盘调度</li>
<li>分区Partition</li>
<li>保护Protection</li>
</ol></li>
<li>有些存储不需要很快
<ol type="1">
<li>三级存储包括光盘、磁带</li>
<li>仍然必须由操作系统或应用程序进行管理</li>
</ol></li>
</ol>
<h3 id="高速缓存机制caching">1.5.5 高速缓存机制Caching</h3>
<ol type="1">
<li><p>重要原理，在计算机（硬件、操作系统、软件）的多个级别执行</p></li>
<li><p>将正在使用的信息临时从较慢的存储复制到较快的存储</p></li>
<li><p>Faster Storage（cache）首先检查，判断信息是否存在</p>
<ol type="1">
<li>如果存在，则直接从缓存中使用信息（fast）</li>
<li>如果不存在，则将数据复制到缓存并在其中使用</li>
</ol></li>
<li><p>缓存小于正在缓存的存储</p>
<ol type="1">
<li>缓存管理是一个重要的设计问题</li>
<li>缓存大小和替换策略</li>
</ol></li>
<li><p>多任务环境必须小心使用最新的值，无论它存储在存储层次结构中的何处</p>
<p><img src="/images/AssetMarkdown/image-20220919151453353.png" alt="image-20220919151453353" style="zoom:80%;" /></p></li>
<li><p>多处理器环境必须在硬件中提供缓存一致性，以便所有CPU在其缓存中都具有最新的值</p></li>
<li><p>分布式环境情况更加复杂</p>
<ol type="1">
<li>一个基准可以有多个副本</li>
<li>第19章涵盖的各种解决方案</li>
</ol></li>
</ol>
<h3 id="io子系统">1.5.6 I/O子系统</h3>
<ol type="1">
<li>操作系统的一个目的是向用户隐藏硬件设备的特性</li>
<li><strong>I/O Subsystem</strong>的任务：
<ol type="1">
<li>I/O的内存管理，包括缓冲（在传输数据时临时存储数据）、缓存（将部分数据存储在更快的存储中以提高性能）、假脱机（一个作业的输出与其他作业的输入重叠）</li>
<li>通用设备驱动程序接口</li>
<li>特定硬件设备的驱动程序</li>
</ol></li>
</ol>
<h2 id="security-and-protection安全和保护">1.6 Security and
Protection安全和保护</h2>
<ol type="1">
<li>保护<strong>Protection</strong>：控制进程或用户
访问操作系统定义的资源 的机制</li>
<li>安全性<strong>Security</strong>：防御系统内部和外部攻击
<ol type="1">
<li>范围广泛，包括拒绝服务(denial-of-service)、蠕虫(worms)、病毒(viruses)、身份盗窃(identity
theft)、服务盗窃(theft of service)</li>
</ol></li>
<li>系统通常首先区分用户，以确定谁可以做什么
<ol type="1">
<li>用户身份(<strong>user IDs、security
IDs</strong>)：包括姓名和相关号码，每个用户一个</li>
<li>user ID与该用户的所有文件、进程关联，以确定访问控制</li>
<li>组标识符(<strong>group
ID</strong>)：允许定义和管理用户集，然后还可以与每个进程、文件关联</li>
<li><strong>权限提升Privilege
escalation</strong>：允许用户更改为具有更多权限的有效ID</li>
</ol></li>
</ol>
<h2 id="virtualization虚拟化">1.7 Virtualization虚拟化</h2>
<ol type="1">
<li>允许操作系统在其他操作系统中运行应用程序</li>
<li><strong>仿真Emulation</strong>：当源CPU类型与目标CPU类型不一样时使用该技术
<ol type="1">
<li>通常是最慢的方法</li>
<li>当计算机语言未编译为本机代码时：<strong>Interpretation翻译</strong></li>
</ol></li>
<li>虚拟化<strong>Virtualization</strong>：为CPU本机编译的OS，运行本机也编译过的guest
OS
<ol type="1">
<li>考虑运行WinXP客户机的VMware，每个客户机都运行本机WinXP主机操作系统上的应用程序</li>
<li><strong>VMM</strong>(虚拟机管理器 virtual machine
Manager)提供虚拟化服务</li>
</ol></li>
<li><strong>VMM</strong>可以本地化运行，在这种情况下，它们也是主机
<ol type="1">
<li>因此，没有通用主机（VMware ESX和Citrix XenServer）</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220919153643248.png" alt="image-20220919153643248" style="zoom:80%;" /></p>
<h2 id="distribute-system分布式系统">1.8 Distribute
System分布式系统</h2>
<ol type="1">
<li>分布式计算
<ol type="1">
<li>独立的、可能异构的、联网在一起的系统的集合</li>
<li>网络(<strong>Network</strong>)是通信路径，TCP/IP最常见
<ol type="1">
<li>局域网（LAN）</li>
<li>广域网（WAN）</li>
<li>城域网（MAN）</li>
<li>个人局域网（PAN）</li>
</ol></li>
</ol></li>
<li>网络操作系统(<strong>Network Operating
System</strong>)：提供跨网络的系统之间的功能
<ol type="1">
<li>通信方案允许系统交换消息</li>
<li>看起来是单一系统</li>
</ol></li>
</ol>
<h2 id="kernel-data-structures内核数据结构">1.9 Kernel Data
Structures内核数据结构</h2>
<ol type="1">
<li><p>Linked List</p>
<p><img src="/images/AssetMarkdown/image-20220919154221402.png" alt="image-20220919154221402" style="zoom:80%;" /></p></li>
<li><p>Binary Search Tree</p>
<p><img src="/images/AssetMarkdown/image-20220919154534541.png" alt="image-20220919154534541" style="zoom:80%;" /></p></li>
<li><p>Hash Map</p>
<p><img src="/images/AssetMarkdown/image-20220919154737046.png" alt="image-20220919154737046" style="zoom:80%;" /></p></li>
</ol>
<h2 id="computing-environments计算环境">1.10 Computing
Environments计算环境</h2>
<h3 id="传统计算-traditional">1.10.1 传统计算 Traditional</h3>
<ol type="1">
<li>独立通用机器</li>
<li>但由于大多数系统与其他系统（即互联网）互连，因此变得模糊</li>
<li>门户<strong>Portals</strong>提供对内部系统的web访问</li>
<li>网络计算机（thin clients）就像Web终端</li>
<li>移动计算机通过无线网络互连</li>
<li>网络无处不在，甚至家庭系统也使用防火墙保护家庭计算机免受互联网攻击</li>
</ol>
<p><strong>Mainfram Systems大型机系统</strong>：</p>
<ol type="1">
<li><p>Batch System：批处理系统</p>
<ol type="1">
<li><p>Multiprogramming：多道程序，多个作业同时保存在主存中，CPU在其中多路复用</p>
<p><img src="/images/AssetMarkdown/image-20220922162547276.png" alt="image-20220922162547276" style="zoom:50%;" /></p></li>
</ol></li>
<li><p>Time-Sharing Systems：分时系统</p>
<ol type="1">
<li><strong>分时</strong>：多个用户分时共享使用同一台计算机
<ol type="1">
<li>也就是说把计算机的系统资源（尤其是CPU时间）进行时间上分割，即将整个工作时间分成一个个的时间片，每个时间片分给一个用户使用</li>
<li>这样将CPU工作时间分别提供给多个用户使用，每个用户依次地轮流且使用一个时间片</li>
</ol></li>
<li><strong>响应时间</strong>：是分时系统的重要指标，它是用户发出终端命令到系统作出响应的时间间隔。
<ol type="1">
<li>系统的响应时间主要是根据用户所能接受的等待时间确定的。</li>
<li>假设分时系统中进程数(用户数)为n，每个进程的运行时间片为q，则系统的最大响应时间为：<span
class="math inline">\(S=(n-1)×q\)</span></li>
<li>响应时间仅计算第一次被运行的时间点</li>
</ol></li>
</ol></li>
<li><p>Desktop Systems：桌面系统</p>
<ol type="1">
<li>个人计算机：专用于单个用户的计算机系统</li>
<li>I/O设备：键盘、鼠标、显示屏、小型打印机</li>
<li>重点：用户的便利性和响应能力</li>
<li>可以采用为大型操作系统开发的技术，通常个人只使用计算机，不需要高级CPU利用率的保护功能</li>
<li>可以运行多种不同类型的操作系统</li>
</ol></li>
</ol>
<h3 id="移动计算-mobile">1.10.2 移动计算 Mobile</h3>
<ol type="1">
<li>手持智能手机、平板电脑等</li>
<li>它们与“传统”笔记本电脑的功能区别是什么？
<ol type="1">
<li>附加功能–更多操作系统功能（GPS、gyroscope陀螺仪)</li>
<li>允许新类型的应用程序，如增强现实</li>
<li>使用IEEE 802.11无线或蜂窝数据网络进行连接</li>
</ol></li>
</ol>
<p><strong>计算应用领域</strong>：</p>
<p><img src="/images/AssetMarkdown/image-20220922163724580.png" alt="image-20220922163724580" style="zoom:80%;" /></p>
<h3 id="客户机client-服务器server计算">1.10.3
客户机Client-服务器Server计算</h3>
<ol type="1">
<li><p>智能PC取代了无人机终端</p></li>
<li><p>现在许多系统都是服务器，响应客户端生成的请求</p>
<ol type="1">
<li>计算服务器系统compute-server
system：为客户端提供请求服务（即数据库）的接口</li>
<li>文件服务器系统file-server
system：为客户端提供存储和检索文件的接口</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220922163943559.png" alt="image-20220922163943559" style="zoom: 80%;" /></p></li>
</ol>
<h3 id="点对点计算-peer-to-peer">1.10.4 点对点计算 Peer-to-Peer</h3>
<ol type="1">
<li><p>分布式系统的另一种模型</p></li>
<li><p>P2P无法区分客户端和服务器</p>
<ol type="1">
<li>相反，所有节点都被视为对等节点</li>
<li>可以分别充当客户端、服务器或两者
<ol type="1">
<li>节点必须加入P2P网络</li>
<li>在网络上向中央查找服务注册其服务，或</li>
</ol></li>
<li>广播服务请求并通过发现协议响应服务请求</li>
</ol></li>
<li><p>示例包括Napster和Gnutella、Voice over
IP（VoIP），如Skype</p></li>
<li><p>Blockchain technology 区块链技术</p>
<p><img src="/images/AssetMarkdown/image-20220922164125326.png" alt="image-20220922164125326" style="zoom:80%;" /></p></li>
</ol>
<h3 id="虚拟化计算-virtualization">1.10.5 虚拟化计算 Virtualization</h3>
<h3 id="云计算-cloud-computing">1.10.6 云计算 Cloud Computing</h3>
<ol type="1">
<li>通过网络将计算、存储甚至应用程序作为服务提供</li>
<li>基于虚拟化的虚拟化逻辑扩展
<ol type="1">
<li>Amazon
EC2拥有数千台服务器、数百万台虚拟机、PB存储空间，可在互联网上使用，根据使用情况付费</li>
</ol></li>
<li>Many types
<ol type="1">
<li>Public cloud(公有云)：任何愿意付费的人都可以通过互联网获得</li>
<li>Private cloud(私有云)：由公司运营供公司自用</li>
<li>Hybrid cloud(混合云)：包括公共云组件和私有云组件</li>
<li>Software as a Service (<strong>SaaS</strong>，软件即服务)
：通过互联网提供的一个或多个应用程序(即文字处理器)</li>
<li>Platform as a Service (<strong>PaaS</strong>，平台即服务)
：软件堆栈可通过Internet(即数据库服务器)供应用程序使用</li>
<li>Infrastructure as a Service (<strong>IaaS</strong>，基础设施即服务)
：通过Internet可用的服务器或存储(即可用于备份的存储)</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220922165454650.png" alt="image-20220922165454650" style="zoom:80%;" /></p>
<h3 id="实时嵌入式系统-real-time-embedded-systems">1.10.7 实时嵌入式系统
Real-Time Embedded Systems</h3>
<ol type="1">
<li>实时嵌入式系统——最流行的计算机形式
<ol type="1">
<li>各种相当大的、特殊用途的、有限用途的操作系统、实时操作系统</li>
<li>使用扩展</li>
</ol></li>
<li>还有许多其他特殊的计算环境
<ol type="1">
<li>有些有操作系统，有些在没有操作系统的情况下执行任务</li>
</ol></li>
<li>实时操作系统具有<strong>明确定义的固定时间限制</strong>，运行顺序与要求的顺序一定相同
<ol type="1">
<li>处理必须在约束内完成</li>
<li>只有在满足约束条件时才能正确操作</li>
</ol></li>
<li><strong>嵌入式系统</strong>：是以应用为中心，以计算机技术为基础，采用<strong>可剪裁软硬件</strong>，适用于对功能、可靠性、成本、体积、功耗等有严格要求的<strong>专用计算机系统</strong>，用于实现对其他设备的控制、监视或管理等功能</li>
<li><strong>嵌入式操作系统</strong>：运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等资源进行统一协调、调度和控制的系统软件</li>
</ol>
<h2 id="总结">1.10 总结</h2>
<p><img src="/images/AssetMarkdown/image-20220922170942935.png" alt="image-20220922170942935" style="zoom:80%;" /></p>
<h1 id="chapter-2operating-system-structures">Chapter
2：Operating-System Structures</h1>
<h2 id="操作系统提供的服务">2.1 操作系统提供的服务</h2>
<p><img src="/images/AssetMarkdown/image-20220922171943398.png" alt="image-20220922171943398" style="zoom:80%;" /></p>
<ol type="1">
<li>用户界面<strong>User Interface</strong>：
<ol type="1">
<li>几乎所有操作系统都有用户界面（UI）</li>
<li>在命令行界面（CLI）、图形用户界面（GUI）和批处理之间有所不同</li>
</ol></li>
<li>程序执行<strong>Program Execution</strong>：
<ol type="1">
<li>系统必须能够将程序加载到内存并运行该程序，正常或异常结束执行（指示错误）</li>
</ol></li>
<li>I/O操作<strong>I/O operations</strong>：
<ol type="1">
<li>正在运行的程序可能需要I/O，这可能涉及文件或I/O设备</li>
</ol></li>
<li>文件系统操作<strong>File-System Manipulation</strong>：
<ol type="1">
<li>程序需要读取和写入文件和目录，创建和删除它们，搜索它们，列出文件信息，权限管理</li>
</ol></li>
<li>通信<strong>Communication</strong>：
<ol type="1">
<li>进程可以在同一台计算机上或在网络上的计算机之间交换信息</li>
<li>通信可以通过共享内存或消息传递（数据包由操作系统移动）</li>
</ol></li>
<li>错误检测<strong>Error Detection</strong>：
<ol type="1">
<li>操作系统需要不断意识到可能的错误</li>
<li>错误可能出现在CPU和内存硬件、I/O设备、用户程序中</li>
<li>对于每种类型的错误，操作系统都应该采取适当的措施来确保正确和一致的计算</li>
<li>调试设施可以大大提高用户和程序员有效使用系统的能力</li>
</ol></li>
<li>资源分配<strong>Resource allocation</strong>：
<ol type="1">
<li>当多个用户或多个作业同时运行时，必须将资源分配给每个用户或作业</li>
<li>许多类型的资源（如CPU周期、主内存和文件存储）可能有特殊的分配代码，其他（如I/O设备）可能有一般的请求和发布代码。</li>
</ol></li>
<li><strong>Accounting</strong>：
<ol type="1">
<li>跟踪哪些用户使用了多少和什么类型的计算机资源</li>
</ol></li>
<li>保护和安全<strong>Protection and Security</strong>：
<ol type="1">
<li>存储在多用户或联网计算机系统中的信息的所有者可能希望控制该信息的使用，并发进程不应相互干扰</li>
<li>保护包括确保控制对系统资源的所有访问</li>
<li>来自外部的系统安全需要用户身份验证，扩展到保护外部I/O设备免受无效访问尝试</li>
<li>如果要保护系统，必须在整个系统中采取预防措施。链条的坚固程度取决于它最薄弱的环节</li>
</ol></li>
</ol>
<h2 id="user-operating-system-interface">2.2 User Operating System
Interface</h2>
<ol type="1">
<li><strong>Operating System Interface</strong>操作系统的接口：
<ol type="1">
<li>User Interface （用户接口）</li>
<li>Program Interface （程序接口，system call）</li>
</ol></li>
<li><strong>User interface</strong>：用户接口，Almost all operating
systems have a user interface (UI)
<ol type="1">
<li><strong>Command-Line Interface
(CLI)</strong>：命令行用户接口，文本界面</li>
<li><strong>Graphics User Interface (GUI)</strong>：图形用户接口</li>
<li><strong>Touch-Screen Interface</strong>：触摸屏接口</li>
<li><strong>Choice of Interface</strong>：语音接口</li>
</ol></li>
</ol>
<h2 id="system-calls">2.3 System Calls</h2>
<ol type="1">
<li><p>系统调用<strong>System
Call</strong>：操作系统提供的服务的编程接口</p>
<ol type="1">
<li>系统调用：进程和操作系统内核之间的编程接口</li>
<li>通常用高级语言（C或C++）编写</li>
<li>通常由程序通过高级应用程序接口(<strong>API</strong>)访问，而不是直接使用系统调用
<ol type="1">
<li>系统调用过于复杂，不适于编程</li>
<li>通过<strong>API</strong>将系统调用封装起来，便于编程</li>
</ol></li>
<li>三种最常见的API：
<ol type="1">
<li>用于Windows的Win32 API</li>
<li>用于基于POSIX的系统的POSIX API（包括几乎所有版本的UNIX、Linux和Mac
OS X）</li>
<li>用于Java虚拟机（JVM）的Java API</li>
</ol></li>
</ol></li>
<li><p>API与系统调用的区别</p>
<ol type="1">
<li><p><strong>应用编程接口(API)</strong>：其实是一组函数定义，这些函数说明了如何获得一个给定的服务</p></li>
<li><p><strong>系统调用</strong>：是通过软中断向内核发出一个明确的请求，每个系统调用对应一个封装例程（wrapper
routine，唯一目的就是发布系统调用），一些API应用了封装例程</p></li>
<li><p><strong>API还包含各种编程接口</strong>，如：C库函数、OpenGL编程接口等</p></li>
<li><p><strong>系统调用的实现是在内核完成的，而用户态的函数是在函数库中实现的</strong></p>
<p><img src="/images/AssetMarkdown/image-20220922173955455.png" alt="image-20220922173955455" style="zoom:80%;" /></p></li>
</ol></li>
<li><p>参数的传递：</p>
<ol type="1">
<li><p>放到register</p></li>
<li><p>放到内存中，用register传递指针</p>
<p><img src="/images/AssetMarkdown/image-20220922174933864.png" alt="image-20220922174933864" style="zoom:50%;" /></p></li>
<li><p>放到栈中，使用时从栈中pop出来</p></li>
</ol></li>
<li><p>系统调用的种类</p>
<ol type="1">
<li>Process control：进程控制
<ol type="1">
<li>创建/终止/结束/中止/加载/执行 进程</li>
<li>获取/设置 进程属性</li>
<li>等待 一段时间/某个事件的发生</li>
<li>分配/释放/出错时转储 内存</li>
<li>用于确定错误的调试器<strong>Debugger</strong>，单步执行</li>
<li>用于管理进程之间共享数据访问的锁<strong>Locks</strong></li>
</ol></li>
<li>File management：文件管理
<ol type="1">
<li>创建/删除/打开/关闭/读/写/重定位 文件</li>
<li>获取/设置 文件属性</li>
</ol></li>
<li>Device management：设备管理
<ol type="1">
<li>访问/释放/读/写/重定位 设备</li>
<li>获取/设置 设备属性</li>
<li>逻辑挂载/逻辑接触挂载 设备</li>
</ol></li>
<li>Information maintenance：信息维护
<ol type="1">
<li>获取/设置 时间/日期/系统数据/进程属性/文件属性/设备属性</li>
</ol></li>
<li>Communications：通信
<ol type="1">
<li>创建/删除 通信联系</li>
<li>如果是<strong>message passing
model</strong>，则需要发送/接受信息</li>
<li>如果是<strong>shared-memory
model</strong>，则需要创建/访问共享空间</li>
<li>传递状态信息</li>
<li>远程连接</li>
</ol></li>
<li>Protection：安全保护
<ol type="1">
<li>对资源/文件的访问权限</li>
<li>用户的权限</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220926144126518.png" alt="image-20220926144126518" style="zoom:80%;" /></p></li>
</ol>
<h2 id="system-services">2.4 System Services</h2>
<p>系统程序<strong>System
programs</strong>为程序开发和执行提供了方便的环境。它们可以分为：</p>
<ol type="1">
<li>文件操作：创建、删除、复制、重命名、打印、转储、列出并通常操作文件和目录</li>
<li>状态信息</li>
<li>文件修改：文本编辑器</li>
<li>编程语言支持：编译器、汇编器、调试器、解释器</li>
<li>程序加载和执行：加载/重新加载</li>
<li>通信：创建进程之间的连接，允许用户对另外一个用户进行传输文件/发送信息/远程控制</li>
<li>后台服务：启动时启动某些程序，打印错误日志，用户文本操作</li>
<li>应用程序</li>
</ol>
<p>大多数用户对操作系统的认知是由系统程序<strong>System
programs</strong>定义的，而不是实际的系统调用<strong>System
calls</strong></p>
<h2 id="linkers-and-loaders">2.5 Linkers and Loaders</h2>
<ol type="1">
<li><p>编译成目标文件的源代码，可加载到任何物理内存位置：可重定位的目标文件<strong>relocatable
object file</strong></p></li>
<li><p>链接器<strong>Linker</strong>将这些<strong>obj</strong>文件，合并为单个二进制可执行文件<strong>executable
file</strong></p>
<ol type="1">
<li>引入了库</li>
</ol></li>
<li><p>程序作为二进制可执行文件加载<strong>load</strong>在辅助存储上</p></li>
<li><p>必须由要执行的加载程序带入内存</p>
<ol type="1">
<li>重新定位<strong>Relocation</strong>将最终地址分配给程序部件，并调整程序中的代码和数据以匹配这些地址</li>
</ol></li>
<li><p>现代操作系统不会将库链接到可执行文件中</p>
<ol type="1">
<li>相反，动态链接库(<strong>DLL</strong>)是根据需要加载的，由所有使用同一版本库的用户共享</li>
<li>在程序运行时，按照需要加载一次</li>
</ol></li>
<li><p>对象，可执行文件具有标准格式，因此操作系统知道如何加载和启动它们</p>
<p><img src="/images/AssetMarkdown/image-20220926150251040.png" alt="image-20220926150251040" style="zoom:80%;" /></p></li>
</ol>
<h2 id="为什么应用程序只运行在特定的操作系统上">2.6
为什么应用程序只运行在特定的操作系统上</h2>
<ol type="1">
<li>在一个系统上编译的应用程序通常不能在其他操作系统上执行</li>
<li>每个操作系统都提供自己独特的系统调用、自己的文件格式等</li>
<li>应用程序可以是多操作系统
<ol type="1">
<li>用解释语言编写，如Python、Ruby和多个操作系统上可用的解释器</li>
<li>以包含包含运行应用程序的VM的语言编写的应用程序（如Java）</li>
<li>使用标准语言（如C），在每个操作系统上分别编译，以便在每个系统上运行</li>
</ol></li>
<li>应用程序二进制接口(<strong>Application Binary
Interface，ABI</strong>)：是API的体系结构等价物
<ol type="1">
<li>定义了二进制代码的不同组件如何在给定的体系结构、CPU等上与给定的操作系统交互</li>
</ol></li>
</ol>
<h2 id="operating-system-design-and-implementation">2.7 Operating-System
Design and Implementation</h2>
<ol type="1">
<li>操作系统的设计和实现不是“可解决的”，但一些方法已经证明是成功的</li>
<li>不同操作系统的内部结构可能有很大差异</li>
<li>从定义目标和规范开始</li>
<li>受硬件选择、系统类型的影响</li>
<li>用户目标和系统目标
<ol type="1">
<li>用户目标：操作系统应便于使用、易于学习、可靠、安全和快速</li>
<li>系统目标：操作系统应易于设计、实施和维护，并且灵活、可靠、无错误和高效</li>
</ol></li>
</ol>
<p>操作系统的设计考虑</p>
<ol type="1">
<li>功能设计：操作系统应具备哪些功能</li>
<li>算法设计：选择和设计满足系统功能的算法和策略，并分析和估算其效能</li>
<li>结构设计：选择合适的操作系统结构</li>
<li>按照系统的功能和特性要求，选择合适的结构，使用相应的结构设计方法将系统逐步地分解、抽象和综合，使操作系统结构清晰、简单、可靠、易读、易修改，而且使用方便，适应性强</li>
</ol>
<p>具体实现</p>
<ol type="1">
<li>变化很大
<ol type="1">
<li>早期操作系统：汇编语言</li>
<li>然后：系统编程语言，如Algol、PL/1</li>
<li>现在：C，C++</li>
</ol></li>
<li>实际上通常是多种语言的混合
<ol type="1">
<li>组件中的最低级别</li>
<li>主体用C表示</li>
<li>用C、C++、脚本语言（如PERL、Python、shell脚本）编写的系统程序</li>
</ol></li>
<li>更高级的语言更容易移植到其他硬件，但速度较慢</li>
<li>仿真可以允许操作系统在非本机硬件上运行</li>
</ol>
<h2 id="operating-system-structure">2.8 Operating-System Structure</h2>
<ol type="1">
<li><p>Simple Structure：简单结构</p>
<ol type="1">
<li>MS-DOS：以最少的空间提供最多的功能</li>
<li>未划分为模块</li>
<li>虽然MS-DOS有一些结构，但其接口和功能级别没有很好地分离</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220926154200710.png" alt="image-20220926154200710" style="zoom:50%;" /></p></li>
<li><p>Layered Approach：层次化结构</p>
<ol type="1">
<li>操作系统被划分为若干层（级别），每一层都构建在较低层之上</li>
<li>底层（第0层）是硬件；最高的（N层）是用户界面</li>
<li>通过模块化，层的选择使得每个层只使用较低层的功能（操作）和服务
<ol type="1">
<li>上一层只能使用下一层的功能</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220926154322875.png" alt="image-20220926154322875" style="zoom:50%;"/></p></li>
<li><p>Monolithic Kernels Structure：单/宏内核结构</p>
<p><img src="/images/AssetMarkdown/image-20220926154624778.png" alt="image-20220926154624778" style="zoom:80%;" /></p>
<ol type="1">
<li>内核的整个代码都打包到一个文件中</li>
<li>每个函数都可以访问内核的所有其他部分</li>
<li>最早和最常见的操作系统体系结构（UNIX）</li>
<li>操作系统的每个组件都包含在内核中</li>
<li>示例：OS/360、VMS和Linux</li>
<li>优点：高效</li>
<li>缺点：很难定位问题，很难修改和维护，内核会变得越来越大</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220926155006512.png" alt="image-20220926155006512" style="zoom:80%;" /></p></li>
<li><p>Microkernel：微内核，只保留必要的程序，在内核模式中运行的程序</p>
<ol type="1">
<li><p>只有最基本的功能由内核实现</p></li>
<li><p>所有其它功能委托给一些独立进程实现，这些进程通过明确定义的通信接口与中心内核通信</p></li>
<li><p>系统的各个部分彼此都很清楚的划分开来，同时也迫使程序员使用“清洁的”程序设计技术</p></li>
<li><p>优点：动态可扩展性、在运行时切换重要组件</p></li>
<li><p>缺点：在各个组件之间支持复杂通信需要额外的CPU时间</p>
<p><img src="/images/AssetMarkdown/image-20220929163127806.png" alt="image-20220929163127806" style="zoom:80%;" /></p></li>
<li><p>现有的系统多使用微内核结构</p>
<p><img src="/images/AssetMarkdown/image-20220929163258312.png" alt="image-20220929163258312" style="zoom:80%;" /></p></li>
</ol></li>
<li><p>Modules：模块</p>
<ol type="1">
<li>大多数现代操作系统实现kernel modules(内核模块）
<ol type="1">
<li>使用面向对象的方法</li>
<li>每个核心组件都是独立的</li>
<li>每个人都通过已知接口与其他人交谈</li>
<li>每个都可以根据需要在内核中加载</li>
</ol></li>
<li>总体而言，与层相似，但更灵活</li>
</ol></li>
<li><p>Hybrid Systems：混合结构</p>
<ol type="1">
<li>大多数现代操作系统实际上不是一个纯模型</li>
<li>Hybrid System结合了多种方法来满足性能、安全性和可用性需求</li>
</ol></li>
<li><p>Virtual Machines：虚拟机</p>
<ol type="1">
<li>虚拟机采用分层方法得出其逻辑结论。它将硬件和操作系统内核视为硬件</li>
<li>虚拟机提供与底层裸硬件相同的接口</li>
<li>操作系统主机会产生一种错觉，认为进程有自己的处理器和（虚拟内存）</li>
<li>为每位host提供一份底层计算机的（虚拟）副本</li>
<li>虚拟机软件：VMWARE、VirtualBox、Microsoft virtual PC</li>
<li>开放堆栈云计算平台</li>
</ol></li>
</ol>
<h1 id="chapter-3processes">Chapter 3：Processes</h1>
<h2 id="进程的概念">3.1 进程的概念</h2>
<h3 id="进程">3.1.1 进程</h3>
<p>进程：一个正在执行的程序，独立的，有权获取资源的</p>
<ol type="1">
<li>计算机的基本工作单位</li>
<li>jobs作业=user programs用户程序=tasks任务=process进程</li>
<li>包含一些资源的指令容器：例如CPU时间（CPU执行指令）、内存、文件、完成其任务的I/O设备</li>
<li>示例：
<ol type="1">
<li>编译进程</li>
<li>字处理进程</li>
<li>调度程序进程(scheduler processes)：sched、swapper</li>
<li>守护进程(daemon process)：ftpd、httpd</li>
</ol></li>
</ol>
<h3 id="内存中的进程">3.1.2 内存中的进程</h3>
<ol type="1">
<li>程序代码，也被称为text section</li>
<li>PC：Program Counter</li>
<li>Register</li>
<li>Data section：全局变量</li>
<li>Stack：临时变量</li>
<li>Heap：动态开辟的内存</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220929172319297.png" alt="image-20220929172319297" style="zoom:80%;" /></p>
<h3 id="进程状态">3.1.3 进程状态</h3>
<ol type="1">
<li><strong>New</strong>(新)：创建进程，在内存中开辟一段空间给进程</li>
<li><strong>Running</strong>(运行、执行)： 进程正在使用CPU</li>
<li><strong>Ready</strong>(就绪)：进程可以使用CPU</li>
<li><strong>Waiting</strong>(等待、blocked阻塞)：进程等待一些事件的发生</li>
<li><strong>Terminated</strong>(终止)：进程停止执行</li>
</ol>
<h3 id="进程状态的切换">3.1.4 进程状态的切换</h3>
<ol type="1">
<li>程序：系统调用</li>
<li>操作系统：调度</li>
<li>外部程序：中断</li>
<li>只有ready状态才能转换到running状态</li>
<li>三个基本状态之间可能转换和转换原因如下：
<ol type="1">
<li>ready→running：当<strong>处理器空闲</strong>时，进程调度程序必将处理机分配给一个处于ready状态的进程
，该进程便由ready状态转换为running状态</li>
<li>running→waiting：处于running状态的进程在运行过程中需要<strong>等待某一事件</strong>发生后（例如因I/O请求等待I/O完成后），才能继续运行，则该进程放弃处理器，从running状态转换为waiting状态</li>
<li>waiting→ready：处于waiting状态的进程，若其<strong>等待的事件已经发生</strong>，于是进程由waiting状态转换为ready状态。</li>
<li>running→ready：处于running状态的进程在其运行过程中，因分给它的<strong>处理器时间片已用完</strong>，而不得不让出（被抢占）处理器，于是进程由running态转换为ready态。</li>
<li>waiting→running，ready→waiting这二种状态转换一般不可能发生</li>
</ol></li>
<li>处于running状态进程：如系统有一个处理器，则在任何一时刻，最多只有一个进程处于运行状态。</li>
<li>处于ready状态进程：一般处于就绪状态的进程按照一定的算法（如先来的进程排在前面，或采用优先权高的进程排在前面）排成一个就绪队列。</li>
<li>处于waiting状态进程：处于等待状态的进程排在等待队列中。由于等待事件原因不同，等待队列也可以按事件分成几个队列。</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220929172953173.png" alt="image-20220929172953173" style="zoom:80%;" /></p>
<p>例：</p>
<p><img src="/images/AssetMarkdown/image-20220929174356541.png" alt="image-20220929174356541" style="zoom:80%;" /></p>
<h3 id="进程与程序的区别">3.1.5 进程与程序的区别</h3>
<ol type="1">
<li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行</li>
<li><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存</li>
<li><strong>进程与程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（即进程状态信息）</li>
<li><strong>进程与程序的对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li>
</ol>
<h3 id="pcb-进程控制块">3.1.6 PCB 进程控制块</h3>
<ol type="1">
<li>每个进程在操作系统内用<strong>进程控制块(Process Control
Block)</strong>来表示，它包含与特定进程相关的许多信息：
<ol type="1">
<li>Process state：进程状态</li>
<li>Program counter：当前进程执行到的位置</li>
<li>CPU registers：CPU中的寄存器</li>
<li>CPU scheduling information：CPU的调度信息</li>
<li>Memory-management information：内存管理信息</li>
<li>Accounting information：统计信息</li>
<li>File management ：文件管理信息</li>
<li>I/O status information：输入/输出状态信息</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20220929174647830.png" alt="image-20220929174647830" style="zoom:80%;" /></p>
<h2 id="process-scheduling-进程调度">3.2 Process Scheduling
进程调度</h2>
<h3 id="scheduling-queue-调度队列">3.2.1 Scheduling Queue 调度队列</h3>
<ol type="1">
<li><strong>Job queue</strong>作业队列：系统中所有进程的集合</li>
<li><strong>Ready
queue</strong>就绪队列：驻留在主存中、就绪并等待执行的所有进程的集合</li>
<li><strong>Device queue</strong>设备队列：等待I/O设备的一组进程</li>
</ol>
<blockquote>
<p>进程会在不同队列之间迁移</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221008164644057.png" alt="image-20221008164644057" style="zoom:80%;" /></p>
<blockquote>
<p>进程调度的表示</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221008165059638.png" alt="image-20221008165059638" style="zoom:80%;" /></p>
<h3 id="schedulers-调度器">3.2.2 Schedulers 调度器</h3>
<ol type="1">
<li><strong>Long-term scheduler / job scheduler</strong>：长程调度 /
作业调度
<ol type="1">
<li>控制ready queue的长度：选择应加入ready queue的进程</li>
<li>调用的频率很低，基本上以秒/分钟为单位</li>
<li>控制多道程序设计<strong>multiprogramming</strong>的程度</li>
<li>大多数现代操作系统没有长期调度程序（如Windows、UNIX、Linux）</li>
</ol></li>
<li><strong>Short-term scheduler / CPU scheduler</strong>：短程调度 /
CPU调度
<ol type="1">
<li>选择ready queue中的哪一个进程能够进入CPU</li>
<li>调用的频率很好高，基本上以毫秒为单位</li>
</ol></li>
<li><strong>Medium-Term Scheduler</strong>：中程调度
<ol type="1">
<li>将一些进程从内存中临时移出，从而减少调度器须要处理进程的数目</li>
<li>这样将进程移出内存的机制叫做<strong>换出(Swapping)</strong></li>
<li>按需调用，可以关闭中程调度</li>
</ol></li>
<li>进程可以被分为：
<ol type="1">
<li>I/O-bound
process：I/O型进程，需要做很多的I/O操作，有很多的CPU中断</li>
<li>CPU-bound process：CPU型进程，需要很多的计算</li>
</ol></li>
</ol>
<h3 id="context-switch-上下文切换">3.2.3 Context Switch 上下文切换</h3>
<ol type="1">
<li>当CPU切换到另一个进程时，系统必须保存旧进程的状态，并通过<strong>上下文切换(Context
Switch)</strong>加载新进程的保存状态</li>
<li>上下文切换时间开销大；系统在切换时没有任何有用的工作</li>
<li>时间取决于硬件支持</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221008170551322.png" alt="image-20221008170551322" style="zoom:80%;" /></p>
<h3 id="移动端的多任务">3.2.4 移动端的多任务</h3>
<ol type="1">
<li>由于屏幕的实际情况，iOS的用户界面限制了
<ol type="1">
<li>单个前台进程：通过用户界面控制</li>
<li>多个后台进程：内存中、正在运行，但不在显示器上，并且有限制</li>
<li>限制包括单个、短任务、接收事件通知、特定的长时间运行任务，如音频播放</li>
</ol></li>
<li>Android运行前台和后台，限制更少
<ol type="1">
<li>后台进程使用服务执行任务</li>
<li>即使后台进程挂起，服务也可以继续运行</li>
<li>服务没有用户界面，占用内存少</li>
</ol></li>
</ol>
<h2 id="operations-on-process-进程的操作">3.3 Operations on Process
进程的操作</h2>
<h3 id="process-creation-进程创建">3.3.1 Process Creation 进程创建</h3>
<ol type="1">
<li><p>父进程创建子进程，子进程又创建其他进程，形成进程树</p></li>
<li><p>通常，通过进程标识符(<strong>process
identifier，pid</strong>)识别和管理进程</p></li>
<li><p>资源共享：</p>
<ol type="1">
<li>父进程和子进程共享所有资源</li>
<li>子进程共享父进程资源的子集</li>
<li>父进程和子进程不共享资源</li>
</ol></li>
<li><p>执行：</p>
<ol type="1">
<li>父进程和子进程同时执行</li>
<li>父进程一直等到子进程结束</li>
</ol></li>
<li><p>地址空间：</p>
<ol type="1">
<li>子进程是父进程的副本</li>
<li>子进程已经加载进了一段程序</li>
</ol></li>
<li><p>例：UNIX</p>
<ol type="1">
<li><strong>fork()</strong>：系统调用，用于创建一个新的进程
<ol type="1">
<li>int pid1 = fork();</li>
<li>父进程使用fork创建子进程时，子进程会生成一份父进程的备份，除了返回值之外，两者完全一样</li>
<li>从系统调用fork中返回时，两个进程除了返回值pid1不同外，具有完全一样的用户级上下文</li>
<li><strong>在子进程中，pid1的值为0</strong></li>
<li><strong>在父进程中， pid1的值为子进程的进程号</strong></li>
</ol></li>
<li><strong>exec()</strong>：系统调用，用于在fork之后调用新程序，替换进程的内存空间</li>
<li><strong>exit()</strong>：系统调用，终止子进程，并给父进程返回参数</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221008172736560.png" alt="image-20221008172736560" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221008172903009.png" alt="image-20221008172903009" style="zoom:80%;" /></p></li>
</ol>
<blockquote>
<p>C语言代码示例：进程的创建过程</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[ ])</span>&#123; </span><br><span class="line">    <span class="type">int</span> pid1 = fork();  <span class="comment">// fork一个子进程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid1 &lt; <span class="number">0</span>)&#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid1==<span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 子进程执行, 因为子进程的fork返回的是0</span></span><br><span class="line">        execlp(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 父进程执行, 因为父进程的fork返回的是子进程的pid</span></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 阻塞父进程, 直到子进程执行完成</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child Complete&quot;</span>);                      </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="process-termination-进程终止">3.3.2 Process Termination
进程终止</h3>
<ol type="1">
<li>引起进程终止的事件
<ol type="1">
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ol></li>
<li>进程执行完最后一条指令后，会询问操作系统如何终止它
<ol type="1">
<li>从子进程向父进程输出数据</li>
<li>操作系统释放该进程的数据</li>
</ol></li>
<li>如果父进程被终止，那么子进程会发生：
<ol type="1">
<li>有些操作系统不会让子进程继续运行</li>
<li>子进程通过<strong>cascading termination</strong>终止运行</li>
<li>子进程被过继到另一个父进程</li>
</ol></li>
<li>移动端操作系统
<ol type="1">
<li>会因为系统资源不够，而终止一些进程</li>
<li>此时要有一个进程的优先级排序，从重要到不重要，排序如下：
<ol type="1">
<li>前端进程</li>
<li>可见进程</li>
<li>服务进程</li>
<li>后台进程</li>
<li>空进程</li>
</ol></li>
<li>Android会优先终止最不重的进程</li>
</ol></li>
</ol>
<h2 id="ipcinterprocess-communication-进程通信">3.4 IPC：Interprocess
Communication 进程通信</h2>
<ol type="1">
<li><p><strong>Independent
Process</strong>：独立进程，不被其它进程的执行影响，也不能影响其它进程的执行</p></li>
<li><p><strong>Cooperating
Process</strong>：合作进程，可以其它进程的执行影响，也可以影响其它进程的执行</p>
<ol type="1">
<li>优点：
<ol type="1">
<li>信息共享</li>
<li>加速计算</li>
<li>模块化</li>
<li>更加便捷</li>
</ol></li>
<li>需要<strong>IPC</strong>：Interprocess Communication，进程通信</li>
</ol></li>
<li><p><strong>IPC</strong>的两种模式</p>
<ol type="1">
<li>共享内存</li>
<li>消息传递</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221008174950771.png" alt="image-20221008174950771" style="zoom:80%;" /></p></li>
<li><p>通信类型：</p>
<ol type="1">
<li>直接通信
<ol type="1">
<li><strong>send(P, message)</strong>：直接发消息给进程P</li>
<li><strong>receive(Q, message)</strong>：直接接收来自进程Q的消息</li>
</ol></li>
<li>间接通信
<ol type="1">
<li><strong>send(A, message)</strong>：发送消息给邮件服务器A</li>
<li><strong>receive(A, message)</strong>：从邮件服务器A接收消息</li>
</ol></li>
</ol></li>
<li><p>常用通信机制：</p>
<ol type="1">
<li>信号(signal)：进程发送信号</li>
<li>共享存储区(shared memory)：不同进程共享一段空间，进行通信</li>
<li>管道(pipe)：进程间通过一种操作将结果传输过去</li>
<li>消息(message)</li>
<li>套接字(socket)</li>
</ol></li>
</ol>
<h3 id="linux进程通信机制">3.4.1 Linux进程通信机制</h3>
<p>Linux实现进程间通信(<strong>IPC</strong> Inter Process
Communication)：</p>
<ol type="1">
<li>System V IPC机制:
<ol type="1">
<li>信号量：保证不同进程得到的信息是一样的</li>
<li>消息队列、</li>
<li>共享内存</li>
</ol></li>
<li>管道（pipe）、命名管道</li>
<li>套接字（socket）</li>
<li>信号( signal )</li>
<li>文件锁(file lock)</li>
<li>POSIX线程：
<ol type="1">
<li>互斥锁(互斥体、互斥量)（mutex）、条件变量(condition variables)</li>
</ol></li>
<li>POSIX：
<ol type="1">
<li>消息队列、信号、共享内存</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221010144032973.png" alt="image-20221010144032973" style="zoom:80%;" /></p>
<h3 id="windows-进程线程通信机制">3.4.2 Windows 进程线程通信机制</h3>
<ol type="1">
<li>基于文件映射的共享存储区</li>
<li>无名管道和命名管道
<ol type="1">
<li>server32pipe.c、client32pipe.c</li>
<li>启动多个client进程进行通信</li>
</ol></li>
<li>邮件槽</li>
<li>套接字</li>
<li>剪帖板(Clipboard)</li>
<li>信号</li>
<li>其他同步机制</li>
</ol>
<h2 id="ipcin-shared-memory-systems">3.5 IPC：in Shared-Memory
Systems</h2>
<ol type="1">
<li>希望通信的进程之间共享的内存区域</li>
<li>通信受用户进程的控制，而不是操作系统的控制</li>
<li>主要问题是：提供允许用户进程在访问共享内存时同步其操作的机制
<ol type="1">
<li>在第6、7章会讨论同步</li>
</ol></li>
<li>协同进程的并发执行需要允许进程相互通信并同步其操作的机制（第6章）。</li>
<li>合作过程的共同范式：Producer-Consumer
Problem(生产者-消费者问题）</li>
<li>生产者进程生成消费者进程使用的信息
<ol type="1">
<li>unbounded-buffer(无限缓冲区)：对缓冲区的大小没有实际限制。</li>
<li>bounded-buffer(有限缓冲区)：假设存在固定的缓冲区大小。</li>
</ol></li>
</ol>
<h3 id="bounded-buffershared-memory-solution">3.5.1
Bounded-Buffer：Shared-Memory Solution</h3>
<ol type="1">
<li><p><strong>Shared data</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;item;</span><br><span class="line"></span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>为了保证进程对共享空间的正确操作，只能使用<strong>BUFFER_SIZE-1</strong>的空间</p>
<ol type="1">
<li>空间是一个循环队列</li>
</ol></li>
<li><p><strong>Producer</strong>：生产者，生成数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">item nextProduced;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    produce an item in nextProduced;</span><br><span class="line">    <span class="comment">// buffer中没有空位, 什么都不做</span></span><br><span class="line">    <span class="keyword">while</span> ((in + <span class="number">1</span>) % BUFFER_SIZE == out);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向buffer中添加一个item</span></span><br><span class="line">    buffer[in] = nextProduced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Consumer</strong>：消费者，使用数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">item nextConsumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// buffer中没有item, 什么都不做</span></span><br><span class="line">    <span class="keyword">while</span> (in == out);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从buffer中拿走一个item</span></span><br><span class="line">    nextConsumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    consume the item in nextConsumed ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ipcin-message-passing-systems">3.6 IPC：in Message-Passing
Systems</h2>
<ol type="1">
<li>进程通信和同步其操作的机制</li>
<li>消息系统：流程之间无需借助共享变量即可进行通信</li>
<li>IPC设施提供两种操作：
<ol type="1">
<li><strong>send(message)</strong></li>
<li><strong>receive(message)</strong></li>
</ol></li>
<li>message的大小是固定的或可变的</li>
<li>如果进程P和Q想要沟通，他们需要：
<ol type="1">
<li>在他们之间建立通信联系</li>
<li>通过发送/接收交换message</li>
</ol></li>
<li>实现的任务：
<ol type="1">
<li>如何建立链接？</li>
<li>一个链接可以与两个以上的进程关联吗？</li>
<li>每对通信进程之间可以有多少个链接？</li>
<li>链路的容量是多少？</li>
<li>链接可以容纳的消息大小是固定的还是可变的？</li>
<li>链路是单向的还是双向的？</li>
</ol></li>
<li>通信链路的实现
<ol type="1">
<li>物理：
<ol type="1">
<li>共享内存</li>
<li>硬件总线</li>
<li>网络</li>
</ol></li>
<li>逻辑：
<ol type="1">
<li>直接或间接</li>
<li>同步或异步</li>
<li>自动或显式缓冲</li>
</ol></li>
</ol></li>
</ol>
<h3 id="direct-communication直接通信">3.6.1 Direct
Communication（直接通信）</h3>
<ol type="1">
<li>进程必须明确命名：
<ol type="1">
<li><strong>send(P, message)</strong>：向进程P发送消息</li>
<li><strong>receive(Q, message)</strong>：从进程Q接收消息</li>
</ol></li>
<li>通信链路的属性
<ol type="1">
<li>自动建立链接</li>
<li>链接只与一对通信进程相关联</li>
<li>每对之间只有一条链路</li>
<li>链接可能是单向的，但通常是双向的</li>
</ol></li>
</ol>
<h3 id="indirect-communication间接通信">3.6.2 Indirect
Communication（间接通信）</h3>
<ol type="1">
<li>message从mailbox（也称为port）定向和接收
<ol type="1">
<li>每个mailbox都有唯一的id</li>
<li>进程只有在共享mailbox时才能通信</li>
</ol></li>
<li>通信链路的属性
<ol type="1">
<li>仅当进程共享common mailbox时才建立链接</li>
<li>链接可能与许多进程关联</li>
<li>每对进程可以共享多个通信链路</li>
<li>链接可以是单向的或双向的</li>
</ol></li>
<li>操作
<ol type="1">
<li>创建新的mailbox(port)</li>
<li>通过mailbox发送和接收message</li>
<li>销毁mailbox</li>
</ol></li>
<li>基本操作：
<ol type="1">
<li><strong>send(A, message)</strong>：将消息发送到邮箱A</li>
<li><strong>receive(A, message)</strong>：从邮箱A接收消息</li>
</ol></li>
</ol>
<h3 id="synchronization同步">3.6.3 Synchronization同步</h3>
<ol type="1">
<li>消息传递可以是阻塞的或非阻塞的</li>
<li>Blocking(阻塞)被认为是同步的
<ol type="1">
<li>Blocking send：发送方被阻止，直到确认消息被收到</li>
<li>Blocking receive：在消息可用之前，接收器被阻止</li>
</ol></li>
<li>Non-blocking(非阻塞)被认为是异步的
<ol type="1">
<li>Non-blocking send：发送方不断发送消息</li>
<li>Non-blocking
receive：接收器不断接收消息，可能是有效消息，也可能是Null消息</li>
</ol></li>
<li>可能的不同组合
<ol type="1">
<li>如果发送和接收都被是Blocking，称为完整性过程<strong>have a
rendezvous</strong></li>
</ol></li>
</ol>
<h3 id="buffering">3.6.4 Buffering</h3>
<ol type="1">
<li>附加到链接的消息队列，以三种方式之一实施
<ol type="1">
<li>零容量
<ol type="1">
<li>链路上没有消息排队</li>
<li>发送方必须等待接收方接收完成后，才能再次发送消息</li>
</ol></li>
<li>容量有限
<ol type="1">
<li>n条消息的有限长度</li>
<li>如果链接已满，发送方必须等待</li>
</ol></li>
<li>无限容量
<ol type="1">
<li>无限长度</li>
<li>发送程序从不等待</li>
</ol></li>
</ol></li>
</ol>
<h3 id="实例">3.6.5 实例</h3>
<ol type="1">
<li>例： 设计一个程序，要求
<ol type="1">
<li>用函数msgget创建消息队列</li>
<li>从键盘输入的字符串添加到消息队列</li>
<li>创建一个进程，使用函数msgrcv读取队列中的消息并在计算机屏幕上输出</li>
</ol></li>
<li>分析 ：
<ol type="1">
<li>程序先调用msgget函数创建、打开消息队列</li>
<li>接着调用msgsnd函数，把输入的字符串添加到消息队列中</li>
<li>子进程调用msgrcv函数，读取消息队列中的消息并打印输出</li>
<li>最后调用msgctl函数，删除系统内核中的消息队列</li>
</ol></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msgfork.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体，定义消息的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msgmbuf</span>&#123;</span><br><span class="line">    <span class="type">long</span> msg_type;		<span class="comment">//消息类型</span></span><br><span class="line">    <span class="type">char</span> msg_text[<span class="number">512</span>]; <span class="comment">//消息内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> qid,len;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msgmbuf</span> msg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用ftok函数，根据当前文件的目录，产生标准的key</span></span><br><span class="line">    <span class="keyword">if</span>((key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;a&#x27;</span>)) == <span class="number">-1</span>) &#123;   </span><br><span class="line">     	<span class="built_in">perror</span>(<span class="string">&quot;产生标准key出错&quot;</span>);</span><br><span class="line">     	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用msgget函数，创建、打开消息队列</span></span><br><span class="line">    <span class="keyword">if</span>((qid = <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;创建消息队列出错&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印输出队列号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建、打开的队列号是：%d\n&quot;</span>,qid);  </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程PID=: %d 发送消息\n&quot;</span>,<span class="built_in">getpid</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;请输入要加入队列的消息：&quot;</span>); </span><br><span class="line">        <span class="comment">// 键盘输入的消息存入变量msg_text</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">fgets</span>((&amp;msg)-&gt;msg_text, <span class="number">512</span>, stdin)) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;没有消息&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.msg_type=<span class="built_in">getpid</span>();</span><br><span class="line">        len=<span class="built_in">strlen</span>(msg.msg_text);</span><br><span class="line">        <span class="comment">// 调用msgsnd函数，添加消息到消息队列</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">msgsnd</span>(qid,&amp;msg,len,<span class="number">0</span>))&lt;<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;添加消息出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程PID=：%d 接收消息\n&quot;</span>,<span class="built_in">getpid</span>())</span><br><span class="line">        <span class="comment">// 调用msgrcv函数，从消息队列读取消息</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">msgrcv</span>(qid,&amp;msg,<span class="number">512</span>,<span class="number">0</span>,<span class="number">0</span>))&lt;<span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;读取消息出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 打印输出消息内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取的消息是：%s\n&quot;</span>,(&amp;msg)-&gt;msg_text); </span><br><span class="line">        <span class="comment">// 调用msgctl函数，删除系统中的消息队列</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">msgctl</span>(qid,IPC_RMID,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;删除消息队列出错&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分成两个独立的程序：msgsnd.c,msgrcv.c。分别编译和运行</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221010154723335.png" alt="image-20221010154723335" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221010154729917.png" alt="image-20221010154729917" style="zoom:80%;" /></p>
<h2 id="ipcexample">3.7 IPC：example</h2>
<h3 id="windows">3.7.1 Windows</h3>
<ol type="1">
<li>通过高级本地过程调用（LPC）功能以消息传递为中心
<ol type="1">
<li>仅在同一系统上的进程之间工作</li>
<li>使用端口（如邮箱）建立和维护通信通道</li>
<li>通信工作如下：
<ol type="1">
<li>客户端打开子系统连接端口对象的句柄</li>
<li>客户端发送连接请求</li>
<li>服务器创建两个专用通信端口，并将其中一个端口的句柄返回客户端</li>
<li>客户端和服务器使用相应的端口句柄发送消息或回调，并侦听回复</li>
</ol></li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221013162834236.png" alt="image-20221013162834236" style="zoom:80%;" /></p>
<h3 id="pipe-管道通信">3.7.2 Pipe 管道通信</h3>
<ol type="1">
<li>充当允许两个进程通信的管道</li>
<li>问题：
<ol type="1">
<li>通信是单向的还是双向的？</li>
<li>在双向通信的情况下，是半双工还是全双工？（在工作时是否有一端读或写？）</li>
<li>沟通过程之间必须存在关系（即父子关系）吗？</li>
<li>管道可以通过网络使用吗？</li>
</ol></li>
<li><strong>Ordinary
pipes</strong>普通管道：无法从创建它的流程外部访问。通常，父进程创建个管道，并使用它与它创建的子进程通信。</li>
<li><strong>Named
pipes</strong>命名管道：可以在没有父子关系的情况下访问。</li>
</ol>
<h4 id="ordinary-pipes">3.7.2.1 Ordinary pipes</h4>
<ol type="1">
<li>普通管道允许以标准 <strong>生产者-消费者</strong> 的形式进行通信
<ol type="1">
<li>生产者写入一端（管道的写入端<strong>write-end</strong>）</li>
<li>消费者从另一端（管道的读取端<strong>read-end</strong>）读取</li>
</ol></li>
<li>因此，普通管道是<strong>单向的</strong></li>
<li>需要沟通流程之间的<strong>父子关系</strong></li>
<li>Windows调用这些匿名管道<strong>anoymous pipes</strong></li>
</ol>
<h4 id="named-pipes">3.7.2.2 Named pipes</h4>
<ol type="1">
<li>命名管道比普通管道更强大</li>
<li>通信是<strong>双向的</strong></li>
<li>沟通过程之间<strong>不需要父子关系</strong></li>
<li>多个进程可以使用命名管道进行通信</li>
<li>在UNIX和Windows系统上提供</li>
</ol>
<h2 id="communication-in-clientserver-systems">3.8 Communication in
Client–Server Systems</h2>
<h3 id="socket-套接字">3.8.1 Socket 套接字</h3>
<ol type="1">
<li><strong>Socket</strong>被定义为通信的端点</li>
<li>IP地址和端口串联：消息包开头包含的数字，用于区分主机上的网络服务</li>
<li><strong>socket</strong>
<strong>161.25.19.8:1625</strong>指：主机<strong>161.25.119.8</strong>上的端口<strong>1625</strong></li>
<li>通信由一对<strong>socket</strong>组成</li>
<li><strong>1024</strong>以下的所有端口都是众所周知的，用于标准服务</li>
<li>特殊IP地址<strong>127.0.0.1</strong>（loopback），用于指运行进程的系统</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221013163733736.png" alt="image-20221013163733736" style="zoom:67%;" /></p>
<h3 id="remote-procedure-calls-远过程调用">3.8.2 Remote Procedure Calls
远过程调用</h3>
<ol type="1">
<li><strong>Remote Procedure
Calls</strong>(<strong>RPC</strong>，远过程调用)：抽象网络系统上进程之间的过程调用
<ol type="1">
<li>再次使用端口来区分服务</li>
</ol></li>
<li>存根<strong>stubs</strong>：服务器上实际过程的客户端代理</li>
<li>客户端存根<strong>The client-side
stub</strong>：定位服务器并整理(marshalls)参数</li>
<li>服务器端存根<strong>The server-side
stub</strong>：接收此消息，解压缩编组参数，并在服务器上执行过程</li>
<li>在Windows上，stub代码根据用Microsoft接口定义语言(<strong>MIDL</strong>)编写的规范编译</li>
<li>通过外部数据表示(<strong>XDL</strong>，External Data
Representation)格式处理数据表示，以考虑不同的体系结构
<ol type="1">
<li>大端和小端</li>
</ol></li>
<li>远程通信比本地通信有更多的故障情况
<ol type="1">
<li>消息只能传递确定的一次，而不能最多传递一次</li>
</ol></li>
<li>操作系统通常提供<strong>rendezvous /
matchmaker</strong>服务来连接客户端和服务器</li>
<li>Android RPC的执行过程：</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221013164324392.png" alt="image-20221013164324392" style="zoom:80%;" /></p>
<h1 id="chapter-4threads-concurrency">Chapter 4：Threads &amp;
Concurrency</h1>
<h2 id="overview">4.1 Overview</h2>
<p><img src="/images/AssetMarkdown/image-20221013165603587.png" alt="image-20221013165603587" style="zoom:67%;" /></p>
<p>进程：</p>
<ol type="1">
<li>资源拥有单位：
<ol type="1">
<li>给每个进程分配一虚拟地址空间</li>
<li>保存进程映像</li>
<li>控制一些资源（文件，I/O设备）</li>
<li>有状态、优先级、调度</li>
</ol></li>
<li>调度单位：
<ol type="1">
<li>进程是由一个或多个程序的一次执行</li>
<li>可能会与其他进程交替执行</li>
</ol></li>
</ol>
<h3 id="线程thread的概念">4.1.1 线程Thread的概念</h3>
<ol type="1">
<li><strong>进程</strong>：资源的<strong>拥有单元</strong>称为进程 /
任务</li>
<li><strong>线程</strong>：资源的<strong>调度单位</strong>称为线程 /
轻型进程(light weight process)
<ol type="1">
<li>线程只拥有在运行中必不可省的资源(PC、register、stack)</li>
<li>但它可与同属一个进程的其它线程共享进程拥有的全部资源</li>
</ol></li>
</ol>
<p>线程定义为：进程内一个<strong>执行单元</strong>或一个<strong>可调度实体</strong></p>
<ol type="1">
<li>有执行状态（状态转换）</li>
<li>不运行时保存上下文</li>
<li>有一个执行栈</li>
<li>有一些局部变量的静态存储</li>
<li>可存取所在进程的内存和其他资源</li>
<li>可以创建、撤消另一个线程</li>
</ol>
<h3 id="线程的特点">4.1.2 线程的特点</h3>
<ol type="1">
<li>不拥有<strong>系统资源</strong>（只拥有少量的资源，资源是分配给进程）</li>
<li>一个进程中的多个线程可并发执行（进程可创建线程执行同一程序的不同部分）</li>
<li>系统开销小、切换快。（进程的多个线程都在进程的地址空间活动）</li>
</ol>
<h3 id="线程的优点">4.1.3 线程的优点</h3>
<ol type="1">
<li><strong>创建一个新线程</strong>花费时间少（结束亦如此）</li>
<li><strong>两个线程的切换</strong>花费时间少
<ol type="1">
<li>如果机器设有 “存储[恢复]所有寄存器”
指令，则整个切换过程用几条指令即可完成</li>
</ol></li>
<li>因为同一进程内的<strong>线程共享内存和文件</strong>，因此它们之间相互通信无须调用内核</li>
<li>适合<strong>多处理机</strong>系统</li>
</ol>
<h3 id="线程的使用案例">4.1.4 线程的使用案例</h3>
<ol type="1">
<li>LAN中的一个文件服务器，在一段时间内需要处理几个文件请求
<ol type="1">
<li>有效的方法是：为每一个请求创建一个线程</li>
<li>在一个SMP机器上：多个线程可以同时在不同的处理器上运行</li>
</ol></li>
<li>一个线程显示菜单，并读入用户输入；另一个线程执行用户命令
<ol type="1">
<li>考虑一个应用：由几个独立部分组成，这几个部分不需要顺序执行，则每个部分可以以线程方式实现</li>
<li>当一个线程因I/O阻塞时，可以切换到同一应用的另一个线程</li>
</ol></li>
</ol>
<h2 id="多核编程">4.2 多核编程</h2>
<ol type="1">
<li><p>多核系统给程序员带来新的挑战：</p>
<ol type="1">
<li>划分活动</li>
<li>负载均衡：保证任务的计算量尽量均衡</li>
<li>数据拆分</li>
<li>数据依赖性</li>
<li>测试和调试</li>
</ol></li>
<li><p>多线程服务端结构</p>
<ol type="1">
<li>服务端、客户端各自是一个进程</li>
<li>当有请求时，服务端创建一个线程，处理请求</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221013173723379.png" alt="image-20221013173723379" style="zoom:67%;" /></p></li>
<li><p>多核系统的并行执行：</p>
<p><img src="/images/AssetMarkdown/image-20221013173753691.png" alt="image-20221013173753691" style="zoom:67%;" /></p></li>
</ol>
<h2 id="multithreading-models">4.3 Multithreading Models</h2>
<p>线程的实现机制：</p>
<ol type="1">
<li>用户级线程 user-level thread</li>
<li>内核级线程 kernel-level thread</li>
<li>两者结合方法</li>
</ol>
<h3 id="user-threads-用户级线程">4.3.1 User Threads 用户级线程</h3>
<ol type="1">
<li>用户级线程：
<ol type="1">
<li>不依赖于OS核心（内核不了解用户线程的存在）</li>
<li>应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程</li>
<li>如：数据库系统informix、图形处理Aldus PageMaker</li>
<li><strong>调度</strong>由<strong>应用软件</strong>内部进行，通常采用非抢先式和更简单的规则，也无需用户态/核心态切换，所以速度特别快</li>
<li>一个线程发起系统调用而阻塞，则整个进程在等待。</li>
</ol></li>
<li>特点：
<ol type="1">
<li>用户线程的维护由应用进程完成</li>
<li>内核不了解用户线程的存在</li>
<li>用户线程切换不需要内核特权</li>
<li>用户线程调度算法可针对应用优化</li>
<li>一个线程发起系统调用而阻塞，则整个进程在等待（多对一模型中）</li>
</ol></li>
<li>三个主要的线程库(创建用户级线程)
<ol type="1">
<li>POSIX Pthreads 、 Win32 threads、 Java threads</li>
</ol></li>
</ol>
<h3 id="kernel-threads-内核级线程">4.3.2 Kernel Threads 内核级线程</h3>
<ol type="1">
<li>内核级线程：
<ol type="1">
<li>依赖于OS内核，由内核的内部需求进行创建和撤销，用来执行一个指定的函数</li>
<li>一个线程发起系统调用而阻塞，不会影响其他线程</li>
<li>时间片分配给线程，所以多线程的进程获得更多CPU时间</li>
</ol></li>
<li>特点：
<ol type="1">
<li>内核维护进程和线程的上下文信息</li>
<li><strong>线程切换由内核完成</strong></li>
<li>时间片分配给线程，所以多线程的进程获得更多CPU时间
<ol type="1">
<li>如1个进程拥有10个线程，4个进程各自拥有1个线程，则CPU会对这14个线程进行分配资源</li>
</ol></li>
<li>一个线程发起系统调用而阻塞，不会影响其他线程的运行</li>
</ol></li>
<li>Examples
<ol type="1">
<li>Windows XP/2000 及以后</li>
<li>Solaris</li>
<li>Linux</li>
<li>Mac OS X</li>
</ol></li>
</ol>
<h3 id="many-to-one-多个用户线程-一个内核线程">4.3.3 Many-to-One
多个用户线程, 一个内核线程</h3>
<p>多个用户级线程 映射到 单个内核线程</p>
<ol type="1">
<li><p>由用户级运行库实现</p>
<ol type="1">
<li>在用户级别创建、调度和同步线程</li>
</ol></li>
<li><p>操作系统不知道用户级线程</p>
<ol type="1">
<li>操作系统认为<strong>每个进程</strong>只包含<strong>一个控制线程</strong></li>
</ol></li>
<li><p>示例：</p>
<ol type="1">
<li>Solaris Green Threads</li>
<li>GNU Portable Threads</li>
</ol></li>
<li><p>优点：</p>
<ol type="1">
<li>不需要操作系统支持，全部在用户态模式进行</li>
<li>可以由用户自己设定调整调度策略，以满足应用程序需求</li>
<li>由于没有系统调用，因此降低了线程操作的开销</li>
</ol></li>
<li><p>缺点：</p>
<ol type="1">
<li>无法利用多处理器，不是没有真正并行，而是在多个用户级线程之间进行轮转</li>
<li>当一个线程阻塞时，整个进程块也会阻塞</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221013174811066.png" alt="image-20221013174811066" style="zoom:50%;" /></p>
<h3 id="one-to-one-一个用户线程-一个内核线程">4.3.4 One-to-One
一个用户线程, 一个内核线程</h3>
<p>每个用户级线程 都映射到 内核线程</p>
<ol type="1">
<li>操作系统为每个用户级线程提供一个内核线程</li>
<li>每个内核线程独立调度</li>
<li>操作系统执行的线程操作（创建、调度、同步）</li>
<li>示例
<ol type="1">
<li>Windows NT/XP/2000操作系统</li>
<li>Linux操作系统</li>
<li>Solaris 9及更高版本</li>
</ol></li>
<li>优点：
<ol type="1">
<li>每个内核线程在多处理器中，均可平行执行</li>
<li>当一个线程阻塞时，其它线程还能被正常调度</li>
</ol></li>
<li>缺点：
<ol type="1">
<li>线程间的操作消耗过大</li>
<li>操作系统会随着线程数目的增加而变大</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221017143430515.png" alt="image-20221017143430515" style="zoom: 50%;" /></p>
<h3 id="many-to-many-多个用户线程-多个内核线程">4.3.5 Many-to-Many
多个用户线程, 多个内核线程</h3>
<p>将多个用户级线程 映射到 多个内核线程</p>
<ol type="1">
<li>允许操作系统创建足够数量的内核线程</li>
<li>示例：
<ol type="1">
<li>Solaris版本9之前的版本</li>
<li>带有ThreadFiber软件包的Windows NT/2000</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221017143735468.png" alt="image-20221017143735468" style="zoom:50%;" /></p>
<h3 id="two-level-model-两级模型">4.3.6 Two-level Model 两级模型</h3>
<p><img src="/images/AssetMarkdown/image-20221017143852109.png" alt="image-20221017143852109" style="zoom:80%;" /></p>
<ol type="1">
<li><strong>Solaris</strong>的多线程是与传统UNIX调度模型相区别的主要特征</li>
<li><strong>LWP</strong>：每个进程内的内核线程的虚拟执行环境
<ol type="1">
<li><strong>LWP</strong>允许进程内的内核线程互相独立地进行系统调用</li>
<li>如果没有<strong>LWP</strong>，一次就只能进行一次系统调用</li>
<li>每次的系统调用由一个线程来引发，它的寄存器会被放在<strong>LWP</strong>的堆栈里面，等它返回的时候，系统调用返回代码也会被放在<strong>LWP</strong>里面</li>
</ol></li>
<li><strong>M-N</strong>的<strong>优点</strong>：
<ol type="1">
<li>快速的用户线程创建和删除</li>
<li>线程同步不需要系统调用</li>
<li>快速的用户线程上下文切换</li>
</ol></li>
<li><strong>M-N</strong>的<strong>缺点</strong>：
<ol type="1">
<li>复杂的编程模型</li>
<li>信号处理的问题</li>
</ol></li>
<li><strong>1-1</strong>模型的<strong>优点</strong>：
<ol type="1">
<li>每个用户级线程都有一个lwp和一个 kthread 相对应</li>
<li>只有内核级的线程调度</li>
<li>线程创建和删除、线程同步的开销大</li>
<li>线程调度和同步更到位</li>
</ol></li>
</ol>
<h3 id="solaris用户线程内核线程lwp三者之间的关系">4.3.7
Solaris用户线程、内核线程、LWP三者之间的关系</h3>
<p><img src="/images/AssetMarkdown/image-20221017144240018.png" alt="image-20221017144240018" style="zoom:80%;" /></p>
<ol type="1">
<li>对于一个用户进程来说，它的每个线程分成两个部分，一个部分是用户态下的部分，一个是系统态下的部分，也就是用户线程和内核线程</li>
<li>一个线程在用户态下执行的时候，运行的是用户线程的代码，而当发生系统调用的时候，就由内核线程来执行内核代码</li>
<li>在<strong>Solaris</strong>的线程模型中，<strong>每一个用户线程对应一个内核线程</strong>，这种对应通过<strong>lwp</strong>来体现。</li>
<li>所用的内核线程串成一个双向循环链表，可以通过进程的<strong>proc</strong>结构中的<strong>p_tlist</strong>字段找到这个链表</li>
<li>每一个<strong>lwp</strong>用<strong>_
klwp</strong>数据结构表示，每个内核线程用一个<strong>_
kthread</strong>结构表示，<strong>_
kthread</strong>结构中有一个字段<strong>t_lwp</strong>指向它所对应的**_klwp**结构。</li>
<li>用户线程用<strong>ulwp</strong>表示，<strong>ulwp</strong>与**_kthread<strong>的对应不是用指针来表示的，而是通过</strong>线程id**
<ol type="1">
<li><strong>ulwp</strong>，**_kthread<strong>和</strong>_klwp<strong>中都有一个字段表示</strong>线程的id<strong>，通过</strong>id**它们就可以一一对应起来</li>
</ol></li>
</ol>
<h2 id="thread-libraries-线程库">4.4 Thread Libraries 线程库</h2>
<ol type="1">
<li>线程库为程序员提供了创建和管理线程的API</li>
<li>实施的两种主要方式
<ol type="1">
<li><strong>没有内核支持的库</strong>：代码和数据结构都在用户空间，只导致用户空间中本地函数调用（而不是系统调用）</li>
<li><strong>由操作系统直接支持的内核级库</strong>：代码和数据结构都在内核空间，通常导致系统调用</li>
</ol></li>
</ol>
<h3 id="pthread">4.4.1 Pthread</h3>
<ol type="1">
<li><p>可以作为用户级或内核级提供</p></li>
<li><p>用于线程创建和同步的<strong>POSIX</strong>(Portable Operating
System Interface，便携式操作系统接口)标准（IEEE 1003.1c）API</p>
<p>http://standards.ieee.org/reading/ieee/stad_public/description/posix</p></li>
<li><p>API指定线程库的行为，实现取决于库的开发</p></li>
<li><p>在UNIX操作系统（Solaris、Linux、Mac OS X）中常见</p></li>
</ol>
<h3 id="java-threads">4.4.2 Java Threads</h3>
<ol type="1">
<li><strong>Java</strong>线程由<strong>JVM</strong>管理</li>
<li>通常使用底层OS提供的线程模型实现</li>
<li><strong>Java线程</strong>可以通过以下方式创建：
<ol type="1">
<li><strong>extend</strong> 线程类</li>
<li>实现<strong>Runnable</strong>接口</li>
</ol></li>
</ol>
<h2 id="implicit-threading-隐私多线程">4.5 Implicit Threading
隐私多线程</h2>
<ol type="1">
<li>多核系统多线程编程，一个应用程序有可能有几百个甚至上千的线程，这样的程序面临许多挑战
<ol type="1">
<li>编程挑战：任务分解、任务的工作量平衡、数据分割、数据依赖、测试与调试</li>
<li>程序执行顺序的正确性问题：同步、互斥</li>
</ol></li>
<li><strong>策略</strong>：隐私线程<strong>Implicit
Threading</strong>，当前一种流行趋势
<ol type="1">
<li>将线程的创建与管理交给编译器和运行时库来完成</li>
</ol></li>
<li>几种隐私线程的设计方法：
<ol type="1">
<li><strong>Thread Pools</strong>：线程池</li>
<li><strong>Fork Join</strong></li>
<li><strong>OpenMP</strong>：用于共享内存并行系统的多处理器程序设计的一套指导性编译处理方案
<ol type="1">
<li>OpenMP支持的编程语言包括C、C++和Fortran。</li>
</ol></li>
<li><strong>Grand Central Dispatch</strong>(GCD，大中央调度)
<ol type="1">
<li>Apple for its macOS and iOS operating systems.</li>
</ol></li>
<li><strong>Intel Thread Building Blocks</strong>(TBB)：
<ol type="1">
<li>Intel开发的构建多线程库，open source</li>
<li>TBB是一个可移植的C++库，能够运行在Windows、Linux、Macintosh以及UNIX等系统上</li>
</ol></li>
<li>Java</li>
</ol></li>
</ol>
<h3 id="thread-pool-线程池">4.5.1 Thread Pool 线程池</h3>
<ol type="1">
<li>预先创建出一系列线程，然后分配</li>
<li>线程池中如果没有空余线程，则需要等待</li>
</ol>
<h3 id="fork-join-parallelism">4.5.2 Fork-Join Parallelism</h3>
<p><img src="/images/AssetMarkdown/image-20221017145526083.png" alt="image-20221017145526083" style="zoom:80%;" /></p>
<ol type="1">
<li><p>主线程将任务分为多个子任务<strong>fork</strong>，然后再合并到主线程<strong>join</strong></p></li>
<li><p>伪代码</p>
<p><img src="/images/AssetMarkdown/image-20221017145725008.png" alt="image-20221017145725008" style="zoom:67%;" /></p></li>
<li><p>这一过程可以递归的进行</p>
<p><img src="/images/AssetMarkdown/image-20221017145747384.png" alt="image-20221017145747384" style="zoom: 67%;" /></p></li>
<li><p>示例：</p>
<blockquote>
<ol type="1">
<li>The <strong>ForkJoinTask</strong> is an abstract base class</li>
<li><strong>RecursiveTask</strong> and <strong>RecursiveAction</strong>
classes extend <strong>ForkJoinTask</strong></li>
<li><strong>RecursiveTask</strong> returns a result (via the return
value from the <strong>compute()</strong> method)</li>
<li><strong>RecursiveAction</strong> does not return a result</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221017150037418.png" alt="image-20221017150037418" style="zoom: 67%;" /></p>
</blockquote>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221017145914802.png" alt="image-20221017145914802" style="zoom: 40%;" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221017145918468.png" alt="image-20221017145918468" style="zoom: 80%;" /></td>
</tr>
</tbody>
</table></li>
</ol>
<h3 id="openmp">4.5.3 OpenMP</h3>
<ol type="1">
<li><p>编译器指令集和C、C++、FORTRAN的API</p></li>
<li><p>为共享内存环境中的并行编程提供支持</p></li>
<li><p>标识并行区域–可以并行运行的代码块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/* 串行代码 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">//创建尽可能多的线程</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am a parallel region.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 串行代码 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="grand-central-dispatch">4.5.4 Grand Central Dispatch</h3>
<ol type="1">
<li><p>用于macOS和iOS操作系统的Apple技术</p></li>
<li><p>C、C++和Objective-C语言、API和运行时库的扩展</p></li>
<li><p>允许识别平行部分</p></li>
<li><p>管理线程的大部分细节</p></li>
<li><p>块位于“^{}”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123;<span class="built_in">printf</span>(<span class="string">&quot;I am a block&quot;</span>);&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Block放置在调度队列中</p>
<ol type="1">
<li>从队列中移除时，分配给线程池中的可用线程</li>
</ol></li>
<li><p>两种类型的调度队列：</p>
<ol type="1">
<li>串行：按<strong>FIFO</strong>的顺序删除块，队列按进程，称为主队列
<ol type="1">
<li>程序员可以在程序中创建额外的串行队列</li>
</ol></li>
<li>并行：按<strong>FIFO</strong>的顺序删除块，但一次可以删除多个</li>
<li>按服务质量划分的四个全系统队列：
<ol type="1">
<li>QOS_CLASS_USER_INTERACTIVE</li>
<li>QOS_CLASS_USER_INITIATED</li>
<li>QOS_CLASS_USER_UTILITY</li>
<li>QOS_CLASS_USER_BACKGROUND</li>
</ol></li>
</ol></li>
<li><p>对于Swift语言，任务定义为闭包，类似于块，减去插入符号</p>
<ol type="1">
<li>使用dispatch_async()函数将闭包提交到队列</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> dispatch.get.global.queue(<span class="type">QOS</span>.<span class="type">CLASS</span>.<span class="type">USER</span><span class="operator">/</span><span class="type">INITIATED</span>, <span class="number">0</span>)</span><br><span class="line">dispatch.async(queue, &#123;<span class="built_in">print</span>(<span class="string">&quot;I am a closure.&quot;</span>)&#125; )</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="intel-threading-building-blocks-tbb">4.5.5 Intel Threading
Building Blocks (TBB)</h3>
<ol type="1">
<li><p>用于设计并行C++程序的模板库</p></li>
<li><p>简单for循环的串行版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">apply</span>(v[i]);</span><br></pre></td></tr></table></figure></li>
<li><p>使用TBB的<strong>parallel_for</strong>语句编写的for循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), n, [=](<span class="type">size_t</span> i)&#123; <span class="built_in">apply</span>(v[i]); &#125; );</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="threading-issues">4.6 Threading Issues</h2>
<ol type="1">
<li>fork()和exec()系统调用的语义</li>
<li>目标线程的线程删除
<ol type="1">
<li>异步或延迟</li>
</ol></li>
<li>信号处理</li>
<li>线程池
<ol type="1">
<li>线程特定数据</li>
</ol></li>
<li>调度器激活</li>
</ol>
<h3 id="fork和exec的语义">4.6.1 fork()和exec()的语义</h3>
<ol type="1">
<li>fork()：有的Unix系统有两种形式的fork()，与应用程序有关
<ol type="1">
<li>复制所有线程：如果调用fork()后不调用exec()，复制所有线程</li>
<li>只复制调用fork()的线程：如果调用fork()后立即调用exec()，操作系统只需复制调用fork()的线程</li>
</ol></li>
<li>exec()：如果一个线程调用exec()，exec()参数指定的程序会替换整个进程（包括所有线程）</li>
</ol>
<h3 id="thread的删除">4.6.2 Thread的删除</h3>
<ol type="1">
<li><strong>线程取消</strong>(thread
cancellation)：在线程完成之前终止线程的任务，要取消的线程称为<strong>目标线程</strong></li>
<li>线程取消的两种情况：
<ol type="1">
<li><strong>异步取消</strong>(asynchronous
cancellation)：由一个线程<strong>立即终止</strong>目标线程。
<ol type="1">
<li>对于异步取消，因为如果在已经给目标线程分配资源或目标线程正在更新与其他线程共享的数据的情况下，操作系统从回收系统资源时不能将所有资源全部回收。</li>
</ol></li>
<li><strong>延迟取消</strong>(deferred
cancellation)：目标线程<strong>周期性</strong>地检查其是否应该终止，允许目标线程以有序方式终止自己</li>
</ol></li>
</ol>
<h3 id="signal-handling-信号处理">4.6.3 Signal Handling 信号处理</h3>
<ol type="1">
<li>UNIX系统中使用信号通知进程发生了特定事件</li>
<li>信号处理器用于处理信号
<ol type="1">
<li>信号由特定事件生成</li>
<li>信号被传递到进程</li>
<li>信号已处理</li>
</ol></li>
<li>Options：
<ol type="1">
<li>将信号传递给信号适用的线程</li>
<li>将信号传递给进程中的每个线程</li>
<li>将信号传递给进程中的某些线程</li>
<li>分配特定线程以接收进程的所有信号</li>
</ol></li>
<li>信号可分为同步和异步：
<ol type="1">
<li><strong>同步信号</strong>：被发送到产生信号的同一进程
<ol type="1">
<li>E.g. 非法访问内存、被0所除</li>
</ol></li>
<li><strong>异步信号</strong>：由运行进程之外的事件产生，通常被发送到另一进程
<ol type="1">
<li>E.g. 使用特殊键、定时器到期</li>
</ol></li>
</ol></li>
</ol>
<h3 id="thread-pool-线程池-1">4.6.4 Thread Pool 线程池</h3>
<ol type="1">
<li>多线程服务器的潜在问题：
<ol type="1">
<li>处理请求前创建线程需要时间，线程完成工作后要被丢弃；</li>
<li>如果允许所有并发请求都用新线程处理，则无法限制系统中并发执行的线程数量，大量消耗系统资源</li>
</ol></li>
<li>在等待工作的池中创建多个线程</li>
<li>优点：
<ol type="1">
<li>使用现有线程服务请求通常比创建新线程稍快</li>
<li>允许将应用程序中的线程数绑定到池的大小</li>
</ol></li>
</ol>
<h3 id="thread-specific-data-线程特有数据">4.6.5 Thread Specific Data
线程特有数据</h3>
<ol type="1">
<li>允许每个线程拥有自己的数据副本</li>
<li>当您无法控制线程创建过程时(即使用线程池时)，此功能非常有用</li>
</ol>
<h3 id="scheduler-activations-调度器激活">4.6.5 Scheduler Activations
调度器激活</h3>
<ol type="1">
<li>M:N和两级模型都需要通信来维护分配给应用程序的适当数量的内核线程
<ol type="1">
<li>轻量级进程(Lightweight process,
<strong>LWP</strong>)：实现多对多模型或二级模型的系统在用户线程和内核线程之间通常设置一种中间数据结构，通常为LWP。</li>
<li>对于用户线程库，LWP表现为一种应用程序可以调度用户线程来运行的虚拟处理器。每个LWP与内核线程相连，该内核线程被操作系统调度到物理处理器上运行。如果物理处理器上运行的内核线程阻塞，则与其相连的LWP也阻塞，关系链顶端与LWP相连的用户线程也阻塞</li>
</ol></li>
<li>调度程序激活提供了向上调用：一种从内核到线程库的通信机制
<ol type="1">
<li>upcall：内核通知应用程序与其有关的特定事件的过程；</li>
<li>upcall
handler：upcall处理句柄，在虚拟处理器(<strong>LWP</strong>)上运行。</li>
</ol></li>
<li>此通信允许应用程序维护正确数量的内核线程</li>
</ol>
<p>调度器激活（scheduler
activation）：一种解决用户线程与内核间通信的方法。</p>
<ol type="1">
<li>工作方式：内核提供一组LWP给应用程序，应用程序可调度用户线程到一个可用的LWP上。</li>
<li>当一个应用线程将要阻塞时，事件引发内核发送<strong>upcall</strong>到应用程序，通知应用程序线程阻塞并标识特殊线程</li>
<li>内核分配一个新的LWP给应用程序</li>
<li>应用程序在该新LWP上运行<strong>upcall handler</strong>：
<ol type="1">
<li>保存该阻塞线程的状态</li>
<li>放弃阻塞线程运行的原虚拟处理器</li>
</ol></li>
<li><strong>upcall
handler</strong>调度另一个适合在新LWP上运行的线程</li>
<li>当原先阻塞的线程准备好执行时，内核发送另一个<strong>upcall</strong>到线程库，通知线程库原先阻塞的线程已经能够运行了
<ol type="1">
<li>内核可能分配一个新的LWP</li>
<li>或抢占一个用户线程并在其LWP用于运行处理该事件的upcall handler</li>
</ol></li>
<li>应用程序将已处于未堵塞状态的线程标记为“能够运行”，调度一条合适的线程到可用LWP上运行</li>
</ol>
<h2 id="operating-system-examples">4.7 Operating-System Examples</h2>
<h3 id="windows-xp-thread">4.7.1 Windows XP Thread</h3>
<p><img src="/images/AssetMarkdown/image-20221017153825431.png" alt="image-20221017153825431" style="zoom:80%;" /></p>
<ol type="1">
<li>应用程序以独立进程方式运行，每个进程可包括一个或多个线程</li>
<li>使用<strong>一对一映射</strong>，也提供对fiber库的支持（多对多模型）</li>
<li>每个线程包含
<ol type="1">
<li>线程id</li>
<li>寄存器集</li>
<li>独立的用户堆栈和内核堆栈</li>
<li>专用数据存储区</li>
</ol></li>
<li>寄存器集、堆栈和专用存储区域称为线程的上下文</li>
<li>同属一个进程的每个线程都能访问进程的地址空间</li>
<li>线程的主要数据结构包括：
<ol type="1">
<li><strong>ETHREAD</strong>(executive thread
block)：执行线程块，包括指向线程所属进程的指针、线程开始控制的子程序的地址、指向KTHREAD的指针</li>
<li><strong>KTHREAD</strong>(kernel thread
block)：内核线程块，包括线程的调度和同步信息、指向内核栈的指针、指向TEB的指针</li>
<li><strong>TEB</strong>(thread environment
block)：用户空间的数据结构，供线程在用户模式下运行时访问，包含许多其他域、用户模式栈、用于线程特定数据的数组</li>
</ol></li>
</ol>
<h3 id="linux-threads">4.7.2 Linux Threads</h3>
<ol type="1">
<li><p>Linux不区分进程和线程，通常称之为任务（task）</p>
<ol type="1">
<li><strong>Task_struct</strong>：Linux系统中每个任务都有一个唯一的内核数据结构struct
task_struct，它并不保存任务本身的数据，而是指向其他存储这些数据的数据结构（e.g.
打开文件列表、信号处理信息、虚拟内存等）的指针</li>
</ol></li>
<li><p>系统调用fork()提供传统进程复制功能，系统调用clone()提供创建线程功能。</p>
<ol type="1">
<li><p>调用fork()时，所创建的新任务具有父进程所有数据的副本</p></li>
<li><p>调用clone()时，所创建新任务根据所传递标志集指向父任务的数据结构。</p></li>
<li><p>调用clone()时传递一组标志，决定父任务与子任务之间发生多少共享</p>
<p><img src="/images/AssetMarkdown/image-20221017154347587.png" alt="image-20221017154347587" style="zoom:80%;" /></p></li>
</ol></li>
</ol>
<h1 id="chapte-5cpu-scheduling">Chapte 5：CPU Scheduling</h1>
<h2 id="基础概念-basic-concepts">5.1 基础概念 Basic Concepts</h2>
<h3 id="cpu调度">5.1.1 CPU调度</h3>
<ol type="1">
<li><p>CPU调度 == 处理器调度 == 进程调度</p></li>
<li><p>最大化CPU的利用率</p></li>
<li><p>进程执行的特点：CPU Burst 和 I/O Burst交替进行</p>
<ol type="1">
<li>CPU Burst Time，I/O Burst Time</li>
<li>CPU-bound program：以CPU计算为主的程序</li>
<li>I/O-bound program：以I/O为主的程序</li>
<li>只考虑进程的CPU Burst Time</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221020162923271.png" alt="image-20221020162923271" style="zoom: 30%;" /></p></li>
<li><p>进程的CPU Burst Time的统计规律</p>
<ol type="1">
<li>短时间的CPU Burst Time占据绝大部分</li>
<li>因此CPU调度是高频调度</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221020163157981.png" alt="image-20221020163157981" style="zoom: 50%;" /></p></li>
</ol>
<h3 id="cpu调度器-scheduler">5.1.2 CPU调度器 Scheduler</h3>
<ol type="1">
<li>调度器起作用的时机：
<ol type="1">
<li>进程从running到waiting状态</li>
<li>进程从running到ready状态</li>
<li>进程从waiting到ready状态</li>
<li>进程终止</li>
</ol></li>
<li>调度方式：
<ol type="1">
<li><strong>Nonpreemptive</strong>非抢占式调度：
<ol type="1">
<li>调度程序一旦把处理器分配给某进程后，它便会一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理器分配给另一个进程</li>
<li>调度时机：上述1、4</li>
</ol></li>
<li><strong>Preemptive</strong>抢占式调度：
<ol type="1">
<li>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程</li>
<li>剥夺原则有：优先权原则、短进程优先原则、时间片原则</li>
<li>调度时机：上述2、3</li>
</ol></li>
</ol></li>
</ol>
<h3 id="调度程序-dispatcher">5.1.3 调度程序 Dispatcher</h3>
<ol type="1">
<li>实际执行调度的模块，任务如下：
<ol type="1">
<li>切换上下文</li>
<li>切换到user mode</li>
<li>跳转到user program中正确的位置，并且重新启动program</li>
</ol></li>
<li><strong>Dispatcher
Latency</strong>调度延迟：调度程序停止一个进程到启动一个进程所需要的时间</li>
</ol>
<h2 id="调度标准-scheduling-criteria">5.2 调度标准 Scheduling
Criteria</h2>
<h3 id="调度算法的选择准则和评价">5.2.1 调度算法的选择准则和评价</h3>
<ol type="1">
<li>面向用户(User-oriented)的准则和评价
<ol type="1">
<li>周转时间<strong>Turnaround
time</strong>：进程从<strong>提交</strong>到<strong>完成</strong>所经历的时间。包括：在CPU上执行，就绪列和阻塞队列中等待。
<ol type="1">
<li>周转时间 <strong>T</strong> = 完成时间 - 提交时间</li>
<li>平均周转时间 = <span class="math inline">\(\sum\)</span>
周转时间/进程数</li>
<li>带权周转时间<strong>W</strong> =
<strong>T</strong>(周转时间)/<strong>t</strong>(CPU执行时间)</li>
<li>平均带权周转时间 = <span class="math inline">\(\sum\)</span>
<strong>W</strong>/进程数</li>
</ol></li>
<li>响应时间<strong>Response
time</strong>：从进程<strong>提出请求</strong>到<strong>首次被响应</strong>的时间段
<ol type="1">
<li>第一次被调度到，而不是输出结果</li>
<li>在分时系统环境下</li>
</ol></li>
<li>等待时间<strong>Waiting
time</strong>：进程在<strong>就绪队列</strong>中<strong>等待</strong>的时间总和</li>
<li>截止时间：开始截止时间和完成截止时间
<ol type="1">
<li>实时系统，与周转时间有些相似</li>
<li>开始截止时间：在某个时间点之前必须开始</li>
<li>完成截止时间：在某个时间点之前必须完成</li>
</ol></li>
<li>公平性：不因作业或进程本身的特性而使上述指标过分恶化
<ol type="1">
<li>如长进程等待很长时间</li>
<li>不同进程之间的上述指标不能差异过大</li>
</ol></li>
<li>优先级：可以使关键任务达到更好的指标</li>
</ol></li>
<li>面向系统的调度性能准则
<ol type="1">
<li>吞吐量<strong>Throughput</strong>：单位时间内所完成的进程数
<ol type="1">
<li>跟进程本身特性和调度算法都有关系</li>
<li>批处理系统</li>
<li>平均周转时间不是吞吐量的倒数，因为并发执行的进程在时间上可以重叠</li>
<li>如：在2小时内完成4个进程，而每个周转时间是1小时，则吞吐量是2个进程/小时</li>
</ol></li>
<li>处理器利用率<strong>CPU utilization</strong>：使CPU尽可能的忙碌</li>
<li>各种设备的均衡利用：
<ol type="1">
<li>如CPU繁忙的进程和I/O繁忙的进程搭配</li>
<li>大中型主机</li>
</ol></li>
</ol></li>
<li>调度算法本身的调度性能准则</li>
<li>易于实现</li>
<li>执行开销比较小</li>
</ol>
<h3 id="最优准则-optimization-criteria">5.2.4 最优准则 Optimization
Criteria</h3>
<ol type="1">
<li>最大的CPU利用率 Max CPU utilization　</li>
<li>最大的吞吐量 Max throughput</li>
<li>最短的周转时间 Min turnaround time</li>
<li>最短的等待时间 Min waiting time</li>
<li>最短的响应时间 Min response time</li>
<li>公平</li>
</ol>
<h2 id="调度算法-scheduling-algorithms-计算">5.3 调度算法 Scheduling
Algorithms (<strong>计算</strong>)</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">算法名</th>
<th style="text-align: center;">注释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>First-Come, First-Served
(FCFS)</strong> Scheduling</td>
<td style="text-align: center;">先来先服务调度</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Shortest-Job-First
(SJF)</strong> Scheduling</td>
<td style="text-align: center;">短作业优先调度</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Priority</strong>
Scheduling</td>
<td style="text-align: center;">优先权调度</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Round Robin</strong> (RR)</td>
<td style="text-align: center;">时间片轮转调度</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Multilevel Queue</strong>
Scheduling</td>
<td style="text-align: center;">多级队列调度</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Multilevel Feedback</strong>
Queue Scheduling</td>
<td style="text-align: center;">多级反馈队列调度</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>高响应比优先调度算法：<strong>Highest Response Ratio
Next(HRRN)</strong>
<ol type="1">
<li>响应比<strong>R</strong> = (等待时间 + 要求执行时间) /
要求执行时间</li>
</ol></li>
</ol>
<h3 id="先来先服务调度-fcfs">5.3.1 先来先服务调度 FCFS</h3>
<h4 id="算法内容">5.3.1.1 算法内容</h4>
<ol type="1">
<li><p><strong>FCFS</strong>算法：First-Come, First-Served
Scheduling</p>
<ol type="1">
<li>按照<strong>进程或作业提交顺序</strong>形成就绪状态的先后次序，分派CPU</li>
<li>当前进程或作业占用CPU，直到执行完或阻塞，才出让CPU(<strong>非抢占方式</strong>)</li>
<li>在进程或作业唤醒后(如I/O完成)，并不立即恢复执行，通常等到当前作业或进程出让CPU</li>
<li>最简单的算法</li>
</ol></li>
<li><p>FCFS的特点</p>
<ol type="1">
<li>比较有利于长进程，而不利于短进程</li>
<li>有利于CPU Bound的进程，而不利于I/O Bound的进程</li>
</ol></li>
</ol>
<h4 id="示例">5.3.1.2 示例</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Burst Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P<sub>1</sub></td>
<td style="text-align: center;">24</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>2</sub></td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P<sub>3</sub></td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p><strong>Gantt
Chart</strong>：根据进程的顺序排列，下标画时间点</p>
<p><img src="/images/AssetMarkdown/image-20221020171350881.png" alt="image-20221020171350881" style="zoom: 67%;" /></p></li>
<li><p><strong>Turnaround Time</strong>：终止时间 - 到达时间</p>
<ol type="1">
<li>P<sub>1</sub> = 24，P<sub>2</sub> = 27，P<sub>3</sub> = 30</li>
<li>Average Turnaround Time = (24 + 27 + 30) / 3 = 27</li>
</ol></li>
<li><p><strong>Waiting Time</strong>：Turnaround Time -
实际运行的时间</p>
<ol type="1">
<li>P<sub>1</sub> = 24 - 24 = 0，P<sub>2</sub> = 27 - 3 =
24，P<sub>3</sub> = 30 - 3 = 27</li>
<li>Average Waiting Time = (0 + 24 + 27) / 3 = 17</li>
</ol></li>
</ol>
<h3 id="短作业优先调度-sjf">5.3.2 短作业优先调度 SJF</h3>
<h4 id="算法内容-1">5.3.2.1 算法内容</h4>
<ol type="1">
<li><p><strong>SJF</strong>算法：Shortest-Job-First (SJF) Scheduling</p>
<ol type="1">
<li>对<strong>预计执行时间</strong>短的作业（进程）优先分派处理器</li>
<li>又称为“短进程优先”<strong>SPF(Shortest Process
First)</strong>，这是对FCFS算法的改进，其目标是减少平均周转时间</li>
</ol></li>
<li><p>两种模式</p>
<ol type="1">
<li>非抢占<strong>nonpreemptive</strong>：一旦CPU被赋予进程，它就不能被抢占，直到完成其CPU
Burst</li>
<li>抢占<strong>preemptive</strong>：如果新进程到达时CPU
Burst长度小于当前执行进程的剩余时间，则抢占
<ol type="1">
<li>该方案被称为最短剩余时间优先（SRTF，Shortest-Remaining-Time-First）</li>
</ol></li>
</ol></li>
<li><p>优点：平均等待时间最小</p></li>
</ol>
<h4 id="最短剩余时间优先-srtf">5.3.2.2 最短剩余时间优先 SRTF</h4>
<ol type="1">
<li><p>最短剩余时间优先<strong>SRTF</strong>(Shortest Remaining Time
First)：基于抢占的<strong>SJF</strong>算法</p></li>
<li><p>允许比当前进程剩余时间更短的进程来抢占</p></li>
</ol>
<h4 id="最高响应比优先-hrrn">5.3.2.3 最高响应比优先 HRRN</h4>
<ol type="1">
<li>最高响应比优先<strong>HRRN</strong>(Highest Response Ratio
Next)</li>
<li>响应比R = (等待时间 + 要求执行时间) / 要求执行时间</li>
<li>是<strong>FCFS</strong>和<strong>SJF</strong>的折中</li>
</ol>
<h4 id="示例-1">5.3.2.4 示例</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Arrival Time</th>
<th style="text-align: center;">Burst Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P<sub>1</sub></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">7</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>2</sub></td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P<sub>3</sub></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>4</sub></td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">4</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><strong>SJF (non-preemptive)</strong>：
<ol type="1">
<li><img src="/images/AssetMarkdown/image-20221020173141442.png" alt="image-20221020173141442" style="zoom:80%;" />
<ol type="1">
<li>第0时刻只有P<sub>1</sub>到来，因此先执行P<sub>1</sub></li>
<li>P<sub>1</sub>结束后为第7时刻，此时的进程有P<sub>2</sub>,
P<sub>3</sub>, P<sub>4</sub>，P<sub>3</sub>的Burst
Time最短，因此执行P<sub>3</sub></li>
</ol></li>
<li><strong>Turnaround Time</strong>
<ol type="1">
<li>P<sub>1</sub> = 7 - 0 = 7，P<sub>2</sub> = 12 - 2 =
10，P<sub>3</sub> = 8 - 4 = 4，P<sub>4</sub> = 16 - 5 = 11</li>
<li>Average Turnaround Time = (7 + 10 + 4 + 11) / 4 = 8</li>
</ol></li>
<li><strong>Waiting Time</strong>
<ol type="1">
<li>P<sub>1</sub> = 0 - 0 = 0，P<sub>2</sub> = 8 - 2 = 6，P<sub>3</sub>
= 7 - 4 = 3，P<sub>4</sub> = 12 - 5 = 7</li>
<li>Average Waiting Time = (0 + 6 + 3 + 7) / 4 = 4</li>
</ol></li>
</ol></li>
<li><strong>SJF (preemptive)</strong>：
<ol type="1">
<li><img src="/images/AssetMarkdown/image-20221020173744162.png" alt="image-20221020173744162" style="zoom:67%;" />
<ol type="1">
<li>第2时刻，P<sub>2</sub>到来，其时间比P<sub>1</sub>剩余时间短，因此打断P<sub>1</sub>，执行P<sub>2</sub></li>
<li>第4时刻，P<sub>3</sub>到来，其时间比P<sub>2</sub>剩余时间短，因此打断P<sub>2</sub>，执行P<sub>3</sub></li>
<li>第5时刻，P<sub>3</sub>结束，此时等待队列如下，因此执行P<sub>2</sub>
<ol type="1">
<li>P<sub>1</sub>：5s</li>
<li>P<sub>2</sub>：2s</li>
</ol></li>
<li>第7时刻，P<sub>2</sub>结束，P<sub>4</sub>到来，此时等待队列如下，因此执行P<sub>4</sub>
<ol type="1">
<li>P<sub>1</sub>：5s</li>
<li>P<sub>4</sub>：4s</li>
</ol></li>
<li>第11时刻，P<sub>4</sub>结束，执行P<sub>1</sub></li>
</ol></li>
<li><strong>Turnaround Time</strong>
<ol type="1">
<li>P<sub>1</sub> = 16 - 0 = 16，P<sub>2</sub> = 7 - 2 =
5，P<sub>3</sub> = 5 - 4 = 1，P<sub>4</sub> = 11 - 5 = 6</li>
<li>Average Turnaround Time = (16 + 5 + 1 + 6) / 4 = 7</li>
</ol></li>
<li><strong>Waiting Time</strong>
<ol type="1">
<li>P<sub>1</sub> = (0 - 0) + (11 - 2) = 9，P<sub>2</sub> = (2 - 2) + (5
- 4) = 1，P<sub>3</sub> = 4 - 4 = 0，P<sub>4</sub> = 7 - 5 = 2</li>
<li>Average Waiting Time = (9 + 1 + 0 + 2) / 4 = 4</li>
</ol></li>
</ol></li>
</ol>
<h4 id="预测cpu-burst-time指数平均法">5.3.3.5 预测CPU Burst
Time：指数平均法</h4>
<ol type="1">
<li><p>只能估计长度</p></li>
<li><p>可以通过使用以前CPU突发的长度，使用指数平均来完成</p>
<ol type="1">
<li><span class="math inline">\(t_n\)</span> = 第n次CPU
burst的真实值</li>
<li><span class="math inline">\(\tau_n\)</span> = 第n次CPU
burst的预测值</li>
<li><span class="math inline">\(\alpha\)</span>，<span
class="math inline">\(0 \le \alpha \le 1\)</span></li>
<li>定义：<span class="math inline">\(\tau_{n+1}=\alpha
t_n+(1-\alpha)\tau_n\)</span></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221020174921849.png" alt="image-20221020174921849" style="zoom:67%;" /></p></li>
<li><p>几种<span class="math inline">\(\alpha\)</span>的取值</p>
<ol type="1">
<li><span class="math inline">\(\alpha=0\)</span>：<span
class="math inline">\(\tau_{n+1} = \tau_{n}\)</span>，只考虑预测值</li>
<li><span class="math inline">\(\alpha=1\)</span>：<span
class="math inline">\(\tau_{n+1} = t_{n}\)</span>，只考虑实际值</li>
</ol></li>
<li><p>展开<span class="math inline">\(\tau_{n+1}\)</span> <span
class="math display">\[
\begin{aligned}
\tau_{n+1}=    &amp;\ \ \ \ \ \ \alpha t_n \\
           &amp;+ (1-\alpha)\ t_{n-1} \\
           &amp;+ \ ...\\
           &amp;+(1-\alpha)^i\ \alpha t_{n-i} \\
           &amp;+ \ ...\\
           &amp;+(1-\alpha)^{n+1} \tau_{0}
\end{aligned}
\]</span></p></li>
</ol>
<h3 id="优先级调度-priority-scheduling">5.3.3 优先级调度 Priority
Scheduling</h3>
<h4 id="算法内容-2">5.3.3.1 算法内容</h4>
<ol type="1">
<li>该算法总是把处理机分配给就绪队列中具有<strong>最高优先权</strong>的进程
<ol type="1">
<li><strong>SJF</strong>是以下一次CPU脉冲长度作为优先数的优先级调度</li>
</ol></li>
<li>常用以下两种方法来确定进程的优先权：
<ol type="1">
<li><strong>静态优先权</strong>：静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型、进程对资源的要求、用户要求的优先权。</li>
<li><strong>动态优先权</strong>：动态优先权是基于某种原则，使进程的优先权随时间改变而改变。</li>
</ol></li>
<li>假定：最小的整数 &lt;=&gt; 最高的优先级.</li>
<li>两种模式
<ol type="1">
<li>非抢占式<strong>Non-preemptive priority
scheduling</strong>：将优先级较高的进程置于队列的前端
<ol type="1">
<li>默认所有进程一起到来</li>
</ol></li>
<li>抢占式<strong>Preemptive priority
scheduling</strong>：在较高优先级进程到达时中断并抢占正在运行的进程
<ol type="1">
<li>默认所有进程的到达时间有前后区别</li>
</ol></li>
</ol></li>
<li>问题：饥饿<strong>Starvation</strong>，低优先级的进程永远不会被执行</li>
<li>解决方法：老化<strong>Aging</strong>，随着进程运行时间的增长，其优先级会降低</li>
</ol>
<h4 id="示例-2">5.3.3.2 示例</h4>
<blockquote>
<p><strong>非抢占式</strong>：non-preemptive</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Burst Time</th>
<th style="text-align: center;">Priority</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P<sub>1</sub></td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>2</sub></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P<sub>3</sub></td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>4</sub></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P<sub>5</sub></td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p><img src="/images/AssetMarkdown/image-20221024144014656.png" alt="image-20221024144014656" style="zoom:80%;" /></p>
<ol type="1">
<li>平均Turnaround time：(16+1+18+19+6) / 5 = 12</li>
<li>平均waiting time：(6+0+16+18+1) / 5 = 8.2</li>
</ol>
<blockquote>
<p><strong>抢占式</strong>：preemptive</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Arrival Time</th>
<th style="text-align: center;">Burst Time</th>
<th style="text-align: center;">Priority</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P<sub>1</sub></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>2</sub></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P<sub>3</sub></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>4</sub></td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P<sub>5</sub></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p><img src="/images/AssetMarkdown/image-20221024144435400.png" alt="image-20221024144435400" style="zoom:80%;" /></p>
<ol type="1">
<li>平均Turnaround time：(17+1+15+1+5) / 5 = 7.8</li>
<li>平均waiting time：(7+0+13+0+0) / 5 = 4</li>
</ol>
<h3 id="时间片轮转调度-rr">5.3.4 时间片轮转调度 RR</h3>
<h4 id="算法内容-3">5.3.4.1 算法内容</h4>
<ol type="1">
<li>基本思路：通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率。</li>
<li><strong>RR</strong>算法：Round Robin
<ol type="1">
<li>将系统中所有的就绪进程按照<strong>FCFS</strong>原则，排成一个队列</li>
<li>每次调度时将CPU分派给队首进程，让其执行一个<strong>时间片
(timeslice)</strong>
<ol type="1">
<li>时间片的长度从几个ms到几百ms</li>
</ol></li>
<li>在一个时间片结束时，发生时钟中断</li>
<li>调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程</li>
<li>进程可以未使用完一个时间片，就出让CPU（如阻塞）</li>
</ol></li>
<li>每个进程都有一小单位的CPU时间(<strong>time
quantum</strong>)，通常为10-100毫秒。经过这段时间后，进程被抢占并添加到就绪队列的末尾</li>
<li>如果<strong>ready
queue</strong>中有<strong>n</strong>个进程，并且<strong>time
quantum</strong>为<strong>q</strong>，那么每个进程一次获得最多为<strong>q</strong>个时间单位的<strong>CPU</strong>时间的<strong>1/n</strong>，进程最大等待<strong>(n-1)q</strong>个时间单位
<ol type="1">
<li>当q很大时，变为了FIFO</li>
<li>当q很小时，上下文切换的开销过高</li>
</ol></li>
<li>时间片长度的影响因素：
<ol type="1">
<li>就绪进程的数目：当响应时间一定时，<strong>数目越多，时间片越小</strong></li>
<li>系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间、平均周转时间、平均带权周转时间过长</li>
</ol></li>
<li>优点：response更好</li>
<li>缺点：比<strong>SJF</strong>的average turnaround time长</li>
</ol>
<h4 id="示例-3">5.3.4.2 示例</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Process</th>
<th style="text-align: center;">Burst Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P<sub>1</sub></td>
<td style="text-align: center;">53</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>2</sub></td>
<td style="text-align: center;">17</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P<sub>3</sub></td>
<td style="text-align: center;">68</td>
</tr>
<tr class="even">
<td style="text-align: center;">P<sub>4</sub></td>
<td style="text-align: center;">24</td>
</tr>
</tbody>
</table>
<p><img src="/images/AssetMarkdown/image-20221024150527509.png" alt="image-20221024150527509" style="zoom:80%;" /></p>
<ol type="1">
<li>平均Turnaround time：(134+37+162+121) / 4 = 113.5</li>
<li>平均waiting time：(81+20+94+97) / 4 = 70.5</li>
</ol>
<h4 id="time-quantum-时间片的选择">5.3.4.3 Time Quantum
时间片的选择</h4>
<ol type="1">
<li>要求80%的CPU burst time应该小于q</li>
</ol>
<h3 id="多级队列调度">5.3.5 多级队列调度</h3>
<p><img src="/images/AssetMarkdown/image-20221024152844819.png" alt="image-20221024152844819" style="zoom: 67%;" /></p>
<p>本算法引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标</p>
<ol type="1">
<li>根据进程的性质或类型的不同，将Ready队列再分为若干个子队列</li>
<li>每个作业固定归入一个队列</li>
<li>各队列的不同处理：不同队列可有不同的优先级、时间片长度、调度策略等
<ol type="1">
<li>如：系统进程、用户交互进程、批处理进程等</li>
</ol></li>
<li>Ready Queue的分类
<ol type="1">
<li>foreground (interactive) 前台（交互式）— RR，时间片轮转调度</li>
<li>background (batch) 　　后台 （批处理）— FCFS，先来先服务调度</li>
</ol></li>
<li>多级队列算法调度须在队列间进行
<ol type="1">
<li><strong>固定优先级调度</strong>：即前台运行完后再运行后台
<ol type="1">
<li>有可能产生饥饿</li>
</ol></li>
<li><strong>给定时间片调度</strong>：即每个队列得到一定的CPU时间，进程在给定时间内执行
<ol type="1">
<li>不同队列的时间片长度不一样</li>
<li>如，80%的时间执行前台的RR调度，20%的时间执行后台的FCFS调度</li>
</ol></li>
</ol></li>
</ol>
<h3 id="多级反馈队列">5.3.6 多级反馈队列</h3>
<ol type="1">
<li>多级反馈队列算法：Multilevel Feedback Queue Scheduling
<ol type="1">
<li>是时间片轮转算法和优先级算法的综合和发展</li>
<li>同一个进程可以在不同队列之间转移</li>
</ol></li>
<li>优点：
<ol type="1">
<li>为提高系统吞吐量和缩短平均周转时间而照顾短进程</li>
<li>为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li>
<li>不必估计进程的执行时间，动态调节</li>
</ol></li>
<li>方法：
<ol type="1">
<li>设置<strong>多个就绪队列</strong>，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定<strong>优先级越低则时间片越长</strong>，如逐级加倍</li>
<li>新进程进入内存后，<strong>先投入队列1的末尾</strong>，按<strong>FCFS</strong>算法调度；<strong>若按队列1一个时间片未能执行完，则降低投入到队列2的末尾</strong>，同样按<strong>FCFS</strong>算法调度；如此下去，降低到最后的队列，则按"<strong>时间片轮转</strong>"算法调度直到完成</li>
<li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢占执行新进程，并把被抢占的进程投入原队列的末尾</li>
</ol></li>
<li>几点说明：
<ol type="1">
<li><strong>I/O型进程</strong>：让其进入最高优先级队列，以及时响应I/O交互。通常执行一个小时间片，要求可处理完一次I/O请求的数据，然后转入到阻塞队列</li>
<li><strong>计算型进程</strong>：每次执行完时间片，进入更低优先级级队列。最终采用最大时间片来执行，减少调度次数</li>
<li><strong>I/O次数不多，而主要是CPU处理的进程</strong>：在I/O完成后，优先放回I/O请求时离开的队列，以免每次都回到最高优先级队列后再逐次下降</li>
<li>为适应一个进程在不同时间段的运行特点，<strong>I/O完成时，提高优先级</strong>；<strong>时间片用完时，降低优先级</strong>；</li>
</ol></li>
</ol>
<h2 id="多处理器调度-multiple-processor-scheduling">5.4* 多处理器调度
Multiple-Processor Scheduling</h2>
<ol type="1">
<li>当多个CPU可用时，CPU调度更加复杂</li>
<li>多处理器中的 同构处理器Homogeneous processors
<ol type="1">
<li>负载分担</li>
</ol></li>
<li>非对称多处理Asymmetric
multiprocessing：只有一个处理器访问系统数据结构，减少了数据共享的需要</li>
</ol>
<h2 id="线程调度-thread-scheduling">5.5* 线程调度 Thread Scheduling</h2>
<ol type="1">
<li>本地调度：线程库如何决定将哪个线程放入可用的LWP</li>
<li>全局调度：内核如何决定下一个运行哪个内核线程</li>
</ol>
<h2 id="操作系统示例-operating-systems-examples">5.6 操作系统示例
Operating Systems Examples</h2>
<ol type="1">
<li>两种算法：Time-sharing、Real-time</li>
<li>时间共享 Time-sharing
<ol type="1">
<li>基于credit的优先级：下一步执行拥有最高credit的进程</li>
<li>触发计时器中断时扣除credit</li>
<li>当credit=0时，选择另一个进程</li>
<li>当所有进程的credit均为0时，将重新编辑
<ol type="1">
<li>基于优先级和历史等因素</li>
</ol></li>
</ol></li>
<li>实时 Real-time
<ol type="1">
<li>软实时</li>
<li>Posix.1b compliant：两种
<ol type="1">
<li>FCFS和RR</li>
<li>优先级最高的进程总是首先运行</li>
</ol></li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221027164612041.png" alt="image-20221027164612041" style="zoom:67%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221027164619528.png" alt="image-20221027164619528" style="zoom:67%;" /></p>
<h2 id="总结-1">5.7 总结</h2>
<ol type="1">
<li>CPU Burst Time 、I/O Burst Time</li>
<li>CPU-bound program（CPU型程序） 、I/O-bound program（I/O型程序）</li>
<li>long-term scheduler（长程调度）、medium-term
scheduler（中程调度）short-term scheduler（短程调度）</li>
<li>time slicing（时间片）</li>
<li>response time（响应时间）、turnaround time（周转时间）、waiting
time（等待时间）、Average Turnaround time（平均周转时间）Average waiting
time（平均等待时间）</li>
<li>preemptive scheduling（抢占式调度）、Nonpreemptive
scheduling（非抢占式调度）</li>
<li>throughput（吞吐量）：单位时间内完成的任务</li>
<li>从ready queue中选择一个进程，为它分配CPU</li>
<li>调度算法
<ol type="1">
<li>first-come, first served (<strong>FCFS</strong>)</li>
<li>shortest job first (<strong>SJF</strong>)
<ol type="1">
<li>provably optimal, but difficult to know CPU burst</li>
</ol></li>
<li>general <strong>priority</strong> scheduling
<ol type="1">
<li>starvation, and aging</li>
</ol></li>
<li>round-robin (<strong>RR</strong>)
<ol type="1">
<li>for time-sharing, interactive system</li>
<li>problem: how to select the time quantum?</li>
</ol></li>
<li><strong>Multilevel queue</strong>
<ol type="1">
<li>different algorithms for different classes of processes</li>
</ol></li>
<li><strong>Multilevel feedback queue</strong>
<ol type="1">
<li>allow process to move from one (ready) queue to another</li>
</ol></li>
</ol></li>
</ol>
<h1 id="chapter-6process-synchronization-进程同步">Chapter 6：Process
Synchronization 进程同步</h1>
<h2 id="background">6.1 Background</h2>
<ol type="1">
<li><p>对共享数据的并发访问可能导致数据不一致：data
inconsistency</p></li>
<li><p>维护数据一致性需要有机制来确保合作流程的有序执行</p></li>
<li><p>有界缓冲区问题的共享内存解决方案(第3章)允许缓冲区中最多有n-1个项。使用所有N个缓冲区的解决方案并不简单</p></li>
<li><p>假设我们通过添加一个变量counter来修改生产者–消费者代码</p>
<ol type="1">
<li>counter初始化为0，并在每次向缓冲区添加新项时递增</li>
<li>counter++和counter--必须被原子性的执行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	. . .</span><br><span class="line">&#125; item;</span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer process(thread):</span></span><br><span class="line">item nextProduced;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (counter == BUFFER_SIZE) ;  <span class="comment">/* do nothing */</span></span><br><span class="line">    buffer[in] = nextProduced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer process (thread):</span></span><br><span class="line">item nextConsumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (counter == <span class="number">0</span>)	;  <span class="comment">/* do nothing */</span></span><br><span class="line">    nextConsumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原子操作">6.1.1 原子操作</h3>
<ol type="1">
<li><p><strong>原子操作 Atomic
operation</strong>：是指完整地完成而不中断的操作</p>
<ol type="1">
<li><p>counter++和counter--均会被实现为三条指令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> = counter;</span><br><span class="line"><span class="keyword">register</span> = <span class="keyword">register</span> +/- <span class="number">1</span>;</span><br><span class="line">counter = <span class="keyword">register</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果生产者和消费者都试图同时更新缓冲区，汇编语言语句可能会交错</p></li>
<li><p>交错取决于生产者和消费者流程的安排方式</p></li>
</ol></li>
</ol>
<h3 id="非原子操作冲突示例">6.1.2 非原子操作冲突示例</h3>
<blockquote>
<p>有两个进程P1、P2，它们分别执行下面的程序体，其中total是两个进程都能访问的共享变量，初值为0（可理解为共享存储段中的存储单元），count是每个进程的私有变量。假设这两个进程并发执行，并可自由交叉（interleave），则这两个进程都执行完后，变量total可能得到的最小取值是<code>3</code></p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P1:&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">for</span> (count =<span class="number">1</span>; count &lt;= <span class="number">50</span>; count++)</span><br><span class="line">		total = total + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br><span class="line">P2: &#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">for</span> (count =<span class="number">1</span>; count &lt;= <span class="number">50</span>; count++)</span><br><span class="line">		total = total + <span class="number">2</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ol type="1">
<li><p>total = total + 1和total = total + 2经过编译后各为三条指令</p>
<p><img src="/images/AssetMarkdown/image-20221027171738434.png" alt="image-20221027171738434" style="zoom:67%;" /></p></li>
<li><p>P1和P2并发执行过程中，这些指令会交替运行。如果两个进程按如下顺序执行：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作</th>
<th style="text-align: center;">对应指令</th>
<th style="text-align: center;">对应的值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P1第1次循环</td>
<td style="text-align: center;">register1 = total</td>
<td style="text-align: center;">register1 = 0</td>
</tr>
<tr class="even">
<td style="text-align: center;">P1第1次循环</td>
<td style="text-align: center;">register1 = register1 + 1</td>
<td style="text-align: center;">register1 = 1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P2循环49次</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">P1第1次循环</td>
<td style="text-align: center;">total =register1</td>
<td style="text-align: center;">total =1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P2第50次循环</td>
<td style="text-align: center;">register2 = total</td>
<td style="text-align: center;">register2 = 1</td>
</tr>
<tr class="even">
<td style="text-align: center;">P2第50次循环</td>
<td style="text-align: center;">register2 = register2 + 2</td>
<td style="text-align: center;">register2 = 3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P1循环48次</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">P1第50次循环</td>
<td style="text-align: center;">register1 = total</td>
<td style="text-align: center;">register1 = 49</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P1第50次循环</td>
<td style="text-align: center;">register1 = register1 + 1</td>
<td style="text-align: center;">register1 =50</td>
</tr>
<tr class="even">
<td style="text-align: center;">P1第50次循环</td>
<td style="text-align: center;">total = register1</td>
<td style="text-align: center;">total = 50</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P2第50次循环</td>
<td style="text-align: center;">total = register2</td>
<td style="text-align: center;">total = 3</td>
</tr>
</tbody>
</table></li>
<li><p>两个进程运行结束后，变量total的值为3。</p></li>
</ol>
<h3 id="race-condition">6.1.3 Race Condition</h3>
<ol type="1">
<li>Race
Condition(竞争条件)：多个进程同时访问和操作共享数据，共享数据的最终值取决于哪个进程最后完成，执行的结果取决于访问发生的特定顺序</li>
<li>为了防止出现争用情况，必须同步并发进程</li>
</ol>
<h3 id="进程同步的概念">6.1.4 进程同步的概念</h3>
<p>进程之间竞争资源面临三个控制问题：</p>
<ol type="1">
<li><strong>互斥</strong>(mutual
exclusion)：指多个进程不能同时使用同一个资源</li>
<li><strong>死锁</strong>(deadlock)：指多个进程互不相让，都得不到足够的资源
<ol type="1">
<li>永远得不到资源</li>
</ol></li>
<li><strong>饥饿</strong>(starvation)：指一个进程长时间得不到资源(其他进程可能轮流占用资源)
<ol type="1">
<li>资源分配不公平</li>
</ol></li>
</ol>
<h2 id="the-critical-section-problem重点">6.2 The Critical-Section
Problem(<strong>重点</strong>)</h2>
<h3 id="问题的定义">6.2.1 问题的定义</h3>
<ol type="1">
<li>n个进程都在竞争使用某些共享数据</li>
<li>每个流程都有一个代码段，称为关键部分(临界区）,
其中访问共享数据。</li>
<li>问题：确保当一个进程在其关键部分执行时，不允许其他进程在其重要部分执行</li>
</ol>
<h3 id="临界区临界资源">6.2.2 临界区&amp;临界资源</h3>
<ol type="1">
<li><strong>临界资源</strong>：一次只允许一个进程使用(访问)的资源
<ol type="1">
<li>如：硬件打印机、磁带机等，软件的消息缓冲队列、变量、数组、缓冲区等。</li>
</ol></li>
<li><strong>临界区</strong>：访问临界资源的那段代码</li>
<li>对临界区问题的解法必须满足：
<ol type="1">
<li><strong>Mutual Exclusion</strong>(互斥)
<ol type="1">
<li>如果进程P<sub>i</sub>正在临界区中执行，则其他进程不能在临界区中执行</li>
</ol></li>
<li><strong>Progress</strong>(空闲让进)
<ol type="1">
<li>如果没有进程在临界区中执行，并且存在一些进程希望进入临界区，则不能无限期地推迟选择下一个将进入临界区的进程</li>
</ol></li>
<li><strong>Bounded Waiting</strong>(让权等待)
<ol type="1">
<li>在一个进程发出进入临界区的请求之后，在该请求被批准之前，其他进程被允许进入临界区的次数必须存在一个界限</li>
<li>不是必须的</li>
</ol></li>
</ol></li>
</ol>
<h3 id="一个进程的结构应该是">6.2.3 一个进程的结构应该是</h3>
<p><img src="/images/AssetMarkdown/image-20221031142201362.png" alt="image-20221031142201362" style="zoom:80%;" /></p>
<h2 id="多进程临界区问题的解决方法软件方法">6.3
多进程临界区问题的解决方法：软件方法</h2>
<h3 id="peterson-solutions两个进程">6.3.1 Peterson
Solutions：两个进程</h3>
<blockquote>
<ol type="1">
<li>Software Solution：通过软件方法解决进程互斥</li>
<li>针对两个进程之间的同步</li>
<li>假设Load和Store均是原子操作</li>
</ol>
</blockquote>
<h4 id="算法1">6.3.1.1 算法1</h4>
<ol type="1">
<li><p>只有两个进程P<sub>0</sub>，P<sub>1</sub></p></li>
<li><p>共享变量</p>
<ol type="1">
<li>int turn = 0</li>
<li>turn = i：表示轮到P<sub>i</sub>进入临界区，i = 0/1</li>
</ol></li>
<li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p>
<p><img src="/images/AssetMarkdown/image-20221027173940774.png" alt="image-20221027173940774" style="zoom:80%;" /></p></li>
<li><p>满足<strong>互斥</strong>，但是不满足<strong>空闲让进</strong></p></li>
<li><p>缺点：</p>
<ol type="1">
<li><strong>强制轮流</strong>进入临界区，没有考虑进程的实际需要。容易造成资源利用不充分</li>
<li>在P<sub>i</sub>出让临界区之后，P<sub>j</sub>使用临界区之前，P<sub>i</sub>不可能再次使用临界区</li>
</ol></li>
</ol>
<h4 id="算法2-1">6.3.1.2 算法2-1</h4>
<ol type="1">
<li><p>共享变量</p>
<ol type="1">
<li>bool flag[2] = false</li>
<li>flag[i] = true：表示P<sub>i</sub>想要进入临界区，i = 0/1</li>
</ol></li>
<li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p>
<p><img src="/images/AssetMarkdown/image-20221027174338587.png" alt="image-20221027174338587" style="zoom:80%;" /></p></li>
<li><p>满足<strong>互斥</strong>，但是不满足<strong>空闲让进</strong></p></li>
<li><p>缺点：</p>
<ol type="1">
<li>P<sub>0</sub>和P<sub>1</sub>可能都进入不了临界区</li>
<li>当P<sub>0</sub>执行了flag[0] =
true后，然后P<sub>1</sub>执行了flag[1] =
true，这样两个进程都无法进入临界区</li>
</ol></li>
</ol>
<h4 id="算法2-2">6.3.1.3 算法2-2</h4>
<ol type="1">
<li><p>共享变量</p>
<ol type="1">
<li>bool flag[2] = false</li>
<li>flag[i] = true：表示P<sub>i</sub>想要进入临界区，i = 0/1</li>
</ol></li>
<li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p>
<p><img src="/images/AssetMarkdown/image-20221027174706683.png" alt="image-20221027174706683" style="zoom:80%;" /></p></li>
<li><p>满足<strong>空闲让进</strong>，但是不满足<strong>互斥</strong></p></li>
<li><p>缺点：</p>
<ol type="1">
<li>P<sub>0</sub>和P<sub>1</sub>可能同时进入临界区</li>
<li>当flag [0] = flag [1] = false时， P<sub>0</sub>执行了while
(flag[1])后，P<sub>1</sub>执行while (flag[0])
，这样两个进程同时进入了临界区</li>
</ol></li>
</ol>
<h4 id="peterson算法">6.3.1.4 Peterson算法</h4>
<ol type="1">
<li><p>共享变量</p>
<ol type="1">
<li><strong>int turn = 0</strong></li>
<li><strong>bool flag[2] = false</strong></li>
<li>turn = i：表示<strong>轮到P<sub>i</sub></strong>进入临界区，i =
0/1</li>
<li>flag[i] =
true：表示<strong>P<sub>i</sub>准备好</strong>进入临界区，i = 0/1</li>
</ol></li>
<li><p>进程P<sub>0</sub>和P<sub>1</sub>的操作：</p>
<p><img src="/images/AssetMarkdown/image-20221027174954828.png" alt="image-20221027174954828" style="zoom:80%;" /></p></li>
<li><p>满足了三个要求，但是只能解决2个进程的临界区问题</p></li>
</ol>
<h3 id="bakery-algorithmn个进程">6.3.2 Bakery Algorithm：n个进程</h3>
<p>思想：</p>
<ol type="1">
<li>进入临界区之前，进程会获得一个<strong>number</strong>，拥有最小<strong>number</strong>的进程可以进入临界区</li>
<li>如果<strong>P<sub>i</sub></strong>和<strong>P<sub>j</sub></strong>的<strong>number</strong>相同，则先执行进程<strong>id</strong>小的进程</li>
<li>编号方案总是按枚举的递增顺序生成数字，如1,2,3,3,3,3,4,5...</li>
</ol>
<p>定义：</p>
<ol type="1">
<li><strong>order</strong>：(a, b)，a为number，b为进程id</li>
<li><strong>(a, b) &lt; (c, d)</strong>：当且仅当 a&lt;c 或者 a=c,
b&lt;d</li>
</ol>
<p>共享数据：</p>
<ol type="1">
<li><strong>bool choosing[n] = false;</strong></li>
<li><strong>int number[n] = 0;</strong></li>
<li>choosing[i] =
true：表示<strong>P<sub>i</sub>正在获取</strong>它的<strong>number</strong></li>
<li>number[i]：是<strong>P<sub>i</sub>的当前number</strong>。如果值为0，表示P<sub>i</sub>未参加排队，不想获得该资源</li>
</ol>
<p>进程P<sub>i</sub>的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="comment">// 获取一个number</span></span><br><span class="line">	choosing[i] = <span class="literal">true</span>;</span><br><span class="line">	number[i] = <span class="built_in">max</span>(number[<span class="number">0</span>], number[<span class="number">1</span>], ... , number[n<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">	choosing[i] = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 等待其它优先级更高的进程进入临界区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; </span><br><span class="line">        <span class="comment">// 等待进程P[j]获取自己的number</span></span><br><span class="line">        <span class="keyword">while</span>(choosing[j]); </span><br><span class="line">        <span class="comment">// 进程P[j]参与排队, 并且比当前进程优先级高, 则等待P[j]执行完成</span></span><br><span class="line">       	<span class="keyword">while</span>((number[j] != <span class="number">0</span>) &amp;&amp; (number[j],j) &lt; (number[i],i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="built_in">critical_section</span>();	<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">	number[i] = <span class="number">0</span>;		<span class="comment">// 从队列中出来, 不再等待进入临界区</span></span><br><span class="line">	<span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="多进程临界区问题的解决方法硬件方法">6.4
多进程临界区问题的解决方法：硬件方法</h2>
<ol type="1">
<li>许多系统为关键部分代码提供硬件支持</li>
<li>单处理器：可以禁用中断
<ol type="1">
<li>当前运行的代码将在没有抢占的情况下执行</li>
<li>在多处理器系统上通常效率太低</li>
<li>使用此功能的操作系统不可广泛扩展</li>
</ol></li>
<li>特殊的原子硬件指令：原子 =&gt; 不可中断
<ol type="1">
<li>从内存中取一个变量并且设置为某个值：test and set</li>
<li>交换内存中两个变量的内容：swap</li>
</ol></li>
</ol>
<h3 id="test-and-set测试与设置">6.4.1 Test-and-Set：测试与设置</h3>
<ol type="1">
<li><p>返回变量的原始值，并将其赋值为<strong>true</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> &amp;target)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> rv = target;</span><br><span class="line">    target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将其变为一条<strong>原子指令</strong>之后，进程与临界区的交互变为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, 该指令返回false, 并将lock赋值为true</span></span><br><span class="line">    <span class="comment">// 其它进程再执行该指令时, 会由于返回值为true, 而停到这里</span></span><br><span class="line">    <span class="comment">// 进程执行完成后, 将lock赋值为false, 其它进程可以访问临界区</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(lock));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();	<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">	lock = <span class="literal">false</span>;		<span class="comment">// 之后的第一个进程可以进入临界区</span></span><br><span class="line">	<span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="swap交换">6.4.2 Swap：交换</h3>
<ol type="1">
<li><p>交换两个变量的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span> <span class="params">(boolean *a, boolean *b)</span>&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将其变为一条<strong>原子指令</strong>之后，进程与临界区的交互变为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, key与lock交换, key变为false, lock变为true</span></span><br><span class="line">    <span class="comment">// 其它进程再执行该指令时, key与lock交换后均为true, 会停到这里</span></span><br><span class="line">    <span class="comment">// 进程执行完成后, 将lock赋值为false, 其它进程可以访问临界区</span></span><br><span class="line">    <span class="keyword">while</span>(key == <span class="literal">true</span>) Swap(&amp;lock, &amp;key);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    critical_section();	<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">	lock = <span class="literal">false</span>;		<span class="comment">// 之后的第一个进程可以进入临界区		</span></span><br><span class="line">	remainder_section();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="硬件方法的优缺点">6.4.3 硬件方法的优缺点</h3>
<ol type="1">
<li><p>优点</p>
<ol type="1">
<li>适用于<strong>任意数目的进程</strong>，在单处理器或多处理器上</li>
<li><strong>简单</strong>，容易验证其正确性</li>
<li>可以支持进程内存在<strong>多个临界区</strong>，只需为每个临界区设立一个布尔变量</li>
</ol></li>
<li><p>缺点</p>
<ol type="1">
<li>不能实现<strong>让权等待</strong>：
<ol type="1">
<li>因为等待要耗费CPU时间</li>
</ol></li>
<li>可能<strong>饥饿</strong>：
<ol type="1">
<li>从等待进程中随机选择一个进入临界区，有的进程可能一直选不上</li>
</ol></li>
<li>可能<strong>死锁</strong>：
<ol type="1">
<li>单CPU情况下，P<sub>1</sub>执行特殊指令进入临界区，这时拥有更高优先级P2执行并中断P1</li>
<li>如果P<sub>2</sub>又要使用P<sub>1</sub>占用的资源，按照资源分配规则拒绝P<sub>2</sub>对资源的要求，P<sub>2</sub>陷入等待循环</li>
<li>然后P<sub>1</sub>也得不到CPU，因为P<sub>1</sub>比P<sub>2</sub>优先级低</li>
</ol></li>
</ol></li>
<li><p><strong>解决饥饿</strong></p>
<ol type="1">
<li><strong>waiting[i]</strong>：进程P<sub>i</sub>正在等待进入临界区</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> waiting[n] = <span class="literal">false</span>, lock = <span class="literal">false</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个进程准备进入临界区时, 将lock变为true, 返回给key为false</span></span><br><span class="line">    <span class="comment">// 之后的进程始终为true, 也就是不能进入临界区</span></span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (waiting[i] &amp;&amp; key) key = <span class="built_in">TestAndSet</span>(lock);</span><br><span class="line">    waiting[i] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();	<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择下一个进入临界区的进程(下一个waiting[j] = true)</span></span><br><span class="line">    <span class="comment">// 让waiting[j] = false, 则被选中的进程跳出while循环, 可以进入临界区</span></span><br><span class="line">    <span class="comment">// lock的释放由进程P[j]执行</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = (i + <span class="number">1</span>) % n; j != i; j = (j + <span class="number">1</span>) % n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(waiting[j]) &#123;</span><br><span class="line">            waiting[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有进程等待进入临界区, 则直接释放lock</span></span><br><span class="line">    <span class="keyword">if</span> (j == i)  lock = <span class="literal">false</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol type="1">
<li>该算法满足所有关键部分的要求。</li>
<li>证明满足互斥要求：
<ol type="1">
<li>我们注意到，只有当<strong>waiting[i]=false</strong>或<strong>key=false</strong>时，进程<strong>Pi</strong>才能进入临界区</li>
<li>只有在执行<strong>TestAndSet</strong>时，<strong>key</strong>的值才能变为<strong>false</strong></li>
<li>执行<strong>TestAndSet</strong>的第一个进程将发现<strong>key==false</strong>；所有其他人都必须等待</li>
<li>只有当另一个进程离开临界区时，<strong>waiting[i]</strong>才能变为<strong>false</strong>；只有一个<strong>waiting[i]</strong>设置为<strong>false</strong>，保持互斥要求。</li>
</ol></li>
</ol>
</blockquote></li>
</ol>
<h3 id="自旋锁-spinlock">6.4.4 自旋锁 spinlock</h3>
<ol type="1">
<li>Windows、Linux内核用来达到多处理器互斥的机制“自旋锁”，它类同于TestAndSet指令机制。自旋锁是一个与共用数据结构有关的锁定机制。</li>
<li>自旋锁像它们所保护的数据结构一样，储存在共用内存中。为了速度和使用任何在处理器体系下提供的锁定机构，获取和释放自旋锁的代码是用汇编语言写的。例如在Intel处理器上，Windows使用了一个只在486处理器或更高处理器上运行的指令。</li>
<li>当线程试图获得自旋锁时，在处理器上所有其它工作将终止。因此拥有自旋锁的线程永远不会被抢占，但允许它继续执行以便使它尽快把锁释放。内核对于使用自旋锁十分小心，当它拥有自旋锁时，它执行的指令数将减至最少。</li>
</ol>
<h2 id="semaphores-信号量">6.5 Semaphores 信号量</h2>
<h3 id="信号量">6.5.1 信号量</h3>
<p>信号量分类：</p>
<ol type="1">
<li>整型信号量：integer semaphore</li>
<li>记录型信号量：record semaphore</li>
<li>AND型信号量，信号量集</li>
<li>二值信号量：binary semaphore</li>
</ol>
<p>信号量的任务：解决<strong>busy
waiting</strong>，即之前进程中的while()语句</p>
<ol type="1">
<li><p>整型信号量：<strong>S</strong></p></li>
<li><p>对S的两个标准操作：<strong>wait()</strong>、<strong>signal()</strong></p>
<ol type="1">
<li>也成为<strong>P()</strong>、<strong>V()</strong></li>
<li>这两个操作是<strong>原子操作</strong></li>
</ol></li>
<li><p>两种信号量</p>
<ol type="1">
<li>计数信号量 Counting semaphore：整数取值范围</li>
<li>二值信号量 Binary semaphore：只有0/1两个值</li>
</ol></li>
</ol>
<h3 id="用信号量解决冲突">6.5.2 用信号量解决冲突</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">// 共享数据, 初始值表示最多可以有多少个进程同时进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P[i]</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个进程将mutex--, mutex变为0</span></span><br><span class="line">    <span class="comment">// 其它进程会在当前wait(mutex)处等待</span></span><br><span class="line">    <span class="built_in">wait</span> (mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">critical_section</span>();	<span class="comment">// 进入临界区执行的部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进程执行完成, 将mutex++</span></span><br><span class="line">    <span class="comment">// 其它进程可以通过wait(mutex)指令</span></span><br><span class="line">    <span class="built_in">signal</span> (mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">remainder_section</span>();<span class="comment">// 不需要进入临界区执行的部分</span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>必须保证没有两个进程可以在同一信号量上同时执行wait()和signal()</li>
<li>没有解决busy waiting的问题</li>
<li>但是将解决临界区问题的代码简化了</li>
</ol>
<h3 id="没有busy-waiting的信号量实现">6.5.3 没有busy
waiting的信号量实现</h3>
<ol type="1">
<li><p>实现了一个waiting queue，等待队列中的每一个实体有2个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;				<span class="comment">// S: 记录型信号量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *list;	<span class="comment">// 等待队列中的下一个进程</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li>
<li><p>2个操作</p>
<ol type="1">
<li><strong>block()</strong>：将调用操作的进程放置在适当的等待队列中
<ol type="1">
<li>进程：running → waiting</li>
</ol></li>
<li><strong>wakeup()</strong>：删除等待队列中的一个进程，并将其置于就绪队列中
<ol type="1">
<li>进程：waiting → ready</li>
</ol></li>
</ol></li>
<li><p>具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(semaphore * S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 将这个进程加入S-&gt;list</span></span><br><span class="line">        <span class="built_in">block</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(semaphore *S) &#123; </span><br><span class="line">    S-&gt;value++; </span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 将进程P从S-&gt;list中移除</span></span><br><span class="line">        <span class="built_in">wakeup</span>(P); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="waitsignal操作讨论">6.5.4 wait、signal操作讨论</h3>
<ol type="1">
<li>通常用信号量表示资源或临界区</li>
<li>信号量的物理含义
<ol type="1">
<li><strong>S.value&gt;0</strong>：表示有S.value个资源可用；</li>
<li><strong>S.value=0</strong>：表示无资源可用或表示不允许进程再进入临界区；</li>
<li><strong>S.value&lt;0</strong>：则|S.value|表示在等待队列中进程的个数或表示等待进入临界区的进程个数</li>
</ol></li>
<li><strong>wait(S)≡P(S)≡down(S)</strong>：表示申请一个资源</li>
<li><strong>signal(S)≡V(S)≡up(S)</strong>： 表示释放一个资源</li>
<li>wait、signal操作必须成对出现，有一个wait操作就一定有一个signal操作
<ol type="1">
<li>当为互斥操作时(控制A, B不会同时访问临界区)，它们同处于同一进程</li>
<li>当为同步操作时(控制先让A执行, 再让B执行)，则不在同一进程中出现</li>
</ol></li>
<li>如果两个wait操作相邻，那么它们的顺序至关重要，而两个相邻的signal操作的顺序无关紧要</li>
<li>一个同步wait操作与一个互斥wait操作在一起时，同步wait操作在互斥wait操作前</li>
<li>wait、signal操作的优缺点
<ol type="1">
<li>优点：简单，而且表达能力强</li>
<li>缺点：不够安全；wait、signal操作使用不当会出现死锁；实现复杂</li>
</ol></li>
</ol>
<h3 id="信号量用于通用同步操作">6.5.5 信号量用于通用同步操作</h3>
<ol type="1">
<li><p>先执行P<sub>i</sub>中的A操作，再执行P<sub>j</sub>中的B操作</p>
<ol type="1">
<li>信号量<strong>flag初始化为0</strong></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">P[i]</th>
<th style="text-align: center;">P[j]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
</tr>
<tr class="even">
<td style="text-align: center;">A</td>
<td style="text-align: center;">wait(flag)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">signal(flag)</td>
<td style="text-align: center;">B</td>
</tr>
<tr class="even">
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
</tr>
</tbody>
</table></li>
<li><p>一组合作进程，执行顺序如图。请用P(wait)、V(signal)操作实现进程间的同步操作</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221103165404062.png" alt="image-20221103165404062" style="zoom: 50%;" /></th>
<th
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221103165348103.png" alt="image-20221103165348103" style="zoom: 50%;" /></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol type="1">
<li><p>设置8个信号量a~h，初始值均为0</p></li>
<li><p>各进程的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">	...;</span><br><span class="line">	<span class="built_in">signal</span>(a);</span><br><span class="line">	<span class="built_in">signal</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">	<span class="built_in">wait</span>(a);</span><br><span class="line">	...;</span><br><span class="line">	<span class="built_in">signal</span>(c);</span><br><span class="line">	<span class="built_in">signal</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P3</span>()&#123;</span><br><span class="line">	<span class="built_in">wait</span>(b);</span><br><span class="line">	...;</span><br><span class="line">	<span class="built_in">signal</span>(e);</span><br><span class="line">	<span class="built_in">signal</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P4</span>()&#123;</span><br><span class="line">	<span class="built_in">wait</span>(c);</span><br><span class="line">	<span class="built_in">wait</span>(e);</span><br><span class="line">	...;</span><br><span class="line">	<span class="built_in">signal</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P5</span>()&#123;</span><br><span class="line">	<span class="built_in">wait</span>(d);</span><br><span class="line">	<span class="built_in">wait</span>(f);</span><br><span class="line">	...;</span><br><span class="line">	<span class="built_in">signal</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P6</span>()&#123;</span><br><span class="line">	<span class="built_in">wait</span>(g);</span><br><span class="line">	<span class="built_in">wait</span>(h);</span><br><span class="line">	...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>两个进程互斥：信号量初始为1</p>
<p><img src="/images/AssetMarkdown/image-20221103170050338.png" alt="image-20221103170050338" style="zoom:80%;" /></p></li>
</ol>
<h3 id="死锁和饥饿">6.5.6 死锁和饥饿</h3>
<ol type="1">
<li><p>死锁Deadlock：两个或多个进程无限期地等待一个事件，该事件只能由其中一个等待进程引起</p>
<p><img src="/images/AssetMarkdown/image-20221103170213479.png" alt="image-20221103170213479"  /></p></li>
<li><p>饥饿Starvation：无限期阻塞。进程可能永远不会从其挂起的信号量队列中删除</p></li>
<li><p>优先级反转Priority
Inversion：低优先级进程持有高优先级进程所需的锁时的调度问题</p></li>
</ol>
<h2 id="同步的经典问题">6.6 同步的经典问题</h2>
<h3 id="有限缓冲区问题bounded-buffer-problem">6.6.1
有限缓冲区问题：Bounded-Buffer Problem</h3>
<ol type="1">
<li><p>有限缓冲区问题，也成为生产者-消费者问题，是最著名的同步问题</p>
<ol type="1">
<li>它描述一组生产者(P<sub>1</sub>……P<sub>m</sub>)向一组消费者(C<sub>1</sub>……C<sub>q</sub>)提供消息</li>
<li>它们共享一个有限缓冲池(bounded buffer pool)</li>
<li>生产者向其中投放消息，消费者从中取得消息</li>
<li>生产者-消费者问题是许多相互合作进程的一种抽象</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221103171832558.png" alt="image-20221103171832558" style="zoom:67%;" /></p></li>
<li><p>N个buffer，每个可以存储1个item</p>
<ol type="1">
<li>信号量<strong>full</strong>：初始化为0，表示已经使用的buffer个数</li>
<li>信号量<strong>empty</strong>：初始化为N，表示还未使用的buffer个数</li>
<li>信号量<strong>mutex</strong>：初始化为1，作为互斥信号量</li>
</ol></li>
<li><p>需要保证：</p>
<ol type="1">
<li>对同一个buffer的操作是互斥操作</li>
</ol></li>
<li><p>生产者进程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">	<span class="comment">// produce an item in nextp</span></span><br><span class="line">	...;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">wait</span>(empty);	<span class="comment">// 保证所有生产者插入的数量 &lt; 当前buffer的剩余空间的大小</span></span><br><span class="line">	<span class="built_in">wait</span>(mutex);	<span class="comment">// 保证互斥</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// add nextp to buffer</span></span><br><span class="line">	...;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">signal</span>(mutex);	<span class="comment">// 保证互斥</span></span><br><span class="line">    <span class="built_in">signal</span>(full);	<span class="comment">// 声明有一个数据插入到buffer中, 便于消费者的使用</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>消费者进程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="built_in">wait</span>(full);		<span class="comment">// 保证所有消费者使用的数量 &lt; 当前buffer中存在的数据数量</span></span><br><span class="line">	<span class="built_in">wait</span>(mutex);	<span class="comment">// 保证互斥</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// remove an item from buffer to nextc</span></span><br><span class="line">	...;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">signal</span>(mutex);	<span class="comment">// 保证互斥</span></span><br><span class="line">    <span class="built_in">signal</span>(empty);	<span class="comment">// 声明有一个buffer已经为空, 便于生产者使用</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// consume the item in nextc</span></span><br><span class="line">	...;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="读写问题readers-and-writers-problem">6.6.2 读写问题：Readers and
Writers Problem</h3>
<ol type="1">
<li>一个数据集（如文件）如果被几个并行进程所共享：
<ol type="1">
<li><strong>Reader</strong>：有些进程只要求读数据集内容，它称读者</li>
<li><strong>Writer</strong>：一些进程则要求修改数据集内容，它称写者</li>
<li>几个Reader可以同时读些数据集，而不需要互斥</li>
<li>一个Writer不能和其它进程（不管是写者或读者）同时访问些数据集，它们之间必须互斥</li>
</ol></li>
</ol>
<h4 id="第一readers-writers问题">6.6.2.1 第一Readers-Writers问题</h4>
<ol type="1">
<li><p>读优先，要求：</p>
<ol type="1">
<li>允许多个Reader同时阅读</li>
<li>同一时间只有一个写入程序可以访问共享数据</li>
<li>Writer能会挨饿</li>
</ol></li>
<li><p>共享数据：</p>
<ol type="1">
<li>Data set</li>
<li>信号量<strong>mutex</strong>：初始化为1，作为互斥信号量</li>
<li>信号量<strong>wrt</strong>：初始化为1，作为不同Writer之间的互斥信号量</li>
<li>整数<strong>readcount</strong>：初始化为0</li>
</ol></li>
<li><p>Writer进程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="built_in">wait</span> (wrt);		<span class="comment">// 有wrt锁时, Writer不能写</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// writing is performed</span></span><br><span class="line">    ...;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">signal</span> (wrt);	<span class="comment">// 释放wrt锁</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Reader进程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">wait</span>(mutex);	<span class="comment">// 对readcount的互斥锁</span></span><br><span class="line">    readcount++;</span><br><span class="line">    <span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="built_in">wait</span>(wrt); 	<span class="comment">// 第一个Reader到时</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex);	<span class="comment">// 释放对readcount的互斥锁</span></span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reading is performed</span></span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">wait</span>(mutex);	<span class="comment">// 对readcount的互斥锁</span></span><br><span class="line">    readcount--;</span><br><span class="line">    <span class="keyword">if</span>(readcount == <span class="number">0</span>) <span class="built_in">signal</span>(wrt);	<span class="comment">// 最后一个Reader离开时</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex);	<span class="comment">// 释放对readcount的互斥锁</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="第二readers-writers问题">6.6.2.2 第二Readers-Writers问题</h4>
<ol type="1">
<li>要求：
<ol type="1">
<li>一旦Writer准备好了，Writer就会尽快进行写作</li>
<li>Reader可能会饿死</li>
</ol></li>
</ol>
<h3 id="哲学家就餐问题dining-philosopher-problem">6.6.3
哲学家就餐问题：Dining-Philosopher Problem</h3>
<blockquote>
<p>多进程、多资源的同步问题</p>
</blockquote>
<ol type="1">
<li><p>问题说明：</p>
<ol type="1">
<li>n个哲学家坐在一个圆桌旁</li>
<li>每个哲学家与邻居共用一根筷子</li>
<li>每个哲学家都必须有一双筷子才能吃</li>
<li>邻居不能同时吃饭</li>
<li>哲学家在思考和吃饭之间交替</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221103174703952.png" alt="image-20221103174703952" style="zoom:67%;" /></p></li>
<li><p>共享数据：</p>
<ol type="1">
<li>信号量：chopstick[5]，初始值为1</li>
</ol></li>
<li><p>哲学家i：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 等待两只筷子的使用</span></span><br><span class="line">    <span class="built_in">wait</span>(chopstick[i]);</span><br><span class="line">    <span class="built_in">wait</span>(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用两只筷子</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">eat</span>();</span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明已经使用完两只筷子</span></span><br><span class="line">    <span class="built_in">signal</span>(chopstick[i]);</span><br><span class="line">    <span class="built_in">signal</span>(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不使用筷子的操作</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="built_in">think</span>();</span><br><span class="line">   	...;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>该方法很容易产生死锁</p>
<ol type="1">
<li>原因：两个wait语句并不是原子操作</li>
<li>例如：每个哲学家均拿起了自己左边的一根筷子</li>
</ol></li>
<li><p>避免死锁的方法：</p>
<ol type="1">
<li>同时只允许n-1个哲学家申请资源 ==&gt;
至少有一个哲学家拿到了2个筷子</li>
<li>奇数编号的哲学家先拿左边再拿右边，偶数编号的哲学家先拿右边再拿左边</li>
<li>把哲学家分为三种状态：思考、饥饿、吃饭，并且一次拿到两只筷子，否则不拿
<ol type="1">
<li>hungry状态唯有保证自己能够拿到2只筷子，才能进入eat状态</li>
<li>本质上是保证了两句wait的原子性</li>
</ol></li>
<li>每个哲学家拿起第1根筷子一定时间后，若拿不到第2根筷子，再放下第1根筷子
<ol type="1">
<li>但是可能大家一起拿一起放</li>
</ol></li>
</ol></li>
</ol>
<h2 id="monitors管程">6.7* Monitors(管程)</h2>
<p>管程是一种高级同步机制</p>
<ol type="1">
<li>管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程</li>
<li>管程可以函数库的形式实现</li>
<li>相比之下，管程比信号量好控制</li>
</ol>
<h3 id="信号量同步的缺点">6.7.1 信号量同步的缺点</h3>
<ol type="1">
<li>同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如wait、signal操作的次序错误、重复或遗漏）</li>
<li>可读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序</li>
<li>不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局</li>
<li>正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误</li>
</ol>
<h3 id="管程的引入">6.7.2 管程的引入</h3>
<blockquote>
<p>1973年，Hoare和Hanson所提出；其基本思想是把信号量及其操作原语封装在一个对象内部。即：将共享变量以及对共享变量能够进行的所有操作集中在一个模块中。</p>
</blockquote>
<ol type="1">
<li>管程的定义：管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块</li>
<li>管程可增强模块的独立性：系统按资源管理的观点分解成若干模块，用数据表示抽象系统资源，同时分析了共享资源和专用资源在管理上的差别，按不同的管理方式定义模块的类型和结构，使同步操作相对集中，从而增加了模块的相对独立性</li>
<li>引入管程可提高代码的可读性，便于修改和维护，正确性易于保证：采用集中式同步机制。一个操作系统或并发程序由若干个这样的模块所构成，一个模块通常较短，模块之间关系清晰</li>
</ol>
<h3 id="管程的主要特性">6.7.3 管程的主要特性</h3>
<ol type="1">
<li>模块化：一个管程是一个基本程序单位，可以单独编译</li>
<li>抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码</li>
<li>信息封装：管程是半透明的，管程中的外部过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的</li>
</ol>
<h3 id="管程的实现要素">6.7.4 管程的实现要素</h3>
<ol type="1">
<li>管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接地访问管程中的共享变量</li>
<li>为了保证管程共享变量的数据完整性，规定管程互斥进入</li>
<li>管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作</li>
</ol>
<h3 id="管程的的组成">6.7.5 管程的的组成</h3>
<ol type="1">
<li><strong>名称</strong>：为每个共享资源设立一个管程</li>
<li><strong>数据结构说明</strong>：一组局部于管程的控制变量</li>
<li><strong>操作原语</strong>：对控制变量和临界资源进行操作的一组原语过程（程序代码），是访问该管程的唯一途径。这些原语本身是互斥的，任一时刻只允许一个进程去调用，其余需要访问的进程就等待</li>
<li><strong>初始化代码</strong>：对控制变量进行初始化的代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">monitor monitor-name&#123;</span><br><span class="line">	shared variable declarations;</span><br><span class="line">	<span class="function">procedure body <span class="title">P1</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">procedure body <span class="title">P2</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function">procedure body <span class="title">Pn</span> <span class="params">(…)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		initialization code</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/AssetMarkdown/image-20221107145057689.png" alt="image-20221107145057689" style="zoom:80%;" /></p>
<h3 id="管程中的多个进程进入">6.7.6 管程中的多个进程进入</h3>
<ol type="1">
<li>当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权；当一个进入管程的进程执行唤醒操作时（如Ｐ唤醒Ｑ），管程中便存在两个同时处于活动状态的进程，如何处理？。</li>
<li>若进程P唤醒进程Q，则随后可有两种执行方式（进程P、Q都是管程中的进程）
<ol type="1">
<li>P等待，直到Q离开管程或下一次等待。Hoare采用。</li>
<li>Q等待，直到P离开管程或下一次等待。1980年，Lampson和Redell采用</li>
</ol></li>
<li><strong>入口等待队列(entry
queue)</strong>：因为管程是互斥进入的，所以当一个进程试图进入一个巳被占用的管程时它应当在管程的入口处等待，因而在管程的入口处应当有一个进程等待队列，称作入口等待队列</li>
<li><strong>紧急等待队列</strong>：如果进程Ｐ唤醒进程Ｑ，则Ｐ等待Ｑ继续，如果进程Ｑ在执行又唤醒进程Ｒ，则Ｑ等待Ｒ继续，...，如此，在管程内部，由于执行唤醒操作，可能会出现多个等待进程（已被唤醒，但由于管程的互斥进入而等待），因而还需要有一个进程等待队列，这个等待队列被称为紧急等待队列。它的优先级应当高于入口等待队列的优先级</li>
</ol>
<h3 id="条件变量condition">6.7.7 条件变量(condition)</h3>
<ol type="1">
<li>由于管程通常是用于管理资源的，因而在管程内部，应当存在某种等待机制。当进入管程的进程因资源被占用等原因不能继续运行时使其等待。为此在管程内部可以说明和使用一种特殊类型的变量---条件变量</li>
<li>每个条件变量表示一种等待原因，并不取具体数值---相当于每个原因对应一个队列</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221107145621005.png" alt="image-20221107145621005" style="zoom:80%;" /></p>
<h3 id="同步操作原语">6.7.8 同步操作原语</h3>
<ol type="1">
<li>同步操作原语wait和signal：针对条件变量x，x.wait()将自己阻塞在x队列中，x.signal()将x队列中的一个进程唤醒</li>
<li><strong>x.wait()</strong>：如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程排入x队列尾部
<ol type="1">
<li>紧急等待队列与x队列的关系：紧急等待队列是由于管程的互斥进入而等待的队列，而x队列是因资源被占用而等待的队列</li>
</ol></li>
<li><strong>x.signal()</strong>：如果x队列为空，则相当于空操作，执行此操作的进程继续；否则唤醒第一个等待者，执行x.signal()操作的进程排入紧急等待队列的尾部</li>
</ol>
<h3 id="用管程解决哲学家问题">6.7.9 用管程解决哲学家问题</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">monitor dp &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;thinking, hungry, eating&#125; state[<span class="number">5</span>];</span><br><span class="line">    condition self[<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickup</span><span class="params">(<span class="type">int</span> i)</span></span>; 	<span class="comment">// 哲学家i拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putdown</span><span class="params">(<span class="type">int</span> i)</span></span>; 	<span class="comment">// 哲学家i放下筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span>; 		<span class="comment">// 判断哲学家i是否可以拿起筷子</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化时, 所有哲学家均为thinking</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            state[i] = thinking;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哲学家i拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickup</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">		state[i] = hungry;		<span class="comment">// 将自己变为hungry状态</span></span><br><span class="line">		<span class="built_in">test</span>(i);				<span class="comment">// 判断自己是否能够拿起筷子</span></span><br><span class="line">		<span class="keyword">if</span> (state[i] != eating)	<span class="comment">// 如果不能, 把自己放进wait queue中</span></span><br><span class="line">			self[i].<span class="built_in">wait</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 哲学家i放下筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putdown</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">		state[i] = thinking;<span class="comment">// 将自己变为thinking状态, 即释放资源</span></span><br><span class="line">		<span class="built_in">test</span>((i+<span class="number">4</span>) % <span class="number">5</span>);	<span class="comment">// 判断左邻居是否能够拿起筷子</span></span><br><span class="line">		<span class="built_in">test</span>((i+<span class="number">1</span>) % <span class="number">5</span>);	<span class="comment">// 判断右邻居是否能够拿起筷子</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哲学家i是否可以拿起筷子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ( (state[(i + <span class="number">4</span>) % <span class="number">5</span>] != eating) &amp;&amp; 	<span class="comment">// 左边没有eating</span></span><br><span class="line">		  	 (state[i] == hungry) &amp;&amp;			<span class="comment">// 自己处于饥饿状态</span></span><br><span class="line">		  	 (state[(i + <span class="number">1</span>) % <span class="number">5</span>] != eating)		<span class="comment">// 右边没有eating</span></span><br><span class="line">           ) &#123;</span><br><span class="line">			state[i] = eating;</span><br><span class="line">			self[i].<span class="built_in">signal</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Philosopher i:</span></span><br><span class="line"><span class="keyword">do</span>&#123;  </span><br><span class="line">    dp.<span class="built_in">pickup</span>(i);</span><br><span class="line">    eat;</span><br><span class="line">    dp.<span class="built_in">putdown</span>(i);</span><br><span class="line">    think;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结-2">6.8 总结</h2>
<p><img src="/images/AssetMarkdown/image-20221107151133964.png" alt="image-20221107151133964" style="zoom:80%;" /></p>
<h1 id="chapter-7deadlocks死锁">Chapter 7：Deadlocks死锁</h1>
<h2 id="system-model">7.1 System Model</h2>
<p><img src="/images/AssetMarkdown/image-20221107152551989.png" alt="image-20221107152551989" style="zoom:80%;" /></p>
<ol type="1">
<li><strong>死锁</strong>：
<ol type="1">
<li>一组被阻塞的进程，每个进程持有一个资源，并等待获取该组中另一个进程持有的资源</li>
<li>指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</li>
</ol></li>
<li>系统模型
<ol type="1">
<li>资源类型<span class="math inline">\(R_1,R_2,...R_m\)</span>
<ol type="1">
<li>CPU时钟、内存空间、I/O设备</li>
</ol></li>
<li>每个资源类型<span class="math inline">\(R_i\)</span>可以有<span
class="math inline">\(W_i\)</span>个实例
<ol type="1">
<li>每种资源类型可以有多个实例</li>
<li>实例对应着实际能够分配的资源类型</li>
</ol></li>
<li>进程对资源的使用有以下三种类型
<ol type="1">
<li>Request 申请</li>
<li>Use 使用</li>
<li>Release 释放</li>
</ol></li>
</ol></li>
</ol>
<h2 id="死锁的特征">7.2 死锁的特征</h2>
<h3 id="产生死锁的4个必要条件">7.2.1 产生死锁的4个必要条件</h3>
<ol type="1">
<li><strong>Mutual exclusion</strong>互斥：
<ol type="1">
<li>同一时间只有一个进程能够使用一个资源实例</li>
</ol></li>
<li><strong>Hold and wait</strong>占有并等待、请求和保持：
<ol type="1">
<li>进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放</li>
</ol></li>
<li><strong>No preemption</strong>不可抢占、不剥夺：
<ol type="1">
<li>资源只能由持有该资源的进程在该进程完成任务后自愿释放</li>
</ol></li>
<li><strong>Circular wait</strong>循环等待：
<ol type="1">
<li>存在一组{P<sub>0</sub>，P<sub>1</sub>，…，P<sub>n</sub>}等待进程，使得P<sub>0</sub>正在等待P<sub>1</sub>所持有的资源，P<sub>1</sub>正在等待P<sub>2</sub>持有的资源，…，P<sub>n–1</sub>正在等待P<sub>n</sub>持有的资源，P<sub>n</sub>正在等待P<sub>0</sub>持有的</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221107153603565.png" alt="image-20221107153603565" style="zoom: 67%;" /></p>
<h3 id="资源分配图-resource-allocation-graph">7.2.2 资源分配图
Resource-Allocation Graph</h3>
<ol type="1">
<li><p>节点<span class="math inline">\(V\)</span>：</p>
<ol type="1">
<li>进程节点：P = {P<sub>1</sub>, P<sub>2</sub>, …, P<sub>n</sub>}</li>
<li>资源节点：R = {R<sub>1</sub>, R<sub>2</sub>, …, R<sub>m</sub>}</li>
</ol></li>
<li><p>边<span class="math inline">\(E\)</span>：</p>
<ol type="1">
<li>请求边：P<sub>i</sub> → R<sub>j</sub></li>
<li>分配边：R<sub>j</sub> → P<sub>i</sub></li>
</ol></li>
<li><p>节点&amp;边的图例</p>
<p><img src="/images/AssetMarkdown/image-20221107153842238.png" alt="image-20221107153842238" style="zoom: 67%;" /></p></li>
<li><p>例：</p>
<ol type="1">
<li>P<sub>1</sub>获取了R<sub>2</sub>资源，请求R<sub>1</sub>的资源</li>
<li>P<sub>2</sub>获取了R<sub>1</sub>、R<sub>2</sub>资源，请求R<sub>3</sub>资源</li>
<li>P<sub>3</sub>获取了R<sub>3</sub>资源</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221107153922149.png" alt="image-20221107153922149" style="zoom:67%;" /></p></li>
<li><p><img src="/images/AssetMarkdown/image-20221107154315836.png" alt="image-20221107154315836" style="zoom:80%;" /></p></li>
<li><p><img src="/images/AssetMarkdown/image-20221107154449530.png" alt="image-20221107154449530" style="zoom:80%;" /></p></li>
<li><p>判断条件</p>
<ol type="1">
<li>如果图中没有环 ==&gt; 没有死锁</li>
<li>如果图中有环
<ol type="1">
<li>如果每个资源只有一个实例 ==&gt; 死锁</li>
<li>如果每个资源拥有多个实例 ==&gt; 有可能死锁，也可能不死锁</li>
</ol></li>
</ol></li>
<li><p>死锁定理：</p>
<ol type="1">
<li><span class="math inline">\(S\)</span>为死锁状态的充分条件是：<span
class="math inline">\(S\)</span>状态的资源分配图是不可完全简化的</li>
<li>资源分配图（有向图）的简化：离散数学算法</li>
</ol></li>
</ol>
<h2 id="处理死锁的方法">7.3 处理死锁的方法</h2>
<ol type="1">
<li>保证系统不进入死锁状态
<ol type="1">
<li>Prevention死锁预防</li>
<li>Avoidance死锁避免</li>
</ol></li>
<li>允许系统进入死锁状态，然后恢复
<ol type="1">
<li>Detection死锁检测</li>
<li>Recovery死锁解除</li>
</ol></li>
<li>忽略死锁状态，操作系统假装不发生死锁，人为解决死锁状态</li>
</ol>
<h2 id="死锁预防-deadlock-prevention">7.4 死锁预防 Deadlock
Prevention</h2>
<ol type="1">
<li>不保证相互排斥(<strong>Mutual Exclusion</strong>)
<ol type="1">
<li>不需要可共享资源；必须保留不可分割的资源</li>
<li>虚拟化</li>
</ol></li>
<li>不保证保持等待(<strong>Hold and Wait</strong>)
<ol type="1">
<li>必须确保无论进程何时请求资源，它都不会保留任何其他资源</li>
<li>要求进程在开始执行之前请求并分配其所有资源，或者仅当进程没有资源时才允许进程请求资源</li>
<li>资源静态预分配方式</li>
<li>资源利用率低；可能导致饥饿</li>
</ol></li>
<li>允许抢占(<strong>No Preemption</strong>)
<ol type="1">
<li>如果持有某些资源的进程请求另一个无法立即分配给它的资源，那么当前持有的所有资源都将被释放</li>
<li>抢占的资源将添加到进程正在等待的资源列表中</li>
<li>只有当进程能够重新获得它的旧资源以及它所请求的新资源时，它才会重新启动</li>
</ol></li>
<li>保证不出现循环等待(<strong>Circular Wait</strong>)
<ol type="1">
<li>给所有资源类型的编号，并要求每个进程以递增的顺序请求资源</li>
<li>F(磁带驱动器)=1，F(磁盘驱动器)=5，F(打印机)=12</li>
<li>资源的有序申请破坏了循环等待条件</li>
</ol></li>
</ol>
<h2 id="死锁避免-deadlock-avoidance">7.5 死锁避免 Deadlock
Avoidance</h2>
<ol type="1">
<li>要求每个进程声明其可能需要的每种类型的最大资源数量</li>
<li>死锁避免算法动态检查资源分配状态，以确保永远不会出现循环等待条件</li>
<li>资源分配状态由可用和已分配资源的数量以及进程的最大需求来定义</li>
</ol>
<h3 id="安全状态-safe-state">7.5.1 安全状态 Safe State</h3>
<ol type="1">
<li><p>当进程请求可用资源时，系统必须决定立即分配是否使系统处于安全状态</p></li>
<li><p>安全状态是指系统的一种状态，在此状态开始系统能按某种顺序（如P<sub>1</sub>、P<sub>2</sub>……P<sub>n</sub>）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。</p>
<ol type="1">
<li>这个序列（P<sub>1</sub>、P<sub>2</sub>…….P<sub>n</sub>）称为安全序列</li>
<li>若系统此状态不存在一个安全序列，则称系统处于不安全状态</li>
<li>如果存在所有进程的安全序列，则系统处于安全状态</li>
</ol></li>
<li><p>序列（P<sub>1</sub>、P<sub>2</sub>……P<sub>n</sub>）是安全的，
满足：对于每个P<sub>i</sub>，P<sub>i</sub>仍然可以请求的资源，可以由<strong>当前可用资源+所有P<sub>j</sub>所持有的资源</strong>来满足，其中<strong>j＜i</strong>。</p>
<ol type="1">
<li>如果P<sub>i</sub>资源需求不立即可用，则P<sub>i</sub>可以等到所有P<sub>j</sub>完成</li>
<li>当P<sub>j</sub>完成时，P<sub>i</sub>可以获得所需的资源、执行、返回分配的资源并终止</li>
<li>当P<sub>i</sub>终止时，P<sub>i+1</sub>可以获得其所需的资源，依此类推</li>
</ol></li>
<li><p>定理</p>
<ol type="1">
<li>系统处于安全状态 ==&gt; 没有死锁</li>
<li>系统处于不安全状态 ==&gt; 可能死锁</li>
<li>死锁避免：保证系统不会进入不安全状态</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221110165653047.png" alt="image-20221110165653047" style="zoom:50%;" /></p></li>
<li><p>避免算法</p>
<ol type="1">
<li>每个资源只有一个实例：resource-allocation graph</li>
<li>每个资源有多个实例：banker’s algorithm</li>
</ol></li>
</ol>
<h3 id="resource-allocation-graph-algorithm-资源分配图算法">7.5.3
Resource-Allocation Graph Algorithm 资源分配图算法</h3>
<ol type="1">
<li><strong>需求边</strong>P<sub>i</sub>→R<sub>j</sub>：P<sub>i</sub>可能会请求资源R<sub>j</sub>，用虚线表示</li>
<li><strong>需求边</strong>转化为<strong>请求边</strong>：当且仅当该进程请求了该资源</li>
<li><strong>请求边</strong>转化为<strong>分配边</strong>：当且仅当资源被分配给了这个进程</li>
<li><strong>分配边</strong>转化为<strong>请求边</strong>：当且仅当资源被进程释放</li>
<li>资源必须在系统中声明优先级</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221110171751275.png" alt="image-20221110171751275" style="zoom:80%;" /></p>
<ol type="1">
<li>算法：假设进程P<sub>i</sub>申请资源R<sub>j</sub>。只有在需求边P<sub>i</sub>→R<sub>j</sub>变成分配边
R<sub>j</sub>→P<sub>i</sub>
而不会导致资源分配图形成环时，才允许申请。</li>
<li>用算法循环检测，如果没有环存在，那么资源分配会使系统处于安全状态。如果存在环，资源分配会使系统不安全。进程P<sub>i</sub>必须等待。</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221110172013247.png" alt="image-20221110172013247" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221110172028197.png" alt="image-20221110172028197" style="zoom:80%;" /></p>
<h3 id="bankers-algorithm-银行家算法">7.5.3 Banker’s Algorithm
银行家算法</h3>
<ol type="1">
<li>每个过程必须事先声明最大使用量</li>
<li>当进程请求资源时，它可能需要等待</li>
<li>当一个进程获得其所有资源时，它必须在有限的时间内返回这些资源</li>
<li>参数定义
<ol type="1">
<li><strong>n</strong>：进程数目</li>
<li><strong>m</strong>：资源的种类</li>
<li><strong>Available</strong>：长度为m的向量。如果Availabe[j]=k，表示R<sub>j</sub>有k个实例可以使用</li>
<li><strong>Max</strong>：n×m的矩阵。如果Max[i]
[j]=k，那么P<sub>i</sub>会申请至多k个R<sub>j</sub>资源</li>
<li><strong>Allocation</strong>：n×m的矩阵。如果Allocation[i]
[j]=k，那么P<sub>i</sub>已经申请了k个R<sub>j</sub>资源</li>
<li><strong>Need</strong>：n×m的矩阵。如果Need[i]
[j]=k，那么P<sub>i</sub>还需要k个R<sub>j</sub>资源来完成任务
<ol type="1">
<li>Need[i] [j] = Max[i] [j] - Allocation[i] [j]</li>
</ol></li>
</ol></li>
</ol>
<h4 id="safety-algorithm-安全算法">7.5.3.1 Safety Algorithm
安全算法</h4>
<ol type="1">
<li>令<strong>Work</strong>为一个长度为<strong>m</strong>的向量，<strong>Finish</strong>为一个长度为<strong>n</strong>的向量，初始化为：
<ol type="1">
<li>Work = Availabe</li>
<li>Finish[i] = { false }</li>
</ol></li>
<li>找到一个序号<strong>i</strong>，满足
<ol type="1">
<li>Finish[i] = false</li>
<li>Need[i] <span class="math inline">\(\le\)</span> Work</li>
<li>如果不存在，进入步骤4</li>
</ol></li>
<li><strong>Work = Work + Allocation[i]</strong>
<ol type="1">
<li>Finish[i] = true</li>
<li>返回步骤2</li>
</ol></li>
<li>如果<strong>Finish = { true }</strong>，则系统已经在安全状态</li>
</ol>
<h4 id="resource-request-algorithm-资源-请求算法">7.5.3.2
Resource-Request Algorithm 资源-请求算法</h4>
<p><strong>Request[i]</strong>：进程P<sub>i</sub>的请求向量，如果Request[i]
[j]=k，那么P<sub>i</sub>想要申请k个R<sub>j</sub>资源</p>
<ol type="1">
<li><p>如果Request[i] <span class="math inline">\(\le\)</span>
Need[i]，则进入步骤2。否则，引发错误条件，因为进程已超过其最大声明</p></li>
<li><p>如果Request[i] <span class="math inline">\(\le\)</span>
Availabe，则进入步骤3。否则，P<sub>i</sub>必须等待，因为资源不能满足需求</p></li>
<li><p>通过如下修改状态，尝试将请求的资源分配给P<sub>i</sub></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available = Available - Request[i];</span><br><span class="line">Allocation[i] = Allocation[i] + Request[i];</span><br><span class="line">Need[i] = Need[i] - Request[i];</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>调用<strong>Safety Algorithm</strong></li>
<li>如果安全，则可以分配给P<sub>i</sub></li>
<li>如果不安全，则P<sub>i</sub>必须等待，并恢复旧的资源分配状态</li>
</ol></li>
</ol>
<h4 id="例">7.5.3.3 例</h4>
<p><img src="/images/AssetMarkdown/image-20221110174813937.png" alt="image-20221110174813937" style="zoom:80%;" /></p>
<ol type="1">
<li><p>系统的状态（是否安全）？</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221110174824533.png" alt="image-20221110174824533" style="zoom:80%;" /></th>
</tr>
</thead>
<tbody>
</tbody>
</table></li>
<li><p>P1的请求(1,0,2)是否通过？</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221114144616824.png" alt="image-20221114144616824" style="zoom:80%;" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221114145030851.png" alt="image-20221114145030851" style="zoom: 80%;" /></td>
</tr>
</tbody>
</table></li>
<li><p>P4的请求(3,3,0)是否通过？</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221114150016856.png" alt="image-20221114150016856" style="zoom:80%;" /></th>
</tr>
</thead>
<tbody>
</tbody>
</table></li>
<li><p>P0的请求(0,2,0)是否通过？</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221114150041457.png" alt="image-20221114150041457" style="zoom:80%;" /></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221114150056267.png" alt="image-20221114150056267" style="zoom:80%;" /></td>
</tr>
</tbody>
</table></li>
</ol>
<h2 id="死锁检测-deadlock-detection">7.6 死锁检测 Deadlock
Detection</h2>
<h3 id="每个资源只有一个实例">7.6.1 每个资源只有一个实例</h3>
<ol type="1">
<li>维护一个等待图wait-for-graph：资源分配图的变形
<ol type="1">
<li>节点：进程</li>
<li>边：P<sub>i</sub>→P<sub>j</sub>表示P<sub>i</sub>正在等待P<sub>j</sub>释放资源</li>
</ol></li>
<li>定期调用检测图中是否存在环的算法</li>
<li>检测图中是否存在环的算法为O(n<sup>2</sup>)，其中n是图中顶点的数量</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221114151401765.png" alt="image-20221114151401765" style="zoom:80%;" /></p>
<h3 id="每个资源有多个实例">7.6.2 每个资源有多个实例</h3>
<ol type="1">
<li>数据结构：
<ol type="1">
<li><strong>Available</strong>：长度为m的向量。如果Availabe[j]=k，表示R<sub>j</sub>有k个实例可以使用</li>
<li><strong>Allocation</strong>：n×m的矩阵。如果Allocation[i]
[j]=k，那么P<sub>i</sub>已经申请了k个R<sub>j</sub>资源</li>
<li><strong>Request</strong>：n×m的矩阵。如果Request[i]
[j]=k，那么P<sub>i</sub>正在申请k个R<sub>j</sub>资源</li>
</ol></li>
<li>检测算法：O(m×n<sup>2</sup>)
<ol type="1">
<li>令<strong>Work</strong>为一个长度为<strong>m</strong>的向量，<strong>Finish</strong>为一个长度为<strong>n</strong>的向量，初始化为：
<ol type="1">
<li>Work = Availabe</li>
<li>Finish[i] = { Allocation[k] [i]==0 ? true : false }</li>
</ol></li>
<li>找到一个序号<strong>i</strong>，满足
<ol type="1">
<li>Finish[i] = false</li>
<li>Request[i] <span class="math inline">\(\le\)</span> Work</li>
<li>如果不存在，进入步骤4</li>
</ol></li>
<li><strong>Work = Work + Allocation[i]</strong>
<ol type="1">
<li>Finish[i] = true</li>
<li>返回步骤2</li>
</ol></li>
<li>如果存在<strong>Finish[i] ==
false</strong>，则系统处于死锁状态，且是P<sub>i</sub>被死锁</li>
</ol></li>
</ol>
<h3 id="示例-4">7.6.3 示例</h3>
<ol type="1">
<li><p>一共5个进程：P<sub>0</sub>~
P<sub>4</sub>，3中资源：A(7个示例)、B(2个示例)、C(6个示例)</p></li>
<li><p>T<sub>0</sub>时的snapshot：</p>
<p><img src="/images/AssetMarkdown/image-20221114152426673.png" alt="image-20221114152426673" style="zoom:80%;" /></p>
<ol type="1">
<li>执行序列：P<sub>0</sub>, P<sub>2</sub>, P<sub>3</sub>,
P<sub>1</sub>, P<sub>4</sub></li>
</ol></li>
<li><p>T<sub>1</sub>时的snapshot：</p>
<p><img src="/images/AssetMarkdown/image-20221114152613665.png" alt="image-20221114152613665" style="zoom:80%;" /></p>
<ol type="1">
<li>将P<sub>0</sub>执行结束后，无法执行P<sub>1</sub>~
P<sub>4</sub>的任意一个进程，系统进入死锁状态</li>
<li>处于死锁状态的进程为P<sub>1</sub>~ P<sub>4</sub></li>
</ol></li>
</ol>
<h3 id="死锁检测算法的使用">7.6.4 死锁检测算法的使用</h3>
<ol type="1">
<li>死锁检测算法的使用频率，取决于死锁发生的频率、希望有多少进程需要被回滚
<ol type="1">
<li>死锁发生的频率越高，死锁检测算法的使用频率越高</li>
<li>希望回滚的进程越少，死锁检测算法的使用频率越高</li>
</ol></li>
<li>如果随机调用检测算法，那么资源图中可能会有很多循环，因此我们将无法判断是哪个死锁进程“导致”了死锁</li>
</ol>
<h2 id="从死锁中恢复">7.7 从死锁中恢复</h2>
<ol type="1">
<li>检测到死锁后采取措施：
<ol type="1">
<li>通知系统管理员</li>
<li>系统自己恢复</li>
</ol></li>
<li>打破死锁两种方法：
<ol type="1">
<li>进程终止</li>
<li>抢占资源</li>
</ol></li>
</ol>
<h3 id="进程终止-process-termination">7.7.1 进程终止 Process
Termination</h3>
<ol type="1">
<li>中止所有死锁进程</li>
<li>一次中止一个进程，直到消除死锁循环</li>
<li>许多因素可能决定选择哪种进程，包括：
<ol type="1">
<li>进程的优先级</li>
<li>这个进程计算了多长时间，还有多长时间才能完成</li>
<li>进程使用的资源</li>
<li>资源进程需要完成</li>
<li>需要终止多少进程</li>
<li>该进程是交互式的还是批处理的</li>
</ol></li>
</ol>
<h3 id="抢占资源-resource-preemption">7.7.2 抢占资源 Resource
Preemption</h3>
<ol type="1">
<li>选择受害者：将成本降至最低最小化代价</li>
<li>回滚rollback： 返回到某个安全状态，从该状态重新启动进程。</li>
<li>饥饿starvation：同样的过程可能总是被选为受害者，包括成本因素中的回滚次数。</li>
</ol>
<h1 id="chapter-8main-memory">Chapter 8：Main Memory</h1>
<h2 id="background-1">8.1 Background</h2>
<ol type="1">
<li>程序必须（从磁盘）放入内存，并放置在进程中才能运行</li>
<li>CPU只能直接访问主存储器和寄存器</li>
<li>寄存器访问的时间：1个CPU clock</li>
<li>主存储器访问的时间：需要很多周期</li>
<li>cache位于主内存和CPU寄存器之间</li>
<li>确保正确操作所需的内存保护</li>
</ol>
<h3 id="存储架构">8.1.1 存储架构</h3>
<p><img src="/images/AssetMarkdown/image-20221117163742987.png" alt="image-20221117163742987" style="zoom:80%;" /></p>
<h3 id="主存">8.1.2 主存</h3>
<p>基于冯·诺依曼体系结构，数据和程序指令存在于共享内存空间中</p>
<ol type="1">
<li>程序重复执行以下内容：fetch-decode-execute</li>
<li>执行部分通常需要：数据获取和存储操作</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117163934518.png" alt="image-20221117163934518" style="zoom:80%;" /></p>
<h3 id="逻辑地址-vs-物理地址">8.1.3 逻辑地址 vs 物理地址</h3>
<ol type="1">
<li><strong>Logical
address</strong>(逻辑地址，相对地址，虚地址)：generated by the CPU; also
referred to as virtual address
<ol type="1">
<li>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式。</li>
<li>其首地址为0，其余指令中的地址都相对于首地址来编址。</li>
<li>不能用逻辑地址在内存中读取信息。</li>
</ol></li>
<li><strong>Physical address</strong>(物理地址，绝对地址，实地址)
：address seen by the memory unit
<ol type="1">
<li>内存中存储单元的地址。物理地址可直接寻址</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117164559398.png" alt="image-20221117164559398" style="zoom:80%;" /></p>
<h3 id="基址寄存器限长寄存器">8.1.4 基址寄存器、限长寄存器</h3>
<p>基址寄存器base register、限长寄存器limit
register：定义了逻辑内存空间</p>
<p><img src="/images/AssetMarkdown/image-20221117164654643.png" alt="image-20221117164654643" style="zoom:80%;" /></p>
<h3 id="将指令和数据与内存绑定">8.1.5 将指令和数据与内存绑定</h3>
<p>Address
binding(地址绑定、地址映射、重定位)：指令和数据到内存地址的转换可以在三个不同的阶段进行</p>
<ol type="1">
<li>编译时间：
<ol type="1">
<li>如果内存位置先验已知，则可以生成绝对代码</li>
<li>如果开始位置更改，则必须重新编译代码</li>
</ol></li>
<li>加载时间：
<ol type="1">
<li>如果编译时内存位置未知，则必须生成可<strong>重定位代码 relocatable
code</strong></li>
</ol></li>
<li>执行时间：
<ol type="1">
<li>如果进程在执行过程中可以从一个内存段移动到另一个内存，则绑定延迟到运行时</li>
<li>需要地址映射的硬件支持（如：Base and Limit Registers）</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117165240437.png" alt="image-20221117165240437" style="zoom:67%;" /></p>
<h3 id="memory-management-unit-mmu">8.1.6 Memory-Management Unit
(MMU)</h3>
<ol type="1">
<li>将虚拟地址映射到物理地址的硬件设备</li>
<li>在MMU方案中，重定位寄存器(relocation
register)中的值被添加到用户进程在发送到内存时生成的每个地址</li>
<li>用户程序处理逻辑地址；它永远看不到真实的物理地址</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117165947940.png" alt="image-20221117165947940" style="zoom:80%;" /></p>
<h3 id="dynamic-loading-动态载入">8.1.7 Dynamic Loading 动态载入</h3>
<ol type="1">
<li>使用动态加载，进程启动时不会加载外部库
<ol type="1">
<li>库以可重定位的形式存储在磁盘上</li>
<li>仅在需要时将库加载到内存中</li>
</ol></li>
<li>更好的内存空间利用率；从未加载未使用的例程</li>
<li>当需要大量代码来处理不经常发生的情况时很有用</li>
<li>无需通过程序设计实现操作系统的特殊支持</li>
</ol>
<h3 id="dynamic-linking-动态链接">8.1.8 Dynamic Linking 动态链接</h3>
<ol type="1">
<li>使用动态链接，可以将外部库预加载到（共享）内存中
<ol type="1">
<li>当进程调用库函数时，确定相应的物理地址</li>
</ol></li>
<li>一小段代码 (stub) 用于定位适当的内存驻留库例程</li>
<li>Stub用例程的地址替换自身，并执行例程</li>
<li>操作系统需要检查例程是否在进程的内存地址中</li>
<li>动态链接对库的调用特别有用</li>
<li>这种模式也称为共享库</li>
<li>Dynamically Linked Library 动态链接库</li>
</ol>
<h2 id="swapping-交换技术">8.2 Swapping 交换技术</h2>
<h3 id="交换技术">8.2.1 交换技术</h3>
<ol type="1">
<li>进程可以临时从内存中交换到后备存储，然后再带回内存中继续执行</li>
<li>Backing
store备份存储：足够大的快速磁盘，可容纳所有用户的所有内存映像副本；必须提供对这些内存映像的直接访问
<ol type="1">
<li>Linux、UNIX-交换区</li>
<li>Windows-交换文件（pagefile.sys）</li>
</ol></li>
<li>Roll out，Roll in(调出，调进)
<ol type="1">
<li>用于基于优先级的调度算法的交换变量</li>
<li>低优先级进程被交换出去，以便可以加载和执行高优先级进程</li>
</ol></li>
<li>交换时间的主要部分是传输时间；总传输时间与交换的内存量成正比</li>
<li>在许多系统（如UNIX、Linux和Windows）上都可以找到经过修改的交换版本</li>
<li>系统维护一个准备好运行的进程队列，这些进程在磁盘上具有内存映像</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117171601893.png" alt="image-20221117171601893" style="zoom:80%;" /></p>
<h3 id="不同操作系统的swapping">8.2.2 不同操作系统的Swapping</h3>
<ol type="1">
<li>UNIX, Linux, and Windows：
<ol type="1">
<li>正常情况下，禁止交换</li>
<li>当空闲内存低于某一个阈值时，启用交换换出</li>
<li>当空闲内存增加一定数量时，停止换出</li>
</ol></li>
<li>移动系统不支持交换，Flash memory based：
<ol type="1">
<li>小空间</li>
<li>闪存写次数限制</li>
<li>在移动平台上闪存和CPU之间的吞吐量很低</li>
</ol></li>
<li>iOS要求应用程序自愿放弃分配的内存
<ol type="1">
<li>只读数据从系统中直接删除，已修改数据不会被删除</li>
<li>OS可以终止任何未能释放足够空间的应用</li>
</ol></li>
<li>Android如果空闲内存不足，会终止应用程序，但首先会将应用程序状态写入闪存，以便快速重启</li>
</ol>
<h2 id="contiguous-allocation-连续分配">8.3 Contiguous Allocation
连续分配</h2>
<h3 id="连续分配">8.3.1 连续分配</h3>
<ol type="1">
<li>主内存通常分为两个分区(分区):
<ol type="1">
<li>Resident operating
system常驻操作系统：通常保存在具有中断向量的低内存中</li>
<li>User processes用户进程：保存在高内存中</li>
</ol></li>
<li>Relocation registers
重新定位寄存器：用于保护用户进程彼此不受影响，以及防止操作系统代码和数据发生变化
<ol type="1">
<li>Base register基址寄存器：包含最小物理地址的值</li>
<li>Limit
register限制寄存器：包含逻辑地址范围–每个逻辑地址必须小于限制寄存器</li>
<li>MMU动态映射逻辑地址</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117172600963.png" alt="image-20221117172600963" style="zoom:67%;" /></p>
<h3 id="multiple-partition-allocation-多分区分配">8.3.2
Multiple-partition allocation 多分区分配</h3>
<p>分区式管理的基本思想是将内存划分成若干个连续区域，称为分区。每个分区只能存放一个进程</p>
<h4 id="fixed-partitioning-固定分区">8.3.2.1 Fixed Partitioning
固定分区</h4>
<ol type="1">
<li>预先将内存空间切分成多个分区，当进程需要分区时，将一个大小匹配的分区分配给它</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117173040646.png" alt="image-20221117173040646" style="zoom:67%;" /></p>
<h4 id="dynamic-partitions-动态分区">8.3.2.2 Dynamic Partitions
动态分区</h4>
<ol type="1">
<li><p>动态划分内存，在程序装入内存时把可用内存“切出”一个连续的区域分配给该进程，且分区大小正好适合进程的需要</p></li>
<li><p>操作系统需要维护的信息包括：</p>
<ol type="1">
<li>allocated partitions 已分配的分区</li>
<li>free partitions (hole) 空闲的分区</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117173241390.png" alt="image-20221117173241390" style="zoom:80%;" /></p></li>
<li><p>如何满足free holes列表中大小为n的请求</p>
<ol type="1">
<li><p><strong>First-Fit</strong>：找到第一个能够满足要求的hole</p>
<p><img src="/images/AssetMarkdown/image-20221117173822733.png" alt="image-20221117173822733" style="zoom:67%;" /></p></li>
<li><p><strong>Best-Fit</strong>：找到能够满足要求的、最小的hole</p>
<p><img src="/images/AssetMarkdown/image-20221117173855252.png" alt="image-20221117173855252" style="zoom:67%;" /></p></li>
<li><p><strong>Worst-Fit</strong>：找到能够满足要求的、最大的hole</p>
<p><img src="/images/AssetMarkdown/image-20221117174055187.png" alt="image-20221117174055187" style="zoom: 67%;" /></p></li>
<li><p><strong>Next-Fit</strong>：从上次查找结束的地方开始，找到第一个能够满足要求的hole</p>
<p><img src="/images/AssetMarkdown/image-20221117174216889.png" alt="image-20221117174216889" style="zoom:67%;" /></p></li>
</ol></li>
</ol>
<h3 id="fragmentation-碎片">8.3.3 Fragmentation 碎片</h3>
<ol type="1">
<li><p>内存因碎片而浪费，这可能会导致性能问题</p>
<ol type="1">
<li>Internal
fragmentation(内碎片、内零头)：在单个进程内存空间中浪费内存</li>
<li>External fragmentation(外碎片、外零头)：可能会减少可运行进程的数量
<ol type="1">
<li>总内存剩余空间可以满足要求，但由于内存空间不连续，导致程序不能运行</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117174441628.png" alt="image-20221117174441628" style="zoom:80%;" /></p></li>
<li><p>通过压缩或整理碎片减少外部碎片(compaction or defragmentation
）</p>
<ol type="1">
<li>重新排列内存内容，将所有可用内存块组织在一个大块中</li>
<li>只有当重新定位是动态的并且在执行时完成时，才能进行压缩</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221117174612719.png" alt="image-20221117174612719" style="zoom:80%;" /></p></li>
</ol>
<h2 id="paging-分页页式存储管理">8.4 Paging 分页，页式存储管理</h2>
<h3 id="paging">8.4.1 Paging</h3>
<ol type="1">
<li>进程的物理地址空间可能是不连续的；只要物理内存可用，就为进程分配物理内存</li>
<li>将<strong>物理内存</strong>划分为固定大小的块，称为<strong>frames</strong>(帧、物理块、页框)
<ol type="1">
<li>大小为2的整数次幂，介于512 bytes和8192 bytes之间</li>
<li>Linux、Windows for x86：4K</li>
</ol></li>
<li>将<strong>逻辑内存</strong>分成与帧大小相同的块，称为<strong>pages</strong>(页）</li>
<li>使用paging的模式
<ol type="1">
<li>跟踪所有空闲帧</li>
<li>要运行n pages大小的程序，需要找到n个空闲的frames，然后加载程序
<ol type="1">
<li>如果找不到，可以使用swap技术，将一部分程序放进内存，另一部分程序放入swap区</li>
</ol></li>
<li>设置<strong>page table</strong>(页表)，将逻辑地址转换为物理地址
<ol type="1">
<li>page table 列出了进程的逻辑页与其在主存中的物理帧间的对应关系</li>
</ol></li>
</ol></li>
<li>会存在Internal fragmentation</li>
</ol>
<h3 id="noncontiguous-allocation-非连续内存分配">8.4.2 Noncontiguous
Allocation 非连续内存分配</h3>
<ol type="1">
<li>当一个进程需要n个page运行时，操作系统会找到n个空闲的frame</li>
<li>操作系统通过一个page table，跟踪页的使用</li>
<li>一般情况下，最后一个page都无法用满，但是系统依旧会给它分配一个frame
<ol type="1">
<li>会导致Internal fragmentation</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221121144118808.png" alt="image-20221121144118808" style="zoom:80%;" /></p>
<h3 id="逻辑和物理内存的分页模型">8.4.3 逻辑和物理内存的分页模型</h3>
<ol type="1">
<li><p>page table将逻辑内存地址映射到物理内存地址</p>
<p><img src="/images/AssetMarkdown/image-20221121144326270.png" alt="image-20221121144326270" style="zoom:67%;" /></p></li>
<li><p>例：进程<span
class="math inline">\(P_i\)</span>需要16字节的逻辑内存</p>
<ol type="1">
<li>逻辑内存通过页面表映射到32字节内存，页面大小为4字节</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221121144532110.png" alt="image-20221121144532110" style="zoom:67%;" /></p></li>
</ol>
<h3 id="address-translation-scheme-地址变换">8.4.4 Address Translation
Scheme 地址变换</h3>
<ol type="1">
<li><p>CPU生成的地址分为：</p>
<ol type="1">
<li>page
number(p)页号：用作页表的索引，该页表包含物理内存中每个页的基地址</li>
<li>page
offset(d)偏移：与基地址相结合以定义发送到存储器单元的物理存储器地址</li>
</ol></li>
<li><p>若page size = 2<sup>n</sup>，地址空间为
2<sup>m</sup>，则地址可以分为：</p>
<p><img src="/images/AssetMarkdown/image-20221121145047525.png" alt="image-20221121145047525" style="zoom:67%;" /></p></li>
<li><p>Paging Hardware</p>
<p><img src="/images/AssetMarkdown/image-20221121145916777.png" alt="image-20221121145916777" style="zoom: 67%;" /></p></li>
<li><p>页面大小为4KB，虚地址2362H、1565H的物理地址分别是？页表如下</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">页号</th>
<th style="text-align: center;">页框 (Page Frame)号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">101H</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">102H</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">254H</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>4KB=1000H</li>
<li>逻辑地址2362H对应的页号为2，254000H+362H = 254362H</li>
<li>逻辑地址1565H对应的页号为1，102000H+565H = 102565H</li>
</ol></li>
</ol>
<h3 id="page-table的实现">8.4.5 Page Table的实现</h3>
<ol type="1">
<li>页表保存在Main Memory中</li>
<li>页表基寄存器(<strong>PTBR</strong>, Page-table base
register)：指向页表，x86:cr3</li>
<li>页表长度寄存器(<strong>PTLR</strong>, Page-table length register
)：表示页表的大小</li>
<li>在该方案中，每个数据/指令访问都需要两次memory访问
<ol type="1">
<li>一个用于页表</li>
<li>一个用于数据/指令</li>
</ol></li>
<li>两次内存访问可以通过使用cache来加速，该cache被称为联想寄存器、快表
<ol type="1">
<li>associative memory</li>
<li>TLB：translation look-aside buffers</li>
</ol></li>
<li>一些TLB在每个TLB条目中存储地址空间标识符(ASID, address-space
identifiers)：唯一标识每个进程，为该进程提供地址空间保护</li>
</ol>
<h3 id="associative-memory">8.4.6 Associative Memory</h3>
<p><img src="/images/AssetMarkdown/image-20221121152152896.png" alt="image-20221121152152896" style="zoom:67%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221121152437668.png" alt="image-20221121152437668" style="zoom:67%;" /></p>
<ol type="1">
<li>并行查找：Address translation(p, d)
<ol type="1">
<li>如果p在Associative Memory中，则取出帧#</li>
<li>否则，从内存中的页表获取帧#</li>
</ol></li>
</ol>
<h3 id="effective-access-time-有效访问时间">8.4.7 Effective Access Time
有效访问时间</h3>
<ol type="1">
<li>快表访问时间：Associative Lookup = <span
class="math inline">\(\epsilon\)</span> time unit</li>
<li>内存访问时间：memory cycle time = <span
class="math inline">\(t\)</span><br />
</li>
<li>命中率：Hit ratio = <span class="math inline">\(\alpha\)</span></li>
<li>有效访问时间：EAT = <span
class="math inline">\((t+\epsilon)\alpha+(t+t+\epsilon)(1-\alpha)\)</span></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221121153123328.png" alt="image-20221121153123328" style="zoom:80%;" /></p>
<h3 id="memory-protection-内存保护">8.4.8 Memory Protection
内存保护</h3>
<ol type="1">
<li>通过将保护位与每个帧相关联来实现内存保护</li>
<li>Valid-invalid bit 附加到页表中每个条目：
<ol type="1">
<li>“valid”表示关联页面位于进程的逻辑地址空间中，因此是合法页面</li>
<li>“invalid”表示页面不在进程的逻辑地址空间中</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221121153531892.png" alt="image-20221121153531892" style="zoom:67%;" /></p>
<h3 id="共享页面">8.4.9 共享页面</h3>
<ol type="1">
<li>共享代码
<ol type="1">
<li>进程之间共享的只读代码的一个副本。</li>
<li><strong>共享代码</strong>必须出现在所有进程的<strong>逻辑地址空间中的同一位置</strong></li>
</ol></li>
<li>私有代码和数据
<ol type="1">
<li>每个进程都保留代码和数据的单独副本</li>
<li>私有代码和数据的页面可以出现在逻辑地址空间的任何位置</li>
</ol></li>
<li>重新输入代码(重入代码)、 纯代码(纯代码)</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221121153744348.png" alt="image-20221121153744348" style="zoom:80%;" /></p>
<h3 id="page-table的数据结构">8.4.10 Page Table的数据结构</h3>
<h4 id="分级页表-hierarchical-paging">8.4.10.1 分级页表 Hierarchical
Paging</h4>
<ol type="1">
<li><p>x86的逻辑地址空间有2<sup>32</sup>Byte，如页面大小为4KB（2<sup>12</sup>Byte），则页表项最多有1M（2<sup>20</sup>）个，每个页表项占用4Byte，故每个进程的页表占用4MB内存空间，还要求是连续的，显然这是不现实的。</p></li>
<li><p>将逻辑地址空间分解为多个页表</p>
<ol type="1">
<li>一种简单的技术是两级页表</li>
<li>Linux：四级页表</li>
<li>Windows：两级页表</li>
</ol></li>
<li><p>两级页表</p>
<p><img src="/images/AssetMarkdown/image-20221121154658709.png" alt="image-20221121154658709" style="zoom:67%;" /></p></li>
<li><p>两级页表示例：</p>
<ol type="1">
<li><p>逻辑地址（在具有4K页面大小的32位机器上）分为：</p>
<ol type="1">
<li>20-bit page number</li>
<li>12-bit page offset</li>
</ol></li>
<li><p>由于页表是分页的，页码进一步分为：</p>
<ol type="1">
<li>10-bit page number</li>
<li>10-bit page offset</li>
</ol></li>
<li><p>因此，逻辑地址如下：</p>
<p><img src="/images/AssetMarkdown/image-20221121154943437.png" alt="image-20221121154943437" style="zoom:50%;" /></p></li>
<li><p>其中p<sub>1</sub>是outer page table的索引，p<sub>2</sub>是page of
the page table的偏移量</p></li>
</ol></li>
<li><p>地址转换模式：</p>
<p><img src="/images/AssetMarkdown/image-20221124162941866.png" alt="image-20221124162941866" style="zoom:67%;" /></p></li>
<li><p>三级Page</p>
<p><img src="/images/AssetMarkdown/image-20221124163748171.png" alt="image-20221124163748171" style="zoom:67%;" /></p></li>
</ol>
<h4 id="哈希页表-hashed-page-tables">8.4.10.2 哈希页表 Hashed Page
Tables</h4>
<ol type="1">
<li>通常情况下，地址空间&gt;32位</li>
<li>虚拟页码被hash到页表中
<ol type="1">
<li>此页表包含hash到同一位置的元素链</li>
</ol></li>
<li>在此链中比较虚拟页码以搜索匹配项
<ol type="1">
<li>如果找到匹配，则提取相应的物理帧</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221124164131844.png" alt="image-20221124164131844" style="zoom:80%;" /></p>
<h4 id="反向反置页表-inverted-page-table">8.4.10.3 反向(反置)页表
Inverted Page Table</h4>
<ol type="1">
<li>每个进程均有一个页表，想要让所有进程共享一个页表</li>
<li>每个进程自己的page number都是从0开始，但是所有进程的page
number均会映射到唯一的frame number</li>
<li>在Inverted Page Table中，索引对应物理内存中的frame
number，值对应进程+virtual number</li>
<li>进程在找frame时，需要遍历Inverted Page Table，十分耗时</li>
<li>通过hash table降低遍历所需时间</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221124164727384.png" alt="image-20221124164727384" style="zoom:80%;" /></p>
<h2 id="segmentation-分段段式管理">8.5 Segmentation 分段，段式管理</h2>
<blockquote>
<p>将同一类别的数据，放到对应大小的连续的内存空间</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221124165904816.png" alt="image-20221124165904816" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221124170112955.png" alt="image-20221124170112955" style="zoom:80%;" /></p>
<h3 id="segmentation-architecture">8.5.1 Segmentation Architecture</h3>
<ol type="1">
<li><p>逻辑地址分为两个部分：段号+段内地址</p>
<p><img src="/images/AssetMarkdown/image-20221124170223059.png" alt="image-20221124170223059" style="zoom:80%;" /></p></li>
<li><p><strong>Segment
table</strong>(段表)：映射二维物理地址；每个entry具有：</p>
<ol type="1">
<li><strong>base</strong>：包含段在内存中的起始物理地址</li>
<li><strong>limit</strong>：指定段的长度</li>
</ol></li>
<li><p><strong>Segment-table base
register(STBR)</strong>段表基址寄存器：指向段表在内存中的位置</p></li>
<li><p><strong>Segment-table length
register(STLR)</strong>段表限长寄存器：指示程序使用的段数；</p>
<ol type="1">
<li>如果<strong>s&lt;STLR</strong>，则段号s合法</li>
</ol></li>
<li><p>保护：</p>
<ol type="1">
<li>Segment table中的每一个entry都会包含：
<ol type="1">
<li>有效位 validation bit：为0时表示该segment无效</li>
<li>读/写/执行 权限</li>
</ol></li>
<li>保护位与段相关；代码共享发生在段级别</li>
<li>由于段的长度不同，内存分配是一个动态存储分配问题</li>
<li>下图显示了一个分段示例</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221124170509111.png" alt="image-20221124170509111" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221124170958507.png" alt="image-20221124170958507" style="zoom:80%;" /></p>
<h2 id="example-the-intel-pentium">8.6 Example: The Intel Pentium</h2>
<ol type="1">
<li>支持分段和分页分段</li>
<li>CPU生成逻辑地址
<ol type="1">
<li>给分段单元
<ol type="1">
<li>产生线性地址</li>
</ol></li>
<li>将线性地址给到paging unit
<ol type="1">
<li>在主内存中生成物理地址</li>
<li>paging units相当于MMU</li>
</ol></li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221124172249080.png" alt="image-20221124172249080" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221124172256488.png" alt="image-20221124172256488" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221124172318435.png" alt="image-20221124172318435" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221124172324503.png" alt="image-20221124172324503" style="zoom:80%;" /></p>
<h1 id="chapter-9virtual-memory">Chapter 9：Virtual Memory</h1>
<h2 id="background-2">9.1 Background</h2>
<h4 id="virtual-memory">9.1.1 Virtual Memory</h4>
<ol type="1">
<li>Virtual Memory：只有运行程序的一部分需要加载到内存中执行
<ol type="1">
<li>虚拟内存将用户逻辑内存与物理内存分开</li>
<li>逻辑（或虚拟）地址空间可以大于物理地址空间</li>
<li>允许多个进程共享物理地址空间</li>
<li>实现更快的流程创建</li>
</ol></li>
<li>Virtual Memory的实现方法：
<ol type="1">
<li>Demand paging （请求调页，按需调页，请求页式管理）</li>
<li>0Demand segmentation（请求段式管理）</li>
</ol></li>
</ol>
<h3 id="局部性原理">9.1.2 局部性原理</h3>
<ol type="1">
<li><strong>局部性原理</strong>(principle of
locality)：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。表现为：
<ol type="1">
<li><strong>时间局部性</strong>：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内</li>
<li><strong>空间局部性</strong>：当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内</li>
</ol></li>
<li><strong>虚拟存储器</strong>是具有请求调入功能和置换功能，能仅把进程的一部分装入内存便可运行进程的存储管理系统，它能从逻辑上对内存容量进行扩充的一种虚拟的存储器系统</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221128142639363.png" alt="image-20221128142639363" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221128142607160.png" alt="image-20221128142607160" style="zoom: 80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221128142621439.png" alt="image-20221128142621439" style="zoom:80%;" /></p>
<h2 id="demand-paging按需调页请求调页">9.2 Demand
Paging：按需调页、请求调页</h2>
<h3 id="demand-paging">9.2.1 Demand Paging</h3>
<ol type="1">
<li>仅在需要时将页面放入内存
<ol type="1">
<li>所需I/O更少</li>
<li>所需内存更少</li>
<li>更快的响应</li>
<li>更多用户</li>
</ol></li>
<li>需要页面 → 对它的引用
<ol type="1">
<li>无效的引用 → abort</li>
<li>不在内存中 → bring to memory</li>
</ol></li>
<li>Lazy swapper：除非需要页面，否则永远不要将页面交换到内存中
<ol type="1">
<li>处理页面的swapper是一个pager</li>
</ol></li>
</ol>
<blockquote>
<p>Transfer of a Paged Memory to Contiguous Disk Space</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221128142844807.png" alt="image-20221128142844807" style="zoom:80%;" /></p>
<h3 id="valid-invalid-bit">9.2.2 Valid-Invalid Bit</h3>
<ol type="1">
<li><p>每个页表条目都有一个Valid-Invalid Bit：v → 在内存中，i →
不在内存中</p></li>
<li><p>初始化：所有条目上的Valid-Invalid Bit设置为i</p></li>
<li><p>页表快照示例：</p>
<p><img src="/images/AssetMarkdown/image-20221128143549825.png" alt="image-20221128143549825" style="zoom:80%;" /></p></li>
<li><p>在地址转换期间，如果页表条目中的Valid-Invalid Bit为i → page
fault</p></li>
</ol>
<blockquote>
<p>Page Table When Some Pages Are Not in Main Memory</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221128143601069.png" alt="image-20221128143601069" style="zoom:80%;" /></p>
<h3 id="更完整的页表">9.2.3 更完整的页表</h3>
<p><img src="/images/AssetMarkdown/image-20221128143658452.png" alt="image-20221128143658452" style="zoom:80%;" /></p>
<ol type="1">
<li>在请求分页系统中的每个页表项如图所示：
<ol type="1">
<li><strong>状态位P</strong>(存在位)：用于指示该页是否已调入内存，供程序访问时参考</li>
<li><strong>访问字段A</strong>：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选换出页时参考。</li>
<li><strong>修改位R/W</strong>：表示该页在调入内存后是否被修改过</li>
<li><strong>外存地址</strong>：用于指出该页在外存上的地址，供调入该页时使用</li>
</ol></li>
</ol>
<h3 id="page-fault缺页">9.2.4 Page Fault：缺页</h3>
<p>如果存在对页面的引用，则对该页面的第一次引用将会产生：Page
Fault(缺页)</p>
<ol type="1">
<li>操作系统查看另一个表以决定：
<ol type="1">
<li>无效的引用 → abort</li>
<li>仅仅是不在内存中</li>
</ol></li>
<li>获取空帧</li>
<li>将page交换进frame</li>
<li>重置表格</li>
<li>设置Valid-Invalid Bit = v</li>
<li>重新启动导致页面错误的指令</li>
</ol>
<blockquote>
<p>Steps in Handling a Page Fault</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221128144328745.png" alt="image-20221128144328745" style="zoom:80%;" /></p>
<h3 id="demand-paging-performance">9.2.5 Demand Paging Performance</h3>
<ol type="1">
<li><p><strong>page fault rate</strong> p：</p>
<ol type="1">
<li>p=0.0：没有page fault</li>
<li>p=1.0：所有page均发生page fault</li>
<li>通常p很小</li>
</ol></li>
<li><p><strong>effective memory-access
time</strong>：<strong>EAT</strong></p>
<ol type="1">
<li>(1-p) × physical-memory-access + p × page-fault service time</li>
</ol></li>
<li><p><strong>page-fault service time</strong>：</p>
<ol type="1">
<li>page-fault-overhead + swap-page-out + swap-page-in +
restart-overhead</li>
</ol></li>
<li><p>要计算EAT，我们必须知道需要多少时间来处理page fault。page
fault导致以下操作顺序发生：</p>
<ol type="1">
<li>操作系统发生trap</li>
<li>保存用户寄存器和进程状态</li>
<li>确定中断是page fault</li>
<li>检查页面引用是否合法，并确定页面在磁盘上的位置</li>
<li>向空闲帧发出磁盘读取请求：
<ol type="1">
<li>在队列中等待设备，直到读取请求得到服务</li>
<li>等待设备查找时间和延迟时间</li>
<li>开始将page转移到free frame</li>
</ol></li>
<li>等待时，将CPU分配给其他用户（CPU调度，可选）</li>
<li>从磁盘中断（I/O完成）</li>
<li>为其他用户保存寄存器和进程状态（如果执行步骤6）</li>
<li>确定中断来自磁盘</li>
<li>更正页面表和其他表，以显示所需页面现在已在内存中</li>
<li>等待CPU再次分配给此进程</li>
<li>恢复用户寄存器、进程状态和新页表，然后恢复中断指令</li>
</ol></li>
<li><p>page-fault service time中的三个主要的部分</p>
<ol type="1">
<li>Service the page-fault interrupt：缺页中断服务时间</li>
<li>Read in the page：将缺页读入时间</li>
<li>Restart the process：重新启动进程时间</li>
</ol></li>
<li><p>示例：</p>
<p><img src="/images/AssetMarkdown/image-20221128145139548.png" alt="image-20221128145139548" style="zoom:80%;" /></p></li>
</ol>
<h2 id="process-creation">9.3 Process Creation</h2>
<ol type="1">
<li>虚拟内存在进程创建过程中提供了其他好处：Copy-on-Write写时拷贝</li>
<li>Copy-on-Write写时拷贝：允许父进程和子进程最初共享内存中的相同页面。如果任何一个进程修改了共享页面，则只复制该页面
<ol type="1">
<li>COW允许更高效的流程创建，因为只复制修改过的页面</li>
<li>可用页面是从一个清零页面池中分配的</li>
<li>Windows、Linux、Solaris</li>
</ol></li>
</ol>
<blockquote>
<p>Before Process 1 Modifies Page C</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221128150404451.png" alt="image-20221128150404451" style="zoom:80%;" /></p>
<blockquote>
<p>After Process 1 Modifies Page C</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221128150424447.png" alt="image-20221128150424447" style="zoom:80%;" /></p>
<h2 id="page-replacement-页面置换">9.4 Page Replacement 页面置换</h2>
<h3 id="page-replacement">9.4.1 Page Replacement</h3>
<p>如果没有free frame：</p>
<ol type="1">
<li>Page Replacement：在内存中找到一些页面，但没有真正使用，请将其替换
<ol type="1">
<li>算法</li>
<li>性能：需要寻找一个可能导致page fault最少的算法</li>
</ol></li>
<li>同一页可能会多次进入内存</li>
<li>通过修改 page-fault service routine
以实现页面替换，防止内存过度分配</li>
<li>使用<strong>modify(dirty)</strong>位减少页面传输的开销：只有修改过的页面才会写入磁盘</li>
<li>页面替换完成了逻辑内存和物理内存之间的分离：可以在较小的物理内存上提供较大的虚拟内存</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221128150907676.png" alt="image-20221128150907676" style="zoom:80%;" /></p>
<h3 id="页面置换的过程">9.4.2 页面置换的过程</h3>
<ol type="1">
<li>在磁盘上查找所需页面的位置</li>
<li>查找空闲帧：
<ol type="1">
<li>如果有空闲帧，请使用它</li>
<li>如果没有空闲帧，则使用页面替换算法选择victim frame</li>
<li>将victim page写入磁盘；相应地更改页面和框架表。</li>
</ol></li>
<li>将所需页面放入（新的）free frame；更新页面和框架表</li>
<li>重新启动流程</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221128152032875.png" alt="image-20221128152032875" style="zoom:80%;" /></p>
<h3 id="页面置换的算法">9.4.3 页面置换的算法</h3>
<ol type="1">
<li><p>希望page-fault rate最低</p></li>
<li><p>通过在一个特定的内存引用字符串(reference
string，引用串)并计算该字符串上的页面错误数，来判断算法的优劣</p></li>
<li><p>reference string：（每页100字节）</p>
<blockquote>
<p>0100, 0432, 0101, 0612, 0102, 0103, 0104, 0611, 0120</p>
<p>→ 1, 4, 1, 6, 1, 6, 1</p>
</blockquote></li>
<li><p>在我们的所有示例中，reference string为：</p>
<blockquote>
<p>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</p>
<p>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</p>
</blockquote></li>
<li><p>一般来说，帧数越多，page fault越小</p></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221128152212443.png" alt="image-20221128152212443" style="zoom:80%;" /></p>
<p>页面置换算法：</p>
<ol type="1">
<li>First-In-First-Out
Algorithm：<strong>FIFO</strong>，先进先出算法</li>
<li>Optimal Algorithm：<strong>OPT</strong>，最佳页面置换算法</li>
<li>Least Recently Used
Algorithm：<strong>LRU</strong>，最近最少使用算法</li>
<li>LRU Approximation Algorithms ：<strong>近似LRU算法</strong>
<ol type="1">
<li>Additional-Reference-Bits Algorithm</li>
<li>Second-Chance（clock） Algorithm</li>
<li>Enhanced Second-Chance Algorithm</li>
</ol></li>
<li>Counting-Base Page Replacement：
<ol type="1">
<li>Least Frequently Used
Algorithm：<strong>LFU</strong>，最不经常使用算法</li>
<li>Most Frequently Used
Algorithm：<strong>MFU</strong>，引用最多算法00000000000000000000000000</li>
</ol></li>
<li>Page Buffering Algorithm：页面缓冲算法</li>
</ol>
<h4 id="fifo算法">9.4.3.1 FIFO算法</h4>
<ol type="1">
<li>先进先出算法</li>
<li><strong>Belady’s Anomaly</strong>：更多的帧反而导致更多的page
fault</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221128152501463.png" alt="image-20221128152501463" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221128152640303.png" alt="image-20221128152640303" style="zoom:80%;" /></p>
<h4 id="optimal-page-replacement">9.4.3.2 Optimal Page Replacement</h4>
<ol type="1">
<li><strong>OPT</strong>(最佳页面置换算法)：选择距离下次使用最远的page进行替换</li>
<li>理论最优，但是实际情况中很难判断哪个page距离下次使用最远</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221128152939195.png" alt="image-20221128152939195" style="zoom:80%;" /></p>
<h4 id="lru算法">9.4.3.3 LRU算法</h4>
<ol type="1">
<li><p><strong>LRU</strong>(最近最少使用算法)：选择内存中<strong>最久没有引用</strong>的页面被置换</p>
<ol type="1">
<li>这是局部性原理的合理近似，性能接近最佳算法</li>
<li>但由于需要记录页面使用时间，硬件开销太大</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221128153815218.png" alt="image-20221128153815218" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221128154107099.png" alt="image-20221128154107099" style="zoom:80%;" /></p></li>
<li><p>如何获知“多长时间没引用”？</p>
<ol type="1">
<li>counter实现
<ol type="1">
<li>每个页面条目都有一个计数器；每次通过该条目引用页面时，将clock复制到计数器中</li>
<li>当需要更改页面时，查看计数器以确定要更改的页面</li>
</ol></li>
<li>stack实现：以双向链表形式保存页码堆栈
<ol type="1">
<li><p>引用的页面：</p>
<ol type="1">
<li>将其移至顶部</li>
<li>需要更改6个指针</li>
</ol></li>
<li><p>不搜索替换</p>
<p><img src="/images/AssetMarkdown/image-20221128154413987.png" alt="image-20221128154413987" style="zoom:67%;" /></p></li>
</ol></li>
</ol></li>
</ol>
<h4 id="lru-approximation-algorithms">9.4.3.4 LRU Approximation
Algorithms</h4>
<p><strong>Reference bit</strong></p>
<ol type="1">
<li>每个页表条目关联一个位，初始值为0</li>
<li>当页面被引用时，Reference bit设置为1</li>
<li>替换Reference bit为0的页（如果存在）</li>
<li>然而，我们不知道页被访问的顺序</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221201163509642.png" alt="image-20221201163509642" style="zoom:80%;" /></p>
<h5 id="additional-reference-bits-algorithm">9.4.3.4.1
Additional-Reference-Bits Algorithm</h5>
<p>附加引用位算法：</p>
<ol type="1">
<li>为内存中的表中的每一页保留8位字节</li>
<li>每隔一段时间（每100毫秒），timer中断将控制权转移到OS
<ol type="1">
<li>OS将每个页面的Reference
Bit移到其8位字节的最高位，将其他位右移1位，丢弃低位</li>
<li>这些8位字节包含过去8个clock的页面使用历史</li>
</ol></li>
<li>如果我们将这些8位字节解释为无符号整数，则编号最低的页面是LRU页面，可以替换</li>
<li>被访问时左边<strong>最高位置1</strong>，<strong>定期右移</strong>并且最高位补0，于是<strong>寄存器数值最小</strong>的是最久未使用页面。</li>
</ol>
<h5 id="second-chance-clock-algorithm">9.4.3.4.2 Second-Chance (clock)
Algorithm</h5>
<p>Second chance(clock算法)：</p>
<ol type="1">
<li>需要Reference Bit</li>
<li>循环替换</li>
<li>如果要替换的页面(按顺时钟顺序)的Reference Bit=1，则：
<ol type="1">
<li>将Reference Bit设置为0</li>
<li>将页面留在内存中</li>
<li>替换下一页(按顺时钟顺序)，遵循相同规则</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221201164212728.png" alt="image-20221201164212728" style="zoom:80%;" /></p>
<h5 id="enhanced-second-chance-algorithm">9.4.3.4.3 Enhanced
Second-Chance Algorithm</h5>
<p>增强二次机会算法（改进型的clock算法）</p>
<ol start="2" type="1">
<li>使用引用位和修改位：引用过或修改过置成1</li>
<li>(Reference bit, modified bit) ：
<ol type="1">
<li>(0,0)：最优先需要被替换的页</li>
<li>(0,1)：也可以被替换，但不如上一种更优</li>
<li>(1,0)：可能会马上被使用</li>
<li>(1,1)：最不应该被替换的页</li>
</ol></li>
<li>淘汰次序：(0,0) → (0,1) → (1,0) → (1,1)</li>
</ol>
<h4 id="counting-algorithm">9.4.3.5 Counting Algorithm</h4>
<ol type="1">
<li>记录每页的引用次数</li>
<li>LFU(Least Frequently Used) Algorithm
(最不经常使用算法)：替换被引用次数最少的页面</li>
<li>MFU(Most Frequently Used) Algorithm
(经常使用算法)：被引用次数最小的页面可能刚刚被引入，尚未被使用</li>
</ol>
<h4 id="page-buffering-algorithm-页面缓冲算法">9.4.3.6 Page Buffering
Algorithm 页面缓冲算法</h4>
<p>页面缓冲算法：通过被置换页面的缓冲，有机会找回刚被置换的页面</p>
<ol type="1">
<li>被置换页面的选择和处理：用FIFO算法选择被置换页，把被置换的页面放入两个链表之一。即：如果页面未被修改，就将其归入到<strong>空闲页面链表</strong>的末尾，否则将其归入到<strong>已修改页面链表</strong></li>
<li>需要调入新的页面时，将新页面内容读入到空闲页面链表的第一项所指的页面，然后将第一项删除</li>
<li>空闲页面和已修改页面，仍停留在内存中一段时间，如果这些页面被再次访问，这些页面还在内存中</li>
<li>当已修改页面达到一定数目后，再将它们一起调出到外存，然后将它们归入空闲页面链表</li>
</ol>
<h2 id="allocation-of-frames-帧分配">9.5 Allocation of Frames
帧分配</h2>
<h3 id="fixed-allocation-固定分配">9.5.1 Fixed Allocation 固定分配</h3>
<ol type="1">
<li>Equal allocation 平均分配法：将帧平均分配给每个进程</li>
<li>Proportional allocation 按比例分配法：根据进程的大小按比例分配</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221201170031536.png" alt="image-20221201170031536" style="zoom: 50%;" /></p>
<h3 id="priority-allocation-优先级分配">9.5.2 Priority Allocation
优先级分配</h3>
<ol type="1">
<li>根据进程的优先级，按比例分配</li>
<li>如果进程P<sub>i</sub>发生了page fault
<ol type="1">
<li>选择P<sub>i</sub>自己的一个帧进行替换</li>
<li>选择比P<sub>i</sub>优先级低的一个进程的一个帧进行替换</li>
</ol></li>
</ol>
<h3 id="global-vs.-local-allocation">9.5.3 Global vs. Local
Allocation</h3>
<p>置换策略：</p>
<ol type="1">
<li>Global replacement
全局置换：进程从所有帧的集合中选择替换帧；一个进程可以从另一个进程获取帧</li>
<li>Local replacement
局部置换：每个进程仅从其自己的一组分配帧中进行选择</li>
</ol>
<p>分配策略：</p>
<ol type="1">
<li>固定分配</li>
<li>可变分配</li>
</ol>
<h3 id="帧的分配和置换策略">9.5.4 帧的分配和置换策略</h3>
<p>组合成三种策略：</p>
<ol type="1">
<li>固定分配局部置换策略</li>
<li>可变分配全局置换策略</li>
<li>可变分配局部置换策略</li>
</ol>
<h2 id="thrashing-颠簸抖动">9.6 Thrashing 颠簸、抖动</h2>
<ol type="1">
<li>如果一个进程没有足够的page，则page-fault rate会很高，会导致：
<ol type="1">
<li>很低的CPU利用率</li>
<li>误导OS以为有必要提高多任务的程度</li>
<li>误导OS装入更多作业，内存中驻留更多进程</li>
<li>于是，每个进程拥有的页帧数更少</li>
<li>如此恶性循环，会怎样 ？</li>
</ol></li>
<li>Thrashing = a process is busy swapping pages in and out</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221201171543293.png" alt="image-20221201171543293" style="zoom:80%;" /></p>
<h3 id="demand-paging-and-thrashing">9.6.1 Demand Paging and
Thrashing</h3>
<ol type="1">
<li>为什么会有demand page work：局部性原理
<ol type="1">
<li>进程从一个位置迁移到另一个位置</li>
<li>地点可能重叠</li>
</ol></li>
<li>为什么会有trash：<span
class="math inline">\(\sum\)</span>locality的大小 &gt; 总内存大小</li>
</ol>
<h3 id="working-set-model">9.6.2 Working-Set Model</h3>
<ol type="1">
<li><strong>working
set(WS)</strong>工作集：在最近Δ次页访问的页的集合</li>
<li><strong>working-set window</strong>工作集窗口Δ：固定次数的页访问
<ol type="1">
<li>如：10000 instruction</li>
</ol></li>
<li><strong>WSS<sub>i</sub></strong> working set size of Process
P<sub>i</sub>工作集大小 = 在最近Δ时间内的页访问总次数
<ol type="1">
<li>如果Δ太小：不能表示整个局部空间</li>
<li>如果Δ太大：包括了多个局部空间</li>
<li>如果Δ=∞：包括了整个程序</li>
</ol></li>
<li><span class="math inline">\(D = \sum
WSS_i\)</span>：总共需要的帧；<span
class="math inline">\(m\)</span>：总共可用的帧
<ol type="1">
<li><span
class="math inline">\(D&gt;m\)</span>时，会出现Thrashing，需要减少进程数目</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221201173253855.png" alt="image-20221201173253855" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221201173542748.png" alt="image-20221201173542748" style="zoom:80%;" /></p>
<h3 id="page-fault-frequency-scheme-缺页频率">9.6.3 Page-Fault Frequency
Scheme 缺页频率</h3>
<p>缺页频率应该保证在一个区间</p>
<ol type="1">
<li>如果过低：从进程收回帧</li>
<li>如果过高：给进程分配帧</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221201173547998.png" alt="image-20221201173547998" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221201173554956.png" alt="image-20221201173554956" style="zoom:80%;" /></p>
<h2 id="memory-mapped-files">9.7 Memory-Mapped Files</h2>
<ol type="1">
<li>Memory-Mapped Files
I/O：通过将磁盘块映射到内存中的页面，允许将文件I/O视为例行内存访问</li>
<li>最初使用请求分页读取文件。文件的页面大小部分从文件系统读取到物理页面中。对文件的后续读/写被视为普通内存访问。</li>
<li>通过内存而不是read() write()
系统调用处理文件I/O，简化了文件访问</li>
<li>还允许多个进程映射同一文件，从而共享内存中的页面</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221201174152851.png" alt="image-20221201174152851" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221201174157228.png" alt="image-20221201174157228" style="zoom:80%;" /></p>
<h2 id="allocating-kernel-memory">9.8 Allocating Kernel Memory</h2>
<h3 id="allocating-kernel-memory-1">9.8.1 Allocating Kernel Memory</h3>
<ol type="1">
<li>与分配用户空间的方式不同</li>
<li>通常从空闲内存池分配
<ol type="1">
<li>内核根据结构，请求不同大小的内存</li>
<li>某些内核内存需要是连续的</li>
</ol></li>
</ol>
<h3 id="buddy-system">9.8.2 Buddy System</h3>
<ol type="1">
<li>从由物理上连续的页组成固定大小的段，然后分配内存</li>
<li>使用power-of-2 allocator分配内存
<ol type="1">
<li>每个单元的大小为2<sup>n</sup></li>
<li>每次分配内存的请求对齐到2<sup>n</sup>，如请求6，则分配2<sup>3</sup></li>
<li>当请求的内存比可用的段小时，当前段被分成两个2<sup>n-1</sup>的伙伴
<ol type="1">
<li>继续，直到大小合适的块可用</li>
</ol></li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221205142443883.png" alt="image-20221205142443883" style="zoom:80%;" /></p>
<h3 id="slab-allocator">9.8.3 Slab Allocator</h3>
<blockquote>
<p>另一种内存分配策略</p>
</blockquote>
<ol type="1">
<li>Slab：是一个或多个物理上连续的页面</li>
<li>Cache：由一个或多个slab组成</li>
<li>每个唯一内核数据结构 &lt;==&gt; 一个cache
<ol type="1">
<li>每个cache都填充了object：数据结构的实例</li>
</ol></li>
<li>创建cache时，填充标记为空闲的对象</li>
<li>存储结构时，对象标记为已使用</li>
<li>如果slab中充满了已使用的对象，则从空slab中分配下一个对象
<ol type="1">
<li>如果没有空slab，则分配新的slab</li>
</ol></li>
<li>优点：没有碎片、快速满足内存请求</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221205142954698.png" alt="image-20221205142954698" style="zoom:80%;" /></p>
<h2 id="other-considerations">9.9 Other Considerations</h2>
<h3 id="prepaging-预调页">9.9.1 Prepaging 预调页</h3>
<ol type="1">
<li>减少进程启动时出现的大量page-faults</li>
<li>在进程启用之前，预先将一些页调到内存中</li>
<li>但是如果预调页没有被使用，则会浪费I/O</li>
<li>假设预调页的页数为<span class="math inline">\(s\)</span>，其中<span
class="math inline">\(\alpha\)</span>个页被用到
<ol type="1">
<li>节省的page fault数：<span
class="math inline">\(s*\alpha\)</span></li>
<li>浪费的预调页：<span class="math inline">\(s*(1-\alpha)\)</span></li>
<li>如果<span
class="math inline">\(\alpha\)</span>接近0，则称为prepaging loses</li>
</ol></li>
</ol>
<h3 id="page-size-页大小">9.9.2 Page Size 页大小</h3>
<ol type="1">
<li>页大小会影响：
<ol type="1">
<li>碎片的大小 fragmentation：页越大，碎片越大</li>
<li>页表的大小：页越大，页表越小</li>
<li>I/O消耗：页越大，I/O消耗越大</li>
<li>局部性 Locality：如果页小于working set，则page fault会比较大</li>
</ol></li>
<li>增加页大小：
<ol type="1">
<li>会导致碎片的大小增加</li>
<li>并且并不是所偶有的应用程序都需要一个大的页大小</li>
</ol></li>
<li>提供多种页大小：
<ol type="1">
<li>这使得需要更大页大小的应用程序有机会在不增加碎片的情况下使用它们</li>
</ol></li>
</ol>
<h3 id="tlb范围">9.9.3 TLB范围</h3>
<ol type="1">
<li>TLB Reach：TLB能够到达的内存范围</li>
<li><strong>TLB Reach = TLB Size × Page Size</strong></li>
<li>理想情况下，每个进程的working set均存储在TLB中，否则page
fault会比较大</li>
</ol>
<h3 id="程序结构">9.9.4 程序结构</h3>
<ol type="1">
<li>遍历二维数组时，先枚举列还是先枚举行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">128</span>][<span class="number">128</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line">        data[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) </span><br><span class="line">        data[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="io锁定">9.9.5 I/O锁定</h3>
<ol type="1">
<li><strong>I/O Interlock</strong>：页面有时必须锁定在内存中</li>
<li>考虑I/O：用于从设备复制文件的页面必须被锁定，以防止页面替换算法被选中而替换</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221205145130942.png" alt="image-20221205145130942" style="zoom:67%;" /></p>
<h2 id="operating-system-examples-1">9.10 Operating System Examples</h2>
<h3 id="windows-xp">9.10.1 Windows XP</h3>
<ol type="1">
<li>Uses demand paging with <strong>clustering</strong>. Clustering
brings in pages surrounding the faulting page</li>
<li>Processes are assigned <strong>working set minimum</strong> and
<strong>working set maximum</strong></li>
<li>Working set minimum is the minimum number of pages the process is
guaranteed to have in memory</li>
<li>A process may be assigned as many pages up to its working set
maximum</li>
<li>When the amount of free memory in the system falls below a
threshold, <strong>automatic working set trimming</strong> is performed
to restore the amount of free memory</li>
<li>Working set trimming removes pages from processes that have pages in
excess of their working set minimum</li>
</ol>
<h3 id="solaris">9.10.2 Solaris</h3>
<ol type="1">
<li>Maintains a list of free pages to assign faulting processes</li>
<li><strong>Lotsfree</strong> – threshold parameter (amount of free
memory) to begin paging</li>
<li><strong>Desfree</strong> – threshold parameter to increasing
paging</li>
<li><strong>Minfree</strong> – threshold parameter to being
swapping</li>
<li>Paging is performed by pageout process</li>
<li>Pageout scans pages using modified clock algorithm</li>
<li>Scanrate is the rate at which pages are scanned. This ranges from
slowscan to fastscan</li>
<li>Pageout is called more frequently depending upon the amount of free
memory available</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221205145550355.png" alt="image-20221205145550355" style="zoom:80%;" /></p>
<h1 id="chapter-10file-system-interface">Chapter 10：File-System
Interface</h1>
<h2 id="file-concept">10.1 File Concept</h2>
<ol type="1">
<li><p>文件：是存储某种介质上的（如磁盘、光盘、SSD等）并具有文件名的一组相关信息的集合</p></li>
<li><p>一个文件是在某些硬件设施上的一系列字符</p>
<p><img src="/images/AssetMarkdown/image-20221205153235071.png" alt="image-20221205153235071" style="zoom:80%;" /></p></li>
<li><p>类型：</p>
<ol type="1">
<li>数据型：数字型、字符型、二进制型</li>
<li>程序型</li>
</ol></li>
</ol>
<h3 id="文件属性">10.1.1 文件属性</h3>
<ol type="1">
<li>Name：文件名</li>
<li>Identifier：文件标识，唯一标记文件系统中的文件</li>
<li>Type：文件类型，系统用于支持不同类型的文件</li>
<li>Location：文件在设备中的位置</li>
<li>Size：当前文件大小</li>
<li>Protection：控制谁可读/写/执行</li>
<li>Time, date, and user
identification：用于保护/安全/使用监视的数据</li>
<li>有关文件的信息保存在磁盘上维护的目录结构中</li>
</ol>
<h3 id="文件操作">10.1.2 文件操作</h3>
<p>文件是一个抽象数据类型</p>
<ol type="1">
<li>create</li>
<li>write</li>
<li>read</li>
<li>reposition within file</li>
<li>delete</li>
<li>truncate</li>
<li>open(F<sub>i</sub>)：在磁盘上的目录结构中搜索entry
Fi，并将条目的内容移动到内存中</li>
<li>close(F<sub>i</sub>)：将内存中entry
Fi的内容移动到磁盘上的目录结构</li>
</ol>
<h3 id="打开文件">10.1.3 打开文件</h3>
<p>用于打开文件的数据信息：</p>
<ol type="1">
<li><strong>File
pointer</strong>：指向文件打开的每个进程的最后一个读/写位置的指针</li>
<li><strong>File-open
count</strong>：文件打开次数的计数器，允许在最后一个进程关闭时从打开的文件表中删除数据</li>
<li><strong>Disk location of the file</strong>：数据访问信息缓存</li>
<li><strong>Access rights</strong>：每个进程访问模式信息</li>
</ol>
<h3 id="文件的内部结构">10.1.4 文件的内部结构</h3>
<ol type="1">
<li><strong>None</strong> 流文件结构
<ol type="1">
<li>一系列word/byte</li>
</ol></li>
<li><strong>Simple record structure</strong> 记录文件结构
<ol type="1">
<li>行</li>
<li>固定长度</li>
<li>可变长度</li>
</ol></li>
<li><strong>Complex Structures</strong>
<ol type="1">
<li>格式化文档</li>
<li>可重定位的加载文件</li>
</ol></li>
<li>通过插入适当的控制字符，可以使用第一种方法模拟后两种</li>
<li>Who decides:
<ol type="1">
<li>操作系统</li>
<li>对应程序</li>
</ol></li>
</ol>
<h2 id="access-methods">10.2 Access Methods</h2>
<ol type="1">
<li><p>Sequential Access 顺序存取</p>
<p><img src="/images/AssetMarkdown/image-20221208162949263.png" alt="image-20221208162949263" style="zoom: 50%;" /></p></li>
<li><p>Direct Access 直接存取</p>
<blockquote>
<p>使用Direct-access File模拟顺序存取</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221208163000966.png" alt="image-20221208163000966" style="zoom:50%;" /></p></li>
<li><p>Indexed sequential-acess 索引顺序</p>
<blockquote>
<p>Index and Relative File</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221208163009799.png" alt="image-20221208163009799" style="zoom:50%;" /></p></li>
</ol>
<h2 id="directory-structure-目录结构">10.3 Directory Structure
目录结构</h2>
<h3 id="目录结构">10.3.1 目录结构</h3>
<ol type="1">
<li><p>目录：一个节点的集合，包含所有文件的相关信息</p>
<p><img src="/images/AssetMarkdown/image-20221208163356292.png" alt="image-20221208163356292" style="zoom:80%;" /></p></li>
</ol>
<h3 id="磁盘结构">10.3.2 磁盘结构</h3>
<ol type="1">
<li>磁盘可以被分割为<strong>partitions(分区)</strong></li>
<li>磁盘/分区可以作为<strong>RAID</strong>来预防failure</li>
<li>磁盘/分区可以使用<strong>raw</strong>，即使没有文件系统 或者
没有被文件系统格式化过</li>
<li>分区，也被称为minidisk，slice</li>
<li>包含文件系统的示例被称为<strong>volume(卷)</strong></li>
<li>包含文件系统的每个卷还跟踪<strong>设备目录</strong>或<strong>卷目录</strong>中的文件系统信息</li>
<li>除了<strong>通用文件系统</strong>外，还有许多<strong>专用文件系统</strong>，通常都在同一操作系统或计算机中</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221208164020816.png" alt="image-20221208164020816" style="zoom:80%;" /></p>
<h3 id="目录的操作">10.3.3 目录的操作</h3>
<ol type="1">
<li>搜索文件</li>
<li>创建文件</li>
<li>删除文件</li>
<li>列出目录</li>
<li>重命名文件</li>
<li>遍历文件系统</li>
</ol>
<h3 id="文件目录的组织结构">10.3.4 文件目录的组织结构</h3>
<p>需要考虑以下问题：</p>
<ol type="1">
<li>查找效率：能够快速定位一个文件</li>
<li>重名：不同用户是否可以拥有同名文件，相同文件是否可以拥有不同名字</li>
<li>分组：通过文件的特性对文件分组</li>
</ol>
<h4 id="single-level-directory-单级目录">10.3.4.1 Single-Level Directory
单级目录</h4>
<p><img src="/images/AssetMarkdown/image-20221208164717968.png" alt="image-20221208164717968" style="zoom:67%;" /></p>
<ol type="1">
<li>重名：不同用户不能拥有同名文件，相同文件不能拥有不同名字</li>
<li>分组：不能按照文件类型进行分组</li>
</ol>
<h4 id="two-level-directory-二级目录">10.3.4.2 Two-Level Directory
二级目录</h4>
<p><img src="/images/AssetMarkdown/image-20221208164843650.png" alt="image-20221208164843650" style="zoom:80%;" /></p>
<ol type="1">
<li>查找效率：使用路径名</li>
<li>重名：不同用户可以拥有同名文件，相同文件不能拥有不同名字</li>
<li>分组：不能按照文件类型进行分组</li>
</ol>
<h4 id="tree-structured-directories-树型目录">10.3.4.3 Tree-Structured
Directories 树型目录</h4>
<p><img src="/images/AssetMarkdown/image-20221208164916177.png" alt="image-20221208164916177" style="zoom:80%;" /></p>
<ol type="1">
<li><p>查找效率：使用路径名，需要有当前目录的路径（绝对路径/相对路径）</p>
<ol type="1">
<li>cd /spell/mail/prog</li>
<li>type list</li>
</ol></li>
<li><p>重名：不同用户可以拥有同名文件，相同文件不能拥有不同名字</p></li>
<li><p>分组：可以按照文件类型进行分组</p></li>
<li><p>删除文件：<code>rm &lt;file-name&gt;</code></p></li>
<li><p>添加目录：<code>mkdir &lt;dir-name&gt;</code></p></li>
<li><p>示例：当前路径为<code>/mail</code>，执行<code>mkdir count</code></p>
<p><img src="/images/AssetMarkdown/image-20221208165305078.png" alt="image-20221208165305078" style="zoom:80%;" /></p></li>
</ol>
<h4 id="acyclic-graph-directories-有向无环图结构目录">10.3.4.4
Acyclic-Graph Directories 有向无环图结构目录</h4>
<p><img src="/images/AssetMarkdown/image-20221208165345326.png" alt="image-20221208165345326" style="zoom:80%;" /></p>
<ol type="1">
<li>同一个文件可以有不同的名字</li>
<li>如果文件被删除了，但是指针没有被删除，则会导致dangling
pointer，解决方法：
<ol type="1">
<li>Backpointers 逆向指针：删除文件时删除所有指针</li>
<li>Backpointers 使用菊花图的组织方式</li>
<li>Entry-hold-count solution 表项保留计数</li>
</ol></li>
<li>新的目录实体类型
<ol type="1">
<li>Link：一个已经存在的文件的另一个名字(指针)</li>
<li>Resolve the link：通过指针定位文件</li>
</ol></li>
</ol>
<h4 id="general-graph-directory-普通图结构目录">10.3.4.5 General Graph
Directory 普通图结构目录</h4>
<p><img src="/images/AssetMarkdown/image-20221208165553339.png" alt="image-20221208165553339" style="zoom:80%;" /></p>
<p>如何保证没有环</p>
<ol type="1">
<li>只允许到文件的link，不允许到目录的链接</li>
<li>垃圾回收机制
<ol type="1">
<li>检测自我引用的文件，其引用计数不等于0</li>
<li>垃圾收集涉及遍历整个文件系统，并标记所有可访问的空间。然后，第二次将所有没有标记的</li>
<li>部分收集到空闲空间链表上。</li>
</ol></li>
<li>每次添加新link时，使用环检测算法(cycle detection
algorithm)，确定是否可以添加</li>
</ol>
<h2 id="文件系统的挂载">10.4 文件系统的挂载</h2>
<ol type="1">
<li>文件系统只有被挂载了(mounted)，才能被使用</li>
<li>文件系统会被挂载到<strong>挂载点(mount point)</strong>上</li>
</ol>
<blockquote>
<ol type="a">
<li>Existing (b) Unmounted Partition</li>
</ol>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221208171015291.png" alt="image-20221208171015291" style="zoom:80%;" /></p>
<blockquote>
<p>mount point 挂载点</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221208171021245.png" alt="image-20221208171021245" style="zoom:80%;" /></p>
<h2 id="文件共享">10.5 文件共享</h2>
<ol type="1">
<li>多用户系统需要实现文件的共享</li>
<li>共享的文件可能是保护模式</li>
<li>在分布式系统中，文件可以通过网络共享
<ol type="1">
<li>通常使用Network File System (NFS) 实现分布式文件共享</li>
</ol></li>
</ol>
<h3 id="文件共享多用户">10.5.1 文件共享：多用户</h3>
<ol type="1">
<li><strong>User IDs</strong>：识别用户，授予每个用户权限和保护</li>
<li><strong>Group IDs</strong>：允许用户在组中，授予组访问权限</li>
</ol>
<h3 id="文件共享远程文件系统">10.5.2 文件共享：远程文件系统</h3>
<ol type="1">
<li>使用网络允许系统之间的文件系统访问
<ol type="1">
<li>使用<strong>FTP等程序</strong>手动共享</li>
<li>使用<strong>分布式文件系统distributed file
systems</strong>自动共享</li>
<li>通过<strong>万维网world wide web</strong>半自动共享</li>
</ol></li>
<li>客户端-服务器模型允许客户端从服务器装载远程文件系统
<ol type="1">
<li>服务器可以为多个客户端提供服务</li>
<li>客户端和用户对客户端标识不安全或复杂</li>
<li><strong>NFS</strong>是标准的UNIX客户端-服务器文件共享协议</li>
<li><strong>CIFS</strong>是标准的Windows协议</li>
<li>标准操作系统文件调用被转换为远程调用</li>
</ol></li>
<li>LDAP、DNS、NIS、Active
Directory等分布式信息系统（分布式命名服务）实现了对远程计算所需信息的统一访问</li>
</ol>
<h3 id="文件共享错误模式">10.5.3 文件共享：错误模式</h3>
<ol type="1">
<li>由于网络故障、服务器故障，远程文件系统添加了新的故障模式</li>
<li>故障恢复可能涉及有关每个远程请求状态的状态信息</li>
<li>无状态协议（如NFS）包含每个请求中的所有信息，允许轻松恢复，但安全性较低</li>
</ol>
<h3 id="文件共享一致性问题">10.5.4 文件共享：一致性问题</h3>
<p><strong>一致性语义Consistency
semantics</strong>：指定多个用户如何同时访问共享文件</p>
<ol type="1">
<li>类似于Ch 7 进程同步算法
<ol type="1">
<li>由于磁盘I/O和网络延迟，会相对简单一点</li>
</ol></li>
<li>Andrew文件系统(AFS)实现了：
<ol type="1">
<li>复杂的远程文件共享语义</li>
</ol></li>
<li>Unix文件系统(UFS)实现了：
<ol type="1">
<li>写入同一打开文件的其他用户立即可见的打开文件</li>
<li>共享文件指针以允许多个用户同时读写</li>
</ol></li>
<li>AFS具有会话语义</li>
<li>仅对文件关闭后开始的会话可见的写入</li>
</ol>
<h2 id="protection">10.6 Protection</h2>
<ol type="1">
<li>文件的拥有者/创建者需要能够控制：
<ol type="1">
<li>可以做什么</li>
<li>谁可以做</li>
</ol></li>
<li>操作的类型：
<ol type="1">
<li>读</li>
<li>写</li>
<li>执行</li>
<li>扩展</li>
<li>删除</li>
<li>列表</li>
</ol></li>
</ol>
<h3 id="access-lists-and-groups">10.6.1 Access Lists and Groups</h3>
<ol type="1">
<li>基础操作：读R、写W、执行X</li>
<li>三种用户
<ol type="1">
<li>所有者owner</li>
<li>组group</li>
<li>公共public</li>
</ol></li>
<li>要求管理员创建group、添加用户到group</li>
<li>对一个特定的文件/子目录，定义访问的权限</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221208172500521.png" alt="image-20221208172500521" style="zoom:80%;" /></p>
<h1 id="chapter-11file-system-implementation">Chapter 11：File System
Implementation</h1>
<h2 id="file-systemorganized-structure">11.1 File-System(organized)
Structure</h2>
<ol type="1">
<li>文件的结构：
<ol type="1">
<li>逻辑存储单元</li>
<li>相关信息的集合</li>
</ol></li>
<li>文件系统总是分层结构</li>
<li>文件系统存储在磁盘上
<ol type="1">
<li>通过允许轻松地存储、定位和检索数据，提供对磁盘的高效和方便的访问</li>
<li><strong>文件系统</strong>：是操作系统中以文件方式管理计算机软件资源的软件和被管理的文件和数据结构（如目录和索引表等）的集合</li>
</ol></li>
<li><strong>File control block
文件控制块</strong>：由文件信息（属性）组成的存储结构</li>
<li><strong>Device driver 设备驱动</strong>：控制物理设备</li>
</ol>
<h3 id="分层设计的文件系统">11.1.1 分层设计的文件系统</h3>
<ol type="1">
<li>应用程序：
<ol type="1">
<li>发送文件请求的代码</li>
</ol></li>
<li>逻辑文件系统
<ol type="1">
<li>管理<strong>元数据</strong>：文件系统的所有结构数据，而不包括实际数据（或文件内容）</li>
<li>根据给定符号文件名来管理目录结构</li>
<li>逻辑文件系统通过文件控制块(FCB)来维护文件结构</li>
</ol></li>
<li>文件组织模块
<ol type="1">
<li>知道文件及其逻辑块和物理块。</li>
<li>空闲空间管理器</li>
</ol></li>
<li>基本文件系统
<ol type="1">
<li>向合适的设备驱动程序发送一般命令就可对磁盘上的物理块进行读写</li>
</ol></li>
<li>I/O控制
<ol type="1">
<li>由设备驱动程序和中断处理程序组成，实现内存与磁盘之间的信息转移</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221208173053023.png" alt="image-20221208173053023" style="zoom:80%;" /></p>
<h3 id="文件系统的类型">11.1.2 文件系统的类型</h3>
<p><img src="/images/AssetMarkdown/image-20221208173658221.png" alt="image-20221208173658221" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221208173713927.png" alt="image-20221208173713927" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221208173728616.png" alt="image-20221208173728616" style="zoom:80%;" /></p>
<h2 id="文件系统的实现">11.2 文件系统的实现</h2>
<h3 id="在磁盘中的文件系统结构">11.2.1 在磁盘中的文件系统结构</h3>
<ol type="1">
<li><p>在磁盘上，文件系统可能包括如下信息：</p>
<ol type="1">
<li>如何启动所存储的操作系统</li>
<li>总的块数</li>
<li>空闲块的数目和位置</li>
<li>目录结构以及各个具体文件等</li>
</ol></li>
<li><p>磁盘结构包括</p>
<ol type="1">
<li><strong>Boot control
block</strong>：包含系统从该卷启动OS所需的信息</li>
<li><strong>Volume(卷)control block</strong>：包含卷详细信息</li>
<li><strong>Directory structure</strong>：组织文件</li>
<li>Per-file <strong>File Control Block
(FCB，文件控制块)</strong>：包含文件的许多详细信息</li>
</ol></li>
<li><p>一个典型的文件控制块如下：</p>
<p><img src="/images/AssetMarkdown/image-20221208174042008.png" alt="image-20221208174042008" style="zoom: 50%;" /></p></li>
</ol>
<h3 id="在内存中的文件系统结构">11.2.2 在内存中的文件系统结构</h3>
<ol type="1">
<li>An in-memory partition table：分区表</li>
<li>An in-memory directory structure：目录结构</li>
<li>The system-wide open-file table：系统打开文件表</li>
<li>The per-process open-file table：进程打开文件表</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221208174329371.png" alt="image-20221208174329371" style="zoom:80%;" /></p>
<h3 id="虚拟文件系统">11.2.3 虚拟文件系统</h3>
<ol type="1">
<li>虚拟文件系统（VFS）提供了一种实现文件系统的面向对象方法</li>
<li>VFS允许相同的系统调用接口（API）用于不同类型的文件系统</li>
<li>API用于VFS接口，而不是任何特定类型的文件系统</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221208174537601.png" alt="image-20221208174537601" style="zoom:67%;" /></p>
<h2 id="目录实现">11.3 目录实现</h2>
<h3 id="线性列表">11.3.1 线性列表</h3>
<ol type="1">
<li><strong>Linear list</strong>线性列表：存储文件名、指向数据块的指针
<ol type="1">
<li>实现简单</li>
<li>但是访问文件需要线性遍历</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212142011949.png" alt="image-20221212142011949" style="zoom:80%;" /></p>
<h3 id="哈希表">11.3.2 哈希表</h3>
<ol type="1">
<li><strong>Hash Table</strong>哈希表：
<ol type="1">
<li>降低了搜索时间</li>
<li>collision冲突：当两个文件名hash到同一个位置时，会发生冲突</li>
<li>fixed
size：哈希表的最大困难是其通常固定的大小和哈希函数对大小的依赖性</li>
</ol></li>
<li>可以使用两层hash优化</li>
</ol>
<h2 id="allocation-methods-文件物理结构">11.4 Allocation Methods,
文件物理结构</h2>
<ol type="1">
<li>An allocation method refers to how disk blocks are allocated for
files:
<ol type="1">
<li>Contiguous allocation 连续分配</li>
<li>Linked allocation 链接分配</li>
<li>Indexed allocation 索引分配</li>
<li>Unix、Linux直接间接混合分配方法</li>
</ol></li>
</ol>
<h3 id="连续分配-1">11.4.1 连续分配</h3>
<h4 id="连续分配-2">11.4.1.1 连续分配</h4>
<ol type="1">
<li><p>每个文件占据磁盘上<strong>连续的块</strong></p></li>
<li><p>简单：只需要知道文件的起始位置(block #)和长度(number of
blocks)</p></li>
<li><p><strong>Random Access 随机存取</strong></p></li>
<li><p>如果动态分配的话，会浪费空间</p></li>
<li><p>文件变动的成本很高</p>
<p><img src="/images/AssetMarkdown/image-20221212143513022.png" alt="image-20221212143513022" style="zoom:67%;" /></p></li>
<li><p>逻辑地址 =&gt; 物理地址：LA / 512</p>
<ol type="1">
<li>LA：存取文件的逻辑地址</li>
<li>512：每块的大小</li>
<li>待访问的块：Q+starting address</li>
<li>块内偏移量：R</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212143550218.png" alt="image-20221212143550218"  /></p>
<h4 id="基于扩展的连续分配系统">11.4.1.2 基于扩展的连续分配系统</h4>
<ol type="1">
<li>将程序分为多个段</li>
<li>每个段是空间中的一片连续的空间</li>
<li>不同段之间可以不连续</li>
</ol>
<figure>
<img src="/images/AssetMarkdown/image-20221212143829537.png"
alt="image-20221212143829537" />
<figcaption aria-hidden="true">image-20221212143829537</figcaption>
</figure>
<h3 id="链接分配">11.4.2 链接分配</h3>
<h4 id="链接分配-1">11.4.2.1 链接分配</h4>
<ol type="1">
<li>文件的内容放在内存中不同的块，通过链表将不同块连接起来</li>
<li>简单：只需要存储链表的起始地址，每个块内部会有指向下一个块的指针</li>
<li>不会浪费空间</li>
<li>不能随机访问</li>
<li>逻辑地址 =&gt; 物理地址：LA / 512</li>
<li>缺点：如果其中一个块的指针被修改了，那么后面的块均无法访问</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212144327110.png" alt="image-20221212144327110" style="zoom:67%;" /></p>
<h4 id="链接分配的变种fat文件系统">11.4.2.2
链接分配的变种：FAT文件系统</h4>
<ol type="1">
<li><p>File-allocation
table(FAT)：文件分配表，是一个单独的数据结构，存储文件的链表信息</p>
<ol type="1">
<li>原本的链表指针存储在每个数据块中</li>
<li>FAT表使用单独的空间，存储了整个文件的每一个块的链表指针</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212144730183.png" alt="image-20221212144730183" style="zoom:67%;" /></p></li>
<li><p>FAT12、FAT16、FAT32</p>
<p><img src="/images/AssetMarkdown/image-20221212144612204.png" alt="image-20221212144612204" style="zoom:80%;" /></p></li>
<li><p>FAT32引导区记录被扩展为：包括重要数据结构的备份，根目录为一个普通的簇链，其目录项可以放在文件区任何地方</p></li>
<li><p>FAT32磁盘的结构：</p>
<ol type="1">
<li><strong>主引导记录MBR</strong>：是主引导区的第一个扇区，它由两个部分组成:
<ol type="1">
<li>第一部分主引导代码，占据扇区的前446个字节，磁盘标识符(FD 4E F2
14)位于这段代码的未尾</li>
<li>第二部分是分区表，分区表中每个条目有16字节长，分区表最多有4个条目，第一个分区条目从扇区的偏移量位置是0x01BE</li>
</ol></li>
<li><strong>扩展引导记录</strong>：与主引导记录类同，如该扩展分区未装操作系统则第一部分主引导代码为0，标签字也标记一个扩展分区引导区和分区引导区的结束</li>
<li>计算机系统启动时，首先执行的是<strong>BIOS引导程序</strong>，完成自检，并加载主引导记录和分区表，然后执行<strong>主引导记录</strong>，由它引导激活分区引导记录，再执行<strong>分区引导记录</strong>，加载操作系统，最后执行<strong>操作系统</strong>，配置系统</li>
</ol></li>
<li><p>FAT32目录项结构</p>
<ol type="1">
<li>FAT的<strong>每个目录项</strong>为<strong>32个字节</strong></li>
</ol></li>
<li><p><strong>FAT32长文件名</strong>的目录项由几个32B表项组成</p>
<ol type="1">
<li>用一个表项存放短文件名和其他属性（包括簇号、文件大小，最后修改时间和最后修改日期、创建时间、创建日期和最后存取日期），短文件名的属性是0x20</li>
<li>用连续若干个表项存放长文件名，每个表项存放13个字符（使用Unicode编码，每个字符占用2个字节）</li>
<li>长文件名的表项首字节的二进制数低5位值，分别为00001 、00010 、 00011
、……，表示它们的次序，左起第2位为1(也就是在低5位基础上加40H)表示该表项是最后一项。最后项存放13个字符位置多余时，先用2个字节0表示结束，再用FFH填充</li>
<li>长文件名的属性是0x0F</li>
<li>长文件名项的第13、27、28字节为0x00，第14字节为短文件名校验和</li>
<li>长文件名The quick
brown.fox（短文件名为THEQUI~1.FOX）目录项格式如下：</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212145723827.png" alt="image-20221212145723827" style="zoom:80%;" /></p></li>
</ol>
<h4 id="ntfs文件系统">11.4.2.3 NTFS文件系统</h4>
<ol type="1">
<li><p>NTFS卷布局：</p>
<p><img src="/images/AssetMarkdown/image-20221212145820512.png" alt="image-20221212145820512"  /></p></li>
<li><p>每个分区均有一个主文件表<strong>Master File
Table(MFT)</strong></p>
<ol type="1">
<li>MFT用数据库记录形式组织，每条记录(MFT表项)长度1K</li>
<li>MFT由一个个MFT项(也称为文件记录)组成，每个MFT项占用1024字节的空间</li>
<li>MFT前16个记录用来存放元数据文件的信息，它们占有固定的位置</li>
<li>每个MFT项的前部几十个字节有着固定的头结构，用来描述本MFT项的相关信息。后面的字节存放着文件属性等</li>
<li>每个文件或目录的信息都包含在MFT中，每个文件或目录至少有一个MFT项</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212145917582.png" alt="image-20221212145917582" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221212150032357.png" alt="image-20221212150032357" style="zoom:80%;" /></p></li>
</ol>
<h3 id="索引分配">11.4.3 索引分配</h3>
<h4 id="索引分配-1">11.4.3.1 索引分配</h4>
<ol type="1">
<li><p>将所有指针统一放到<strong>索引块 index block</strong>中</p></li>
<li><p>逻辑视图</p></li>
<li><p>每个文件都使用磁盘上的索引块来包含文件使用的其他磁盘块的地址</p></li>
<li><p>当写入第<span
class="math inline">\(i\)</span>个块时，块的地址被放置在索引块的第<span
class="math inline">\(i\)</span>个位置</p></li>
<li><p>方法会浪费空间，因为对于小文件，大部分索引块都被浪费了</p>
<ol type="1">
<li>如果索引块太小，我们可以：
<ol type="1">
<li>将几个链接在一起</li>
<li>使用多级索引</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212151200110.png" alt="image-20221212151200110" style="zoom:50%;" /></p></li>
<li><p>需要索引表</p></li>
<li><p>可以实现随机访问</p></li>
<li><p>动态分配不会产生额外的碎片，但是会浪费索引块的空间</p></li>
<li><p>在最大大小为256KB、块大小为512B的文件中从逻辑映射到物理。索引表只需要1个块</p></li>
</ol>
<h4 id="链接索引">11.4.3.2 链接索引</h4>
<ol type="1">
<li>将索引表，使用链表连接起来</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212151713695.png" alt="image-20221212151713695" style="zoom:80%;" /></p>
<h4 id="二级索引">11.4.3.3 二级索引</h4>
<ol type="1">
<li>Two-level index</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221212151851581.png" alt="image-20221212151851581" style="zoom:80%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221212152013361.png" alt="image-20221212152013361" style="zoom:80%;" /></p>
<h3 id="组合模式">11.4.4 组合模式</h3>
<ol type="1">
<li>使用不同索引，适配不同大小的文件
<ol type="1">
<li>direct blocks：直接指向数据所在的位置</li>
<li>single indirect：指向一级索引块</li>
<li>double indirect：指向二级索引块</li>
</ol></li>
</ol>
<blockquote>
<p>Linux ext2/ext3</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221212152131318.png" alt="image-20221212152131318" style="zoom:80%;" /></p>
<h2 id="free-space-management-空闲空间管理">11.5 Free-Space Management
空闲空间管理</h2>
<ol type="1">
<li><p>Bitmap 位图</p>
<p><img src="/images/AssetMarkdown/image-20221215163231777.png" alt="image-20221215163231777" style="zoom:80%;" /></p>
<ol type="1">
<li><p>对于有n个blocks的空间 <span class="math display">\[
bit[i]=\left\{
\begin{aligned}
  &amp; 0 =&gt; block[i]空闲\\
  &amp; 0 =&gt; block[i]被占用
\end{aligned} \right.
\]</span></p></li>
<li><p>Bitmap需要额外的空间来记录空闲空间</p></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221215163339003.png" alt="image-20221215163339003" style="zoom:67%;" /></p></li>
<li><p>Free list 空闲列表</p>
<ol type="1">
<li>将空闲的空间连接起来</li>
<li>没有空间浪费</li>
<li>但是不能容易的得到连续的空间</li>
</ol></li>
<li><p>Grouping 分组</p>
<ol type="1">
<li>可以较为容易的得到一块连续的空间</li>
<li>如果分组大小为固定的，则难以满足所有程序的需求</li>
<li>如果分组大学为动态的，则容易产生碎片</li>
</ol></li>
<li><p>Counting 空闲表</p></li>
<li><p>需要保护的内容：</p>
<ol type="1">
<li>指向空闲列表的指针</li>
<li>Bitmap：
<ol type="1">
<li>必须保存在磁盘上</li>
<li>内存和磁盘中的副本可能不同</li>
<li>不能允许block[i]在内存中的bit[i]=1，而在磁盘上的bit[i]=0</li>
</ol></li>
<li>解决方法：
<ol type="1">
<li>set 磁盘中的 bit[i] = 1</li>
<li>申请block[i]</li>
<li>set 内存中的 bit[i] = 1</li>
</ol></li>
</ol></li>
</ol>
<blockquote>
<p>Linked Free Space List on Disk</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221215164144034.png" alt="image-20221215164144034" style="zoom: 67%;" /></p>
<h2 id="效率和性能">11.6 效率和性能</h2>
<ol type="1">
<li>效率依赖于：
<ol type="1">
<li>磁盘分配、目录算法</li>
<li>文件中目录项的数据的类型</li>
</ol></li>
<li>性能：
<ol type="1">
<li>disk cache：在内存中开辟一块空间，访问磁盘时先访问这块内存</li>
<li>free-behind and
read-ahead：释放时不真正将内存中的内容刷新，读取时提前将相关的block读入内存</li>
<li>通过将部分内存用作虚拟磁盘或RAM磁盘来提高PC性能</li>
</ol></li>
</ol>
<h3 id="page-cache">11.6.1 Page Cache</h3>
<ol type="1">
<li>Page Cache使用虚拟内存技术缓存页面而不是磁盘块，</li>
<li>Memory-mapped I/O会使用Page Cache</li>
<li>通过文件系统的例行I/O使用缓冲区（磁盘）缓存</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221215164907603.png" alt="image-20221215164907603" style="zoom:67%;" /></p>
<h3 id="unified-buffer-cache">11.6.2 Unified Buffer Cache</h3>
<ol type="1">
<li>Unified Buffer Cache
统一缓冲区缓存：使用相同的页面缓存来缓存memory-mapped pages
和普通文件系统I/O</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221215165214104.png" alt="image-20221215165214104" style="zoom:80%;" /></p>
<h2 id="recovery">11.7 Recovery</h2>
<ol type="1">
<li><strong>Consistency checking</strong>
一致性比较：将目录结构中的数据与磁盘上的数据块进行比较，并尝试修复不一致性</li>
<li><strong>back up</strong>
备份：使用系统程序将数据从磁盘备份到其他存储设备（磁带、其他磁盘、光盘）</li>
<li><strong>restoring</strong>
恢复：通过从备份中恢复数据来恢复丢失的文件或磁盘</li>
</ol>
<h3 id="log-structured-file-systems">11.7.1 Log Structured File
Systems</h3>
<ol type="1">
<li><strong>Log structured</strong>
日志结构(或日志)文件系统：将文件系统的每次更新记录为事务
<strong>transaction</strong></li>
<li>所有事务都写入日志
<ol type="1">
<li>事务写入日志后即被视为已提交</li>
<li>但是，文件系统可能尚未更新</li>
</ol></li>
<li>日志中的事务将异步写入文件系统
<ol type="1">
<li>修改文件系统时，事务将从日志中删除</li>
</ol></li>
<li>如果文件系统崩溃，则仍必须执行日志中的所有剩余事务</li>
</ol>
<h3 id="network-file-system-nfs-网络文件系统">11.7.2 Network File System
(NFS) 网络文件系统</h3>
<h4 id="nfs">11.7.2.1 NFS</h4>
<ol type="1">
<li>NFS：跨LAN/WAN访问远程文件的软件系统的实现和规范</li>
<li>该实现是使用不可靠数据报协议(UDP/IP协议和以太网)在Sun工作站上运行的Solaris和SunOS操作系统的一部分</li>
<li>互连工作站被视为一组具有独立文件系统的独立计算机，允许以透明的方式在这些文件系统之间共享
<ol type="1">
<li>远程目录加载在本地文件系统目录上
<ol type="1">
<li>加载的目录看起来像本地文件系统的一个完整子树，替换了从本地目录向下的子树(mount的过程)</li>
</ol></li>
<li>装载操作的远程目录的规范是不透明的；必须提供远程目录的主机名
<ol type="1">
<li>然后可以以透明的方式访问远程目录中的文件</li>
</ol></li>
<li>根据访问权限认证，可能任何文件系统（或文件系统中的目录）都可以远程安装在任何本地目录的顶部</li>
</ol></li>
<li>NFS旨在在不同机器、操作系统和网络架构的异构环境中运行；独立于这些介质的NFS规范
<ol type="1">
<li>这种独立性是通过使用构建在两个独立于实现的接口之间使用的外部数据表示(External
Data Representation XDR)协议之上的RPC原语(RPC primitives)实现的</li>
</ol></li>
<li>NFS规范区分了装载机制提供的服务和实际的远程文件访问服务</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221215171246096.png" alt="image-20221215171246096" style="zoom:67%;" /></p>
<p><img src="/images/AssetMarkdown/image-20221215171336215.png" alt="image-20221215171336215" style="zoom:80%;" /></p>
<h4 id="nfs-mount-protocol">11.7.2.2 NFS Mount Protocol</h4>
<ol type="1">
<li>在服务器和客户端之间建立初始逻辑连接</li>
<li>mount操作包括：要装载的远程目录的名称、存储该目录的服务器计算机的名称
<ol type="1">
<li>mount请求被映射到相应的RPC，并转发到服务器计算机上运行的装载服务器</li>
<li>Export
list导出列表：指定服务器导出以进行mount的本地文件系统，以及允许mount它们的计算机的名称</li>
</ol></li>
<li>在符合其导出列表的装载请求之后，服务器返回一个文件句柄：一个用于进一步访问的密钥</li>
<li>文件句柄：一个文件系统标识符和一个inode编号，用于标识导出的文件系统中装载的目录</li>
<li>装载操作仅更改用户的视图，不会影响服务器端</li>
</ol>
<h4 id="nfs-protocol">11.7.2.3 NFS Protocol</h4>
<ol type="1">
<li>为远程文件操作提供一组远程过程调用。程序支持以下操作：
<ol type="1">
<li>在目录中搜索文件</li>
<li>读取一组目录条目</li>
<li>操作链接和目录</li>
<li>访问文件属性</li>
<li>读取和写入文件</li>
</ol></li>
<li>NFS服务器是无状态<strong>stateless</strong>：每个请求都必须提供一组完整的参数
<ol type="1">
<li>NFS V4刚刚推出，非常不同，有状态</li>
</ol></li>
<li>修改数据时，必须先修改服务器的磁盘，才能将数据返回客户端
<ol type="1">
<li>保证了同步</li>
<li>失去缓存的优势</li>
</ol></li>
<li>NFS协议不提供并发控制机制</li>
</ol>
<h4 id="nfs架构中的三个主要层">11.7.2.4 NFS架构中的三个主要层</h4>
<ol type="1">
<li>UNIX文件系统接口
<ol type="1">
<li>基于打开、读取、写入和关闭调用以及文件描述符</li>
</ol></li>
<li>虚拟文件系统(VFS)层：区分本地文件和远程文件，本地文件根据其文件系统类型进一步区分
<ol type="1">
<li>VFS根据文件系统类型激活文件系统特定操作以处理本地请求</li>
<li>为远程请求调用NFS协议过程</li>
</ol></li>
<li>NFS服务层：体系结构的底层
<ol type="1">
<li>实施NFS协议</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221215172431386.png" alt="image-20221215172431386" style="zoom:80%;" /></p>
<h4 id="nfs-path-name-translation">11.7.2.5 NFS Path-Name
Translation</h4>
<ol type="1">
<li>通过将路径拆分为组件名称并对每对组件名称和目录vnode执行单独的NFS查找调用来执行</li>
<li>为了加快查找速度，客户端的目录名查找缓存保存远程目录名的vnode</li>
</ol>
<h4 id="nfs远端操作">11.7.2.6 NFS远端操作</h4>
<ol type="1">
<li>常规UNIX系统调用与NFS协议RPC之间几乎一一对应（打开和关闭文件除外）</li>
<li>NFS遵循远程服务范式，但为了性能考虑，采用了缓冲和缓存技术</li>
<li>文件块缓存：打开文件时，内核会与远程服务器检查是否获取或重新验证缓存的属性
<ol type="1">
<li>仅当相应的缓存属性是最新的时，才使用缓存文件块</li>
</ol></li>
<li>文件属性缓存：每当新属性从服务器到达时，都会更新属性缓存</li>
<li>在服务器确认数据已写入磁盘之前，客户端不会释放延迟的写入块</li>
</ol>
<h2 id="示例wafl文件系统">*11.8 示例：WAFL文件系统</h2>
<ol type="1">
<li>用于Network Appliance“Filers”：分布式文件系统设备</li>
<li>在任何位置写入文件布局</li>
<li>为NFS、CIFS、http、ftp提供服务</li>
<li>随机I/O优化，写优化
<ol type="1">
<li>用于写缓存的NVRAM</li>
</ol></li>
<li>类似于Berkeley Fast File System，具有广泛的修改</li>
</ol>
<blockquote>
<p>The WAFL File Layout</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221215172923567.png" alt="image-20221215172923567" style="zoom:80%;" /></p>
<blockquote>
<p>Snapshots in WAFL</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221215172935282.png" alt="image-20221215172935282" style="zoom:80%;" /></p>
<h1 id="chapter-12mass-storage-systems">Chapter 12：Mass-Storage
Systems</h1>
<h2 id="大容量存储系统-概览">12.1 大容量存储系统 概览</h2>
<blockquote>
<p>分层存储体系</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221219143646168.png" alt="image-20221219143646168" style="zoom:80%;" /></p>
<ol type="1">
<li>磁盘<code>Magnetic disks</code>：
<ol type="1">
<li>每秒钟60~200转</li>
<li>传输速率<code>Transfer Rate</code>：从驱动器到计算机之间的数据传输速率
<ol type="1">
<li>与磁盘、计算机连接驱动的方式有关</li>
</ol></li>
<li>定位时间<code>Positioning Time</code> /
<code>Random-access time</code>：分为两部分
<ol type="1">
<li>将磁盘臂移动到所需柱面的时间（寻道时间<code>seek time</code>）</li>
<li>所需扇区在磁盘头下旋转的时间（旋转延迟<code>rotational latency</code>）</li>
</ol></li>
<li><code>Head Crash</code>：磁头与磁盘相碰，会导致磁盘坏区</li>
<li>磁盘可以被移除</li>
<li>驱动通过I/O总线与计算机相连
<ol type="1">
<li>总线有很多种，如：EIDE, ATA, SATA, USB, Fibre Channel, SCSI</li>
<li>计算机中的主机控制器使用总线与内置在驱动器或存储阵列中的磁盘控制器通信</li>
</ol></li>
</ol></li>
<li>固态硬盘<code>Solid State Drives</code>：
<ol type="1">
<li>简称固盘，固态硬盘用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成</li>
<li>第一只SSD出现在1978年（STK 4305，每MB售价8800美元，DRAM）</li>
<li>全闪存阵列（AFAS）和混合闪存阵列（HFA）呈爆发式增长</li>
<li>现在SSD的容量是15.36TB（SAS）</li>
<li>非易失性、低功耗（只有HDD的三分之一）</li>
<li>无活动部件、可靠性高：―位误码率(<code>BER</code>)1x10<sup>-17</sup></li>
<li>读取存取时间：0.2毫秒，存取时间比HDD大概快 50倍</li>
</ol></li>
<li>磁带<code>Magnetic tape</code>：
<ol type="1">
<li>出货的磁带驱动器中超过85%是LTO（Linear Tape Open）</li>
<li>磁带驱动器的可靠性、数据传输速率和容量已超过磁盘</li>
<li>磁带的原生容量为10TB，压缩容量超过25TB。(LTO-10:48TB)</li>
<li>磁带的原生数据传输速率为360MB/s</li>
<li>LTFS(Liner Tape File
System)为磁带提供了一种通用、开放的文件系统</li>
<li>由于总体拥有成本，云采用磁带解决方案用于归档服务</li>
<li>对企业级磁带和LTO而言，磁带介质的寿命至少是30年</li>
</ol></li>
</ol>
<h2 id="磁盘结构-1">12.2 磁盘结构</h2>
<h3 id="磁盘结构-2">12.2.1 磁盘结构</h3>
<ol type="1">
<li>磁盘被划分为逻辑块的一个一维阵列，其中逻辑块是最小的传输单位</li>
<li>逻辑块的大小通常为512字节</li>
<li>逻辑块的一维阵列按顺序映射到磁盘的扇区中
<ol type="1">
<li>扇区0：是最外柱面上，第一个磁道的，第一个扇区</li>
<li>映射顺序：磁道上的其它扇区 =&gt; 柱面上的其它磁道 =&gt;
其它柱面</li>
</ol></li>
</ol>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: center;"><img src="/images/AssetMarkdown/image-20221219145527826.png" alt="image-20221219145527826"  /></th>
<th><img src="/images/AssetMarkdown/image-20221219145531858.png" alt="image-20221219145531858" style="zoom:80%;" /></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="host-attached-storage">12.2.2 Host-attached storage</h3>
<ol type="1">
<li><p>主机通过I/O接口与I/O总线进行通信</p></li>
<li><p><code>IDE</code>：</p>
<ol type="1">
<li>每个I/O bus 最多2个驱动器</li>
</ol></li>
<li><p><code>SCSI</code>：</p>
<ol type="1">
<li>SCSI本身是一条总线，一根电缆上最多有16个设备，SCSI启动器请求操作，SCSI目标执行任务</li>
<li>每个目标最多可以有8个逻辑单元（连接到设备控制器的磁盘）</li>
</ol></li>
<li><p><code>FC</code>：Fibre Channel，光纤通道</p>
<ol type="1">
<li>可以是具有24位地址空间的交换结构，这是存储区域网络(SAN, storage area
networks)的基础，其中许多主机连接到许多存储单元</li>
<li>可仲裁126个设备的环路（FC-AL）</li>
</ol></li>
<li><p><code>NAS</code>：Network-attached storage</p>
<ol type="1">
<li>网络连接存储（NAS）是通过网络而不是通过本地连接（如总线）提供的存储</li>
<li>NFS和CIFS（通用Internet文件系统）是通用协议</li>
<li>通过主机和存储之间的远程过程调用（RPC）实现</li>
<li>新的iSCSI协议使用IP网络来承载SCSI协议</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221219150412657.png" alt="image-20221219150412657" style="zoom:80%;" /></p></li>
<li><p><code>SAN</code>：Storage Area Network</p>
<ol type="1">
<li>在大型存储环境中很常见（而且越来越常见）</li>
<li>多个主机连接到多个存储阵列—灵活</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221219150441725.png" alt="image-20221219150441725" style="zoom:80%;" /></p></li>
<li><p>存储虚拟化技术：<code>SNIA</code>(Storage Networking Industry
Association，存储网络联合会)官方对于<code>Virtualization</code>(存储虚拟化技术)的定义如下：</p>
<ol type="1">
<li>是将存储（子）系统内部功能与具体应用、主机及通用网络资源分离、隐藏及抽象的行为。以期达到存储或数据管理的网络无关性</li>
<li>对于存储服务及设备的虚拟化应用，以期达到整合设备功能、隐藏复杂细节以及向已经存在的底层存储资源添加新的应用</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221219150541740.png" alt="image-20221219150541740" style="zoom: 80%;" /></p></li>
</ol>
<h2 id="磁盘调度">12.4 磁盘调度</h2>
<h3 id="磁盘调度-1">12.4.1 磁盘调度</h3>
<ol type="1">
<li>操作系统负责有效地使用硬件-对于磁盘驱动器，这意味着具有快速的访问时间和磁盘带宽</li>
<li>访问时间有三个主要组成部分
<ol type="1">
<li><code>Seek time</code>(寻道时间)：是磁盘将磁头移动到包含所需扇区的气缸的时间</li>
<li><code>Rotational latency</code>(旋转延迟)：是等待磁盘将所需扇区旋转到磁盘头的额外时间</li>
<li><code>Transfer time</code>(传输时间)</li>
</ol></li>
<li><strong>目标：最小化寻道时间</strong></li>
<li>seek time ≈ seek distance 寻道时间 ≈ 寻道距离</li>
<li>磁盘带宽：传输的总字节数 /
第一次服务请求和最后一次传输完成之间的总时间</li>
</ol>
<blockquote>
<ol type="1">
<li>7200(转／每分钟)的硬盘，每旋转一周所需时间为60×1000（毫秒）÷7200＝8.33毫秒，
则平均旋转延迟时间为8.33÷2＝4.17毫秒(平均情况下，需要旋转半圈)。</li>
<li>7200转机械硬盘的寻道时间一般为12-14毫秒，固态硬盘可以达到0.1毫秒甚至更低</li>
<li>固态硬盘持续读写速度超过500MB/s</li>
<li>机械硬盘读写速度超过50~200MB/s（接口不同）</li>
<li>磁带的原生数据传输速率为360MB/s</li>
</ol>
</blockquote>
<h3 id="磁盘调度算法">12.4.2 磁盘调度算法</h3>
<p>假设</p>
<ol type="1">
<li>请求队列为：<code>98, 183, 37, 122, 14, 124, 65, 67</code></li>
<li>磁头目前在：<code>53</code></li>
</ol>
<h4 id="fcfs-先来先服务">12.4.2.1 FCFS 先来先服务</h4>
<blockquote>
<p>总距离：<code>640</code>个磁道距离</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221219152543077.png" alt="image-20221219152543077" style="zoom:67%;" /></p>
<h4 id="sstf-最短寻道时间优先">12.4.2.2 SSTF 最短寻道时间优先</h4>
<ol type="1">
<li>选择对于当前磁头来说，所需寻道时间最小的请求</li>
<li>SSTF(Shortest Seek Time
First)是SJF的一个变种，可能会导致starvation</li>
</ol>
<blockquote>
<p>总距离：<code>236</code>个磁道距离</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221219152910224.png" alt="image-20221219152910224" style="zoom:67%;" /></p>
<h4 id="scan-扫描">12.4.2.3 SCAN 扫描</h4>
<ol type="1">
<li>磁盘臂从磁盘的一端开始，向另一端移动，当遇到请求的块时，直接读取，直到到达磁盘的另一端</li>
<li>此时磁头移动方向取反，继续响应途中遇到的请求</li>
<li>SCAN算法有时称为电梯算法</li>
<li>SCAN算法的稳定性不高</li>
</ol>
<blockquote>
<p>总距离：<code>236</code>个磁道距离</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221219153237456.png" alt="image-20221219153237456" style="zoom:67%;" /></p>
<h4 id="c-scan">12.4.2.4 C-SCAN</h4>
<ol type="1">
<li>磁盘臂从磁盘的一端开始，向另一端移动，当遇到请求的块时，直接读取，直到到达磁盘的另一端</li>
<li>此时磁头直接跳转到磁盘的开始端，然后继续向另一端移动</li>
<li>C-SCAN更加稳定，因为保证了同一时间遇到的请求可以在一次SCAN过程中都取到</li>
</ol>
<blockquote>
<p>总距离：<code>382</code>个磁道距离</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221219153555618.png" alt="image-20221219153555618" style="zoom:67%;" /></p>
<h4 id="look">12.4.2.5 LOOK</h4>
<ol type="1">
<li>SCAN的时候，不一定要到边上，只要到达所有请求的最小/大值处，即可折返</li>
</ol>
<blockquote>
<p>总距离：<code>208</code>个磁道距离</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221219154814261.png" alt="image-20221219154814261" style="zoom:67%;" /></p>
<h4 id="c-look">12.4.2.6 C-LOOK</h4>
<ol type="1">
<li>C-SCAN的时候，不一定要到边上，只要到达所有请求的最小/大值处，即可折返</li>
</ol>
<blockquote>
<p>总距离：<code>322</code>个磁道距离</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221219153956094.png" alt="image-20221219153956094" style="zoom:67%;" /></p>
<h3 id="选择一种磁盘调度算法">12.4.3 选择一种磁盘调度算法</h3>
<ol type="1">
<li>SSTF很常见，具有自然吸引力</li>
<li>SCAN和C-SCAN在磁盘负载较大的系统中表现更好</li>
<li>性能取决于请求的数量和类型</li>
<li>磁盘服务请求可能会受到文件分配方法的影响</li>
<li>磁盘调度算法应作为操作系统的一个单独模块来编写，允许在必要时使用不同的算法来替换</li>
<li>SSTF或LOOK是一种合理的默认算法</li>
</ol>
<h2 id="磁盘控制">12.5 磁盘控制</h2>
<h3 id="磁盘控制-1">12.5.1 磁盘控制</h3>
<ol type="1">
<li>Low-level formatting / physical formatting 低级格式化/物理格式化：
<ol type="1">
<li>为每个扇区采用特别的数据结构，包括头、数据区域和尾部组成</li>
<li>头部和尾部包含了一些磁盘控制器所使用的信息，例如扇区号码和纠错代码（ECC）</li>
<li>当控制器在正常I/O时写入一个扇区数据时，ECC会用一个根据磁盘数据计算出来的值更新</li>
<li>当读入扇区时，ECC值会重新计算，并与原来存储的值相比较，如果两个值不一样，那么可能表示扇区的数据可能已损坏或扇区可能变坏</li>
</ol></li>
<li>要使用磁盘保存文件，操作系统仍需要在磁盘上记录自己的数据结构
<ol type="1">
<li>Partition分区：
<ol type="1">
<li>一个分区可以用来存储操作系统的可执行代码，而其他分区用来存储用户数据</li>
<li>分区可看做一个独立的磁盘</li>
</ol></li>
<li>Logical formatting 逻辑格式化：
<ol type="1">
<li>操作系统将初始的文件系统数据结构存储到磁盘上</li>
<li>这些数据结构包括空闲和已分配的空间（FAT和inode）和一个初始为空的目录</li>
</ol></li>
<li>cluster 簇：
<ol type="1">
<li>为了提高效率，大多数操作系统将块集中到一大块，叫做簇cluster</li>
<li>磁盘I/O通过块完成，文件系统I/O通过簇完成，确保I/O可以进行更多的顺序存取和更少的随机存取</li>
</ol></li>
</ol></li>
</ol>
<h3 id="boot-block-启动块">12.5.2 Boot Block 启动块</h3>
<ol type="1">
<li>Boot block 初始化系统：
<ol type="1">
<li>引导程序（自举程序）初始化系统从cpu寄存器到设备控制器和内存，接着启动操作系统</li>
<li>自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，开始操作系统的执行</li>
</ol></li>
<li>经典的启动顺序
<ol type="1">
<li>ROM中的代码（简单引导）
<ol type="1">
<li>ROM中保留一个很小的自举加载程序，它的作用是进一步从磁盘上调入更为完整的自举程序</li>
</ol></li>
<li>Boot Block中的代码（完全引导）
<ol type="1">
<li>引导加载程序，例如Grub或LILO</li>
<li>磁盘上的自举程序可以容易地进行修改，拥有启动分区的磁盘称为启动磁盘或系统磁盘</li>
</ol></li>
<li>操作系统的整个内核</li>
</ol></li>
</ol>
<h3 id="windows-2000的启动">12.5.3 Windows 2000的启动</h3>
<blockquote>
<ol type="1">
<li>Windows系统通过运行系统ROM上的代码，开始启动，指示系统从MBR读取引导代码。MBR包含一个硬盘分区列表和一个说明系统引导分区的标志</li>
<li>引导分区，boot
partition，包含操作系统和设备驱动程序。系统一旦确定引导分区，它读取该分区的第一个扇区，所谓引导扇区，并继续余下的启动过程，包括加载各种子系统和系统服务</li>
</ol>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221222164450979.png" alt="image-20221222164450979" style="zoom:80%;" /></p>
<h3 id="bad-block-坏块">12.5.4 Bad Block 坏块</h3>
<blockquote>
<p>有坏块是正常的，出厂的时候就有可能有坏块。对于简单磁盘，Format进行逻辑格式化时找到坏块，就在相应的FAT条目上写上特殊值以通知分配程序不要使用该块。如果在正常使用中块变坏，就必须人工的执行chkdsk来搜索坏块。</p>
</blockquote>
<ol type="1">
<li>磁盘经常有缺陷块或坏块</li>
<li>坏块的处理方法</li>
<li>MS-DOS的处理方法: format，chkdsk命令</li>
</ol>
<h2 id="交换空间的管理">12.6 交换空间的管理</h2>
<ol type="1">
<li>交换空间：虚拟内存使用磁盘空间作为主内存的扩展</li>
<li>交换空间可以有2种形式：
<ol type="1">
<li>在普通的文件系统中：windows--<code>pagefile.sys文件</code></li>
<li>在独立的磁盘分区种：linux、unix--<code>SWAP分区</code></li>
</ol></li>
<li>交换空间的大小：
<ol type="1">
<li>交换空间太大容易造成浪费</li>
<li>交换空间太小容易造成死机现象：中断进程或使整个系统死机</li>
</ol></li>
<li>BSD在进程启动时分配交换空间；保存文本段（程序）和数据段
<ol type="1">
<li>内核使用交换映射来跟踪交换空间的使用</li>
</ol></li>
<li>Solaris
2仅在页面被强制移出物理内存时才分配交换空间，而不是在首次创建虚拟内存页面时</li>
</ol>
<blockquote>
<p>Data Structures for Swapping on Linux Systems</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221222165445838.png" alt="image-20221222165445838" style="zoom:80%;" /></p>
<h2 id="raid结构">12.7 RAID结构</h2>
<h3 id="raid介绍">12.7.1 RAID介绍</h3>
<ol type="1">
<li><strong>RAID</strong>：Redundant Arrays of Inexpensive(Independent)
Disks，冗余廉价磁盘阵列
<ol type="1">
<li>RAID是一种把多块独立的硬盘(物理硬盘)按不同的方式组合起来形成一个硬盘组(逻辑硬盘)，从而提供比单个硬盘更高的存储性能和提供数据备份技术</li>
<li>Inexpensive =&gt; Independent</li>
<li>RAID：使用多个磁盘，通过冗余提供可靠性</li>
<li>增加平均故障时间</li>
<li>通常与NVRAM组合使用，提升性能</li>
<li>分为了6个级别</li>
</ol></li>
<li>磁盘使用技术的一些改进涉及使用多个磁盘协同工作</li>
<li>磁盘条带化(striping)：将一组磁盘用作一个存储单元</li>
<li>RAID方案通过存储冗余数据来提高存储系统的性能和可靠性
<ol type="1">
<li>镜像(Mirroring)或shadowing(RAID 1)：保留每个磁盘的副本</li>
<li>条带化镜像(RAID 1+0)或镜像条带(RAID
0+1)：提供了高性能和高可靠性</li>
<li>块交错奇偶校验(RAID 4、5、6)：使用更少的冗余</li>
</ol></li>
<li>如果阵列发生故障，存储阵列中的RAID仍可能发生故障，因此阵列之间的数据自动复制很常见</li>
<li>通常，少数hot-spare
disks不会被分配，自动替换故障磁盘并将数据重建到这些磁盘上</li>
</ol>
<h3 id="raid层级">12.7.2 RAID层级</h3>
<ol type="1">
<li><strong>Raid
0</strong>：没有冗余性的保证，但是可以将多个磁盘条带化成1个</li>
<li><strong>Raid 1</strong>：镜像磁盘，是数据的一个完整拷贝</li>
<li><strong>Raid
2</strong>：内存方式的差错纠正代码结构，内存系统中的每个字节都有一个相关奇偶位，以记录字节中置为1的个数是偶数还是奇数</li>
<li><strong>Raid3</strong>：按位校验，奇偶校验码和其它磁盘的相应扇区或块一起用于恢复出错磁盘的扇区和块</li>
<li><strong>Raid4</strong>：按块校验，奇偶校验码和其它磁盘的相应扇区或块一起用于恢复出错磁盘的扇区和块</li>
<li><strong>Raid5</strong>：将数据和奇偶校验分布在所有N+1块磁盘上</li>
<li><strong>Raid6</strong>：保存了额外的冗余信息以防止多个磁盘出错，每4个位的数据使用了2个位的冗余数据，这样系统可以容忍两个磁盘出错。</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221222171059973.png" alt="image-20221222171059973" style="zoom:80%;" /></p>
<h3 id="raid01-和-raid10">12.7.3 RAID(0+1) 和 RAID(1+0)</h3>
<ol type="1">
<li>RAID 0+1：
<ol type="1">
<li>先分散，再镜像</li>
<li>一组磁盘分散成条，每一条再镜像到另一条</li>
<li>RAID 0和RAID 1的组合，RAID 0提供性能，RAID 1提供可靠性</li>
<li>RAID0+1允许坏多个盘，但只能在坏在同一个RAID0中，不允许两个RAID
0都有坏盘</li>
</ol></li>
<li>RAID 1+0：
<ol type="1">
<li>先镜像，再分散</li>
<li>如果单个磁盘不可用，其它镜像仍如其它磁盘一样可用</li>
<li>RAID1+0允许坏多个盘，只要不是一对磁盘坏就可以</li>
</ol></li>
<li>RAID 1+0在整体容错能力和恢复代价上比RAID
0+1更有优势，所以更为常用</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221222171500654.png" alt="image-20221222171500654" style="zoom:80%;" /></p>
<h3 id="拓展">12.7.4 拓展</h3>
<ol type="1">
<li>单独使用RAID无法防止或检测数据损坏或其他错误，只是防止磁盘故障</li>
<li>Solaris ZFS添加了所有数据和元数据的校验和
<ol type="1">
<li>与对象指针一起保存的校验和，用于检测对象是否正确以及是否已更改</li>
<li>可以检测并纠正数据和元数据损坏</li>
</ol></li>
<li>ZFS还删除了卷、分区
<ol type="1">
<li>磁盘分配到pool中</li>
<li>具有池的文件系统共享该池，使用和释放空间，如“malloc”和“free”内存分配/释放调用</li>
</ol></li>
</ol>
<blockquote>
<p>ZFS Checksums All Metadata and Data</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221222172044176.png" alt="image-20221222172044176" style="zoom:80%;" /></p>
<blockquote>
<p>Traditional and Pooled Storage</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221222172052943.png" alt="image-20221222172052943" style="zoom:80%;" /></p>
<h1 id="chapter-13io-system">Chapter 13：I/O System</h1>
<h2 id="overview-1">13.1 Overview</h2>
<ol type="1">
<li>计算机的两个主要工作
<ol type="1">
<li>I/O</li>
<li>计算</li>
</ol></li>
<li>与计算机相连的设备的控制是操作系统设计者的主要关注点</li>
<li>I/O设备技术出现两个相矛盾的趋势：
<ol type="1">
<li>硬件和软件接口日益增长的标准化</li>
<li>I/O设备日益增长的多样性。</li>
</ol></li>
<li>操作系统内核设计成使用设备驱动程序模块的结构</li>
<li>设备驱动程序为I/O子系统提供了统一接口</li>
</ol>
<h2 id="io硬件">13.2 I/O硬件</h2>
<ol type="1">
<li>I/O系统的组成：
<ol type="1">
<li>PC总线型I/O系统</li>
<li>大型机I/O系统</li>
</ol></li>
<li>通用概念
<ol type="1">
<li>Port ，端口</li>
<li>Bus (daisy chain or shared direct access)，总线</li>
<li>Controller (host adapter)，控制器</li>
</ol></li>
<li>I/O instructions控制设备</li>
<li>寻址方式
<ol type="1">
<li>直接使用I/O指令</li>
<li>内存映射I/O</li>
</ol></li>
</ol>
<blockquote>
<p>PC总线型I/O</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221226143530861.png" alt="image-20221226143530861" style="zoom:80%;" /></p>
<blockquote>
<p>Mainframe Systems 大型机(主机)系统</p>
<ol type="1">
<li>这类计算机以存储器为中心，CPU和各种通道都与存储器相连</li>
</ol>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221226143547576.png" alt="image-20221226143547576" style="zoom:80%;" /></p>
<h2 id="io方式">13.3 I/O方式</h2>
<h3 id="轮询">13.3.1 轮询</h3>
<ol type="1">
<li>CPU查询I/O的状态</li>
<li>I/O返回当前状态
<ol type="1">
<li>command-ready</li>
<li>busy</li>
<li>error</li>
</ol></li>
<li>如果I/O没有准备好，则会返回第1步，进入busy-wait(忙等待)状态</li>
<li>如果I/O准备好了，则CPU读取I/O的数据，写入内存，然后返回第1步</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221226144148862.png" alt="image-20221226144148862" style="zoom:67%;" /></p>
<h3 id="interrupt中断">13.3.2 Interrupt中断</h3>
<ol type="1">
<li>CPU硬件有一条<strong>中断请求线（interrupt-request line,
IRL）</strong>，由I/O设备触发
<ol type="1">
<li>设备控制器通过中断请求线发送信号而引起中断，CPU捕获中断并派遣到中断处理程序，中断处理程序通过处理设备来清除中断。</li>
</ol></li>
<li>两种中断请求
<ol type="1">
<li><strong>非屏蔽中断</strong>：主要用来处理如不可恢复内存错误等事件</li>
<li><strong>可屏蔽中断</strong>：由CPU在执行关键的不可中断的指令序列前加以屏蔽</li>
</ol></li>
<li><strong>中断向量</strong></li>
<li><strong>中断优先级</strong>：能够使CPU延迟处理低优先级中断而不屏蔽所有中断，这也可以让高优先级中断抢占低优先级中断处理。</li>
<li>中断的用途
<ol type="1">
<li>中断机制用于处理各种异常，如被零除，访问一个受保护的或不存在的内存地址</li>
<li>系统调用的实现需要用到中断（软中断）</li>
<li>中断也可以用来管理内核的控制流</li>
</ol></li>
</ol>
<blockquote>
<p>中断驱动I/O循环</p>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221226145032534.png" alt="image-20221226145032534" style="zoom:80%;" /></p>
<h3 id="直接内存访问dmadirect-memory-access">13.3.3
直接内存访问DMA(Direct Memory Access)</h3>
<ol type="1">
<li>用来避免处理大量数据移动时按字节来向控制器送入数据的问题</li>
<li>需要DMA控制器</li>
<li>绕过CPU直接在内存与I/O设备之间进行数据传输</li>
<li>步骤：
<ol type="1">
<li>硬件告诉设备驱动器：要传输在地址X处的磁盘数据</li>
<li>设备驱动器告诉磁盘控制器：从磁盘中读取地址X处的C个字节到buffer</li>
<li>磁盘控制器：初始化DMA传输</li>
<li>磁盘控制器：传输字节，给到DMA控制器</li>
<li>DMA控制器：传输字节给到buffer，地址++，C--，直到C=0</li>
<li>当C=0时，DMA中断CPU，声明传输已经结束</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221226145852776.png" alt="image-20221226145852776" style="zoom: 80%;" /></p>
<h3 id="应用io接口">13.4 应用I/O接口</h3>
<ol type="1">
<li>I/O系统调用：实现统一的I/O接口</li>
<li>I/O系统调用将设备行为封装在泛型类中，如块设备I/O系统调用包括磁盘、磁带、光盘等一系列块设备的read、write、seek。</li>
<li>设备驱动程序(Device-driver)层从内核隐藏I/O控制器之间的差异</li>
<li>设备在许多方面都有所不同
<ol type="1">
<li>Character-stream or block 字符流或者块设备</li>
<li>Sequential or random-access 顺序或随机访问设备</li>
<li>Synchronous or aSynchronous 同步或异步</li>
<li>Sharable or dedicated 共享或独占设备</li>
<li>Speed of operation 操作速度（快速、中速、慢速）</li>
<li>read-write, read only, or write only 读写、只读、只写设备</li>
</ol></li>
</ol>
<blockquote>
<ol type="1">
<li>大多数操作系统存在后门，允许应用程序将任何命令透明的传给设备控制器</li>
<li>对UNIX，这个系统调用是ioctl（）
<ol type="1">
<li>系统调用ioctl能使应用程序访问由设备驱动程序实现的一切功能</li>
<li>Ioctl有三个参数
<ol type="1">
<li>第一个文件描述符，引用某一个硬件设备</li>
<li>第二个是整数，来确定哪个命令</li>
<li>第三个是内存中的指针，使得应用程序和控制器传输任何必要的命令信息或数据</li>
</ol></li>
</ol></li>
</ol>
</blockquote>
<p><img src="/images/AssetMarkdown/image-20221226151634158.png" alt="image-20221226151634158" style="zoom:80%;" /></p>
<h3 id="block-and-character-devices-块和字符设备">13.4.1 Block and
Character Devices 块和字符设备</h3>
<blockquote>
<p>read，write，seek描述了块存储设备的基本特点，这样应用程序就不必关注这些设备的底层差别。</p>
<p>原始I/O或直接I/O文件操作模式</p>
<ol type="1">
<li>原始I/O：将块设备当做一个简单的线性块数组来访问</li>
<li>直接I/O：文件采用禁止缓存和锁的文件操作模式</li>
</ol>
<p>内存映射文件访问是建立在块设备驱动程序之上的。内存映射接口不是提供read和write操作，而是提供通过内存中的字节数组来访问磁盘存储。</p>
<p>应用程序可以get或put一个字符。在此基础上，可以构造库以提供具有缓冲和编辑功能的按行访问。</p>
<p>这种访问方式也有助于输出设备，例如打印机、声卡，这些设备适合于线性字节流</p>
</blockquote>
<ol type="1">
<li>Block devices（块设备） include disk drives
<ol type="1">
<li>Commands include read, write, seek</li>
<li>Raw I/O or file-system access</li>
<li>Memory-mapped file access possible</li>
</ol></li>
<li>Character devices （字符设备） include keyboards, mice, serial ports
<ol type="1">
<li>Commands include get(), put()</li>
<li>Libraries layered on top allow line editing</li>
</ol></li>
</ol>
<h3 id="network-devices-网络设备">13.4.2 Network Devices 网络设备</h3>
<ol type="1">
<li>网络I/O的性能与访问特点与磁盘I/O相比有很大差别，绝大多数操作系统所提供的网络I/O接口也不同于磁盘的read-write-seek接口</li>
<li>许多OS所提供的是网络套接字接口
<ol type="1">
<li>套接字接口还提供了select函数，以管理一组套接字</li>
<li>调用select可以得知哪个套接字已有接收数据需要处理，哪个套接字已有空间可以接收数据以便发送</li>
</ol></li>
</ol>
<h3 id="clocks-and-timers-时钟和定时器">13.4.3 Clocks and Timers
时钟和定时器</h3>
<ol type="1">
<li>提供以下三个基本函数
<ol type="1">
<li>获取当前时间</li>
<li>获取已经逝去的时间</li>
<li>设置定时器以在T时触发操作X</li>
</ol></li>
<li>测量逝去时间和触发器操作的硬件称为可编程间隔定时器（programmable
interval timer）
<ol type="1">
<li>可被设置为等待一定的时间，然后触发中断</li>
<li>也可设置成做一次或重复多次以产生定时中断</li>
</ol></li>
</ol>
<h3 id="blocking-and-nonblocking-io-阻塞和非阻塞io">13.4.4 Blocking and
Nonblocking I/O 阻塞和非阻塞I/O</h3>
<ol type="1">
<li>Blocking：进程挂起直到I/O完成为止
<ol type="1">
<li>很容易使用和理解</li>
<li>对某些需求是低效的</li>
</ol></li>
<li>Nonblocking：I/O调用立刻返回
<ol type="1">
<li>用户界面</li>
<li>通过多进程实现</li>
<li>返回读/写了多少个字节</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221226153141627.png" alt="image-20221226153141627" style="zoom:67%;" /></p>
<h3 id="asynchronous-异步">13.4.5 Asynchronous 异步</h3>
<ol type="1">
<li>Asynchronous(异步)：进程与I/O同时运行
<ol type="1">
<li>难以使用</li>
<li>当I/O完成时，I/O子系统会提醒进程</li>
</ol></li>
<li>非阻塞与异步系统调用的<strong>差别</strong>:
<ol type="1">
<li><strong>非阻塞read调用会马上返回</strong>，其所读取的数据可以等于或少于所要求的，或为零</li>
<li><strong>异步read调用所要求的传输应完整地执行，其具体执行可以是将来某个特定时间</strong></li>
</ol></li>
</ol>
<h2 id="内核io子系统">13.5 内核I/O子系统</h2>
<ol type="1">
<li>内核与I/O有关服务：
<ol type="1">
<li>I/O scheduling：I/O调度</li>
<li>buffering：缓存</li>
<li>caching：高速缓存</li>
<li>spooling：假脱机</li>
<li>device reservation：设备预定</li>
<li>error handling：错误处理</li>
</ol></li>
<li>内核I/O子系统负责：
<ol type="1">
<li>文件和设备命名空间的管理</li>
<li>文件和设备访问控制</li>
<li>操作控制（for example, a modem cannot seek()）</li>
<li>文件系统空间的分配</li>
<li>设备分配</li>
<li>缓冲、高速缓存、假脱机</li>
<li>I/O调度</li>
<li>设备状态监控、错误处理、失败恢复</li>
<li>设备驱动程序的配置和初始化</li>
</ol></li>
</ol>
<h3 id="io调度">13.5.1 I/O调度</h3>
<ol type="1">
<li>I/O调度：调度一组I/O请求就是确定一个好的顺序来执行这些请求
<ol type="1">
<li>某些I/O需要按设备队列的顺序：先来先服务</li>
<li>某些操作系统尝试着公平：优先级高者优先</li>
<li>磁盘I/O调度</li>
</ol></li>
<li>实现
<ol type="1">
<li>OS通过为每个设备维护一个请求队列来实现调度。</li>
<li>可以试图公平，也可以根据不同的优先级进行I/O调度。</li>
<li>其他方法：缓冲、高速缓冲、假脱机</li>
</ol></li>
</ol>
<h3 id="缓冲buffer">13.5.2 缓冲buffer</h3>
<blockquote>
<p><strong>拷贝语义</strong>：</p>
<ol type="1">
<li>某应用程序需要将缓冲区内的数据写入磁盘，它可以调用write()系统调用</li>
<li>当系统调用返回时，如果应用程序改变了缓冲区的内容，根据拷贝语义，操作系统保证要写入磁盘的数据就是write()系统调用发生时的版本</li>
<li>一个简单方法就是操作系统在write()系统调用返回前，将应用程序缓冲区复制到内核缓冲区中</li>
</ol>
</blockquote>
<ol type="1">
<li><strong>缓冲
Buffering</strong>：用来保存在两设备之间或在设备和应用程序之间所传输数据的内存区域。</li>
<li>缓冲作用：
<ol type="1">
<li>解决设备速度不匹配</li>
<li>解决设备传输块的大小不匹配</li>
<li>为了维持<strong>拷贝语义“copy semantics”</strong>要求</li>
</ol></li>
<li>缓冲区管理：为了解决<strong>CPU与I/O之间速度不匹配的矛盾</strong>，在它们之间配置了缓冲区。这样设备管理程序又要负责管理缓冲区的建立、分配和释放。</li>
<li>单缓冲、双缓冲、多缓冲、缓冲池</li>
</ol>
<h3 id="高速缓冲cacheing">13.5.3 高速缓冲cacheing</h3>
<ol type="1">
<li><p><strong>高速缓存 Caching </strong>：fast memory holding copy of
data</p>
<ol type="1">
<li><p>缓冲与高速缓存的差别是缓冲只是保留数据仅有的一个现存拷贝，而高速缓存只是提供了一个驻留在其他地方的数据的一个高速拷贝</p></li>
<li><p>高速缓存和缓冲是两个不同的功能，但有时一块内存区域也可以同时用于两个目的</p></li>
<li><p>当内核接收到I/O请求时，内核首先检查高速缓存以确定相应文件的内容是否在内存中。如果是，物理磁盘I/O就可以避免或延迟</p></li>
</ol></li>
</ol>
<h3 id="假脱机技术-spooling">13.5.4 假脱机技术 SPOOLing</h3>
<ol type="1">
<li><strong>SPOOLing</strong>（Simultaneous Peripheral Operation On
Line）称为<strong>假脱机</strong>技术：
<ol type="1">
<li>用来保存设备输出的缓冲，这些设备如打印机不能接收交叉的数据流</li>
<li>操作系统通过截取对打印机的输出来解决这一问题。应用程序的输出先是假脱机到一个独立的磁盘文件上。当其它应用程序完成打印时，假脱机系统将相应的待送打印机的假脱机文件进行排队</li>
</ol></li>
<li>Printing：打印机虽然是独享设备，通过SPOOLing技术，可以将它改造为一台可供多个用户共享的设备</li>
</ol>
<h3 id="设备预定-device-reservation">13.5.5 设备预定 Device
reservation</h3>
<ol type="1">
<li><strong>设备预定 Device reservation</strong>
<ol type="1">
<li>提供对设备的独占访问</li>
<li>分配和再分配的系统调用</li>
<li>有可能产生死锁</li>
</ol></li>
</ol>
<h3 id="错误处理-error-handling">13.5.6 错误处理 Error Handling</h3>
<ol type="1">
<li><strong>错误处理 Error Handling</strong>
<ol type="1">
<li>操作系统可以恢复磁盘读，设备无效，暂时的失败</li>
<li>当I/O失败时，大多数返回一个错误码</li>
<li>系统日志记录了出错报告</li>
</ol></li>
</ol>
<h3 id="io保护">13.5.7 I/O保护</h3>
<ol type="1">
<li>用户进程可能通过非法的I/O指令，来恶意打破一些正常操作
<ol type="1">
<li>所有I/O指令被特权化</li>
<li>I/O必须通过系统调用</li>
<li>内存映射和I/O端口内存位置也必须受到保护</li>
</ol></li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221229162906570.png" alt="image-20221229162906570" style="zoom:67%;" /></p>
<h3 id="内核数据结构">13.5.8 内核数据结构</h3>
<ol type="1">
<li>内核需要保存I/O组件使用的<strong>状态信息</strong>，包括打开文件表，网络连接，字符设备状态等</li>
<li>许多复杂的数据结构用来跟踪缓冲，内存分配，及“脏”块</li>
<li>某些OS用面向对象的方法和消息传递的方法来实现I/O</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221229163949586.png" alt="image-20221229163949586" style="zoom:80%;" /></p>
<h2 id="io-requests-to-hardware-operations">13.6 I/O Requests to
Hardware Operations</h2>
<p>进程从磁盘中读取一个文件：</p>
<ol type="1">
<li>确定保存文件的设备</li>
<li>转换名字到设备的表示法</li>
<li>把数据从磁盘读到缓冲区中</li>
<li>通知请求进程数据现在是有效的</li>
<li>把控制权返回给进程</li>
</ol>
<blockquote>
<p>一次I/O请求的生命周期</p>
<p><img src="/images/AssetMarkdown/image-20221229164104537.png" alt="image-20221229164104537" style="zoom:80%;" /></p>
</blockquote>
<h2 id="streams">13.7 STREAMS</h2>
<ol type="1">
<li>STREAMS：Unix System
V及更高版本中用户级进程与设备之间的全双工通信信道</li>
<li>流包括：
<ol type="1">
<li>STREAM头与用户进程接口</li>
<li>驱动端与设备接口——它们之间没有或多个STREAM模块。</li>
</ol></li>
<li>每个模块包含一个读队列和一个写队列</li>
<li>消息传递用于队列之间的通信</li>
</ol>
<p><img src="/images/AssetMarkdown/image-20221229164309121.png" alt="image-20221229164309121" style="zoom:67%;" /></p>
<h2 id="性能">13.8 性能</h2>
<ol type="1">
<li>I/O是系统性能的一个主要因素：
<ol type="1">
<li>要求CPU执行设备驱动程序、内核I/O代码</li>
<li>中断导致的上下文切换</li>
<li>数据复制</li>
<li>网络流量尤其紧张</li>
</ol></li>
<li>提高性能的方法：
<ol type="1">
<li>减少上下文开关的数量</li>
<li>减少数据拷贝</li>
<li>通过使用大型传输、智能控制器和轮询减少中断</li>
<li>使用DMA</li>
<li>平衡CPU、内存、总线和I/O性能，实现最高吞吐量</li>
</ol></li>
</ol>
<blockquote>
<p>计算机之间的通信</p>
<p><img src="/images/AssetMarkdown/image-20221229164358578.png" alt="image-20221229164358578" style="zoom:80%;" /></p>
</blockquote>

    </div>

    
    
    

    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>华丰夏
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2022/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">http://example.com/2022/09/12/操作系统/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag"># 专业课</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2022/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81ODcwNy8zNTE2OQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-1introduction"><span class="nav-text">Chapter 1：Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-text">1.1 操作系统在做什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">1.1.1 操作系统的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.1.2 什么是操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E8%A7%92%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6"><span class="nav-text">1.1.2.1
计算机系统组成角度：操作系统是系统软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%A7%92%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E7%94%A8%E6%88%B7%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.1.2.2
用户角度：操作系统是用户与计算机硬件之间接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%A7%92%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85"><span class="nav-text">1.1.2.3
系统角度：操作系统是计算机系统资源的管理者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82%E6%89%A9%E5%85%85%E6%9C%BA%E5%99%A8%E7%9A%84%E8%A7%92%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%89%A9%E5%85%85%E8%A3%B8%E6%9C%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E5%B1%82%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6"><span class="nav-text">1.1.2.4
软件分层、扩充机器的角度：操作系统是扩充裸机的第一层系统软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%80%83%E8%99%91"><span class="nav-text">1.1.2.5 综合考虑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#computer-system-organization"><span class="nav-text">1.2 Computer System
Organization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="nav-text">1.2.1 总线结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8-startup"><span class="nav-text">1.2.2 计算机启动 Startup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-text">1.2.3 中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">1.2.4 存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E7%BB%93%E6%9E%84"><span class="nav-text">1.2.5 IO结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#computer-system-architecture"><span class="nav-text">1.3 Computer System
Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.3.1 单处理器系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.3.2 多处理器系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">1.3.3 计算机系统组件的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clustered-systems%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.3.4 Clustered Systems集群系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operating-system-operations%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-text">1.4 Operating System
Operations操作系统的执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.4.1 两种操作模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timer%E5%AE%9A%E6%97%B6%E5%99%A8%E9%98%B2%E6%AD%A2%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%E8%B5%84%E6%BA%90"><span class="nav-text">1.4.2
Timer(定时器)：防止无限循环&#x2F;进程占用资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#resource-management%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-text">1.5 Resource
Management资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">1.5.1 进程管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">1.5.2 内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="nav-text">1.5.3 文件系统管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%82%A8%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">1.5.4 大容量储存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6caching"><span class="nav-text">1.5.5 高速缓存机制Caching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.5.6 I&#x2F;O子系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#security-and-protection%E5%AE%89%E5%85%A8%E5%92%8C%E4%BF%9D%E6%8A%A4"><span class="nav-text">1.6 Security and
Protection安全和保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#virtualization%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-text">1.7 Virtualization虚拟化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#distribute-system%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.8 Distribute
System分布式系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kernel-data-structures%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1.9 Kernel Data
Structures内核数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#computing-environments%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83"><span class="nav-text">1.10 Computing
Environments计算环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E8%AE%A1%E7%AE%97-traditional"><span class="nav-text">1.10.1 传统计算 Traditional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97-mobile"><span class="nav-text">1.10.2 移动计算 Mobile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BAclient-%E6%9C%8D%E5%8A%A1%E5%99%A8server%E8%AE%A1%E7%AE%97"><span class="nav-text">1.10.3
客户机Client-服务器Server计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E8%AE%A1%E7%AE%97-peer-to-peer"><span class="nav-text">1.10.4 点对点计算 Peer-to-Peer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E8%AE%A1%E7%AE%97-virtualization"><span class="nav-text">1.10.5 虚拟化计算 Virtualization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97-cloud-computing"><span class="nav-text">1.10.6 云计算 Cloud Computing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-real-time-embedded-systems"><span class="nav-text">1.10.7 实时嵌入式系统
Real-Time Embedded Systems</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">1.10 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-2operating-system-structures"><span class="nav-text">Chapter
2：Operating-System Structures</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="nav-text">2.1 操作系统提供的服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#user-operating-system-interface"><span class="nav-text">2.2 User Operating System
Interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#system-calls"><span class="nav-text">2.3 System Calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#system-services"><span class="nav-text">2.4 System Services</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linkers-and-loaders"><span class="nav-text">2.5 Linkers and Loaders</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AA%E8%BF%90%E8%A1%8C%E5%9C%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A"><span class="nav-text">2.6
为什么应用程序只运行在特定的操作系统上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operating-system-design-and-implementation"><span class="nav-text">2.7 Operating-System
Design and Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operating-system-structure"><span class="nav-text">2.8 Operating-System Structure</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-3processes"><span class="nav-text">Chapter 3：Processes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 进程的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-text">3.1.1 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-text">3.1.2 内存中的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">3.1.3 进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="nav-text">3.1.4 进程状态的切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.1.5 进程与程序的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pcb-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-text">3.1.6 PCB 进程控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#process-scheduling-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-text">3.2 Process Scheduling
进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#scheduling-queue-%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="nav-text">3.2.1 Scheduling Queue 调度队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#schedulers-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-text">3.2.2 Schedulers 调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#context-switch-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-text">3.2.3 Context Switch 上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="nav-text">3.2.4 移动端的多任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operations-on-process-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">3.3 Operations on Process
进程的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#process-creation-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text">3.3.1 Process Creation 进程创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process-termination-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-text">3.3.2 Process Termination
进程终止</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipcinterprocess-communication-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">3.4 IPC：Interprocess
Communication 进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">3.4.1 Linux进程通信机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windows-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">3.4.2 Windows 进程线程通信机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipcin-shared-memory-systems"><span class="nav-text">3.5 IPC：in Shared-Memory
Systems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bounded-buffershared-memory-solution"><span class="nav-text">3.5.1
Bounded-Buffer：Shared-Memory Solution</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipcin-message-passing-systems"><span class="nav-text">3.6 IPC：in Message-Passing
Systems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#direct-communication%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="nav-text">3.6.1 Direct
Communication（直接通信）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#indirect-communication%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="nav-text">3.6.2 Indirect
Communication（间接通信）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronization%E5%90%8C%E6%AD%A5"><span class="nav-text">3.6.3 Synchronization同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buffering"><span class="nav-text">3.6.4 Buffering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-text">3.6.5 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipcexample"><span class="nav-text">3.7 IPC：example</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#windows"><span class="nav-text">3.7.1 Windows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipe-%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="nav-text">3.7.2 Pipe 管道通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ordinary-pipes"><span class="nav-text">3.7.2.1 Ordinary pipes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#named-pipes"><span class="nav-text">3.7.2.2 Named pipes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#communication-in-clientserver-systems"><span class="nav-text">3.8 Communication in
Client–Server Systems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">3.8.1 Socket 套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remote-procedure-calls-%E8%BF%9C%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="nav-text">3.8.2 Remote Procedure Calls
远过程调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-4threads-concurrency"><span class="nav-text">Chapter 4：Threads &amp;
Concurrency</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#overview"><span class="nav-text">4.1 Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8Bthread%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">4.1.1 线程Thread的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">4.1.2 线程的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">4.1.3 线程的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">4.1.4 线程的使用案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B"><span class="nav-text">4.2 多核编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multithreading-models"><span class="nav-text">4.3 Multithreading Models</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#user-threads-%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-text">4.3.1 User Threads 用户级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kernel-threads-%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-text">4.3.2 Kernel Threads 内核级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#many-to-one-%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-text">4.3.3 Many-to-One
多个用户线程, 一个内核线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#one-to-one-%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-text">4.3.4 One-to-One
一个用户线程, 一个内核线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#many-to-many-%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E4%B8%AA%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-text">4.3.5 Many-to-Many
多个用户线程, 多个内核线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#two-level-model-%E4%B8%A4%E7%BA%A7%E6%A8%A1%E5%9E%8B"><span class="nav-text">4.3.6 Two-level Model 两级模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solaris%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8Blwp%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">4.3.7
Solaris用户线程、内核线程、LWP三者之间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-libraries-%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="nav-text">4.4 Thread Libraries 线程库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread"><span class="nav-text">4.4.1 Pthread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-threads"><span class="nav-text">4.4.2 Java Threads</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implicit-threading-%E9%9A%90%E7%A7%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">4.5 Implicit Threading
隐私多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-pool-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">4.5.1 Thread Pool 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-join-parallelism"><span class="nav-text">4.5.2 Fork-Join Parallelism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#openmp"><span class="nav-text">4.5.3 OpenMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grand-central-dispatch"><span class="nav-text">4.5.4 Grand Central Dispatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#intel-threading-building-blocks-tbb"><span class="nav-text">4.5.5 Intel Threading
Building Blocks (TBB)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#threading-issues"><span class="nav-text">4.6 Threading Issues</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork%E5%92%8Cexec%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-text">4.6.1 fork()和exec()的语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-text">4.6.2 Thread的删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal-handling-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-text">4.6.3 Signal Handling 信号处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-pool-%E7%BA%BF%E7%A8%8B%E6%B1%A0-1"><span class="nav-text">4.6.4 Thread Pool 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-specific-data-%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="nav-text">4.6.5 Thread Specific Data
线程特有数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scheduler-activations-%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BF%80%E6%B4%BB"><span class="nav-text">4.6.5 Scheduler Activations
调度器激活</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operating-system-examples"><span class="nav-text">4.7 Operating-System Examples</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#windows-xp-thread"><span class="nav-text">4.7.1 Windows XP Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-threads"><span class="nav-text">4.7.2 Linux Threads</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapte-5cpu-scheduling"><span class="nav-text">Chapte 5：CPU Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-basic-concepts"><span class="nav-text">5.1 基础概念 Basic Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E8%B0%83%E5%BA%A6"><span class="nav-text">5.1.1 CPU调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler"><span class="nav-text">5.1.2 CPU调度器 Scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F-dispatcher"><span class="nav-text">5.1.3 调度程序 Dispatcher</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%A0%87%E5%87%86-scheduling-criteria"><span class="nav-text">5.2 调度标准 Scheduling
Criteria</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9%E5%87%86%E5%88%99%E5%92%8C%E8%AF%84%E4%BB%B7"><span class="nav-text">5.2.1 调度算法的选择准则和评价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%87%86%E5%88%99-optimization-criteria"><span class="nav-text">5.2.4 最优准则 Optimization
Criteria</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-scheduling-algorithms-%E8%AE%A1%E7%AE%97"><span class="nav-text">5.3 调度算法 Scheduling
Algorithms (计算)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6-fcfs"><span class="nav-text">5.3.1 先来先服务调度 FCFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9"><span class="nav-text">5.3.1.1 算法内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.3.1.2 示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6-sjf"><span class="nav-text">5.3.2 短作业优先调度 SJF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9-1"><span class="nav-text">5.3.2.1 算法内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-srtf"><span class="nav-text">5.3.2.2 最短剩余时间优先 SRTF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-hrrn"><span class="nav-text">5.3.2.3 最高响应比优先 HRRN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">5.3.2.4 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E6%B5%8Bcpu-burst-time%E6%8C%87%E6%95%B0%E5%B9%B3%E5%9D%87%E6%B3%95"><span class="nav-text">5.3.3.5 预测CPU Burst
Time：指数平均法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-priority-scheduling"><span class="nav-text">5.3.3 优先级调度 Priority
Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9-2"><span class="nav-text">5.3.3.1 算法内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">5.3.3.2 示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6-rr"><span class="nav-text">5.3.4 时间片轮转调度 RR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9-3"><span class="nav-text">5.3.4.1 算法内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-text">5.3.4.2 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time-quantum-%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">5.3.4.3 Time Quantum
时间片的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="nav-text">5.3.5 多级队列调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="nav-text">5.3.6 多级反馈队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6-multiple-processor-scheduling"><span class="nav-text">5.4* 多处理器调度
Multiple-Processor Scheduling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6-thread-scheduling"><span class="nav-text">5.5* 线程调度 Thread Scheduling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B-operating-systems-examples"><span class="nav-text">5.6 操作系统示例
Operating Systems Examples</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">5.7 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-6process-synchronization-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">Chapter 6：Process
Synchronization 进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#background"><span class="nav-text">6.1 Background</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-text">6.1.1 原子操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%86%B2%E7%AA%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">6.1.2 非原子操作冲突示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#race-condition"><span class="nav-text">6.1.3 Race Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">6.1.4 进程同步的概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-critical-section-problem%E9%87%8D%E7%82%B9"><span class="nav-text">6.2 The Critical-Section
Problem(重点)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">6.2.1 问题的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="nav-text">6.2.2 临界区&amp;临界资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84%E5%BA%94%E8%AF%A5%E6%98%AF"><span class="nav-text">6.2.3 一个进程的结构应该是</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="nav-text">6.3
多进程临界区问题的解决方法：软件方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#peterson-solutions%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="nav-text">6.3.1 Peterson
Solutions：两个进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%951"><span class="nav-text">6.3.1.1 算法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%952-1"><span class="nav-text">6.3.1.2 算法2-1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%952-2"><span class="nav-text">6.3.1.3 算法2-2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#peterson%E7%AE%97%E6%B3%95"><span class="nav-text">6.3.1.4 Peterson算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bakery-algorithmn%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="nav-text">6.3.2 Bakery Algorithm：n个进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="nav-text">6.4
多进程临界区问题的解决方法：硬件方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#test-and-set%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%AE%BE%E7%BD%AE"><span class="nav-text">6.4.1 Test-and-Set：测试与设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap%E4%BA%A4%E6%8D%A2"><span class="nav-text">6.4.2 Swap：交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">6.4.3 硬件方法的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-spinlock"><span class="nav-text">6.4.4 自旋锁 spinlock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#semaphores-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">6.5 Semaphores 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">6.5.1 信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="nav-text">6.5.2 用信号量解决冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89busy-waiting%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0"><span class="nav-text">6.5.3 没有busy
waiting的信号量实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#waitsignal%E6%93%8D%E4%BD%9C%E8%AE%A8%E8%AE%BA"><span class="nav-text">6.5.4 wait、signal操作讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">6.5.5 信号量用于通用同步操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF"><span class="nav-text">6.5.6 死锁和饥饿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="nav-text">6.6 同步的经典问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E9%99%90%E7%BC%93%E5%86%B2%E5%8C%BA%E9%97%AE%E9%A2%98bounded-buffer-problem"><span class="nav-text">6.6.1
有限缓冲区问题：Bounded-Buffer Problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%97%AE%E9%A2%98readers-and-writers-problem"><span class="nav-text">6.6.2 读写问题：Readers and
Writers Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80readers-writers%E9%97%AE%E9%A2%98"><span class="nav-text">6.6.2.1 第一Readers-Writers问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8Creaders-writers%E9%97%AE%E9%A2%98"><span class="nav-text">6.6.2.2 第二Readers-Writers问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98dining-philosopher-problem"><span class="nav-text">6.6.3
哲学家就餐问题：Dining-Philosopher Problem</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#monitors%E7%AE%A1%E7%A8%8B"><span class="nav-text">6.7* Monitors(管程)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">6.7.1 信号量同步的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">6.7.2 管程的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-text">6.7.3 管程的主要特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%B4%A0"><span class="nav-text">6.7.4 管程的实现要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">6.7.5 管程的的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%BF%9B%E5%85%A5"><span class="nav-text">6.7.6 管程中的多个进程进入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition"><span class="nav-text">6.7.7 条件变量(condition)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%8E%9F%E8%AF%AD"><span class="nav-text">6.7.8 同步操作原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98"><span class="nav-text">6.7.9 用管程解决哲学家问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-text">6.8 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-7deadlocks%E6%AD%BB%E9%94%81"><span class="nav-text">Chapter 7：Deadlocks死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#system-model"><span class="nav-text">7.1 System Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-text">7.2 死锁的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">7.2.1 产生死锁的4个必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE-resource-allocation-graph"><span class="nav-text">7.2.2 资源分配图
Resource-Allocation Graph</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">7.3 处理死锁的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2-deadlock-prevention"><span class="nav-text">7.4 死锁预防 Deadlock
Prevention</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D-deadlock-avoidance"><span class="nav-text">7.5 死锁避免 Deadlock
Avoidance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81-safe-state"><span class="nav-text">7.5.1 安全状态 Safe State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resource-allocation-graph-algorithm-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="nav-text">7.5.3
Resource-Allocation Graph Algorithm 资源分配图算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bankers-algorithm-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-text">7.5.3 Banker’s Algorithm
银行家算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#safety-algorithm-%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95"><span class="nav-text">7.5.3.1 Safety Algorithm
安全算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resource-request-algorithm-%E8%B5%84%E6%BA%90-%E8%AF%B7%E6%B1%82%E7%AE%97%E6%B3%95"><span class="nav-text">7.5.3.2
Resource-Request Algorithm 资源-请求算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B"><span class="nav-text">7.5.3.3 例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B-deadlock-detection"><span class="nav-text">7.6 死锁检测 Deadlock
Detection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E8%B5%84%E6%BA%90%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="nav-text">7.6.1 每个资源只有一个实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E8%B5%84%E6%BA%90%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="nav-text">7.6.2 每个资源有多个实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="nav-text">7.6.3 示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">7.6.4 死锁检测算法的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%AD%BB%E9%94%81%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="nav-text">7.7 从死锁中恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-process-termination"><span class="nav-text">7.7.1 进程终止 Process
Termination</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E8%B5%84%E6%BA%90-resource-preemption"><span class="nav-text">7.7.2 抢占资源 Resource
Preemption</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-8main-memory"><span class="nav-text">Chapter 8：Main Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#background-1"><span class="nav-text">8.1 Background</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84"><span class="nav-text">8.1.1 存储架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98"><span class="nav-text">8.1.2 主存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-vs-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-text">8.1.3 逻辑地址 vs 物理地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E9%99%90%E9%95%BF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">8.1.4 基址寄存器、限长寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%86%85%E5%AD%98%E7%BB%91%E5%AE%9A"><span class="nav-text">8.1.5 将指令和数据与内存绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memory-management-unit-mmu"><span class="nav-text">8.1.6 Memory-Management Unit
(MMU)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic-loading-%E5%8A%A8%E6%80%81%E8%BD%BD%E5%85%A5"><span class="nav-text">8.1.7 Dynamic Loading 动态载入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic-linking-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">8.1.8 Dynamic Linking 动态链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swapping-%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="nav-text">8.2 Swapping 交换技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="nav-text">8.2.1 交换技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84swapping"><span class="nav-text">8.2.2 不同操作系统的Swapping</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#contiguous-allocation-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-text">8.3 Contiguous Allocation
连续分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-text">8.3.1 连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multiple-partition-allocation-%E5%A4%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-text">8.3.2
Multiple-partition allocation 多分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fixed-partitioning-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="nav-text">8.3.2.1 Fixed Partitioning
固定分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-partitions-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA"><span class="nav-text">8.3.2.2 Dynamic Partitions
动态分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fragmentation-%E7%A2%8E%E7%89%87"><span class="nav-text">8.3.3 Fragmentation 碎片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#paging-%E5%88%86%E9%A1%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">8.4 Paging 分页，页式存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#paging"><span class="nav-text">8.4.1 Paging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noncontiguous-allocation-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">8.4.2 Noncontiguous
Allocation 非连续内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%A1%B5%E6%A8%A1%E5%9E%8B"><span class="nav-text">8.4.3 逻辑和物理内存的分页模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#address-translation-scheme-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="nav-text">8.4.4 Address Translation
Scheme 地址变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-table%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">8.4.5 Page Table的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#associative-memory"><span class="nav-text">8.4.6 Associative Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#effective-access-time-%E6%9C%89%E6%95%88%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4"><span class="nav-text">8.4.7 Effective Access Time
有效访问时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memory-protection-%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-text">8.4.8 Memory Protection
内存保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%A1%B5%E9%9D%A2"><span class="nav-text">8.4.9 共享页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-table%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">8.4.10 Page Table的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BA%A7%E9%A1%B5%E8%A1%A8-hierarchical-paging"><span class="nav-text">8.4.10.1 分级页表 Hierarchical
Paging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8-hashed-page-tables"><span class="nav-text">8.4.10.2 哈希页表 Hashed Page
Tables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8-inverted-page-table"><span class="nav-text">8.4.10.3 反向(反置)页表
Inverted Page Table</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#segmentation-%E5%88%86%E6%AE%B5%E6%AE%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="nav-text">8.5 Segmentation 分段，段式管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#segmentation-architecture"><span class="nav-text">8.5.1 Segmentation Architecture</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#example-the-intel-pentium"><span class="nav-text">8.6 Example: The Intel Pentium</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-9virtual-memory"><span class="nav-text">Chapter 9：Virtual Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#background-2"><span class="nav-text">9.1 Background</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#virtual-memory"><span class="nav-text">9.1.1 Virtual Memory</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-text">9.1.2 局部性原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#demand-paging%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5"><span class="nav-text">9.2 Demand
Paging：按需调页、请求调页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#demand-paging"><span class="nav-text">9.2.1 Demand Paging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valid-invalid-bit"><span class="nav-text">9.2.2 Valid-Invalid Bit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%AE%8C%E6%95%B4%E7%9A%84%E9%A1%B5%E8%A1%A8"><span class="nav-text">9.2.3 更完整的页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-fault%E7%BC%BA%E9%A1%B5"><span class="nav-text">9.2.4 Page Fault：缺页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#demand-paging-performance"><span class="nav-text">9.2.5 Demand Paging Performance</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#process-creation"><span class="nav-text">9.3 Process Creation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#page-replacement-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-text">9.4 Page Replacement 页面置换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#page-replacement"><span class="nav-text">9.4.1 Page Replacement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">9.4.2 页面置换的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">9.4.3 页面置换的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fifo%E7%AE%97%E6%B3%95"><span class="nav-text">9.4.3.1 FIFO算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#optimal-page-replacement"><span class="nav-text">9.4.3.2 Optimal Page Replacement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lru%E7%AE%97%E6%B3%95"><span class="nav-text">9.4.3.3 LRU算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lru-approximation-algorithms"><span class="nav-text">9.4.3.4 LRU Approximation
Algorithms</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#additional-reference-bits-algorithm"><span class="nav-text">9.4.3.4.1
Additional-Reference-Bits Algorithm</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#second-chance-clock-algorithm"><span class="nav-text">9.4.3.4.2 Second-Chance (clock)
Algorithm</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#enhanced-second-chance-algorithm"><span class="nav-text">9.4.3.4.3 Enhanced
Second-Chance Algorithm</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#counting-algorithm"><span class="nav-text">9.4.3.5 Counting Algorithm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#page-buffering-algorithm-%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95"><span class="nav-text">9.4.3.6 Page Buffering
Algorithm 页面缓冲算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#allocation-of-frames-%E5%B8%A7%E5%88%86%E9%85%8D"><span class="nav-text">9.5 Allocation of Frames
帧分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fixed-allocation-%E5%9B%BA%E5%AE%9A%E5%88%86%E9%85%8D"><span class="nav-text">9.5.1 Fixed Allocation 固定分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-allocation-%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E9%85%8D"><span class="nav-text">9.5.2 Priority Allocation
优先级分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#global-vs.-local-allocation"><span class="nav-text">9.5.3 Global vs. Local
Allocation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A7%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="nav-text">9.5.4 帧的分配和置换策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thrashing-%E9%A2%A0%E7%B0%B8%E6%8A%96%E5%8A%A8"><span class="nav-text">9.6 Thrashing 颠簸、抖动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#demand-paging-and-thrashing"><span class="nav-text">9.6.1 Demand Paging and
Thrashing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#working-set-model"><span class="nav-text">9.6.2 Working-Set Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-fault-frequency-scheme-%E7%BC%BA%E9%A1%B5%E9%A2%91%E7%8E%87"><span class="nav-text">9.6.3 Page-Fault Frequency
Scheme 缺页频率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-mapped-files"><span class="nav-text">9.7 Memory-Mapped Files</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#allocating-kernel-memory"><span class="nav-text">9.8 Allocating Kernel Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#allocating-kernel-memory-1"><span class="nav-text">9.8.1 Allocating Kernel Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buddy-system"><span class="nav-text">9.8.2 Buddy System</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab-allocator"><span class="nav-text">9.8.3 Slab Allocator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#other-considerations"><span class="nav-text">9.9 Other Considerations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#prepaging-%E9%A2%84%E8%B0%83%E9%A1%B5"><span class="nav-text">9.9.1 Prepaging 预调页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-size-%E9%A1%B5%E5%A4%A7%E5%B0%8F"><span class="nav-text">9.9.2 Page Size 页大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tlb%E8%8C%83%E5%9B%B4"><span class="nav-text">9.9.3 TLB范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">9.9.4 程序结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E9%94%81%E5%AE%9A"><span class="nav-text">9.9.5 I&#x2F;O锁定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operating-system-examples-1"><span class="nav-text">9.10 Operating System Examples</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#windows-xp"><span class="nav-text">9.10.1 Windows XP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solaris"><span class="nav-text">9.10.2 Solaris</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-10file-system-interface"><span class="nav-text">Chapter 10：File-System
Interface</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#file-concept"><span class="nav-text">10.1 File Concept</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-text">10.1.1 文件属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">10.1.2 文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-text">10.1.3 打开文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-text">10.1.4 文件的内部结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#access-methods"><span class="nav-text">10.2 Access Methods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#directory-structure-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">10.3 Directory Structure
目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">10.3.1 目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="nav-text">10.3.2 磁盘结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">10.3.3 目录的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-text">10.3.4 文件目录的组织结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#single-level-directory-%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95"><span class="nav-text">10.3.4.1 Single-Level Directory
单级目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#two-level-directory-%E4%BA%8C%E7%BA%A7%E7%9B%AE%E5%BD%95"><span class="nav-text">10.3.4.2 Two-Level Directory
二级目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tree-structured-directories-%E6%A0%91%E5%9E%8B%E7%9B%AE%E5%BD%95"><span class="nav-text">10.3.4.3 Tree-Structured
Directories 树型目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acyclic-graph-directories-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95"><span class="nav-text">10.3.4.4
Acyclic-Graph Directories 有向无环图结构目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#general-graph-directory-%E6%99%AE%E9%80%9A%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95"><span class="nav-text">10.3.4.5 General Graph
Directory 普通图结构目录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%82%E8%BD%BD"><span class="nav-text">10.4 文件系统的挂载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-text">10.5 文件共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E5%A4%9A%E7%94%A8%E6%88%B7"><span class="nav-text">10.5.1 文件共享：多用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">10.5.2 文件共享：远程文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E9%94%99%E8%AF%AF%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.5.3 文件共享：错误模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">10.5.4 文件共享：一致性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protection"><span class="nav-text">10.6 Protection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#access-lists-and-groups"><span class="nav-text">10.6.1 Access Lists and Groups</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-11file-system-implementation"><span class="nav-text">Chapter 11：File System
Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#file-systemorganized-structure"><span class="nav-text">11.1 File-System(organized)
Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">11.1.1 分层设计的文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">11.1.2 文件系统的类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">11.2 文件系统的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-text">11.2.1 在磁盘中的文件系统结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-text">11.2.2 在内存中的文件系统结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">11.2.3 虚拟文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">11.3 目录实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%88%97%E8%A1%A8"><span class="nav-text">11.3.1 线性列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">11.3.2 哈希表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#allocation-methods-%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">11.4 Allocation Methods,
文件物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D-1"><span class="nav-text">11.4.1 连续分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D-2"><span class="nav-text">11.4.1.1 连续分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%89%A9%E5%B1%95%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%B3%BB%E7%BB%9F"><span class="nav-text">11.4.1.2 基于扩展的连续分配系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="nav-text">11.4.2 链接分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D-1"><span class="nav-text">11.4.2.1 链接分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D%E7%9A%84%E5%8F%98%E7%A7%8Dfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">11.4.2.2
链接分配的变种：FAT文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ntfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">11.4.2.3 NTFS文件系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="nav-text">11.4.3 索引分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D-1"><span class="nav-text">11.4.3.1 索引分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E7%B4%A2%E5%BC%95"><span class="nav-text">11.4.3.2 链接索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-text">11.4.3.3 二级索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-text">11.4.4 组合模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free-space-management-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-text">11.5 Free-Space Management
空闲空间管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%88%E7%8E%87%E5%92%8C%E6%80%A7%E8%83%BD"><span class="nav-text">11.6 效率和性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#page-cache"><span class="nav-text">11.6.1 Page Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unified-buffer-cache"><span class="nav-text">11.6.2 Unified Buffer Cache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recovery"><span class="nav-text">11.7 Recovery</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#log-structured-file-systems"><span class="nav-text">11.7.1 Log Structured File
Systems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#network-file-system-nfs-%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">11.7.2 Network File System
(NFS) 网络文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nfs"><span class="nav-text">11.7.2.1 NFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nfs-mount-protocol"><span class="nav-text">11.7.2.2 NFS Mount Protocol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nfs-protocol"><span class="nav-text">11.7.2.3 NFS Protocol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nfs%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%B1%82"><span class="nav-text">11.7.2.4 NFS架构中的三个主要层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nfs-path-name-translation"><span class="nav-text">11.7.2.5 NFS Path-Name
Translation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nfs%E8%BF%9C%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="nav-text">11.7.2.6 NFS远端操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8Bwafl%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">*11.8 示例：WAFL文件系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-12mass-storage-systems"><span class="nav-text">Chapter 12：Mass-Storage
Systems</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%A7%88"><span class="nav-text">12.1 大容量存储系统 概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84-1"><span class="nav-text">12.2 磁盘结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84-2"><span class="nav-text">12.2.1 磁盘结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#host-attached-storage"><span class="nav-text">12.2.2 Host-attached storage</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-text">12.4 磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-1"><span class="nav-text">12.4.1 磁盘调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">12.4.2 磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fcfs-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="nav-text">12.4.2.1 FCFS 先来先服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sstf-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="nav-text">12.4.2.2 SSTF 最短寻道时间优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scan-%E6%89%AB%E6%8F%8F"><span class="nav-text">12.4.2.3 SCAN 扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-scan"><span class="nav-text">12.4.2.4 C-SCAN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#look"><span class="nav-text">12.4.2.5 LOOK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-look"><span class="nav-text">12.4.2.6 C-LOOK</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E4%B8%80%E7%A7%8D%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">12.4.3 选择一种磁盘调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%8E%A7%E5%88%B6"><span class="nav-text">12.5 磁盘控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%8E%A7%E5%88%B6-1"><span class="nav-text">12.5.1 磁盘控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#boot-block-%E5%90%AF%E5%8A%A8%E5%9D%97"><span class="nav-text">12.5.2 Boot Block 启动块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windows-2000%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-text">12.5.3 Windows 2000的启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bad-block-%E5%9D%8F%E5%9D%97"><span class="nav-text">12.5.4 Bad Block 坏块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-text">12.6 交换空间的管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#raid%E7%BB%93%E6%9E%84"><span class="nav-text">12.7 RAID结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#raid%E4%BB%8B%E7%BB%8D"><span class="nav-text">12.7.1 RAID介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#raid%E5%B1%82%E7%BA%A7"><span class="nav-text">12.7.2 RAID层级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#raid01-%E5%92%8C-raid10"><span class="nav-text">12.7.3 RAID(0+1) 和 RAID(1+0)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-text">12.7.4 拓展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-13io-system"><span class="nav-text">Chapter 13：I&#x2F;O System</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#overview-1"><span class="nav-text">13.1 Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E7%A1%AC%E4%BB%B6"><span class="nav-text">13.2 I&#x2F;O硬件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E6%96%B9%E5%BC%8F"><span class="nav-text">13.3 I&#x2F;O方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2"><span class="nav-text">13.3.1 轮询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupt%E4%B8%AD%E6%96%AD"><span class="nav-text">13.3.2 Interrupt中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AEdmadirect-memory-access"><span class="nav-text">13.3.3
直接内存访问DMA(Direct Memory Access)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8io%E6%8E%A5%E5%8F%A3"><span class="nav-text">13.4 应用I&#x2F;O接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#block-and-character-devices-%E5%9D%97%E5%92%8C%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="nav-text">13.4.1 Block and
Character Devices 块和字符设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#network-devices-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87"><span class="nav-text">13.4.2 Network Devices 网络设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clocks-and-timers-%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">13.4.3 Clocks and Timers
时钟和定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#blocking-and-nonblocking-io-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9Eio"><span class="nav-text">13.4.4 Blocking and
Nonblocking I&#x2F;O 阻塞和非阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asynchronous-%E5%BC%82%E6%AD%A5"><span class="nav-text">13.4.5 Asynchronous 异步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8io%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-text">13.5 内核I&#x2F;O子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E8%B0%83%E5%BA%A6"><span class="nav-text">13.5.1 I&#x2F;O调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2buffer"><span class="nav-text">13.5.2 缓冲buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2cacheing"><span class="nav-text">13.5.3 高速缓冲cacheing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF-spooling"><span class="nav-text">13.5.4 假脱机技术 SPOOLing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A2%84%E5%AE%9A-device-reservation"><span class="nav-text">13.5.5 设备预定 Device
reservation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-error-handling"><span class="nav-text">13.5.6 错误处理 Error Handling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E4%BF%9D%E6%8A%A4"><span class="nav-text">13.5.7 I&#x2F;O保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">13.5.8 内核数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-requests-to-hardware-operations"><span class="nav-text">13.6 I&#x2F;O Requests to
Hardware Operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#streams"><span class="nav-text">13.7 STREAMS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-text">13.8 性能</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="华丰夏"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">华丰夏</p>
  <div class="site-description" itemprop="description">一切都是上天最好的安排</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/unicorn2022" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;unicorn2022" rel="noopener" target="_blank"><i class="fa fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">华丰夏</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">328k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共204.2k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
