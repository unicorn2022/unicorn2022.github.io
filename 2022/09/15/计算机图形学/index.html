<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机图形学 | 华风夏韵</title><meta name="author" content="华丰夏"><meta name="copyright" content="华丰夏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机图形学学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机图形学">
<meta property="og:url" content="https://hzoi-unicorn.top/2022/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/index.html">
<meta property="og:site_name" content="华风夏韵">
<meta property="og:description" content="计算机图形学学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hzoi-unicorn.top/img/avatar.png">
<meta property="article:published_time" content="2022-09-15T00:00:00.000Z">
<meta property="article:modified_time" content="2023-07-22T11:45:48.237Z">
<meta property="article:author" content="华丰夏">
<meta property="article:tag" content="专业课">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzoi-unicorn.top/img/avatar.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/unicorn2022/Pictures/main/img/favicon.png"><link rel="canonical" href="https://hzoi-unicorn.top/2022/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-PpLfvQYdq5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 华丰夏","link":"链接: ","source":"来源: 华风夏韵","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机图形学',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-07-22 19:45:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/resources/"><i class="fa-fw fa fa-book"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="华风夏韵"><span class="site-name">华风夏韵</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/resources/"><i class="fa-fw fa fa-book"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机图形学</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-15T00:00:00.000Z" title="发表于 2022-09-15 08:00:00">2022-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-22T11:45:48.237Z" title="更新于 2023-07-22 19:45:48">2023-07-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">专业课学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机图形学"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><script type="text/javascript"
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<h1 id="Chanpter-0：Introduction"><a href="#Chanpter-0：Introduction" class="headerlink" title="Chanpter 0：Introduction"></a>Chanpter 0：Introduction</h1><p>三个重要的属性：</p>
<ol>
<li>形状</li>
<li>外表</li>
<li>动态行为的属性（如粗糙度、移动）</li>
</ol>
<p>三个基础任务：</p>
<ol>
<li>建模</li>
<li>模拟物体的行为</li>
<li>渲染Rendering</li>
</ol>
<p>Visual Computer：</p>
<ol>
<li>Image Processing：Image=&gt;Image</li>
<li>Computer Vision：Image=&gt;3D</li>
<li>Computer Graphics：3D=&gt;3D，3D=&gt;Image</li>
</ol>
<h1 id="Chapter-1-2D-Graphics"><a href="#Chapter-1-2D-Graphics" class="headerlink" title="Chapter 1    2D Graphics"></a>Chapter 1    2D Graphics</h1><h2 id="1-1-Rasterization光栅化"><a href="#1-1-Rasterization光栅化" class="headerlink" title="1.1    Rasterization光栅化"></a>1.1    Rasterization光栅化</h2><ol>
<li>将二维基本体(<strong>primitives</strong>，如直线、多边形)转换为光栅图像</li>
<li><strong>PWM</strong>：控制元件一段时间亮，一段时间不亮，以得到不同光强的光</li>
</ol>
<h3 id="1-1-1-坐标系"><a href="#1-1-1-坐标系" class="headerlink" title="1.1.1    坐标系"></a>1.1.1    坐标系</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922081856989.png" alt="image-20220922081856989" style="zoom:80%;" /></p>
<ol>
<li>坐标系：以像素的中心作为整数坐标</li>
</ol>
<h2 id="1-2-线段"><a href="#1-2-线段" class="headerlink" title="1.2    线段"></a>1.2    线段</h2><h3 id="1-2-1-线段的定义"><a href="#1-2-1-线段的定义" class="headerlink" title="1.2.1    线段的定义"></a>1.2.1    线段的定义</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922082519056.png" alt="image-20220922082519056" style="zoom:80%;" /></p>
<ol>
<li>线段：给定起点、终点、以及各自的颜色、线段的颜色<ol>
<li>一般来说，起点和终点均为整数坐标</li>
</ol>
</li>
</ol>
<h3 id="1-2-2-线段的光栅化"><a href="#1-2-2-线段的光栅化" class="headerlink" title="1.2.2    线段的光栅化"></a>1.2.2    线段的光栅化</h3><ol>
<li><p>将线段光栅化到屏幕的要求：</p>
<ol>
<li>选中的像素尽可能接近理想线段</li>
<li>像素的序列尽可能直</li>
<li>像素的亮度尽可能一样</li>
<li>像素的起始和结束尽可能精确</li>
<li>画的足够快</li>
<li>可以画不同宽度的线段</li>
</ol>
</li>
<li><p>将线段光栅化到屏幕的方法：</p>
<ol>
<li>计算线段的表达式</li>
<li>枚举x，计算y，判断计算出的(x,y)属于哪一个像素(Rounding)</li>
<li>给对应的像素上色</li>
</ol>
</li>
<li><p>优化掉Rounding：</p>
<ol>
<li>Rounding的任务：四舍五入，本质是做一个比较</li>
<li>斜率：x每增加一个单位，y变化相应的单位</li>
</ol>
</li>
<li><p>DDA：Digital Differential Analyzer，数字微分分析</p>
</li>
<li><p>线段的象限：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922090026618.png" alt="image-20220922090026618" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="1-2-3-Bresenham画线算法"><a href="#1-2-3-Bresenham画线算法" class="headerlink" title="1.2.3    Bresenham画线算法"></a>1.2.3    Bresenham画线算法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922084258568.png" alt="image-20220922084258568" style="zoom:80%;" /></p>
<p>$y_i=m·x_i+c,其中m=\frac{y_2-y_1}{x_2-x_1}$</p>
<p>思路：</p>
<ol>
<li>对于相邻的两个像素，当x++时，y’只有两种可能：y或y+1</li>
<li>y’是否+1，取决于$y_{actual}$与y+1近，还是y近</li>
</ol>
<p><strong>Bresenham画线算法</strong>：假设线段在第一象限(x增加时y也增加)</p>
<ol>
<li><p>定义：$dx=x_2-x_1,dy=y_2-y_1,m=\frac{dy}{dx}$</p>
</li>
<li><p>定义：$y=m(x_i+1)+b,d_1=y-y_i,d2=y_i+1-y$</p>
</li>
<li><p>若$d<em>1-d_2&gt;0$，则$y</em>{i+1}=y<em>i+1$；若$d_1-d_2&lt;0$，则$y</em>{i+1}=y_i$</p>
</li>
<li><p>定义：$P_i=(d_1-d_2)*dx=2x_idy-2y_idx+2dy+(2b-1)dx$</p>
<ol>
<li>由于线在第一象限上，因此$P_i$与$d_1-d_2$的符号相同</li>
<li>因此：若$P<em>i&gt;0$，则$y</em>{i+1}=y<em>i+1$；若$P_i&lt;0$，则$y</em>{i+1}=y_i$</li>
</ol>
</li>
<li><p>可以计算出，$P<em>{i+1}=P_i+2dy-2(y</em>{i+1}-y_i)dx$</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922084619794.png" alt="image-20220922084619794" style="zoom:80%;" /></p>
</li>
<li><p>伪码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x1,y1);</span><br><span class="line">dx = x2 - x1; dy = y2 - y1; P[<span class="number">1</span>] = <span class="number">2</span>*dy - dx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; x2+<span class="number">1</span>; i++)&#123;</span><br><span class="line">    x[i+<span class="number">1</span>] = x[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P[i] &gt; <span class="number">0</span>) y[i+<span class="number">1</span>] = y[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> y[i+<span class="number">1</span>] = y[i];</span><br><span class="line">    <span class="built_in">plot</span>(x[i+<span class="number">1</span>], y[i+<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(P[i] &gt; <span class="number">0</span>) P[i+<span class="number">1</span>] = P[i] + <span class="number">2</span>*dy - <span class="number">2</span>*dx;</span><br><span class="line">    <span class="keyword">else</span> P[i+<span class="number">1</span>] = P[i] + <span class="number">2</span>*dy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="1-3-圆"><a href="#1-3-圆" class="headerlink" title="1.3    圆"></a>1.3    圆</h2><h3 id="1-3-1-圆的定义-使用极坐标定义"><a href="#1-3-1-圆的定义-使用极坐标定义" class="headerlink" title="1.3.1    圆的定义(使用极坐标定义)"></a>1.3.1    圆的定义(使用极坐标定义)</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922090614503.png" alt="image-20220922090614503"></p>
<p>$x_{i+1}=x_i\cos\Delta\theta-y_i\sin\Delta\theta$</p>
<ol>
<li>存在累加误差</li>
<li>一般情况下，浮点加法的误差比浮点乘法的定义大，误差出现在大数加小数上</li>
</ol>
<h3 id="1-3-2-Bresenham画圆算法"><a href="#1-3-2-Bresenham画圆算法" class="headerlink" title="1.3.2    Bresenham画圆算法"></a>1.3.2    Bresenham画圆算法</h3><p><strong>理论推导</strong>：</p>
<ol>
<li><p>采用八分法画圆：由于圆的对称性，只需要计算出$\frac{1}{8}$圆弧的像素点即可</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzk3MjM=,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:50%;" /></p>
</li>
<li><p>只考虑第一象限的上半部分，x每次增加1，y减少1或不变</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzk3MjM=,size_16,color_FFFFFF,t_70-16639873054602.png" alt="img" style="zoom:80%;" /></p>
</li>
<li><p>将中点$M(x_i+1,y_i-0.5)$带入圆的隐式方程，得到：$d[i]=F(M)=(x[i]+1)^2+(y[i]-0.5)^2-R^2$，如上图所示</p>
<ol>
<li>如果$d\le0$，则M在圆内，$p[i+1]=(x[i]+1,y[i])$</li>
<li>如果$d&gt;0$，则M在圆外，$p[i+1]=(x[i]+1,y[i]-1)$</li>
</ol>
</li>
<li><p>进行递推计算</p>
<ol>
<li>如果$d[i]\le 0$，得到<ol>
<li>$d[i]=(x[i]+1)^2+(y[i]-0.5)^2-R^2$</li>
<li>$d[i+1]=(x[i]+2)^2+(y[i]-0.5)^2-R^2$</li>
<li>$\Delta d = 2x[i]+3$</li>
</ol>
</li>
<li>如果$d[i] &gt; 0$，得到<ol>
<li>$d[i]=(x[i]+1)^2+(y[i]-0.5)^2-R^2$</li>
<li>$d[i+1]=(x[i]+2)^2+(y[i]-1.5)^2-R^2$</li>
<li>$\Delta d = 2(x[i]-y[i])+5$</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>画圆步骤</strong>：</p>
<ol>
<li>画上半部分：<ol>
<li>输入圆的半径，计算初始值$(x[0],y[0])=(0,R)$</li>
<li>判断$d[i]$的符号，计算$(x[i+1],y[i+1])$的坐标</li>
<li>$d[i+1]$根据$d[i]$递推</li>
<li>当$x&lt;y$时，重复2~3步，否则结束</li>
</ol>
</li>
<li>根据对称性，画出完整的圆</li>
</ol>
<h3 id="1-3-3-椭圆的中点画法"><a href="#1-3-3-椭圆的中点画法" class="headerlink" title="1.3.3    椭圆的中点画法"></a>1.3.3    椭圆的中点画法</h3><p><strong>理论推导</strong>：</p>
<ol>
<li><p>椭圆需要画出$\frac{1}{4}$，而且我们需要找到分界点，如下图。</p>
<ol>
<li>分界点上，x为主增量</li>
<li>分界点下，y为主增量</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzk3MjM=,size_16,color_FFFFFF,t_70-16639880829154.png" alt="img" style="zoom:80%;" /></p>
</li>
<li><p>考虑上半部分：</p>
<ol>
<li>将中点$M(x[i]+1,y[i]-0.5)$带入椭圆的隐式方程，得到$d[i]=F(M)=a^2(y[i]-0.5)^2+b^2(x[i]+1)^2-a^2b^2$<ol>
<li>如果$d\le0$，则M在椭圆内，$p[i+1]=(x[i]+1,y[i])$</li>
<li>如果$d&gt;0$，则M在椭圆外，$p[i+1]=(x[i]+1,y[i]-1)$</li>
</ol>
</li>
<li>进行递推计算<ol>
<li>如果$d[i]\le 0$，得到<ol>
<li>$d[i]=a^2(y[i]-0.5)^2+b^2(x[i]+1)^2-a^2b^2$</li>
<li>$d[i+1]=a^2(y[i]-0.5)^2+b^2(x[i]+2)^2-a^2b^2$</li>
<li>$\Delta d = b^2(2x[i]+3)$</li>
</ol>
</li>
<li>如果$d[i] &gt; 0$，得到<ol>
<li>$d[i]=a^2(y[i]-0.5)^2+b^2(x[i]+1)^2-a^2b^2$</li>
<li>$d[i+1]=a^2(y[i]-1.5)^2+b^2(x[i]+2)^2-a^2b^2$</li>
<li>$\Delta d = b^2(2x[i]+3)+2a^2(-y[i]+1)$</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>对于下半部分：</p>
<ol>
<li>将中点$M(x[i]-0.5,y[i]+1)$带入椭圆的隐式方程，得到$d[i]=F(M)=a^2(y[i]+1)^2+b^2(x[i]-0.5)^2-a^2b^2$<ol>
<li>如果$d\le0$，则M在椭圆内，$p[i+1]=(x[i],y[i]+1)$</li>
<li>如果$d&gt;0$，则M在椭圆外，$p[i+1]=(x[i]-1,y[i]+1)$</li>
</ol>
</li>
<li>进行递推计算<ol>
<li>如果$d[i]\le 0$，得到<ol>
<li>$d[i]=a^2(y[i]+1)^2+b^2(x[i]-0.5)^2-a^2b^2$</li>
<li>$d[i+1]=a^2(y[i]+2)^2+b^2(x[i]-0.5)^2-a^2b^2$</li>
<li>$\Delta d = a^2(2y[i]+3)$</li>
</ol>
</li>
<li>如果$d[i] &gt; 0$，得到<ol>
<li>$d[i]=a^2(y[i]+1)^2+b^2(x[i]-0.5)^2-a^2b^2$</li>
<li>$d[i+1]=a^2(y[i]+2)^2+b^2(x[i]-1.5)^2-a^2b^2$</li>
<li>$\Delta d = a^2(2y[i]+3) + 2b^2(-x[i]+1)$</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>画圆步骤</strong>：</p>
<ol>
<li>画上半部分：<ol>
<li>输入椭圆的半径，计算初始值<ol>
<li>$(x[0],y[0])=(0,b)$</li>
<li>$d[0]=a^2(b-0.5)^2+b^2-a^2b^2$</li>
</ol>
</li>
<li>判断$d[i]$的符号，计算$(x[i+1],y[i+1])$的坐标<ol>
<li>如果$d\le0$，则M在椭圆内，$p[i+1]=(x[i]+1,y[i])$</li>
<li>如果$d&gt;0$，则M在椭圆外，$p[i+1]=(x[i]+1,y[i]-1)$</li>
</ol>
</li>
<li>$d[i+1]$根据$d[i]$递推<ol>
<li>如果$d[i]\le 0$，得到$d[i+1] = d[i] + b^2(2x[i]+3)$</li>
<li>如果$d[i] &gt; 0$，得到$d[i+1] = d[i] + b^2(2x[i]+3)+2a^2(-y[i]+1)$</li>
</ol>
</li>
<li>当$2a^2(y[i]-0.5)&gt;2b^2(x[i]+1)$时，重复2~3步，否则结束</li>
</ol>
</li>
<li>画下半部分：<ol>
<li>输入椭圆的半径，计算初始值<ol>
<li>$(x[0],y[0])=(a,0)$</li>
<li>$d[0]=a^2+b^2(a-0.5)^2-a^2b^2$</li>
</ol>
</li>
<li>判断$d[i]$的符号，计算$(x[i+1],y[i+1])$的坐标<ol>
<li>如果$d\le0$，则M在椭圆内，$p[i+1]=(x[i],y[i]+1)$</li>
<li>如果$d&gt;0$，则M在椭圆外，$p[i+1]=(x[i]-1,y[i]+1)$</li>
</ol>
</li>
<li>$d[i+1]$根据$d[i]$递推<ol>
<li>如果$d[i]\le 0$，得到$d[i+1] = d[i] + a^2(2y[i]+3)$</li>
<li>如果$d[i] &gt; 0$，得到$d[i+1] = d[i] + a^2(2y[i]+3) + 2b^2(-x[i]+1)$</li>
</ol>
</li>
<li>当$2a^2(y[i]-0.5) \le 2b^2(x[i]+1)$时，重复2~3步，否则结束</li>
</ol>
</li>
<li>根据对称性，画出完整的椭圆</li>
</ol>
<h2 id="1-4-多边形填充"><a href="#1-4-多边形填充" class="headerlink" title="1.4    多边形填充"></a>1.4    多边形填充</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922091245511.png" alt="image-20220922091245511" style="zoom:80%;" /></p>
<h3 id="1-4-1-判断一个点是否在多边形之中"><a href="#1-4-1-判断一个点是否在多边形之中" class="headerlink" title="1.4.1    判断一个点是否在多边形之中"></a>1.4.1    判断一个点是否在多边形之中</h3><ol>
<li><p>奇偶测试：画水平线，与多边形相交，奇数点和偶数点之间的像素在多边形之中</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922091757368.png" alt="image-20220922091757368" style="zoom:80%;" /></p>
</li>
<li><p>Winding Number test：从选定的点开始，计算与多边形的所有相邻顶点之间的夹角，如果在内部，则夹角和为360°</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922091850038.png" alt="image-20220922091850038" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="1-4-2-Scan-line-Method"><a href="#1-4-2-Scan-line-Method" class="headerlink" title="1.4.2    Scan-line Method"></a>1.4.2    Scan-line Method</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922092116274.png" alt="image-20220922092116274" style="zoom:80%;" /></p>
<ol>
<li><p>从上到下，从左到右，进行扫描</p>
</li>
<li><p>计算每一根扫描线与多边形的交点，奇数点与偶数点之间填充颜色</p>
</li>
<li><p>计算交点：假设交点数不发生变化，则这就是画线算法的一步</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922092542517.png" alt="image-20220922092542517" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="1-4-3-Seed-Fill-Algorithm种子填充算法"><a href="#1-4-3-Seed-Fill-Algorithm种子填充算法" class="headerlink" title="1.4.3    Seed Fill Algorithm种子填充算法"></a>1.4.3    Seed Fill Algorithm种子填充算法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922092634034.png" alt="image-20220922092634034" style="zoom:80%;" /></p>
<h3 id="1-4-4-Clipping"><a href="#1-4-4-Clipping" class="headerlink" title="1.4.4    Clipping"></a>1.4.4    Clipping</h3><ol>
<li><p>Clipping：将不在屏幕中的对象裁剪掉</p>
<ol>
<li>在光栅化之前进行，对primitive进行操作</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220922093506903.png" alt="image-20220922093506903"></p>
</li>
</ol>
<h1 id="Chapter-2：Introduction-to-OpenGL"><a href="#Chapter-2：Introduction-to-OpenGL" class="headerlink" title="Chapter 2：Introduction to OpenGL"></a>Chapter 2：Introduction to OpenGL</h1><h2 id="2-1-OpenGL的功能"><a href="#2-1-OpenGL的功能" class="headerlink" title="2.1    OpenGL的功能"></a>2.1    OpenGL的功能</h2><ol>
<li>定义物体的形状、材质的属性、光照<ol>
<li>根据简单的点、线、多边形构建一个复杂的图形</li>
</ol>
</li>
<li>将物体放到场景中，且投射到摄像机中</li>
<li>将物体的数学表达式转化为像素：<strong>Rasterization</strong></li>
<li>计算物体的每个点的颜色：<strong>Shading</strong></li>
</ol>
<h2 id="2-2-OpenGL工具链"><a href="#2-2-OpenGL工具链" class="headerlink" title="2.2    OpenGL工具链"></a>2.2    OpenGL工具链</h2><ol>
<li>OpenGL <strong>&lt; GL/gl.h &gt;</strong>：跨平台的核心库</li>
<li>GLU <strong>&lt; GL/glu.h &gt;</strong>：实现了一系列的图形函数</li>
<li>GLUT <strong>&lt; GL/glut.h &gt;</strong>：实现了窗口创建、操作系统调用(如鼠标、键盘)</li>
<li>GLUI：用户界面</li>
</ol>
<h2 id="2-3-OpenGL中的三个阶段"><a href="#2-3-OpenGL中的三个阶段" class="headerlink" title="2.3    OpenGL中的三个阶段"></a>2.3    OpenGL中的三个阶段</h2><ol>
<li>在世界坐标中定义一个物体</li>
<li>设置Modeling &amp; Viewing变换</li>
<li>渲染场景</li>
</ol>
<h2 id="2-4-OpenGL的工作方式"><a href="#2-4-OpenGL的工作方式" class="headerlink" title="2.4    OpenGL的工作方式"></a>2.4    OpenGL的工作方式</h2><ol>
<li>OpenGL是一个状态机</li>
<li>OpenGL会给定一个起始状态，有一些初始值</li>
<li>除非显式设置一些值，否则当前状态不会改变<ol>
<li>比如设置当前颜色是红色，在下一次显式更改颜色之前，所有的图形均会化成红色</li>
<li>所有的状态均有一个默认值</li>
</ol>
</li>
</ol>
<h2 id="2-5-OpenGL的元素"><a href="#2-5-OpenGL的元素" class="headerlink" title="2.5    OpenGL的元素"></a>2.5    OpenGL的元素</h2><ol>
<li><p>GL_POINTS：点</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085246455.png" alt="image-20220929085246455" style="zoom:80%;" /></p>
</li>
<li><p>GL_LINES：线</p>
<ol>
<li>给定一个点的数组，两两之间画线</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085347331.png" alt="image-20220929085347331" style="zoom:80%;" /></p>
</li>
<li><p>GL_LINE_STRIP：线</p>
<ol>
<li>给定一个数组，每一根线段的起点是前一根的终点，中点是后一根的起点</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085403212.png" alt="image-20220929085403212" style="zoom:80%;" /></p>
</li>
<li><p>GL_LINE_LOOP</p>
<ol>
<li>线，给定一个数组，每一根线段的起点是前一根的终点，中点是后一根的起点</li>
<li>首尾相连</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085414235.png" alt="image-20220929085414235" style="zoom:80%;" /></p>
</li>
<li><p>GL_TRIANGLES：三角形</p>
<ol>
<li>给定一个点的数组，以三个为一组画三角形</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085449285.png" alt="image-20220929085449285" style="zoom:80%;" /></p>
</li>
<li><p>GL_TRANGLE_FAN：三角形</p>
<ol>
<li>给定一个点的数组，第0个点为扇形的圆心，剩下的逆时针排列</li>
</ol>
</li>
<li><p>GL_TRANGLE_STRIP：三角形</p>
<ol>
<li>给定一个点的数组，相邻两个三角形共边</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085504670.png" alt="image-20220929085504670" style="zoom:80%;" /></p>
</li>
<li><p>GL_POLYGON：多边形</p>
<ol>
<li>多边形默认是共面、凸多边形</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929085255853.png" alt="image-20220929085255853" style="zoom:80%;" /></p>
</li>
<li><p>GL_QUADS：四边形</p>
</li>
<li><p>GL_QUAD_STRIP：四边形</p>
</li>
</ol>
<h2 id="2-6-OpenGL的基础格式"><a href="#2-6-OpenGL的基础格式" class="headerlink" title="2.6    OpenGL的基础格式"></a>2.6    OpenGL的基础格式</h2><h3 id="2-6-1-OpenGL的函数"><a href="#2-6-1-OpenGL的函数" class="headerlink" title="2.6.1    OpenGL的函数"></a>2.6.1    OpenGL的函数</h3><ol>
<li><p>所有的函数名以<strong>gl</strong>开始</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量均为大写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">     GL_COLOR_BUFFER_BIT</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>   数据类型以**GL**开始：为了跨平台</span><br><span class="line"></span><br><span class="line">     ```c++</span><br><span class="line">     GLfloat onevertex[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>大多数函数名的结尾表示参数的数据类型及个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertex3f</span>(...); <span class="comment">//3个GLfoat的参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>glVertex</strong>：所有的对象都是由顶点定义的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertex2f</span>(x, y);</span><br><span class="line"><span class="built_in">glVertex3f</span>(x, y, z);</span><br><span class="line"><span class="built_in">glVertex4f</span>(x, y, z, w);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(a);			<span class="comment">// with a[0], a[1], a[2]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-6-2-根据顶点创建物体"><a href="#2-6-2-根据顶点创建物体" class="headerlink" title="2.6.2    根据顶点创建物体"></a>2.6.2    根据顶点创建物体</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line">	<span class="built_in">glVertex3f</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>);</span><br><span class="line">	<span class="built_in">glVertex3f</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">	<span class="built_in">glVertex3f</span>(<span class="number">3.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">	<span class="built_in">glVertex3f</span>(<span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090505040.png" alt="image-20220929090505040" style="zoom:80%;" /></p>
<h3 id="2-6-3-颜色"><a href="#2-6-3-颜色" class="headerlink" title="2.6.3    颜色"></a>2.6.3    颜色</h3><ol>
<li>根据RGB三个分量，float类型，范围为[0.0, 1.0]</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背景颜色</span></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"><span class="comment">// 物体颜色</span></span><br><span class="line"><span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-6-4-其它可以放在glBegin-glEnd中的函数"><a href="#2-6-4-其它可以放在glBegin-glEnd中的函数" class="headerlink" title="2.6.4    其它可以放在glBegin/glEnd中的函数"></a>2.6.4    其它可以放在glBegin/glEnd中的函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090841289.png" alt="image-20220929090841289" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090901328.png" alt="image-20220929090901328" style="zoom:80%;" /></p>
<h3 id="2-6-5-多边形的显示模型"><a href="#2-6-5-多边形的显示模型" class="headerlink" title="2.6.5    多边形的显示模型"></a>2.6.5    多边形的显示模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090924589.png" alt="image-20220929090924589" style="zoom:80%;" /></p>
<h3 id="2-6-6-编译OpenGL程序"><a href="#2-6-6-编译OpenGL程序" class="headerlink" title="2.6.6    编译OpenGL程序"></a>2.6.6    编译OpenGL程序</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929090945521.png" alt="image-20220929090945521" style="zoom:80%;" /></p>
<h3 id="2-6-7-GLUT-based程序的结构"><a href="#2-6-7-GLUT-based程序的结构" class="headerlink" title="2.6.7    GLUT-based程序的结构"></a>2.6.7    GLUT-based程序的结构</h3><ol>
<li><p>GLUT基于用户定义的回调函数，在每一个事件发生时调用</p>
<ol>
<li><p>用户显示屏幕的函数</p>
</li>
<li><p>用于重新设置viewport的大小的函数</p>
</li>
<li><p>用于处理键盘/鼠标输入的函数</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091042541.png" alt="image-20220929091042541" style="zoom:80%;" /></p>
</li>
</ol>
</li>
<li><p>例：画一个多边形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_RGBA | GLUT_DOUBLE);</span><br><span class="line">    <span class="type">int</span> windowHandle = <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;Simple GLUT App&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(redraw);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glutMainLoop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readraw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glBegin</span>(GL_QUADS);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    	<span class="built_in">glVertex3f</span>(<span class="number">-0.5</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    	<span class="built_in">glVertex3f</span>( <span class="number">0.5</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    	<span class="built_in">glVertex3f</span>( <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    	<span class="built_in">glVertex3f</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">   <span class="built_in">glEnd</span>();</span><br><span class="line">    <span class="built_in">glutSwapBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Double buffer：画在一个buffer中，显示另一个buffer，然后进行切换</p>
<ol>
<li>可以防止显示绘画的过程</li>
</ol>
</li>
<li><p>其它GLUT</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091653690.png" alt="image-20220929091653690" style="zoom:80%;" /></p>
<h3 id="2-6-8-回调"><a href="#2-6-8-回调" class="headerlink" title="2.6.8    回调"></a>2.6.8    回调</h3><ol>
<li><p>Reshape Callback</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091743114.png" alt="image-20220929091743114" style="zoom:80%;" /></p>
</li>
<li><p>鼠标回调</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091758018.png" alt="image-20220929091758018" style="zoom:80%;" /></p>
</li>
<li><p>键盘回调</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091819083.png" alt="image-20220929091819083" style="zoom:80%;" /></p>
</li>
<li><p>静止回调</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091835079.png" alt="image-20220929091835079" style="zoom:80%;" /></p>
</li>
<li><p>菜单回调</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929091846842.png" alt="image-20220929091846842" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="2-6-9-动画"><a href="#2-6-9-动画" class="headerlink" title="2.6.9    动画"></a>2.6.9    动画</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929092157021.png" alt="image-20220929092157021" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929092207632.png" alt="image-20220929092207632" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929092217364.png" alt="image-20220929092217364" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20220929092227042.png" alt="image-20220929092227042" style="zoom:80%;" /></p>
<h1 id="Chapter-3：Basic-Math"><a href="#Chapter-3：Basic-Math" class="headerlink" title="Chapter 3：Basic Math"></a>Chapter 3：Basic Math</h1><h2 id="3-1-向量"><a href="#3-1-向量" class="headerlink" title="3.1    向量"></a>3.1    向量</h2><h3 id="3-1-1-点乘"><a href="#3-1-1-点乘" class="headerlink" title="3.1.1    点乘"></a>3.1.1    点乘</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008081644667.png" alt="image-20221008081644667" style="zoom:80%;" /></p>
<p>$\vec{a}·\vec{b}=|\vec{a}||\vec{b}|\cos\theta=x_a<em>x_b+y_a</em>y_b+z_a*z_b$</p>
<ol>
<li><p>本质是：投影操作</p>
<ol>
<li>函数可以看作是一个无限维的向量</li>
<li>FFT本质上是将函数换了一个坐标轴(不同的余弦函数)，进行投影操作</li>
</ol>
</li>
<li><p>转换坐标：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082012976.png" alt="image-20221008082012976" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="3-1-2-差积"><a href="#3-1-2-差积" class="headerlink" title="3.1.2    差积"></a>3.1.2    差积</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082221936.png" alt="image-20221008082221936" style="zoom:80%;" /></p>
<ol>
<li>方向：右手法则（从$\vec{a}$转到$\vec{b}$）</li>
</ol>
<h3 id="3-1-3-点的操作"><a href="#3-1-3-点的操作" class="headerlink" title="3.1.3    点的操作"></a>3.1.3    点的操作</h3><ol>
<li>点 - 点 = 向量</li>
<li>点 + 向量 = 点</li>
</ol>
<h2 id="3-2-直线"><a href="#3-2-直线" class="headerlink" title="3.2    直线"></a>3.2    直线</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082546772.png" alt="image-20221008082546772" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082742925.png" alt="image-20221008082742925" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008082820347.png" alt="image-20221008082820347" style="zoom:80%;" /></p>
<ol>
<li>直线方程：$(p-p_0)·\vec{n}=0 \rightarrow ax+by+c = 0$<ol>
<li>$\vec{t} = p-p_0=(x_1-x_0,y_1-y_0)$</li>
<li>$\vec{n}=Prep(\vec{t})=(y_0-y_1,x_1-x_0)$</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LineEquation</span><span class="params">(vertex &amp;v0, vertex &amp;v1, line &amp;l)</span></span>&#123;</span><br><span class="line">    l.a = v1.y - v0.y;</span><br><span class="line">    l.b = v0.x - v1.x;</span><br><span class="line">    l.c = -(l.a * v0.x + l.b * v0.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-变换Transform"><a href="#3-3-变换Transform" class="headerlink" title="3.3    变换Transform"></a>3.3    变换Transform</h2><h3 id="3-3-1-平移Translation"><a href="#3-3-1-平移Translation" class="headerlink" title="3.3.1    平移Translation"></a>3.3.1    平移Translation</h3><script type="math/tex; mode=display">
x\rightarrow x+T_x \\
y\rightarrow y+T_y \\
z\rightarrow z+T_z \\</script><ol>
<li>刚体变换：不会改变物体的形状</li>
</ol>
<h3 id="3-3-2-缩放Scaling"><a href="#3-3-2-缩放Scaling" class="headerlink" title="3.3.2    缩放Scaling"></a>3.3.2    缩放Scaling</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008083332443.png" alt="image-20221008083332443" style="zoom:80%;" /></p>
<script type="math/tex; mode=display">
x\rightarrow x*S_x \\
y\rightarrow y*S_y \\
z\rightarrow z*S_z \\</script><ol>
<li>以<strong>原点</strong>为中心进行缩放：直接对xyz乘上对应的缩放因子</li>
<li>以<strong>某个点</strong>为中心进行缩放：先平移到原点，然后缩放，然后再平移回去</li>
</ol>
<h3 id="3-3-3-旋转Rotation"><a href="#3-3-3-旋转Rotation" class="headerlink" title="3.3.3    旋转Rotation"></a>3.3.3    旋转Rotation</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008083723743.png" alt="image-20221008083723743" style="zoom:80%;" /></p>
<script type="math/tex; mode=display">
x'=x*\cos\theta-y*\sin\theta \\
y'=x*\sin\theta+y*\cos\theta \\</script><ol>
<li>刚体变换：不会改变物体的形状</li>
<li>2维：绕原点旋转；3维：绕旋转轴旋转</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008084010992.png" alt="image-20221008084010992" style="zoom:80%;" /></p>
<script type="math/tex; mode=display">
x'=x_r+(x-x_r)\cos\theta-(y-y_r)\sin\theta \\
y'=y_r+(y-y_r)\cos\theta+(x-x_r)\sin\theta \\</script><ol>
<li>绕某一个点旋转：<ol>
<li>将要旋转的点平移到原点上</li>
<li>进行旋转</li>
<li>然后再平移回去</li>
</ol>
</li>
</ol>
<h3 id="3-3-4-剪切Shearing"><a href="#3-3-4-剪切Shearing" class="headerlink" title="3.3.4    剪切Shearing"></a>3.3.4    剪切Shearing</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008084226181.png" alt="image-20221008084226181" style="zoom:80%;" /></p>
<h2 id="3-4-齐次坐标"><a href="#3-4-齐次坐标" class="headerlink" title="3.4    齐次坐标"></a>3.4    齐次坐标</h2><h3 id="3-4-1-点-向量的对应关系"><a href="#3-4-1-点-向量的对应关系" class="headerlink" title="3.4.1    点/向量的对应关系"></a>3.4.1    点/向量的对应关系</h3><ol>
<li>点：$[x,y]\rightarrow[x,y,1]$</li>
<li>向量：$[x,y]\rightarrow[x,y,0]$</li>
<li>$[x,y,w]==[x/w,y/w,z/w]$</li>
</ol>
<h3 id="3-4-2-线性变换与矩阵的对应关系"><a href="#3-4-2-线性变换与矩阵的对应关系" class="headerlink" title="3.4.2    线性变换与矩阵的对应关系"></a>3.4.2    线性变换与矩阵的对应关系</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008085728747.png" alt="image-20221008085728747" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090046598.png" alt="image-20221008090046598" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008085901606.png" alt="image-20221008085901606" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090012572.png" alt="image-20221008090012572" style="zoom:80%;" /></p>
<h3 id="3-4-3-复合变换"><a href="#3-4-3-复合变换" class="headerlink" title="3.4.3    复合变换"></a>3.4.3    复合变换</h3><ol>
<li>每乘一个矩阵，就相当于进行了一次变换</li>
<li>由于矩阵乘法具有结合律，因此可以先将变换矩阵相乘，再和向量相乘</li>
<li>也就是说，可以用一个矩阵，表示任意的齐次变换</li>
<li>先进行的变换，其变换矩阵写在后面</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090542957.png" alt="image-20221008090542957" style="zoom:80%;" /></p>
<h3 id="3-4-4-矩阵形式表示关于某个点P的变换"><a href="#3-4-4-矩阵形式表示关于某个点P的变换" class="headerlink" title="3.4.4    矩阵形式表示关于某个点P的变换"></a>3.4.4    矩阵形式表示关于某个点P的变换</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090552802.png" alt="image-20221008090552802" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008090707899.png" alt="image-20221008090707899" style="zoom:80%;" /></p>
<h3 id="3-4-5-绕任意轴旋转"><a href="#3-4-5-绕任意轴旋转" class="headerlink" title="3.4.5    绕任意轴旋转"></a>3.4.5    绕任意轴旋转</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008091039215.png" alt="image-20221008091039215" style="zoom:80%;" /></p>
<ol>
<li><p>将旋转轴旋转到Z轴</p>
<ol>
<li>$T$：将轴平移至过原点</li>
<li>$R_x(\alpha)$：绕X轴旋转，让旋转轴处于yz平面</li>
<li>$R_y(\beta)$：绕Y轴旋转，让旋转轴处于xz平面</li>
<li>$R_z(\theta)$：绕Z轴旋转，让旋转轴与z轴重合</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008091343729.png" alt="image-20221008091343729" style="zoom:80%;" /></p>
</li>
<li><p>绕Z轴旋转角度</p>
</li>
<li><p>进行第1步的逆变换</p>
</li>
</ol>
<h2 id="3-5-OpenGL中的变换"><a href="#3-5-OpenGL中的变换" class="headerlink" title="3.5    OpenGL中的变换"></a>3.5    OpenGL中的变换</h2><h3 id="3-5-1-CTM"><a href="#3-5-1-CTM" class="headerlink" title="3.5.1    CTM"></a>3.5.1    CTM</h3><ol>
<li>Current Transform Matrix：当前变换矩阵</li>
</ol>
<h3 id="3-5-2-修改CTM"><a href="#3-5-2-修改CTM" class="headerlink" title="3.5.2    修改CTM"></a>3.5.2    修改CTM</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008091844590.png" alt="image-20221008091844590" style="zoom:80%;" /></p>
<h3 id="3-5-3-绕某个轴轴旋转"><a href="#3-5-3-绕某个轴轴旋转" class="headerlink" title="3.5.3    绕某个轴轴旋转"></a>3.5.3    绕某个轴轴旋转</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008092006187.png" alt="image-20221008092006187" style="zoom:80%;" /></p>
<ol>
<li>最后写的操作会最先执行，按照前面写矩阵的顺序写代码即可</li>
</ol>
<h3 id="3-5-4-Matrix-Stack"><a href="#3-5-4-Matrix-Stack" class="headerlink" title="3.5.4    Matrix Stack"></a>3.5.4    Matrix Stack</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221008092229650.png" alt="image-20221008092229650" style="zoom:80%;" /></p>
<h2 id="3-6-向量的进一步应用"><a href="#3-6-向量的进一步应用" class="headerlink" title="3.6    向量的进一步应用"></a>3.6    向量的进一步应用</h2><h3 id="3-6-1-计算两个线段的交点"><a href="#3-6-1-计算两个线段的交点" class="headerlink" title="3.6.1    计算两个线段的交点"></a>3.6.1    计算两个线段的交点</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/v2-23d0f051422fe205ad6ce24b9c41b96a_720w.webp" alt="img" style="zoom: 67%;" /></p>
<ol>
<li><p>判断两个线段相交</p>
<ol>
<li>判断依据：点c和点d在直线ab的两侧，且点a和点b在直线cd的两侧</li>
<li>判断方法：使用向量叉乘求abd, abc的“面积”，当两线段相交时，abc与abd面积正负号相反</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以ab为三角形公共边，求三角形abc, abd的面积，并判断是否不相交</span></span><br><span class="line"><span class="type">double</span> area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);</span><br><span class="line"><span class="type">double</span> area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);</span><br><span class="line"><span class="keyword">if</span> (area_abc * area_abd &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以cd为三角形公共边，求三角形abc, abd的面积，并判断是否不相交</span></span><br><span class="line"><span class="type">double</span> area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);</span><br><span class="line"><span class="type">double</span> area_cdb = area_cda + area_abc - area_abd ;</span><br><span class="line"><span class="keyword">if</span> (area_cda * area_cdb &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算交点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> t = area_cda / ( area_abd - area_abc );</span><br><span class="line"><span class="type">double</span> dx = t * (b.x - a.x),</span><br><span class="line"><span class="type">double</span> dy = t * (b.y - a.y);</span><br><span class="line">intersect_p.x = a.x + dx;</span><br><span class="line">intersect_p.y = a.y + dy;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Chapter-4：Viewing-in-2D-amp-3D"><a href="#Chapter-4：Viewing-in-2D-amp-3D" class="headerlink" title="Chapter 4：Viewing in 2D &amp; 3D"></a>Chapter 4：Viewing in 2D &amp; 3D</h1><h2 id="4-1-2D中的Viewing"><a href="#4-1-2D中的Viewing" class="headerlink" title="4.1    2D中的Viewing"></a>4.1    2D中的Viewing</h2><h3 id="4-1-1-Window"><a href="#4-1-1-Window" class="headerlink" title="4.1.1    Window"></a>4.1.1    Window</h3><ol>
<li><strong>Window</strong>：一个2D世界中的矩形区域<ol>
<li>中心：(xCenter, yCenter)</li>
<li>大小：windowSize</li>
</ol>
</li>
<li><strong>Screen / Viewport</strong>：一个像素点的矩阵<ol>
<li>大小：screenSize，以像素为单位</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082538881.png" alt="image-20221013082538881" style="zoom:80%;" /></p>
<h3 id="4-1-2-2D-Viewing-Transformation"><a href="#4-1-2-2D-Viewing-Transformation" class="headerlink" title="4.1.2    2D Viewing Transformation"></a>4.1.2    2D Viewing Transformation</h3><ol>
<li>将2D世界中能够看到的部分<strong>window</strong>映射到屏幕<strong>viewport</strong>上</li>
<li>也成为：<strong>window-to-viewport transformation</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082315825.png" alt="image-20221013082315825" style="zoom:80%;" /></p>
<h3 id="4-1-3-Derivation推导"><a href="#4-1-3-Derivation推导" class="headerlink" title="4.1.3    Derivation推导"></a>4.1.3    Derivation推导</h3><div class="table-container">
<table>
<thead>
<tr>
<th>先平移到坐标原点，并且进行相应缩放</th>
<th style="text-align:center"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082614575.png" alt="image-20221013082614575" style="zoom:80%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>然后将坐标轴转化为屏幕的坐标</strong></td>
<td style="text-align:center"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082646008.png" alt="image-20221013082646008" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-1-4-Aspect-Ratio纵横比"><a href="#4-1-4-Aspect-Ratio纵横比" class="headerlink" title="4.1.4    Aspect Ratio纵横比"></a>4.1.4    Aspect Ratio纵横比</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082921300.png" alt="image-20221013082921300" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013082941369.png" alt="image-20221013082941369" style="zoom:80%;" /></p>
<h3 id="4-1-5-OpenGL中的命令"><a href="#4-1-5-OpenGL中的命令" class="headerlink" title="4.1.5    OpenGL中的命令"></a>4.1.5    OpenGL中的命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置视口: 最终图像映射到的像素矩阵</span></span><br><span class="line"><span class="comment">// (x,y): 定义视口的左下角</span></span><br><span class="line"><span class="comment">// (width, height): 定义视口矩阵的大小</span></span><br><span class="line"><span class="built_in">glViewport</span>(x, y, width, height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二维正交投影矩阵</span></span><br><span class="line"><span class="built_in">gluOrtho2D</span>(left, right, bottom, top); </span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013083056196.png" alt="image-20221013083056196" style="zoom:80%;" /></p>
<h3 id="4-1-6-Modeling-vs-Viewing"><a href="#4-1-6-Modeling-vs-Viewing" class="headerlink" title="4.1.6    Modeling vs Viewing"></a>4.1.6    Modeling vs Viewing</h3><ol>
<li>Modeling Transformation：修改场景</li>
<li>Viewing Transformation：修改视窗位置，不会修改场景</li>
</ol>
<h2 id="4-2-3D中的Viewing"><a href="#4-2-3D中的Viewing" class="headerlink" title="4.2    3D中的Viewing"></a>4.2    3D中的Viewing</h2><h3 id="4-2-1-透视投影-Perspective-Projection"><a href="#4-2-1-透视投影-Perspective-Projection" class="headerlink" title="4.2.1    透视投影 Perspective Projection"></a>4.2.1    透视投影 Perspective Projection</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013084148797.png" alt="image-20221013084148797" style="zoom:80%;" /></p>
<ol>
<li>所有点的延长线交于一点<ol>
<li><strong>PRP</strong>：Projection Reference Point，投影参考点</li>
<li>也就是眼睛所在位置</li>
</ol>
</li>
<li>投影大小 与 距离、朝向 都有关系</li>
</ol>
<h3 id="4-2-2-平行投影-Parallel-Projection"><a href="#4-2-2-平行投影-Parallel-Projection" class="headerlink" title="4.2.2    平行投影 Parallel Projection"></a>4.2.2    平行投影 Parallel Projection</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013085546793.png" alt="image-20221013085546793" style="zoom:80%;" /></p>
<ol>
<li><p>对应点连线相互平行</p>
<ol>
<li><strong>DOP</strong>：Direction of Projection，投影方向</li>
<li>相当于眼睛在无穷远的位置</li>
</ol>
</li>
<li><p>投影大小 只与 朝向 有关系</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013090314403.png" alt="image-20221013090314403" style="zoom:80%;" /></p>
</li>
<li><p>斜平行投影</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013090608146.png" alt="image-20221013090608146" style="zoom:80%;" /></p>
<ol>
<li>最一般的平行投影</li>
<li>平行与投影平面的角度、大小不变</li>
<li>不平行投影平面的会被拉伸</li>
</ol>
</li>
</ol>
<h2 id="4-3-View-Specification"><a href="#4-3-View-Specification" class="headerlink" title="4.3    View Specification"></a>4.3    View Specification</h2><h3 id="4-3-1-定义一个相机"><a href="#4-3-1-定义一个相机" class="headerlink" title="4.3.1    定义一个相机"></a>4.3.1    定义一个相机</h3><ol>
<li><p><strong>Reference</strong>：相机的位置</p>
</li>
<li><p><strong>view-direction</strong>(vrp)：相机的朝向</p>
</li>
<li><p><strong>up-direction</strong>(upVector)：相机的向上方向</p>
<ol>
<li>保证与<strong>view-direction</strong>垂直</li>
<li>一般是指定一个朝天的方向<strong>sky-vector</strong></li>
<li>然后找最接近朝天方向的垂直于相机朝向的向量</li>
<li>计算方法：<ol>
<li><strong>sky-vector × view-direction</strong>，得到<strong>right-vector</strong></li>
<li><strong>right-vector × view-direction</strong>，得到<strong>up-vector</strong></li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013091629822.png" alt="image-20221013091629822" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="4-3-2-World-to-View-Transformation"><a href="#4-3-2-World-to-View-Transformation" class="headerlink" title="4.3.2    World-to-View Transformation"></a>4.3.2    World-to-View Transformation</h3><ol>
<li>先将相机的坐标轴 平移到 原点</li>
<li>然后将相机的坐标轴 投影到 原坐标轴</li>
</ol>
<h3 id="4-3-3-平行投影"><a href="#4-3-3-平行投影" class="headerlink" title="4.3.3    平行投影"></a>4.3.3    平行投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013091949516.png" alt="image-20221013091949516" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092045138.png" alt="image-20221013092045138" style="zoom:80%;" /></p>
<ol>
<li>先进行<strong>World-to-View Transformation</strong></li>
<li>然后进行平行投影：直接舍弃Z轴</li>
<li>最后进行<strong>2D viewing transformation</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092451427.png" alt="image-20221013092451427" style="zoom:80%;" /></p>
<h3 id="4-3-4-透视投影"><a href="#4-3-4-透视投影" class="headerlink" title="4.3.4    透视投影"></a>4.3.4    透视投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092109964.png" alt="image-20221013092109964" style="zoom:80%;" /></p>
<ol>
<li>先进行<strong>World-to-View Transformation</strong></li>
<li>然后进行透视投影：乘投影矩阵</li>
<li>最后进行<strong>2D viewing transformation</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092416523.png" alt="image-20221013092416523" style="zoom:80%;" /></p>
<h3 id="4-3-5-View-Window"><a href="#4-3-5-View-Window" class="headerlink" title="4.3.5    View Window"></a>4.3.5    View Window</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092157331.png" alt="image-20221013092157331" style="zoom:80%;" /></p>
<h3 id="4-3-6-View-Volume"><a href="#4-3-6-View-Volume" class="headerlink" title="4.3.6    View Volume"></a>4.3.6    View Volume</h3><ol>
<li><p>只有<strong>front plane</strong>和<strong>back plane</strong>之间的物体才能被看见</p>
</li>
<li><p>透视投影：金字塔型</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092557909.png" alt="image-20221013092557909" style="zoom:80%;" /></p>
</li>
<li><p>平行投影：长方体型</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221013092758810.png" alt="image-20221013092758810" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="4-3-7-完整的View-Specification"><a href="#4-3-7-完整的View-Specification" class="headerlink" title="4.3.7    完整的View Specification"></a>4.3.7    完整的View Specification</h3><ol>
<li>定义世界坐标系<ol>
<li>position of viewing：<strong>vrp</strong></li>
<li>direction of viewing：<strong>-n</strong></li>
<li>up direction for viewing：<strong>upVector</strong></li>
</ol>
</li>
<li>定义视角坐标系<ol>
<li>view window：<strong>center(cx, cy), width, height</strong></li>
<li><strong>prp</strong>：distance from the view plane</li>
<li><strong>front clipping plane</strong>：distance from view plane</li>
<li><strong>back clipping plane</strong>：distance from view plane</li>
</ol>
</li>
</ol>
<h2 id="4-4-OpenGL编程"><a href="#4-4-OpenGL编程" class="headerlink" title="4.4    OpenGL编程"></a>4.4    OpenGL编程</h2><p>问题：如何处理Back-face Culling无法解决的面</p>
<p>回答：将相机所在的顶点与面上的点连线，与相机朝向向量点乘，判断向量的模</p>
<h1 id="Chapter-5：Hidden-Surface-Removal-amp-Antialiasing"><a href="#Chapter-5：Hidden-Surface-Removal-amp-Antialiasing" class="headerlink" title="Chapter 5：Hidden Surface Removal &amp; Antialiasing"></a>Chapter 5：Hidden Surface Removal &amp; Antialiasing</h1><h2 id="5-1-获得真实的渲染效果"><a href="#5-1-获得真实的渲染效果" class="headerlink" title="5.1    获得真实的渲染效果"></a>5.1    获得真实的渲染效果</h2><h3 id="5-1-1-要求"><a href="#5-1-1-要求" class="headerlink" title="5.1.1    要求"></a>5.1.1    要求</h3><ol>
<li>透视投影的视图</li>
<li>适当剪裁的视场</li>
<li>隐藏看不到的部分</li>
<li>表面细节，如纹理等</li>
<li>光照细节，如阴影等</li>
<li>体积效应，如透过水、蒸汽、烟等分离介质的透明度和半透明性</li>
<li>动态效果，如运动等</li>
</ol>
<h3 id="5-1-2-相关OpenGL函数"><a href="#5-1-2-相关OpenGL函数" class="headerlink" title="5.1.2    相关OpenGL函数"></a>5.1.2    相关OpenGL函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glEnable / <span class="built_in">glDisable</span>(GL_CULL_FACE);</span><br><span class="line"><span class="built_in">glCullFace</span>(mode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glutInitDisplayMode</span>(... | GLUT_DEPTH);</span><br><span class="line"><span class="built_in">glEnalbe</span>(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-View流水线"><a href="#5-1-3-View流水线" class="headerlink" title="5.1.3    View流水线"></a>5.1.3    View流水线</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020080854655.png" alt="image-20221020080854655" style="zoom:80%;" /></p>
<h2 id="5-2-可视表面确定"><a href="#5-2-可视表面确定" class="headerlink" title="5.2    可视表面确定"></a>5.2    可视表面确定</h2><p>目标：</p>
<ol>
<li>给定一组3D对象和视图规范，</li>
<li>确定当沿投影方向观看时，对象的那些部分是可见的</li>
<li>或者，等价地，消除隐藏部分(隐藏线和表面)</li>
<li>可见部分将用适当的阴影绘制/显示</li>
</ol>
<p>方法：</p>
<ol>
<li>对象空间算法<ol>
<li>对象精度</li>
</ol>
</li>
<li>图像空间算法<ol>
<li>图像精度</li>
<li>Z-缓冲区</li>
</ol>
</li>
</ol>
<h3 id="5-3-Back-face-Culling"><a href="#5-3-Back-face-Culling" class="headerlink" title="5.3    Back-face Culling"></a>5.3    Back-face Culling</h3><ol>
<li><p>在一个封闭的多边形表面，如多面体或实心多面体的表面，</p>
<ol>
<li>其法线点远离观察者的面是不可见的，</li>
<li>这样的背面可以在进一步的处理中消除</li>
</ol>
</li>
<li><p>这种方法被称为Back-face Culling</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020081910444.png" alt="image-20221020081910444" style="zoom:80%;" /></p>
</li>
<li><p>Back Face：</p>
<ol>
<li>物体表面的一部分背对眼睛</li>
<li>即法线指向远离眼睛的表面</li>
</ol>
</li>
<li><p>计算方法：</p>
<ol>
<li>面的法向量 与 观察方向向量 点乘</li>
<li>负数表示朝向观察者</li>
<li>正数表示远离观察者</li>
</ol>
</li>
<li><p>Back-face Culling的不足</p>
<ol>
<li>无法判断物体之间的遮挡关系</li>
<li>背面一定看不到，前面不一定能看到</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020082413694.png" alt="image-20221020082413694" style="zoom:67%;" /></p>
</li>
<li><p>Back-face Culling结果成立的情况：</p>
<ol>
<li>单个、闭合的、凸多边形</li>
</ol>
</li>
</ol>
<h2 id="5-4-Painter’s-Algorithm"><a href="#5-4-Painter’s-Algorithm" class="headerlink" title="5.4    Painter’s Algorithm"></a>5.4    Painter’s Algorithm</h2><h3 id="5-4-1-算法"><a href="#5-4-1-算法" class="headerlink" title="5.4.1    算法"></a>5.4.1    算法</h3><ol>
<li>物体从远到近排序，先画远的，后画近的，自动形成遮挡</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020083137512.png" alt="image-20221020083137512" style="zoom:80%;" /></p>
<p>缺点：</p>
<ol>
<li><p>有的图形不可被排序</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020083229134.png" alt="image-20221020083229134" style="zoom:80%;" /></p>
</li>
</ol>
<p>解决方法：</p>
<ol>
<li>将物体进行切割，然后进行排序</li>
</ol>
<h3 id="5-4-2-Warnock’s-Area-Subdivision"><a href="#5-4-2-Warnock’s-Area-Subdivision" class="headerlink" title="5.4.2    Warnock’s Area Subdivision"></a>5.4.2    Warnock’s Area Subdivision</h3><ol>
<li>从整个图像开始</li>
<li>如果满足以下情况之一，则直接进行绘制<ol>
<li>在前面的多边形覆盖整个窗口</li>
<li>有最多一个多边形在窗口</li>
</ol>
</li>
<li>否则将窗口分为4个部分，并且重复这两步</li>
<li>如果区域是单像素的，选择深度最小的表面</li>
<li>优点：<ol>
<li>不过度渲染，抗锯齿性好</li>
<li>进一步获取亚像素信息</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>测试相当复杂和缓慢</li>
<li>不适合硬件实现</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020083812927.png" alt="image-20221020083812927" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="5-4-3-BSP树"><a href="#5-4-3-BSP树" class="headerlink" title="5.4.3    BSP树"></a>5.4.3    BSP树</h3><p>BSP：Binary Space Partitioning Trees</p>
<ol>
<li><p>构建BSP树</p>
<ol>
<li>选择一个切割面，将空间分为两部分<ol>
<li>切割面为根节点，靠近观察者的是左子结点，远离观察者的是右子结点</li>
</ol>
</li>
<li>所有与切割面相交的三角形，会被分解为两个多边形<ol>
<li>判断需要切割：三个顶点带入平面方程，符号不一样</li>
<li>切割方法：二分三角形，每一步舍去在平面同一方向的多边形</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020091257604.png" alt="image-20221020091257604" style="zoom:80%;" /></p>
</li>
<li><p>绘制</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020091527689.png" alt="image-20221020091527689" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020091535653.png" alt="image-20221020091535653" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="5-5-Z-buffer-Algorithm"><a href="#5-5-Z-buffer-Algorithm" class="headerlink" title="5.5    Z-buffer Algorithm"></a>5.5    Z-buffer Algorithm</h2><h3 id="5-5-1-算法"><a href="#5-5-1-算法" class="headerlink" title="5.5.1    算法"></a>5.5.1    算法</h3><ol>
<li>在记录颜色信息的F-Buffer之外，添加一个大小相同的Z-Buffer，存储深度(Z)信息<ol>
<li>深度的计算：相机朝向向量 与 面 交点的Z值</li>
</ol>
</li>
<li>优点：绘画的顺序不影响最后的结果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020084355203.png" alt="image-20221020084355203" style="zoom:80%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(j = 0; j &lt; SCREEN_HEIGHT; j++)</span><br><span class="line">    for(i = 0; i &lt; SCREEN_WIDTH; i++)&#123;</span><br><span class="line">        WriteToFrameBuffer(i, j, BackgroundColor);</span><br><span class="line">        WriteToZBuffer(i, j, MAX);</span><br><span class="line">    &#125;</span><br><span class="line">for(each polygon)</span><br><span class="line">    for(each pixel in polygon&#x27;s projection)&#123;</span><br><span class="line">        z = polygon&#x27;s z value at (i,j);</span><br><span class="line">        if(z &lt; ReadFromZBuffer(i, j))&#123;</span><br><span class="line">            WriteToFrameBuffer(i, j, polygon&#x27;s color at (i, j));</span><br><span class="line">            WriteToZBuffer(i, j, z);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-2-示例"><a href="#5-5-2-示例" class="headerlink" title="5.5.2    示例"></a>5.5.2    示例</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020085640214.png" alt="image-20221020085640214" style="zoom:80%;" /></p>
<h3 id="5-5-3-相关OpenGL函数"><a href="#5-5-3-相关OpenGL函数" class="headerlink" title="5.5.3    相关OpenGL函数"></a>5.5.3    相关OpenGL函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020085912366.png" alt="image-20221020085912366" style="zoom:80%;" /></p>
<h2 id="5-6-Ray-Casting"><a href="#5-6-Ray-Casting" class="headerlink" title="5.6    Ray Casting"></a>5.6    Ray Casting</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020092149931.png" alt="image-20221020092149931" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020092156619.png" alt="image-20221020092156619" style="zoom:80%;" /></p>
<h2 id="5-7-Aliasing-锯齿-混叠"><a href="#5-7-Aliasing-锯齿-混叠" class="headerlink" title="5.7    Aliasing 锯齿/混叠"></a>5.7    Aliasing 锯齿/混叠</h2><ol>
<li><p>Aliasing是由于显示设备的离散特性造成的</p>
</li>
<li><p>栅格化就像用一组有限的值对连续信号进行采样</p>
</li>
<li><p>如果采样率不充分，信号就会丢失，这种抽样误差称为Aliasing</p>
</li>
<li><p>Aliasing的效果：</p>
<ol>
<li>锯齿状边缘</li>
<li>渲染不正确的细节</li>
<li>可能会漏掉小物件</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020092750083.png" alt="image-20221020092750083" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="5-7-1-Super-sampling"><a href="#5-7-1-Super-sampling" class="headerlink" title="5.7.1    Super-sampling"></a>5.7.1    Super-sampling</h3><ol>
<li>每一个像素，采样多个点，进行平均，作为当前像素的颜色</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020092949911.png" alt="image-20221020092949911" style="zoom:80%;" /></p>
<h3 id="5-7-2-Area-sampling"><a href="#5-7-2-Area-sampling" class="headerlink" title="5.7.2    Area-sampling"></a>5.7.2    Area-sampling</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020093204838.png" alt="image-20221020093204838" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221020093215071.png" alt="image-20221020093215071" style="zoom:80%;" /></p>
<p><a target="_blank" rel="noopener" href="http://www.pbrt.org/chapters/pbrt_chapter7.pdf">http://www.pbrt.org/chapters/pbrt_chapter7.pdf</a></p>
<h1 id="Chapter-6：Color-Theory-amp-Programmable-Pipeline"><a href="#Chapter-6：Color-Theory-amp-Programmable-Pipeline" class="headerlink" title="Chapter 6：Color Theory &amp; Programmable Pipeline"></a>Chapter 6：Color Theory &amp; Programmable Pipeline</h1><h2 id="6-1-什么是颜色"><a href="#6-1-什么是颜色" class="headerlink" title="6.1    什么是颜色"></a>6.1    什么是颜色</h2><ol>
<li><strong>Color</strong>是大脑对特定视觉刺激的反应</li>
<li>知觉：观察者锁经历的主观感受，没有观察者就没有颜色</li>
<li>颜色取决于：<ol>
<li>光的物理特性</li>
<li>光与物理材料的相互作用</li>
<li>人类的视觉系统和大脑对由此产生的现象的解释</li>
</ol>
</li>
</ol>
<h2 id="6-2-光的物理特性"><a href="#6-2-光的物理特性" class="headerlink" title="6.2    光的物理特性"></a>6.2    光的物理特性</h2><ol>
<li>光是一种难以观测的动态现象</li>
<li>现在的研究正在试图对光进行建模</li>
<li>目前，物理学家提出了两种模型来解释光的行为<ol>
<li>波模型，将光视为水波</li>
<li>粒子模型，该模型假设光是由微小的、不可见的振动粒子—光子构成的</li>
</ol>
</li>
</ol>
<h3 id="6-2-1-光的粒子模型"><a href="#6-2-1-光的粒子模型" class="headerlink" title="6.2.1    光的粒子模型"></a>6.2.1    光的粒子模型</h3><ol>
<li><p>从颜色的角度来看，采用了粒子模型</p>
</li>
<li><p>当光子沿着直线运动时，它们会以特定的频率振动</p>
</li>
<li><p>假设光子携带一定的能量，能量与它们的振动频率成正比，$E = h f$</p>
<ol>
<li>$h$是普朗克常数</li>
<li>$f$是振动的频率</li>
</ol>
</li>
<li><p>光子的行为是循环的，有一个重复的模式</p>
</li>
<li><p>光子从一个周期开始到下一个周期开始所经过的距离称为波长，$\lambda=\frac{c}{f}$</p>
<ol>
<li>$c$是光速</li>
<li>$f$是频率</li>
</ol>
</li>
<li><p>每个光子都有一个与其相关的波长，<strong>光的颜色</strong>取决于这个<strong>波长</strong></p>
</li>
<li><p><strong>光的强度</strong>取决于存在的<strong>光子的数量</strong></p>
</li>
<li><p>光是一种连续的电磁光谱</p>
<ol>
<li>粒子数在波长上的分布</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027081651698.png" alt="image-20221027081651698" style="zoom: 80%;" /></p>
</li>
</ol>
<h3 id="6-2-2-计算光在脑中产生的电信号"><a href="#6-2-2-计算光在脑中产生的电信号" class="headerlink" title="6.2.2    计算光在脑中产生的电信号"></a>6.2.2    计算光在脑中产生的电信号</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027082504687.png" alt="image-20221027082504687" style="zoom:80%;" /></p>
<p>$r=\int f(x)s(x)dx$</p>
<ol>
<li>$f(x)$：光强沿波长分布函数(右图)</li>
<li>$s(x)$：人眼细胞敏感度沿波长分布函数(左图)</li>
<li>两个函数乘积再积分 ==&gt; 卷积 ==&gt; 离散化之后，变为向量的点乘 ==&gt; $f(x)$在$s(x)$上的投影</li>
</ol>
<h2 id="6-3-颜色模型"><a href="#6-3-颜色模型" class="headerlink" title="6.3    颜色模型"></a>6.3    颜色模型</h2><ol>
<li><p>RGB：加色模型，从黑色开始添加颜色</p>
<ol>
<li>Red / Green / Blue</li>
</ol>
</li>
<li><p>CMYK：减色模型，从白色出发开始减去颜色</p>
<ol>
<li>Cyan / Magenta/ Yellow / Black</li>
</ol>
</li>
<li><p>HSV：</p>
<ol>
<li>Hue(颜色) / Saturation(饱和度) / Value</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027083424996.png" alt="image-20221027083424996" style="zoom:50%;" /></p>
</li>
<li><p>Lab：概念颜色空间</p>
</li>
</ol>
<h2 id="6-4-可编程流水线"><a href="#6-4-可编程流水线" class="headerlink" title="6.4    可编程流水线"></a>6.4    可编程流水线</h2><h3 id="6-4-1-可编程图形学流水线"><a href="#6-4-1-可编程图形学流水线" class="headerlink" title="6.4.1    可编程图形学流水线"></a>6.4.1    可编程图形学流水线</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027085338876.png" alt="image-20221027085338876" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027085417058.png" alt="image-20221027085417058" style="zoom:80%;" /></p>
<h3 id="6-4-2-着色器程序结构"><a href="#6-4-2-着色器程序结构" class="headerlink" title="6.4.2    着色器程序结构"></a>6.4.2    着色器程序结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027085530923.png" alt="image-20221027085530923" style="zoom:80%;" /></p>
<h3 id="6-4-3-GPU的结构"><a href="#6-4-3-GPU的结构" class="headerlink" title="6.4.3    GPU的结构"></a>6.4.3    GPU的结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027085627360.png" alt="image-20221027085627360" style="zoom:80%;" /></p>
<h2 id="6-5-GLSL"><a href="#6-5-GLSL" class="headerlink" title="6.5    GLSL"></a>6.5    GLSL</h2><h3 id="6-5-1-变量"><a href="#6-5-1-变量" class="headerlink" title="6.5.1    变量"></a>6.5.1    变量</h3><ol>
<li><p>uniform：可以在程序中改变，但在shader中是常量</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenGL中预先定义的变量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> <span class="built_in">gl_ModelViewMatrix</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> <span class="built_in">gl_ProjectionMatrix</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> <span class="built_in">gl_NormalMatrix</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户定义</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br></pre></td></tr></table></figure>
</li>
<li><p>attribute：顶点属性的输入</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> <span class="built_in">gl_Color</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> <span class="built_in">gl_FrontColor</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> <span class="built_in">gl_BackColor</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="built_in">gl_FrontColor</span> = <span class="built_in">gl_Color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>varying：顶点属性的输出</p>
</li>
</ol>
<h3 id="6-5-2-向量"><a href="#6-5-2-向量" class="headerlink" title="6.5.2    向量"></a>6.5.2    向量</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="type">vec3</span> v3 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line"><span class="type">vec4</span> v4 = <span class="type">vec4</span>(v3, <span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swizzling</span></span><br><span class="line"><span class="type">vec2</span> v2 = v4.xy;</span><br><span class="line"><span class="type">vec4</span> v2Reverse = v4.wzyx;</span><br><span class="line"><span class="type">vec4</span> result = v4.xyzw + v4.xxxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量运算</span></span><br><span class="line"><span class="type">float</span> result = <span class="built_in">dot</span>(v4, v4Reverse);</span><br><span class="line"><span class="type">vec3</span> result = <span class="built_in">cross</span>(v3, <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure>
<h3 id="6-5-3-纹理"><a href="#6-5-3-纹理" class="headerlink" title="6.5.3    纹理"></a>6.5.3    纹理</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> someTexture;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec4</span> someTexture = <span class="built_in">texture2D</span>(someTexture, <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-4-程序与GLSL沟通"><a href="#6-5-4-程序与GLSL沟通" class="headerlink" title="6.5.4    程序与GLSL沟通"></a>6.5.4    程序与GLSL沟通</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027090918716.png" alt="image-20221027090918716"></p>
<h3 id="6-5-5-顶点着色器"><a href="#6-5-5-顶点着色器" class="headerlink" title="6.5.5    顶点着色器"></a>6.5.5    顶点着色器</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027090936750.png" alt="image-20221027090936750"></p>
<h3 id="6-5-6-片段着色器"><a href="#6-5-6-片段着色器" class="headerlink" title="6.5.6    片段着色器"></a>6.5.6    片段着色器</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027090954131.png" alt="image-20221027090954131"></p>
<h3 id="6-5-7-示例"><a href="#6-5-7-示例" class="headerlink" title="6.5.7    示例"></a>6.5.7    示例</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221027091258602.png" alt="image-20221027091258602"></p>
<h1 id="Chapter-7：Curves"><a href="#Chapter-7：Curves" class="headerlink" title="Chapter 7：Curves"></a>Chapter 7：Curves</h1><h2 id="7-1-曲线的表达形式"><a href="#7-1-曲线的表达形式" class="headerlink" title="7.1    曲线的表达形式"></a>7.1    曲线的表达形式</h2><ol>
<li>显式曲线：$y=f(x)$</li>
<li>隐式曲线：$g(x,y)=0$</li>
<li>参数曲线：$x=x(t),y=y(t)$</li>
</ol>
<h2 id="7-2-隐式曲线-Implicit-Curves"><a href="#7-2-隐式曲线-Implicit-Curves" class="headerlink" title="7.2    隐式曲线 Implicit Curves"></a>7.2    隐式曲线 Implicit Curves</h2><ol>
<li><p>优点：很容易判断一个点是在曲线上/里/外</p>
</li>
<li><p>缺点：难以找到所有的点</p>
</li>
<li><p>找点的方法：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110081551865.png" alt="image-20221110081551865" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="7-3-参数化曲线-Parametric-Curves"><a href="#7-3-参数化曲线-Parametric-Curves" class="headerlink" title="7.3    参数化曲线 Parametric Curves"></a>7.3    参数化曲线 Parametric Curves</h2><ol>
<li>$C = C(u) = [x(u),y(u),z(u)]$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082316876.png" alt="image-20221110082316876" style="zoom:80%;" /></p>
<h3 id="7-3-1-插值"><a href="#7-3-1-插值" class="headerlink" title="7.3.1    插值"></a>7.3.1    插值</h3><ol>
<li><p>Nearest Neighbor插值</p>
<ol>
<li>缺点：值不连续</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082517408.png" alt="image-20221110082517408" style="zoom:67%;" /></p>
</li>
<li><p>线性插值</p>
<ol>
<li>缺点：导数不连续</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082607117.png" alt="image-20221110082607117" style="zoom:80%;" /></p>
</li>
<li><p>平滑插值</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082707969.png" alt="image-20221110082707969" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="7-3-2-Cubic-Hermite插值"><a href="#7-3-2-Cubic-Hermite插值" class="headerlink" title="7.3.2    Cubic Hermite插值"></a>7.3.2    Cubic Hermite插值</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110082735897.png" alt="image-20221110082735897" style="zoom:80%;" /></p>
<ol>
<li><p>已知：两个值，两个导数</p>
</li>
<li><p>假设一个三次多项式：$P(t)=at^3+bt^2+ct+d, P’(t)=3at^2+2bt+c$</p>
<ol>
<li>$P(0)=d,P(1)=a+b+c+d,P’(0)=c,P’(1)=3a+2b+c$</li>
</ol>
<p>| <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083005175.png" alt="image-20221110083005175" style="zoom:80%;" /> |<br>| :—————————————————————————————: |<br>| <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083030111.png" alt="image-20221110083030111" style="zoom:80%;" /> |<br>| <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083212613.png" alt="image-20221110083212613" style="zoom:80%;" /> |<br>| <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083226736.png" alt="image-20221110083226736" style="zoom:80%;" /> |<br>| <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083515950.png" alt="image-20221110083515950" style="zoom:80%;" /> |<br>| <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083536773.png" alt="image-20221110083536773" style="zoom:80%;" /> |<br>| <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083616368.png" alt="image-20221110083616368" style="zoom:80%;" /> |<br>| <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110083640575.png" alt="image-20221110083640575" style="zoom:80%;" /> |</p>
</li>
<li><p>本质上是从以$[t^3,t^2,t,1]$为基，变成了以$[H_0(t),H_1(t),H_2(t),H_3(t)]$为基</p>
</li>
<li><p>Hermite Basic Function</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110084048248.png" alt="image-20221110084048248" style="zoom:80%;" /></p>
<ol>
<li><p>$H_1(t)$函数可以用作动画，开始和停止都会比较慢</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110084102539.png" alt="image-20221110084102539" style="zoom:80%;" /></p>
</li>
</ol>
</li>
<li><p>多个点的插值：相邻的两个点做一次三次插值</p>
<ol>
<li>由于插值保证所有点的导数不变，因此曲线一定连续</li>
</ol>
</li>
</ol>
<h3 id="7-3-3-Catmull-Rom-插值"><a href="#7-3-3-Catmull-Rom-插值" class="headerlink" title="7.3.3    Catmull-Rom 插值"></a>7.3.3    Catmull-Rom 插值</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110084349963.png" alt="image-20221110084349963" style="zoom:80%;" /></p>
<ol>
<li><p>找每个点的斜率：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085220297.png" alt="image-20221110085220297" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085816174.png" alt="image-20221110085816174" style="zoom:80%;" /></p>
</li>
<li><p>要找两个邻居，而不是找一个邻居：</p>
<ol>
<li>一个邻居的偏差为$O(n)$，两个邻居的偏差为$O(n^2)$</li>
<li>通过泰勒展开证明</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085841836.png" alt="image-20221110085841836" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085851775.png" alt="image-20221110085851775" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110085902001.png" alt="image-20221110085902001" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="7-4-Bezier-Curve-贝塞尔曲线"><a href="#7-4-Bezier-Curve-贝塞尔曲线" class="headerlink" title="7.4    Bezier Curve 贝塞尔曲线"></a>7.4    Bezier Curve 贝塞尔曲线</h2><h2 id="7-4-1-计算方式"><a href="#7-4-1-计算方式" class="headerlink" title="7.4.1    计算方式"></a>7.4.1    计算方式</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110090123212.png" alt="image-20221110090123212" style="zoom:80%;" /></p>
<h3 id="7-4-2-性质"><a href="#7-4-2-性质" class="headerlink" title="7.4.2    性质"></a>7.4.2    性质</h3><ol>
<li><p>每个点的权重$\ge 0$</p>
</li>
<li><p>所有点的权重和为$1$</p>
</li>
<li><p>权重有对称性</p>
</li>
<li><p>穿过第一个点、最后一个点</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110090211889.png" alt="image-20221110090211889" style="zoom:80%;" /></p>
</li>
<li><p>$P<em>0P_1,P</em>{n-1}P_n$为$P_0,P_n$处的曲率</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110090352978.png" alt="image-20221110090352978" style="zoom:80%;" /></p>
</li>
<li><p>仿射不变性：先变换后采样的结果 == 先采样后变换的结果</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110090716384.png" alt="image-20221110090716384" style="zoom:80%;" /></p>
</li>
<li><p>贝塞尔曲线一定在所有控制点的凸包内</p>
</li>
<li><p>贝塞尔曲线一定不会比直接连线更陡</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091015792.png" alt="image-20221110091015792" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="7-4-3-示例"><a href="#7-4-3-示例" class="headerlink" title="7.4.3    示例"></a>7.4.3    示例</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091056918.png" alt="image-20221110091056918" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091106122.png" alt="image-20221110091106122" style="zoom:80%;" /></p>
<h3 id="7-4-4-OpenGL中的贝塞尔曲线"><a href="#7-4-4-OpenGL中的贝塞尔曲线" class="headerlink" title="7.4.4    OpenGL中的贝塞尔曲线"></a>7.4.4    OpenGL中的贝塞尔曲线</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110092037061.png" alt="image-20221110092037061" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091001577.png" alt="image-20221110091001577" style="zoom:80%;" /></p>
<h3 id="7-4-5-Rational-Bezier-Curve-有理贝塞尔曲线"><a href="#7-4-5-Rational-Bezier-Curve-有理贝塞尔曲线" class="headerlink" title="7.4.5    Rational Bezier Curve 有理贝塞尔曲线"></a>7.4.5    Rational Bezier Curve 有理贝塞尔曲线</h3><ol>
<li>每一个点对最后曲线的权重可以调节</li>
<li>$P_i$的权重设为$w_i$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091331795.png" alt="image-20221110091331795" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091410787.png" alt="image-20221110091410787" style="zoom:80%;" /></p>
<h3 id="7-4-6-贝塞尔曲线的缺点"><a href="#7-4-6-贝塞尔曲线的缺点" class="headerlink" title="7.4.6    贝塞尔曲线的缺点"></a>7.4.6    贝塞尔曲线的缺点</h3><ol>
<li>控制点个数对应表达式的阶数，点过多时阶数过大</li>
<li>每一个控制点对全局均有影响</li>
</ol>
<h2 id="7-5-B-spline"><a href="#7-5-B-spline" class="headerlink" title="7.5    B-spline"></a>7.5    B-spline</h2><ol>
<li>阶数与控制点个数无关</li>
<li>局部控制</li>
<li>本质上是成片的相接的多项式</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091648614.png" alt="image-20221110091648614" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091728674.png" alt="image-20221110091728674" style="zoom:80%;" /></p>
<h3 id="7-5-1-NURBS"><a href="#7-5-1-NURBS" class="headerlink" title="7.5.1    NURBS"></a>7.5.1    NURBS</h3><p>Non-Uniform Rational B-Spline：区间段的长度可以由人工控制</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110091926951.png" alt="image-20221110091926951" style="zoom:80%;" /></p>
<h3 id="7-5-2-OpenGL中的NURBS"><a href="#7-5-2-OpenGL中的NURBS" class="headerlink" title="7.5.2    OpenGL中的NURBS"></a>7.5.2    OpenGL中的NURBS</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110092019603.png" alt="image-20221110092019603" style="zoom:80%;" /></p>
<h2 id="7-6-总结"><a href="#7-6-总结" class="headerlink" title="7.6    总结"></a>7.6    总结</h2><ol>
<li>从顶点上来看：曲线本质上是对控制点的加权平均，权重由basis function决定</li>
<li>从函数上来看：曲线是由不同的函数线性组合而来，权重由控制点决定，basis function固定不变。相当于将$P(t)$投影到了$B_0(t),…,B_n(t)$的坐标轴上</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221110092101504.png" alt="image-20221110092101504" style="zoom:80%;" /></p>
<h1 id="Chapter-8-Surface"><a href="#Chapter-8-Surface" class="headerlink" title="Chapter 8    Surface"></a>Chapter 8    Surface</h1><h2 id="8-1-参数化曲线"><a href="#8-1-参数化曲线" class="headerlink" title="8.1    参数化曲线"></a>8.1    参数化曲线</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117082250344.png" alt="image-20221117082250344" style="zoom:80%;" /></p>
<h2 id="8-2-参数化曲面"><a href="#8-2-参数化曲面" class="headerlink" title="8.2    参数化曲面"></a>8.2    参数化曲面</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117082414258.png" alt="image-20221117082414258" style="zoom:80%;" /></p>
<h3 id="8-2-1-n阶贝塞尔曲面"><a href="#8-2-1-n阶贝塞尔曲面" class="headerlink" title="8.2.1    n阶贝塞尔曲面"></a>8.2.1    n阶贝塞尔曲面</h3><h4 id="8-2-1-1-曲面的表达式"><a href="#8-2-1-1-曲面的表达式" class="headerlink" title="8.2.1.1    曲面的表达式"></a>8.2.1.1    曲面的表达式</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117082505623.png" alt="image-20221117082505623" style="zoom:80%;" /></p>
<h4 id="8-2-1-2-贝塞尔曲线与贝塞尔曲面的联系"><a href="#8-2-1-2-贝塞尔曲线与贝塞尔曲面的联系" class="headerlink" title="8.2.1.2    贝塞尔曲线与贝塞尔曲面的联系"></a>8.2.1.2    贝塞尔曲线与贝塞尔曲面的联系</h4><ol>
<li>$B_{j,m}(v)$为参数的贝塞尔曲线，计算当$t=v$时对应的点，共$n+1$个</li>
<li>作为控制点，再次计算以$B_{i,n}(u)$为参数的贝塞尔曲线</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117082730133.png" alt="image-20221117082730133" style="zoom:80%;" /></p>
<h4 id="8-2-1-3-贝塞尔曲面的法向量"><a href="#8-2-1-3-贝塞尔曲面的法向量" class="headerlink" title="8.2.1.3    贝塞尔曲面的法向量"></a>8.2.1.3    贝塞尔曲面的法向量</h4><ol>
<li>计算对于$u,v$的偏导，然后进行叉积</li>
<li>$N(u,v)=\frac{\partial S(u,v)}{\partial u} × \frac{\partial S(u,v)}{\partial v}$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083228947.png" alt="image-20221117083228947" style="zoom:80%;" /></p>
<h4 id="8-2-1-4-OpenGL中的使用"><a href="#8-2-1-4-OpenGL中的使用" class="headerlink" title="8.2.1.4    OpenGL中的使用"></a>8.2.1.4    OpenGL中的使用</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083400530.png" alt="image-20221117083400530" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083459717.png" alt="image-20221117083459717" style="zoom:80%;" /></p>
<h3 id="8-2-2-B-spline曲面"><a href="#8-2-2-B-spline曲面" class="headerlink" title="8.2.2    B-spline曲面"></a>8.2.2    B-spline曲面</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083543462.png" alt="image-20221117083543462" style="zoom:80%;" /></p>
<h3 id="8-2-3-NURBS曲面"><a href="#8-2-3-NURBS曲面" class="headerlink" title="8.2.3    NURBS曲面"></a>8.2.3    NURBS曲面</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117083554216.png" alt="image-20221117083554216" style="zoom:80%;" /></p>
<h2 id="8-3-多边形网格"><a href="#8-3-多边形网格" class="headerlink" title="8.3    多边形网格"></a>8.3    多边形网格</h2><h3 id="8-3-1-什么是多边形网格"><a href="#8-3-1-什么是多边形网格" class="headerlink" title="8.3.1    什么是多边形网格"></a>8.3.1    什么是多边形网格</h3><ol>
<li>在三维计算机图形学和实体建模中，定义一个多面体物体形状的顶点、边和面的集合</li>
<li>可以用许多平面近似地表示一个曲线形状</li>
<li>在游戏中呈现几何体的实际标准</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117084031574.png" alt="image-20221117084031574" style="zoom:80%;" /></p>
<h3 id="8-3-2-多边形网格的表示"><a href="#8-3-2-多边形网格的表示" class="headerlink" title="8.3.2    多边形网格的表示"></a>8.3.2    多边形网格的表示</h3><p>顶点信息 + 拓扑信息</p>
<ol>
<li><p>Vertex-Vertex Meshes(VV)</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117084141008.png" alt="image-20221117084141008" style="zoom:80%;" /></p>
</li>
<li><p>Face-Vertex Meshes</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117084204664.png" alt="image-20221117084204664" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="8-3-3-obj格式"><a href="#8-3-3-obj格式" class="headerlink" title="8.3.3    obj格式"></a>8.3.3    obj格式</h3><h4 id="8-3-3-1-示例"><a href="#8-3-3-1-示例" class="headerlink" title="8.3.3.1    示例"></a>8.3.3.1    示例</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117085237119.png" alt="image-20221117085237119" style="zoom:80%;" /></p>
<h4 id="8-3-3-2-含义"><a href="#8-3-3-2-含义" class="headerlink" title="8.3.3.2    含义"></a>8.3.3.2    含义</h4><ol>
<li>mtllib：导入.mtl文件</li>
<li>usemtl：从该句开始后面的面，使用该.mtl文件</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117085252584.png" alt="image-20221117085252584" style="zoom: 80%;" /></p>
<h4 id="8-3-3-3-Wavefront-obj-file"><a href="#8-3-3-3-Wavefront-obj-file" class="headerlink" title="8.3.3.3    Wavefront .obj file"></a>8.3.3.3    Wavefront .obj file</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117085801279.png" alt="image-20221117085801279" style="zoom:80%;" /></p>
<h3 id="8-3-4-Constructive-Solid-Geometry-构造实体几何"><a href="#8-3-4-Constructive-Solid-Geometry-构造实体几何" class="headerlink" title="8.3.4    Constructive Solid Geometry 构造实体几何"></a>8.3.4    Constructive Solid Geometry 构造实体几何</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117085919901.png" alt="image-20221117085919901" style="zoom:80%;" /></p>
<h3 id="8-3-5-L-system：Formal-grammar"><a href="#8-3-5-L-system：Formal-grammar" class="headerlink" title="8.3.5    L-system：Formal grammar"></a>8.3.5    L-system：Formal grammar</h3><ol>
<li><p>Formal grammar</p>
<ol>
<li>Alphabet：字母表</li>
<li>Production rules：推导规则</li>
<li>An initial axiom：公理</li>
</ol>
</li>
<li><p>最后的字符串对应一个图像</p>
</li>
<li><p>应用</p>
<ol>
<li>植物</li>
<li>分形</li>
</ol>
</li>
<li><p>示例：</p>
<ol>
<li><p>生成字符串</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117090339348.png" alt="image-20221117090339348" style="zoom:80%;" /></p>
</li>
<li><p>解释这个字符串</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117090453258.png" alt="image-20221117090453258" style="zoom:80%;" /></p>
</li>
</ol>
</li>
</ol>
<h3 id="8-3-6-Shape-Grammar"><a href="#8-3-6-Shape-Grammar" class="headerlink" title="8.3.6    Shape Grammar"></a>8.3.6    Shape Grammar</h3><ol>
<li><p>将推导规则定义在形状上</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117091357675.png" alt="image-20221117091357675" style="zoom:80%;" /></p>
</li>
<li><p>例：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117091456789.png" alt="image-20221117091456789" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="8-3-7-Subdivision-Curves-Surface"><a href="#8-3-7-Subdivision-Curves-Surface" class="headerlink" title="8.3.7    Subdivision Curves/Surface"></a>8.3.7    Subdivision Curves/Surface</h3><ol>
<li>从一些顶点开始</li>
<li>根据规则，生成新顶点，替换旧顶点：Geometric rule</li>
<li>根据规则，将新顶点连起来：Topological rule</li>
<li>重复若干次，直到收敛</li>
</ol>
<h3 id="8-3-8-使用生成方法的优点"><a href="#8-3-8-使用生成方法的优点" class="headerlink" title="8.3.8    使用生成方法的优点"></a>8.3.8    使用生成方法的优点</h3><ol>
<li>可以构造复杂图形</li>
<li>容易生成</li>
<li>容易通过控制初始点，控制网格</li>
<li>LOD</li>
<li>可以由GPU通过geometry shader原生支持</li>
</ol>
<h2 id="8-4-Sweeping"><a href="#8-4-Sweeping" class="headerlink" title="8.4    Sweeping"></a>8.4    Sweeping</h2><ol>
<li><p>由一个图形+轨迹生成网格</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117092534929.png" alt="image-20221117092534929" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5    总结"></a>8.5    总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221117092612893.png" alt="image-20221117092612893" style="zoom:80%;" /></p>
<p>问题：观察者如何看到光源？<br>回答：反射光源必须经过人眼，即人眼与反射点的连线与法向量<strong>n</strong>的夹角，与<strong>i</strong>与<strong>n</strong>的夹角相同，且三者共面</p>
<h1 id="Chapter-9：Digital-Material-Appearance"><a href="#Chapter-9：Digital-Material-Appearance" class="headerlink" title="Chapter 9：Digital Material Appearance"></a>Chapter 9：Digital Material Appearance</h1><h2 id="9-1-Introduction"><a href="#9-1-Introduction" class="headerlink" title="9.1    Introduction"></a>9.1    Introduction</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124081816705.png" alt="image-20221124081816705" style="zoom:80%;" /></p>
<p>光与物体的交互：</p>
<ol>
<li>吸收</li>
<li>反射：颜色、光泽</li>
<li>穿透</li>
</ol>
<h2 id="9-2-Reflection-Models"><a href="#9-2-Reflection-Models" class="headerlink" title="9.2    Reflection Models"></a>9.2    Reflection Models</h2><h3 id="9-2-1-BRDF"><a href="#9-2-1-BRDF" class="headerlink" title="9.2.1    BRDF"></a>9.2.1    BRDF</h3><p>Bidirectional Reflectance Distribution Function f(i,o)</p>
<ol>
<li>i：入射方向</li>
<li>o：出射方向</li>
<li>是一个4D函数：因为是单位向量，消去了一个自由度<ol>
<li>一个单位球上确定一个向量，只需要2个自由度(经度、纬度)</li>
</ol>
</li>
<li>固定i，一个出方向的二维函数描述了入射光如何沿不同方向反射</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124082727824.png" alt="image-20221124082727824" style="zoom:80%;" /></p>
<h3 id="9-2-2-完美镜面反射"><a href="#9-2-2-完美镜面反射" class="headerlink" title="9.2.2    完美镜面反射"></a>9.2.2    完美镜面反射</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124083131813.png" alt="image-20221124083131813" style="zoom:80%;" /></p>
<ol>
<li>观察者如何看到光源：$\vec{o}$与$\vec{i}$关于法向量$\vec{n}$的夹角相等，且三者共面</li>
<li>判断夹角是否相等：$\vec{h}=\frac{\vec{i}+\vec{o}}{||\vec{i}+\vec{o}||}$与$\vec{n}$的方向相同</li>
</ol>
<h3 id="9-2-3-Fresnel-Reflectance-Term"><a href="#9-2-3-Fresnel-Reflectance-Term" class="headerlink" title="9.2.3    Fresnel Reflectance Term"></a>9.2.3    Fresnel Reflectance Term</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">绝缘体</th>
<th style="text-align:center">导体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124083608406.png" alt="image-20221124083608406" style="zoom:80%;" /></td>
<td style="text-align:center"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124083615758.png" alt="image-20221124083615758" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<p>计算镜面反射率：$n_1,n_2$为两者的反射率，$\theta$为$\vec{i}$和$\vec{n}$的夹角</p>
<script type="math/tex; mode=display">
R(\theta)=R_0+(1-R_0)(1-cos\theta)^5 \\
R_0=(\frac{n_1-n_2}{n_1+n_2})^2</script><h3 id="9-2-4-Microfacet-Based-Models"><a href="#9-2-4-Microfacet-Based-Models" class="headerlink" title="9.2.4    Microfacet-Based Models"></a>9.2.4    Microfacet-Based Models</h3><blockquote>
<ol>
<li>当平面非常小时，均为镜面反射</li>
<li>微面的反射只与微面的方向有关系</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124084056057.png" alt="image-20221124084056057" style="zoom:80%;" /></p>
<blockquote>
<p>  Microfacet-Based Models的计算公式</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124085703236.png" alt="image-20221124085703236" style="zoom:80%;" /></p>
<ol>
<li><p>$D(h)$：有百分之多少的微面，法向量=$\vec{h}$</p>
<ol>
<li>如果微面的法向量≠$\vec{h}$，则在当前的$\vec{i},\vec{o}$的情况下，不可能发生镜面反射，如下图所示</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124084512790.png" alt="image-20221124084512790" style="zoom:80%;" /></p>
</li>
<li><p>$G(i,o,h)$：计算遮挡的情况</p>
<ol>
<li>微面的法向量=$\vec{h}$，可能发生镜面反射，但由于阴影/遮罩，也可能无法发生镜面反射</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124085320197.png" alt="image-20221124085320197" style="zoom:80%;" /></p>
</li>
<li><p>$F(i,h)$：镜面反射率</p>
</li>
</ol>
<blockquote>
<p>  Microfacet-Based Models的一个具体的计算方式：Cook-Torrance Model</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124085635846.png" alt="image-20221124085635846" style="zoom:80%;" /></p>
<h3 id="9-2-5-Anisotropic-BRDF-各向异性"><a href="#9-2-5-Anisotropic-BRDF-各向异性" class="headerlink" title="9.2.5    Anisotropic BRDF 各向异性"></a>9.2.5    Anisotropic BRDF 各向异性</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124090022557.png" alt="image-20221124090022557" style="zoom:80%;" /></p>
<h2 id="9-3-Diffuse-Reflection-漫反射"><a href="#9-3-Diffuse-Reflection-漫反射" class="headerlink" title="9.3    Diffuse Reflection 漫反射"></a>9.3    Diffuse Reflection 漫反射</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124090201135.png" alt="image-20221124090201135" style="zoom:80%;" /></p>
<ol>
<li>一束光打过来，沿每一个可能的出射方向的反射率是相同的：$f(i,o)=constant$<ol>
<li>这只是观察到的情况，物理上不是这样的</li>
<li>物理上是先吸收，后反射</li>
</ol>
</li>
</ol>
<h2 id="9-4-两种反射结合"><a href="#9-4-两种反射结合" class="headerlink" title="9.4    两种反射结合"></a>9.4    两种反射结合</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124090412086.png" alt="image-20221124090412086" style="zoom:80%;" /></p>
<ol>
<li>金属的高光颜色为表面颜色，塑料的高光颜色为白色</li>
<li>额外的一个cos(i, n)表示光实际打到表面的能量占比</li>
</ol>
<h2 id="9-5-BRDF模型在GLSL中的实现"><a href="#9-5-BRDF模型在GLSL中的实现" class="headerlink" title="9.5    BRDF模型在GLSL中的实现"></a>9.5    BRDF模型在GLSL中的实现</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091214190.png" alt="image-20221124091214190" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091225385.png" alt="image-20221124091225385" style="zoom:80%;" /></p>
<h2 id="9-6-实用工具"><a href="#9-6-实用工具" class="headerlink" title="9.6    实用工具"></a>9.6    实用工具</h2><p><a target="_blank" rel="noopener" href="https://www.disneyanimation.com/technology/brdf.html">https://www.disneyanimation.com/technology/brdf.html</a></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091402285.png" alt="image-20221124091402285" style="zoom:80%;" /></p>
<h2 id="9-7-Reflectance-Capture"><a href="#9-7-Reflectance-Capture" class="headerlink" title="9.7    Reflectance Capture"></a>9.7    Reflectance Capture</h2><h3 id="9-7-1-直接采样"><a href="#9-7-1-直接采样" class="headerlink" title="9.7.1    直接采样"></a>9.7.1    直接采样</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091619340.png" alt="image-20221124091619340" style="zoom:80%;" /></p>
<h3 id="9-7-2-光照多路复用"><a href="#9-7-2-光照多路复用" class="headerlink" title="9.7.2    光照多路复用"></a>9.7.2    光照多路复用</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124091806057.png" alt="image-20221124091806057" style="zoom:80%;" /></p>
<p>灯光舞台</p>
<ol>
<li>同时使用数百个光源</li>
<li>只有一个或几个摄像头</li>
<li>投射特定的模式并使用查找表恢复反射率</li>
<li>效率更高</li>
<li>广泛用于电影制作</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124092000943.png" alt="image-20221124092000943" style="zoom:80%;" /></p>
<h2 id="9-8-总结"><a href="#9-8-总结" class="headerlink" title="9.8    总结"></a>9.8    总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124093411345.png" alt="image-20221124093411345" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221124093420018.png" alt="image-20221124093420018" style="zoom:80%;" /></p>
<h1 id="Chapter-10：Texture"><a href="#Chapter-10：Texture" class="headerlink" title="Chapter 10：Texture"></a>Chapter 10：Texture</h1><h2 id="10-1-什么是Texture-Mapping"><a href="#10-1-什么是Texture-Mapping" class="headerlink" title="10.1    什么是Texture Mapping"></a>10.1    什么是Texture Mapping</h2><ol>
<li>Surface存在在3D世界空间中</li>
<li>每个3D表面点在2D图像和2D纹理中也有一个位置</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201081320444.png" alt="image-20221201081320444" style="zoom:80%;" /></p>
<h2 id="10-2-Texture-Coordinates"><a href="#10-2-Texture-Coordinates" class="headerlink" title="10.2    Texture Coordinates"></a>10.2    Texture Coordinates</h2><ol>
<li>纹理坐标也叫UV坐标</li>
<li>UV坐标系左下角为(0,0)，右上角为(1,1)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201081724694.png" alt="image-20221201081724694" style="zoom:80%;" /></p>
<h2 id="10-3-Sponza-Palace-Model"><a href="#10-3-Sponza-Palace-Model" class="headerlink" title="10.3    Sponza Palace Model"></a>10.3    Sponza Palace Model</h2><ol>
<li>一个小的纹理贴图，可以通过重复，将其映射到一个大的物体上</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082117840.png" alt="image-20221201082117840" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082126464.png" alt="image-20221201082126464" style="zoom:80%;" /></p>
<h2 id="10-4-如何生成纹理坐标"><a href="#10-4-如何生成纹理坐标" class="headerlink" title="10.4    如何生成纹理坐标"></a>10.4    如何生成纹理坐标</h2><h3 id="10-4-1-参数化曲面"><a href="#10-4-1-参数化曲面" class="headerlink" title="10.4.1    参数化曲面"></a>10.4.1    参数化曲面</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082247584.png" alt="image-20221201082247584" style="zoom:80%;" /></p>
<h3 id="10-4-2-平面投影"><a href="#10-4-2-平面投影" class="headerlink" title="10.4.2    平面投影"></a>10.4.2    平面投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082441068.png" alt="image-20221201082441068" style="zoom:80%;" /></p>
<h3 id="10-4-3-球面投影"><a href="#10-4-3-球面投影" class="headerlink" title="10.4.3    球面投影"></a>10.4.3    球面投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082645574.png" alt="image-20221201082645574" style="zoom:80%;" /></p>
<h3 id="10-4-4-立方体投影"><a href="#10-4-4-立方体投影" class="headerlink" title="10.4.4    立方体投影"></a>10.4.4    立方体投影</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082705189.png" alt="image-20221201082705189" style="zoom:80%;" /></p>
<h3 id="10-4-5-复杂表面"><a href="#10-4-5-复杂表面" class="headerlink" title="10.4.5    复杂表面"></a>10.4.5    复杂表面</h3><ol>
<li>将物体分为不同的部分，分别使用不同的投影方法</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082825156.png" alt="image-20221201082825156" style="zoom:80%;" /></p>
<h3 id="10-4-6-实际上的操作"><a href="#10-4-6-实际上的操作" class="headerlink" title="10.4.6    实际上的操作"></a>10.4.6    实际上的操作</h3><ol>
<li>切分 cut</li>
<li>摊平 flatten</li>
<li>打包 pack</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201082928756.png" alt="image-20221201082928756" style="zoom:80%;" /></p>
<h2 id="10-5-Texture-Mapping实质是重采样"><a href="#10-5-Texture-Mapping实质是重采样" class="headerlink" title="10.5    Texture Mapping实质是重采样"></a>10.5    Texture Mapping实质是重采样</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201083733711.png" alt="image-20221201083733711" style="zoom:80%;" /></p>
<h2 id="10-6-屏幕坐标-vs-纹理坐标"><a href="#10-6-屏幕坐标-vs-纹理坐标" class="headerlink" title="10.6    屏幕坐标 vs 纹理坐标"></a>10.6    屏幕坐标 vs 纹理坐标</h2><p>在最佳观看尺寸下</p>
<ol>
<li>一个像素样本 &lt;==&gt; 一个纹理样本</li>
<li>取决于纹理分辨率，例如512x512</li>
</ol>
<p>当放大时(离我们越近)：</p>
<ol>
<li>多个像素样本 &lt;==&gt; 一个纹理样本</li>
</ol>
<p>当缩小时(离我们越远)：</p>
<ol>
<li>一个像素样本 &lt;==&gt; 多个纹理样本</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201084620522.png" alt="image-20221201084620522" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201084737849.png" alt="image-20221201084737849" style="zoom:80%;" /></p>
<p>计算具体的对应关系：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201085641752.png" alt="image-20221201085641752" style="zoom:80%;" /></p>
<h2 id="10-7-Texture-Filtering"><a href="#10-7-Texture-Filtering" class="headerlink" title="10.7    Texture Filtering"></a>10.7    Texture Filtering</h2><ol>
<li>采样率不匹配可能导致混叠效应</li>
<li>Idea：去掉超出采样率的“坏”高频部分</li>
</ol>
<h3 id="10-7-1-纹理放大：Bilinear-Filtering-双线性滤波"><a href="#10-7-1-纹理放大：Bilinear-Filtering-双线性滤波" class="headerlink" title="10.7.1    纹理放大：Bilinear Filtering 双线性滤波"></a>10.7.1    纹理放大：Bilinear Filtering 双线性滤波</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201085957359.png" alt="image-20221201085957359" style="zoom:80%;" /></p>
<ol>
<li>想要计算红点的值</li>
<li>找4个临近的节点，进行两次线性插值</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090021141.png" alt="image-20221201090021141" style="zoom: 50%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090109836.png" alt="image-20221201090109836" style="zoom: 50%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090137799.png" alt="image-20221201090137799" style="zoom: 50%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090440048.png" alt="image-20221201090440048" style="zoom:50%;" /></p>
<h3 id="10-7-2-纹理缩小：Mipmap-gt-Trilinear-Filtering"><a href="#10-7-2-纹理缩小：Mipmap-gt-Trilinear-Filtering" class="headerlink" title="10.7.2    纹理缩小：Mipmap =&gt; Trilinear Filtering"></a>10.7.2    纹理缩小：Mipmap =&gt; Trilinear Filtering</h3><ol>
<li>Challenge<ol>
<li>许多texels会增加像素占用</li>
<li>pixel footprint的形状可能很复杂</li>
</ol>
</li>
<li>Idea<ol>
<li>低通过滤器、降低采样率</li>
<li>使用与屏幕采样率匹配的分辨率</li>
</ol>
</li>
</ol>
<blockquote>
<p>  Mipmap：将</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201090959726.png" alt="image-20221201090959726" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091110918.png" alt="image-20221201091110918" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091203711.png" alt="image-20221201091203711" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091245274.png" alt="image-20221201091245274" style="zoom:80%;" /></p>
<blockquote>
<p>  Trilinear Filtering</p>
<ol>
<li>在每个Mipmap Level中进行一次Bilinear</li>
<li>在Mipmap Level之间进行一次线性插值</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091334182.png" alt="image-20221201091334182" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091433151.png" alt="image-20221201091433151" style="zoom:80%;" /></p>
<blockquote>
<p>  OpenGL中的设置：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091528820.png" alt="image-20221201091528820" style="zoom:80%;" /></p>
<blockquote>
<p>  Mipmap的局限：</p>
<ol>
<li>远处的地方，应该是对应一个椭圆，但mip level认为是一个圆形</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091649957.png" alt="image-20221201091649957" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201091752287.png" alt="image-20221201091752287" style="zoom:80%;" /></p>
<h2 id="10-8-高级纹理映射"><a href="#10-8-高级纹理映射" class="headerlink" title="10.8    高级纹理映射"></a>10.8    高级纹理映射</h2><p>纹理 = 内存 + 滤波</p>
<ol>
<li>为分段计算提供数据的一般方法</li>
</ol>
<p>应用程序</p>
<ol>
<li><p>环境照明</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201092006954.png" alt="image-20221201092006954" style="zoom:67%;" /></p>
</li>
<li><p>Micro-geometry映射</p>
</li>
<li><p>程序上的纹理</p>
</li>
<li><p>双向体绘制</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093031432.png" alt="image-20221201093031432" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093103715.png" alt="image-20221201093103715" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093115728.png" alt="image-20221201093115728" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093242373.png" alt="image-20221201093242373" style="zoom:80%;" /></p>
</li>
<li><p>结构函数</p>
</li>
</ol>
<h2 id="10-9-总结"><a href="#10-9-总结" class="headerlink" title="10.9    总结"></a>10.9    总结</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221201093415899.png" alt="image-20221201093415899" style="zoom:80%;" /></p>
<h1 id="Chapter-12：Advanced-Real-time-Rendering"><a href="#Chapter-12：Advanced-Real-time-Rendering" class="headerlink" title="Chapter 12：Advanced Real-time Rendering"></a>Chapter 12：Advanced Real-time Rendering</h1><h2 id="12-1-阴影贴图"><a href="#12-1-阴影贴图" class="headerlink" title="12.1    阴影贴图"></a>12.1    阴影贴图</h2><ol>
<li><p>阴影对真实感非常重要</p>
<ol>
<li>可以显示物体之间的位置关系</li>
<li>光源的位置</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215080952113.png" alt="image-20221215080952113" style="zoom:80%;" /></p>
</li>
<li><p>如何判断点是否在阴影里面：点在灯的视角中被物体遮挡了(深度测试)</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215081326987.png" alt="image-20221215081326987" style="zoom:80%;" /></p>
</li>
<li><p>单个点光源的阴影计算：</p>
<ol>
<li>将光源作为眼睛，只渲染深度，相关的深度缓冲存储为<strong>阴影贴图</strong></li>
<li>对每一个被渲染的点，将其更改到光源的视角，用阴影贴图中的z-value进行测试<ol>
<li>如果不包含，则不使用阴影渲染</li>
<li>否则，渲染阴影</li>
</ol>
</li>
</ol>
</li>
<li><p>多个点光源的阴影计算：</p>
<ol>
<li>计算每个点光源的阴影贴图，然后做线性相加</li>
</ol>
</li>
<li><p>面光源的阴影计算：</p>
<ol>
<li>将面光源采样为多个点光源</li>
</ol>
</li>
<li><p>常见问题</p>
<ol>
<li><p>在Z的判断上精度不够：添加一个offset，而不是完全判断相等</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215082319338.png" alt="image-20221215082319338" style="zoom:80%;" /></p>
</li>
<li><p>当分辨率不高时，相机与光源的采样率区别很大：Perspective Shadow Map</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215082639109.png" alt="image-20221215082639109" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215082733361.png" alt="image-20221215082733361" style="zoom:80%;" /></p>
</li>
</ol>
</li>
</ol>
<h2 id="12-2-Precomputed-Radiance-Transfer"><a href="#12-2-Precomputed-Radiance-Transfer" class="headerlink" title="12.2    Precomputed Radiance Transfer"></a>12.2    Precomputed Radiance Transfer</h2><ol>
<li><p>反射的公式：</p>
<ol>
<li>L~i~(i, p)：入射光为i时，点p的能量</li>
<li>V(i, p)：入射光为i时，点p的可视性</li>
<li>(n,i)：一个cos<n, i>值</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215083258036.png" alt="image-20221215083258036" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215083550112.png" alt="image-20221215083550112" style="zoom:80%;" /></p>
</li>
<li><p>如何计算积分：随机采样</p>
</li>
<li><p>如何高效计算：预先计算好结果</p>
</li>
<li><p>预计算，假设：</p>
<ol>
<li><p>光源很远：表示光L~i~(i)</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215083946872.png" alt="image-20221215083946872" style="zoom:80%;" /></p>
</li>
<li><p>静态场景：可见性函数V(i, p)可以提前计算</p>
</li>
<li><p>Lambertian材质：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215084044453.png" alt="image-20221215084044453" style="zoom:80%;" /></p>
</li>
</ol>
</li>
<li><p>预计算：可以将积分改变为两重循环的积分</p>
</li>
<li><p>卷积定理：</p>
<ol>
<li>一个域下的卷积，是它对偶域上的点积</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215084439503.png" alt="image-20221215084439503" style="zoom:80%;" /></p>
</li>
<li><p>使用什么Base Function？</p>
<ol>
<li>Spherical Harmonics：球面谐波</li>
<li>Haar Wabelets：哈尔</li>
<li>Gaussian Mixtures：高斯混合</li>
</ol>
</li>
<li><p>如何计算参数？</p>
<ol>
<li>卷积，即F(i)和B~k~(i)的卷积</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215085846018.png" alt="image-20221215085846018" style="zoom:80%;" /></p>
</li>
<li><p>SH Lighting：通常用16个参数即可</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215085713134.png" alt="image-20221215085713134" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215085940724.png" alt="image-20221215085940724" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215085958543.png" alt="image-20221215085958543" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215090220502.png" alt="image-20221215090220502" style="zoom:80%;" /></p>
</li>
<li><p>Haar Wabelet：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215090251352.png" alt="image-20221215090251352" style="zoom:80%;" /></p>
</li>
<li><p>Gaussian Mixtures</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215090431734.png" alt="image-20221215090431734" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215090531558.png" alt="image-20221215090531558" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="12-3-Screen-Space-Ambient-Oocclusion-SSAO"><a href="#12-3-Screen-Space-Ambient-Oocclusion-SSAO" class="headerlink" title="12.3    Screen-Space Ambient Oocclusion(SSAO)"></a>12.3    Screen-Space Ambient Oocclusion(SSAO)</h2><ol>
<li>软阴影</li>
<li>是后处理，天然计算动态计算</li>
<li>利用了标准z-buffer</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091058690.png" alt="image-20221215091058690" style="zoom:80%;" /></p>
<h3 id="12-3-1-SSAO对反射公式的近似"><a href="#12-3-1-SSAO对反射公式的近似" class="headerlink" title="12.3.1    SSAO对反射公式的近似"></a>12.3.1    SSAO对反射公式的近似</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091202715.png" alt="image-20221215091202715" style="zoom:80%;" /></p>
<h3 id="12-3-2-为什么要用屏幕空间"><a href="#12-3-2-为什么要用屏幕空间" class="headerlink" title="12.3.2    为什么要用屏幕空间"></a>12.3.2    为什么要用屏幕空间</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091302748.png" alt="image-20221215091302748" style="zoom:80%;" /></p>
<h3 id="12-3-3-Horizon-Split-AO"><a href="#12-3-3-Horizon-Split-AO" class="headerlink" title="12.3.3    Horizon Split AO"></a>12.3.3    Horizon Split AO</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091520998.png" alt="image-20221215091520998" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091527831.png" alt="image-20221215091527831" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091640866.png" alt="image-20221215091640866" style="zoom:80%;" /></p>
<h3 id="12-3-4-SSAO-Demo"><a href="#12-3-4-SSAO-Demo" class="headerlink" title="12.3.4    SSAO Demo"></a>12.3.4    SSAO Demo</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20221215091725119.png" alt="image-20221215091725119" style="zoom:80%;" /></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="unicorn2022.github.io">华丰夏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hzoi-unicorn.top/2022/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">https://hzoi-unicorn.top/2022/09/15/计算机图形学/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hzoi-unicorn.top" target="_blank">华风夏韵</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/26/GAMES101/" title="GAMES101"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GAMES101</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="计算机体系结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机体系结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/19/cmake%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/" title="cmake指令合集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-19</div><div class="title">cmake指令合集</div></div></a></div><div><a href="/2023/07/15/cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="cmake学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-15</div><div class="title">cmake学习笔记</div></div></a></div><div><a href="/2023/03/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" title="人工智能"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="title">人工智能</div></div></a></div><div><a href="/2023/03/01/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/" title="多媒体技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="title">多媒体技术</div></div></a></div><div><a href="/2023/02/28/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%AF%BC%E8%AE%BA/" title="自然语言处理导论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">自然语言处理导论</div></div></a></div><div><a href="/2023/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="title">编译原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">华丰夏</div><div class="author-info__description">一切都是上天最好的安排</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/unicorn2022"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/unicorn2022" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:496300118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">愿你前行的道路有群星闪耀。愿你留下的足迹有百花绽放。你即是上帝的馈赠，世界因你而瑰丽。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chanpter-0%EF%BC%9AIntroduction"><span class="toc-text">Chanpter 0：Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-2D-Graphics"><span class="toc-text">Chapter 1    2D Graphics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Rasterization%E5%85%89%E6%A0%85%E5%8C%96"><span class="toc-text">1.1    Rasterization光栅化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">1.1.1    坐标系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BA%BF%E6%AE%B5"><span class="toc-text">1.2    线段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%BA%BF%E6%AE%B5%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.2.1    线段的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E7%BA%BF%E6%AE%B5%E7%9A%84%E5%85%89%E6%A0%85%E5%8C%96"><span class="toc-text">1.2.2    线段的光栅化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-Bresenham%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-text">1.2.3    Bresenham画线算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%9C%86"><span class="toc-text">1.3    圆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%9C%86%E7%9A%84%E5%AE%9A%E4%B9%89-%E4%BD%BF%E7%94%A8%E6%9E%81%E5%9D%90%E6%A0%87%E5%AE%9A%E4%B9%89"><span class="toc-text">1.3.1    圆的定义(使用极坐标定义)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-Bresenham%E7%94%BB%E5%9C%86%E7%AE%97%E6%B3%95"><span class="toc-text">1.3.2    Bresenham画圆算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E6%A4%AD%E5%9C%86%E7%9A%84%E4%B8%AD%E7%82%B9%E7%94%BB%E6%B3%95"><span class="toc-text">1.3.3    椭圆的中点画法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%A1%AB%E5%85%85"><span class="toc-text">1.4    多边形填充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B9%8B%E4%B8%AD"><span class="toc-text">1.4.1    判断一个点是否在多边形之中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-Scan-line-Method"><span class="toc-text">1.4.2    Scan-line Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-Seed-Fill-Algorithm%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95"><span class="toc-text">1.4.3    Seed Fill Algorithm种子填充算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-Clipping"><span class="toc-text">1.4.4    Clipping</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2%EF%BC%9AIntroduction-to-OpenGL"><span class="toc-text">Chapter 2：Introduction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-OpenGL%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">2.1    OpenGL的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-OpenGL%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="toc-text">2.2    OpenGL工具链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-OpenGL%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">2.3    OpenGL中的三个阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-OpenGL%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">2.4    OpenGL的工作方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-OpenGL%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">2.5    OpenGL的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-OpenGL%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.6    OpenGL的基础格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-OpenGL%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">2.6.1    OpenGL的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E6%A0%B9%E6%8D%AE%E9%A1%B6%E7%82%B9%E5%88%9B%E5%BB%BA%E7%89%A9%E4%BD%93"><span class="toc-text">2.6.2    根据顶点创建物体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E9%A2%9C%E8%89%B2"><span class="toc-text">2.6.3    颜色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-4-%E5%85%B6%E5%AE%83%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%9C%A8glBegin-glEnd%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">2.6.4    其它可以放在glBegin&#x2F;glEnd中的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-5-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.6.5    多边形的显示模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-6-%E7%BC%96%E8%AF%91OpenGL%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.6.6    编译OpenGL程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-7-GLUT-based%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">2.6.7    GLUT-based程序的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-8-%E5%9B%9E%E8%B0%83"><span class="toc-text">2.6.8    回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-9-%E5%8A%A8%E7%94%BB"><span class="toc-text">2.6.9    动画</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3%EF%BC%9ABasic-Math"><span class="toc-text">Chapter 3：Basic Math</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%90%91%E9%87%8F"><span class="toc-text">3.1    向量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E7%82%B9%E4%B9%98"><span class="toc-text">3.1.1    点乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%B7%AE%E7%A7%AF"><span class="toc-text">3.1.2    差积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">3.1.3    点的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%9B%B4%E7%BA%BF"><span class="toc-text">3.2    直线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%8F%98%E6%8D%A2Transform"><span class="toc-text">3.3    变换Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%B9%B3%E7%A7%BBTranslation"><span class="toc-text">3.3.1    平移Translation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E7%BC%A9%E6%94%BEScaling"><span class="toc-text">3.3.2    缩放Scaling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E6%97%8B%E8%BD%ACRotation"><span class="toc-text">3.3.3    旋转Rotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E5%89%AA%E5%88%87Shearing"><span class="toc-text">3.3.4    剪切Shearing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87"><span class="toc-text">3.4    齐次坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E7%82%B9-%E5%90%91%E9%87%8F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">3.4.1    点&#x2F;向量的对应关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">3.4.2    线性变换与矩阵的对应关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E5%A4%8D%E5%90%88%E5%8F%98%E6%8D%A2"><span class="toc-text">3.4.3    复合变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%85%B3%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%82%B9P%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-text">3.4.4    矩阵形式表示关于某个点P的变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-text">3.4.5    绕任意轴旋转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-OpenGL%E4%B8%AD%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-text">3.5    OpenGL中的变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-CTM"><span class="toc-text">3.5.1    CTM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E4%BF%AE%E6%94%B9CTM"><span class="toc-text">3.5.2    修改CTM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E7%BB%95%E6%9F%90%E4%B8%AA%E8%BD%B4%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-text">3.5.3    绕某个轴轴旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-Matrix-Stack"><span class="toc-text">3.5.4    Matrix Stack</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%90%91%E9%87%8F%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%BA%94%E7%94%A8"><span class="toc-text">3.6    向量的进一步应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E7%BA%BF%E6%AE%B5%E7%9A%84%E4%BA%A4%E7%82%B9"><span class="toc-text">3.6.1    计算两个线段的交点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4%EF%BC%9AViewing-in-2D-amp-3D"><span class="toc-text">Chapter 4：Viewing in 2D &amp; 3D</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-2D%E4%B8%AD%E7%9A%84Viewing"><span class="toc-text">4.1    2D中的Viewing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-Window"><span class="toc-text">4.1.1    Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-2D-Viewing-Transformation"><span class="toc-text">4.1.2    2D Viewing Transformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-Derivation%E6%8E%A8%E5%AF%BC"><span class="toc-text">4.1.3    Derivation推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-Aspect-Ratio%E7%BA%B5%E6%A8%AA%E6%AF%94"><span class="toc-text">4.1.4    Aspect Ratio纵横比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-OpenGL%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">4.1.5    OpenGL中的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-Modeling-vs-Viewing"><span class="toc-text">4.1.6    Modeling vs Viewing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-3D%E4%B8%AD%E7%9A%84Viewing"><span class="toc-text">4.2    3D中的Viewing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1-Perspective-Projection"><span class="toc-text">4.2.1    透视投影 Perspective Projection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%B9%B3%E8%A1%8C%E6%8A%95%E5%BD%B1-Parallel-Projection"><span class="toc-text">4.2.2    平行投影 Parallel Projection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-View-Specification"><span class="toc-text">4.3    View Specification</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%9B%B8%E6%9C%BA"><span class="toc-text">4.3.1    定义一个相机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-World-to-View-Transformation"><span class="toc-text">4.3.2    World-to-View Transformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%B9%B3%E8%A1%8C%E6%8A%95%E5%BD%B1"><span class="toc-text">4.3.3    平行投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1"><span class="toc-text">4.3.4    透视投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-View-Window"><span class="toc-text">4.3.5    View Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-6-View-Volume"><span class="toc-text">4.3.6    View Volume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-7-%E5%AE%8C%E6%95%B4%E7%9A%84View-Specification"><span class="toc-text">4.3.7    完整的View Specification</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-OpenGL%E7%BC%96%E7%A8%8B"><span class="toc-text">4.4    OpenGL编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5%EF%BC%9AHidden-Surface-Removal-amp-Antialiasing"><span class="toc-text">Chapter 5：Hidden Surface Removal &amp; Antialiasing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%8E%B7%E5%BE%97%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C"><span class="toc-text">5.1    获得真实的渲染效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E8%A6%81%E6%B1%82"><span class="toc-text">5.1.1    要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E7%9B%B8%E5%85%B3OpenGL%E5%87%BD%E6%95%B0"><span class="toc-text">5.1.2    相关OpenGL函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-View%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">5.1.3    View流水线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%8F%AF%E8%A7%86%E8%A1%A8%E9%9D%A2%E7%A1%AE%E5%AE%9A"><span class="toc-text">5.2    可视表面确定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Back-face-Culling"><span class="toc-text">5.3    Back-face Culling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Painter%E2%80%99s-Algorithm"><span class="toc-text">5.4    Painter’s Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E7%AE%97%E6%B3%95"><span class="toc-text">5.4.1    算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-Warnock%E2%80%99s-Area-Subdivision"><span class="toc-text">5.4.2    Warnock’s Area Subdivision</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-BSP%E6%A0%91"><span class="toc-text">5.4.3    BSP树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Z-buffer-Algorithm"><span class="toc-text">5.5    Z-buffer Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E7%AE%97%E6%B3%95"><span class="toc-text">5.5.1    算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-%E7%A4%BA%E4%BE%8B"><span class="toc-text">5.5.2    示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-%E7%9B%B8%E5%85%B3OpenGL%E5%87%BD%E6%95%B0"><span class="toc-text">5.5.3    相关OpenGL函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Ray-Casting"><span class="toc-text">5.6    Ray Casting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-Aliasing-%E9%94%AF%E9%BD%BF-%E6%B7%B7%E5%8F%A0"><span class="toc-text">5.7    Aliasing 锯齿&#x2F;混叠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-1-Super-sampling"><span class="toc-text">5.7.1    Super-sampling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-2-Area-sampling"><span class="toc-text">5.7.2    Area-sampling</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6%EF%BC%9AColor-Theory-amp-Programmable-Pipeline"><span class="toc-text">Chapter 6：Color Theory &amp; Programmable Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%9C%E8%89%B2"><span class="toc-text">6.1    什么是颜色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%85%89%E7%9A%84%E7%89%A9%E7%90%86%E7%89%B9%E6%80%A7"><span class="toc-text">6.2    光的物理特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%85%89%E7%9A%84%E7%B2%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.2.1    光的粒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E8%AE%A1%E7%AE%97%E5%85%89%E5%9C%A8%E8%84%91%E4%B8%AD%E4%BA%A7%E7%94%9F%E7%9A%84%E7%94%B5%E4%BF%A1%E5%8F%B7"><span class="toc-text">6.2.2    计算光在脑中产生的电信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.3    颜色模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">6.4    可编程流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">6.4.1    可编程图形学流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">6.4.2    着色器程序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-GPU%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">6.4.3    GPU的结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-GLSL"><span class="toc-text">6.5    GLSL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E5%8F%98%E9%87%8F"><span class="toc-text">6.5.1    变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E5%90%91%E9%87%8F"><span class="toc-text">6.5.2    向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3-%E7%BA%B9%E7%90%86"><span class="toc-text">6.5.3    纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-4-%E7%A8%8B%E5%BA%8F%E4%B8%8EGLSL%E6%B2%9F%E9%80%9A"><span class="toc-text">6.5.4    程序与GLSL沟通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-5-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-text">6.5.5    顶点着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-6-%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-text">6.5.6    片段着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-7-%E7%A4%BA%E4%BE%8B"><span class="toc-text">6.5.7    示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-7%EF%BC%9ACurves"><span class="toc-text">Chapter 7：Curves</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%9B%B2%E7%BA%BF%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F"><span class="toc-text">7.1    曲线的表达形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E9%9A%90%E5%BC%8F%E6%9B%B2%E7%BA%BF-Implicit-Curves"><span class="toc-text">7.2    隐式曲线 Implicit Curves</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%8F%82%E6%95%B0%E5%8C%96%E6%9B%B2%E7%BA%BF-Parametric-Curves"><span class="toc-text">7.3    参数化曲线 Parametric Curves</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E6%8F%92%E5%80%BC"><span class="toc-text">7.3.1    插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-Cubic-Hermite%E6%8F%92%E5%80%BC"><span class="toc-text">7.3.2    Cubic Hermite插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-Catmull-Rom-%E6%8F%92%E5%80%BC"><span class="toc-text">7.3.3    Catmull-Rom 插值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Bezier-Curve-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-text">7.4    Bezier Curve 贝塞尔曲线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-1-%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="toc-text">7.4.1    计算方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E6%80%A7%E8%B4%A8"><span class="toc-text">7.4.2    性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-%E7%A4%BA%E4%BE%8B"><span class="toc-text">7.4.3    示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-4-OpenGL%E4%B8%AD%E7%9A%84%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-text">7.4.4    OpenGL中的贝塞尔曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-5-Rational-Bezier-Curve-%E6%9C%89%E7%90%86%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-text">7.4.5    Rational Bezier Curve 有理贝塞尔曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-6-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">7.4.6    贝塞尔曲线的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-B-spline"><span class="toc-text">7.5    B-spline</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-NURBS"><span class="toc-text">7.5.1    NURBS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-OpenGL%E4%B8%AD%E7%9A%84NURBS"><span class="toc-text">7.5.2    OpenGL中的NURBS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E6%80%BB%E7%BB%93"><span class="toc-text">7.6    总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-8-Surface"><span class="toc-text">Chapter 8    Surface</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%8F%82%E6%95%B0%E5%8C%96%E6%9B%B2%E7%BA%BF"><span class="toc-text">8.1    参数化曲线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%8F%82%E6%95%B0%E5%8C%96%E6%9B%B2%E9%9D%A2"><span class="toc-text">8.2    参数化曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-n%E9%98%B6%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E9%9D%A2"><span class="toc-text">8.2.1    n阶贝塞尔曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-1-%E6%9B%B2%E9%9D%A2%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">8.2.1.1    曲面的表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-2-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E4%B8%8E%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E9%9D%A2%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-text">8.2.1.2    贝塞尔曲线与贝塞尔曲面的联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-3-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E9%9D%A2%E7%9A%84%E6%B3%95%E5%90%91%E9%87%8F"><span class="toc-text">8.2.1.3    贝塞尔曲面的法向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-4-OpenGL%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">8.2.1.4    OpenGL中的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-B-spline%E6%9B%B2%E9%9D%A2"><span class="toc-text">8.2.2    B-spline曲面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-NURBS%E6%9B%B2%E9%9D%A2"><span class="toc-text">8.2.3    NURBS曲面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC"><span class="toc-text">8.3    多边形网格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC"><span class="toc-text">8.3.1    什么是多边形网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">8.3.2    多边形网格的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-obj%E6%A0%BC%E5%BC%8F"><span class="toc-text">8.3.3    obj格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-1-%E7%A4%BA%E4%BE%8B"><span class="toc-text">8.3.3.1    示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-2-%E5%90%AB%E4%B9%89"><span class="toc-text">8.3.3.2    含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-3-Wavefront-obj-file"><span class="toc-text">8.3.3.3    Wavefront .obj file</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4-Constructive-Solid-Geometry-%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BD%93%E5%87%A0%E4%BD%95"><span class="toc-text">8.3.4    Constructive Solid Geometry 构造实体几何</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-5-L-system%EF%BC%9AFormal-grammar"><span class="toc-text">8.3.5    L-system：Formal grammar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-6-Shape-Grammar"><span class="toc-text">8.3.6    Shape Grammar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-7-Subdivision-Curves-Surface"><span class="toc-text">8.3.7    Subdivision Curves&#x2F;Surface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-8-%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">8.3.8    使用生成方法的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Sweeping"><span class="toc-text">8.4    Sweeping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E6%80%BB%E7%BB%93"><span class="toc-text">8.5    总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-9%EF%BC%9ADigital-Material-Appearance"><span class="toc-text">Chapter 9：Digital Material Appearance</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-Introduction"><span class="toc-text">9.1    Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-Reflection-Models"><span class="toc-text">9.2    Reflection Models</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-BRDF"><span class="toc-text">9.2.1    BRDF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E5%AE%8C%E7%BE%8E%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84"><span class="toc-text">9.2.2    完美镜面反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-Fresnel-Reflectance-Term"><span class="toc-text">9.2.3    Fresnel Reflectance Term</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-Microfacet-Based-Models"><span class="toc-text">9.2.4    Microfacet-Based Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-5-Anisotropic-BRDF-%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7"><span class="toc-text">9.2.5    Anisotropic BRDF 各向异性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-Diffuse-Reflection-%E6%BC%AB%E5%8F%8D%E5%B0%84"><span class="toc-text">9.3    Diffuse Reflection 漫反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E4%B8%A4%E7%A7%8D%E5%8F%8D%E5%B0%84%E7%BB%93%E5%90%88"><span class="toc-text">9.4    两种反射结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-BRDF%E6%A8%A1%E5%9E%8B%E5%9C%A8GLSL%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">9.5    BRDF模型在GLSL中的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">9.6    实用工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-Reflectance-Capture"><span class="toc-text">9.7    Reflectance Capture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-1-%E7%9B%B4%E6%8E%A5%E9%87%87%E6%A0%B7"><span class="toc-text">9.7.1    直接采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-2-%E5%85%89%E7%85%A7%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">9.7.2    光照多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-%E6%80%BB%E7%BB%93"><span class="toc-text">9.8    总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-10%EF%BC%9ATexture"><span class="toc-text">Chapter 10：Texture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E4%BB%80%E4%B9%88%E6%98%AFTexture-Mapping"><span class="toc-text">10.1    什么是Texture Mapping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-Texture-Coordinates"><span class="toc-text">10.2    Texture Coordinates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-Sponza-Palace-Model"><span class="toc-text">10.3    Sponza Palace Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87"><span class="toc-text">10.4    如何生成纹理坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-1-%E5%8F%82%E6%95%B0%E5%8C%96%E6%9B%B2%E9%9D%A2"><span class="toc-text">10.4.1    参数化曲面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-2-%E5%B9%B3%E9%9D%A2%E6%8A%95%E5%BD%B1"><span class="toc-text">10.4.2    平面投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-3-%E7%90%83%E9%9D%A2%E6%8A%95%E5%BD%B1"><span class="toc-text">10.4.3    球面投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-4-%E7%AB%8B%E6%96%B9%E4%BD%93%E6%8A%95%E5%BD%B1"><span class="toc-text">10.4.4    立方体投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-5-%E5%A4%8D%E6%9D%82%E8%A1%A8%E9%9D%A2"><span class="toc-text">10.4.5    复杂表面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-6-%E5%AE%9E%E9%99%85%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">10.4.6    实际上的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-Texture-Mapping%E5%AE%9E%E8%B4%A8%E6%98%AF%E9%87%8D%E9%87%87%E6%A0%B7"><span class="toc-text">10.5    Texture Mapping实质是重采样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87-vs-%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87"><span class="toc-text">10.6    屏幕坐标 vs 纹理坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-Texture-Filtering"><span class="toc-text">10.7    Texture Filtering</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-1-%E7%BA%B9%E7%90%86%E6%94%BE%E5%A4%A7%EF%BC%9ABilinear-Filtering-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2"><span class="toc-text">10.7.1    纹理放大：Bilinear Filtering 双线性滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-2-%E7%BA%B9%E7%90%86%E7%BC%A9%E5%B0%8F%EF%BC%9AMipmap-gt-Trilinear-Filtering"><span class="toc-text">10.7.2    纹理缩小：Mipmap &#x3D;&gt; Trilinear Filtering</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-8-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84"><span class="toc-text">10.8    高级纹理映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-9-%E6%80%BB%E7%BB%93"><span class="toc-text">10.9    总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-12%EF%BC%9AAdvanced-Real-time-Rendering"><span class="toc-text">Chapter 12：Advanced Real-time Rendering</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-text">12.1    阴影贴图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-Precomputed-Radiance-Transfer"><span class="toc-text">12.2    Precomputed Radiance Transfer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-Screen-Space-Ambient-Oocclusion-SSAO"><span class="toc-text">12.3    Screen-Space Ambient Oocclusion(SSAO)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-SSAO%E5%AF%B9%E5%8F%8D%E5%B0%84%E5%85%AC%E5%BC%8F%E7%9A%84%E8%BF%91%E4%BC%BC"><span class="toc-text">12.3.1    SSAO对反射公式的近似</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4"><span class="toc-text">12.3.2    为什么要用屏幕空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-3-Horizon-Split-AO"><span class="toc-text">12.3.3    Horizon Split AO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-4-SSAO-Demo"><span class="toc-text">12.3.4    SSAO Demo</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/19/cmake%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/" title="cmake指令合集">cmake指令合集</a><time datetime="2023-07-19T12:19:11.000Z" title="发表于 2023-07-19 20:19:11">2023-07-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="cmake学习笔记">cmake学习笔记</a><time datetime="2023-07-15T10:00:00.000Z" title="发表于 2023-07-15 18:00:00">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="hexo常用指令">hexo常用指令</a><time datetime="2023-07-13T13:11:11.000Z" title="发表于 2023-07-13 21:11:11">2023-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/01/GAMES104/" title="GAMES104">GAMES104</a><time datetime="2023-04-01T04:49:00.000Z" title="发表于 2023-04-01 12:49:00">2023-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" title="人工智能">人工智能</a><time datetime="2023-03-01T02:00:00.000Z" title="发表于 2023-03-01 10:00:00">2023-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 华丰夏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>