<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GAMES104 | 华风夏韵</title><meta name="author" content="华丰夏"><meta name="copyright" content="华丰夏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GAMES104 学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="GAMES104">
<meta property="og:url" content="https://hzoi-unicorn.top/2023/04/01/GAMES104/index.html">
<meta property="og:site_name" content="华风夏韵">
<meta property="og:description" content="GAMES104 学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hzoi-unicorn.top/img/avatar.png">
<meta property="article:published_time" content="2023-04-01T04:49:00.000Z">
<meta property="article:modified_time" content="2023-07-27T15:06:21.989Z">
<meta property="article:author" content="华丰夏">
<meta property="article:tag" content="GAMES系列课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzoi-unicorn.top/img/avatar.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/unicorn2022/Pictures/main/img/favicon.png"><link rel="canonical" href="https://hzoi-unicorn.top/2023/04/01/GAMES104/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-PpLfvQYdq5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 华丰夏","link":"链接: ","source":"来源: 华风夏韵","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GAMES104',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-07-27 23:06:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/resources/"><i class="fa-fw fa fa-book"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-list"></i><span> 在线工具</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="华风夏韵"><span class="site-name">华风夏韵</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/resources/"><i class="fa-fw fa fa-book"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-list"></i><span> 在线工具</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">GAMES104</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-01T04:49:00.000Z" title="发表于 2023-04-01 12:49:00">2023-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-27T15:06:21.989Z" title="更新于 2023-07-27 23:06:21">2023-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GAMES%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B/">GAMES系列课程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GAMES104"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><script type="text/javascript"
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<h1 id="二、总览：引擎架构分层与整体pipeline"><a href="#二、总览：引擎架构分层与整体pipeline" class="headerlink" title="二、总览：引擎架构分层与整体pipeline"></a>二、总览：引擎架构分层与整体pipeline</h1><h2 id="2-1-游戏引擎分层简介-5-1"><a href="#2-1-游戏引擎分层简介-5-1" class="headerlink" title="2.1    游戏引擎分层简介 5+1"></a>2.1    游戏引擎分层简介 5+1</h2><ol>
<li>工具层<strong>Tool Layer</strong>：各种编辑器</li>
<li>功能层<strong>Function Layer</strong>：让游戏Visible(渲染)、Movable(物理系统)、Playable(状态机&amp;人机交互)</li>
<li>资源层<strong>Resource Layer</strong>：各种数据文件，如图形、几何、声音、视频、场景等等</li>
<li>核心层<strong>Core Layer</strong>：引擎的工具箱，如内存管理、容器分配、数学运算等等</li>
<li>平台层<strong>Platform Layer</strong>：隐藏不同平台的不同接口</li>
</ol>
<p>第三方库文件<strong>3nd Party Libraries</strong>，与各个层都会有关系</p>
<h2 id="2-2-资源层"><a href="#2-2-资源层" class="headerlink" title="2.2    资源层"></a>2.2    资源层</h2><ol>
<li>将各种资源文件，转化成引擎统一的格式，如<strong>.uasset</strong></li>
<li>这一步会将很多冗余信息清除，将文件的格式转化为GPU可以高效绘制的格式</li>
<li>还需要生成一些资源文件，用于表示不同资源文件之间的关联</li>
<li>需要负责管理所有资产的<strong>生命周期</strong>：垃圾回收GC、延迟加载</li>
</ol>
<h2 id="2-3-功能层"><a href="#2-3-功能层" class="headerlink" title="2.3    功能层"></a>2.3    功能层</h2><ol>
<li>每经过一个<strong>Tick</strong>，会将整个游戏的逻辑和渲染运行一遍</li>
<li><strong>tick</strong>会分为两个步骤：<strong>tickLogic()</strong> =&gt; <strong>tickRender()</strong><ol>
<li><strong>tickLogic()</strong>：对世界的模拟，如输入输出、物理系统、碰撞检测</li>
<li><strong>tickRender()</strong>：对世界的渲染</li>
</ol>
</li>
<li>功能层是整个引擎中最多的部分，会跟具体游戏有关联</li>
<li>功能层的某些模块既可以当作是引擎的模块，也可以当作是游戏的模块，如：相机的移动</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425210150246.png" alt="image-20230425210150246" style="zoom:80%;" /></p>
<p>多线程计算：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425210452719.png" alt="image-20230425210452719" style="zoom:80%;" /></p>
<h2 id="2-4-核心层"><a href="#2-4-核心层" class="headerlink" title="2.4    核心层"></a>2.4    核心层</h2><ol>
<li>数学库：<ol>
<li>为了提高效率，因此会在核心层中，重写数学库</li>
<li>如用SIMD实现矩阵乘法</li>
</ol>
</li>
<li>数据结构和容器：<ol>
<li>也是为了提高效率，因此会在核心层中，重写数据结构，而不是直接使用STL容器</li>
</ol>
</li>
<li>内存管理<ol>
<li>游戏引擎会提前申请一大块内存，由引擎管理</li>
<li>三个原则：尽可能将数据放到一起、按顺序访问数据、一次申请/释放一整块数据</li>
</ol>
</li>
<li>一般来说，核心层的代码质量最高，轻易不会修改</li>
</ol>
<h2 id="2-5-平台层"><a href="#2-5-平台层" class="headerlink" title="2.5    平台层"></a>2.5    平台层</h2><ol>
<li><p>掩盖掉不同平台之间的差异</p>
<ol>
<li><p>文件的路径</p>
</li>
<li><p>图形学API：用Render Hardware Interface(RHI)隐藏起来</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230425211749281.png" alt="image-20230425211749281" style="zoom:80%;" /></p>
</li>
<li><p>硬件架构</p>
</li>
</ol>
</li>
<li><p>平台层的好坏影响了游戏在不同平台上的性能优劣</p>
</li>
</ol>
<h2 id="2-6-工具层"><a href="#2-6-工具层" class="headerlink" title="2.6    工具层"></a>2.6    工具层</h2><p>允许所有人用引擎创建游戏</p>
<ol>
<li>保证工具层展示的结果和最终游戏的结果是一样的</li>
<li>以开发效率为优先，而不是以运行效率为优先</li>
</ol>
<p>DCC：Digital Content Creation</p>
<ol>
<li>将其他工具产生的数字资产，转化为引擎统一的数字资产</li>
</ol>
<h2 id="2-7-为什么要分层架构"><a href="#2-7-为什么要分层架构" class="headerlink" title="2.7    为什么要分层架构"></a>2.7    为什么要分层架构</h2><ol>
<li>降低问题的复杂度，让每一层只需要考虑自己的任务<ol>
<li>越底层的东西越不会轻易改变</li>
<li>越往上，越灵活；越往下，越稳定</li>
</ol>
</li>
<li>要先将问题划分为不同层次的任务，然后再进行开发</li>
<li>只允许上层调用下层，下层不能调用上层</li>
</ol>
<h1 id="三、总览：如何构建游戏世界"><a href="#三、总览：如何构建游戏世界" class="headerlink" title="三、总览：如何构建游戏世界"></a>三、总览：如何构建游戏世界</h1><h2 id="3-1-Event机制"><a href="#3-1-Event机制" class="headerlink" title="3.1    Event机制"></a>3.1    Event机制</h2><p>实现不同对象之间的交互：</p>
<ol>
<li><p>unity：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehavior</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span>&#123;</span><br><span class="line">        gameObject.SendMessage(<span class="string">&quot;ApplyDamage&quot;</span>, <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example2</span> : <span class="title">MonoBehavior</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ApplyDamage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span>&#123;</span><br><span class="line">        Debug.Log(damage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>unreal：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143147437.png" alt="image-20230707143147437"  /></p>
</li>
</ol>
<p>为了确保时序的严格一致，所有GO要将消息发送给邮局，然后再由邮局在下一个tick的时候发送给不同的GO</p>
<ol>
<li>精彩回放：将每个人的输入保存下来，回放时重新跑一遍</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707144344760.png" alt="image-20230707144344760" style="zoom:80%;" /></p>
<h2 id="3-2-场景管理"><a href="#3-2-场景管理" class="headerlink" title="3.2    场景管理"></a>3.2    场景管理</h2><p>当场景中的GO过多时，将世界划分为层级结构，每个GO仅与临近格子的GO交互</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143457464.png" alt="image-20230707143457464" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143700974.png" alt="image-20230707143700974" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143746289.png" alt="image-20230707143746289" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707143901007.png" alt="image-20230707143901007" style="zoom:80%;" /></p>
<h2 id="3-3-GO的绑定"><a href="#3-3-GO的绑定" class="headerlink" title="3.3    GO的绑定"></a>3.3    GO的绑定</h2><p>先进行父节点的tick，然后再进行子节点的tick</p>
<h2 id="3-4-Q-amp-A"><a href="#3-4-Q-amp-A" class="headerlink" title="3.4    Q&amp;A"></a>3.4    Q&amp;A</h2><h3 id="3-4-1-如果一个tick时间过长怎么办"><a href="#3-4-1-如果一个tick时间过长怎么办" class="headerlink" title="3.4.1    如果一个tick时间过长怎么办"></a>3.4.1    如果一个tick时间过长怎么办</h3><ol>
<li>比如一个爆炸，瞬间产生了与非常多的GO的交互</li>
<li>此时我们可以将这些GO分批处理，在相邻的几帧分别处理，从而降低某一帧的计算量</li>
</ol>
<h3 id="3-4-2-空气墙和其他GO有什么区别"><a href="#3-4-2-空气墙和其他GO有什么区别" class="headerlink" title="3.4.2    空气墙和其他GO有什么区别"></a>3.4.2    空气墙和其他GO有什么区别</h3><ol>
<li>空气墙通常是很简单的几何体，如平面、长方体、参数曲面之类的，不会导入复杂mesh表示。</li>
<li>对于引擎而言，实际上没有太大区别</li>
</ol>
<h3 id="3-4-3-tick时，渲染线程和逻辑线程怎么同步"><a href="#3-4-3-tick时，渲染线程和逻辑线程怎么同步" class="headerlink" title="3.4.3    tick时，渲染线程和逻辑线程怎么同步"></a>3.4.3    tick时，渲染线程和逻辑线程怎么同步</h3><ol>
<li>tick一般分为两大步：tick_logic、tick_render，分别使用不同的线程计算</li>
<li>tick_logic负责不同GO之间的交互，tick_render负责准备一些数据，如渲染相关的数据</li>
<li>一般是先tick_logic，然后再进行tick_render</li>
</ol>
<h3 id="3-4-4-空间划分如何处理动态物体"><a href="#3-4-4-空间划分如何处理动态物体" class="headerlink" title="3.4.4    空间划分如何处理动态物体"></a>3.4.4    空间划分如何处理动态物体</h3><ol>
<li>通常就是树的插入与删除</li>
<li>一般而言，做引擎的时候会实现两三种经典的空间划分算法，供具体的游戏选择</li>
</ol>
<h3 id="3-4-5-物理和动画相互影响时怎么处理"><a href="#3-4-5-物理和动画相互影响时怎么处理" class="headerlink" title="3.4.5    物理和动画相互影响时怎么处理"></a>3.4.5    物理和动画相互影响时怎么处理</h3><ol>
<li>通常是插值的方法</li>
<li>在刚刚受击的时候，动画的位移影响大一点，越到后面越小</li>
<li>将动画的位移给到物理系统，让物理系统根据动画和物理进行模拟</li>
</ol>
<h1 id="四、渲染：游戏引擎中的渲染实践"><a href="#四、渲染：游戏引擎中的渲染实践" class="headerlink" title="四、渲染：游戏引擎中的渲染实践"></a>四、渲染：游戏引擎中的渲染实践</h1><h2 id="4-1-渲染流水线"><a href="#4-1-渲染流水线" class="headerlink" title="4.1    渲染流水线"></a>4.1    渲染流水线</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707152906090.png" alt="image-20230707152906090" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707152954767.png" alt="image-20230707152954767" style="zoom:80%;" /></p>
<h2 id="4-2-可渲染物体-Renderable"><a href="#4-2-可渲染物体-Renderable" class="headerlink" title="4.2    可渲染物体 Renderable"></a>4.2    可渲染物体 Renderable</h2><p>shader代码也是Renderable，因为在渲染的时候，数据会和shader代码一起送往GPU，GPU根据shader代码绘制模型数据</p>
<h3 id="4-2-1-Mesh-Render-Component"><a href="#4-2-1-Mesh-Render-Component" class="headerlink" title="4.2.1    Mesh Render Component"></a>4.2.1    Mesh Render Component</h3><ol>
<li>游戏世界中的所有东西都是一个Game Object</li>
<li>只有当GO包含Mesh Render Component的时候，它才会被绘制到屏幕上</li>
</ol>
<h3 id="4-2-2-Renderable的组成"><a href="#4-2-2-Renderable的组成" class="headerlink" title="4.2.2    Renderable的组成"></a>4.2.2    Renderable的组成</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707160416640.png" alt="image-20230707160416640" style="zoom:80%;" /></p>
<h3 id="4-2-3-Mesh-Primitive"><a href="#4-2-3-Mesh-Primitive" class="headerlink" title="4.2.3    Mesh Primitive"></a>4.2.3    Mesh Primitive</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707160508258.png" alt="image-20230707160508258" style="zoom:80%;" /></p>
<h3 id="4-2-4-Vertex和Index缓存"><a href="#4-2-4-Vertex和Index缓存" class="headerlink" title="4.2.4    Vertex和Index缓存"></a>4.2.4    Vertex和Index缓存</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707160553704.png" alt="image-20230707160553704" style="zoom:80%;" /></p>
<h3 id="4-2-5-Mesh划分"><a href="#4-2-5-Mesh划分" class="headerlink" title="4.2.5    Mesh划分"></a>4.2.5    Mesh划分</h3><ol>
<li>整个mesh存储在一个大的buffer</li>
<li>每个submesh的数据连续存储在buffer中的一小部分</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707161900791.png" alt="image-20230707161900791" style="zoom:80%;" /></p>
<h3 id="4-2-6-Resource-Pool"><a href="#4-2-6-Resource-Pool" class="headerlink" title="4.2.6    Resource Pool"></a>4.2.6    Resource Pool</h3><ol>
<li>将mesh、shader、texture分类存放在不同的地方</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707162106594.png" alt="image-20230707162106594" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707162130199.png" alt="image-20230707162130199" style="zoom: 80%;" /></p>
<h3 id="4-2-7-绘制时根据材质排序"><a href="#4-2-7-绘制时根据材质排序" class="headerlink" title="4.2.7    绘制时根据材质排序"></a>4.2.7    绘制时根据材质排序</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707162737623.png" alt="image-20230707162737623" style="zoom:80%;" /></p>
<h3 id="4-2-8-GPU-Batch-Rendering"><a href="#4-2-8-GPU-Batch-Rendering" class="headerlink" title="4.2.8    GPU Batch Rendering"></a>4.2.8    GPU Batch Rendering</h3><p>同时绘制一批类似的物体</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707163721729.png" alt="image-20230707163721729" style="zoom:80%;" /></p>
<h2 id="4-3-可见性裁剪"><a href="#4-3-可见性裁剪" class="headerlink" title="4.3    可见性裁剪"></a>4.3    可见性裁剪</h2><h3 id="4-3-1-裁剪单个物体"><a href="#4-3-1-裁剪单个物体" class="headerlink" title="4.3.1    裁剪单个物体"></a>4.3.1    裁剪单个物体</h3><ol>
<li>用视锥、包围盒裁剪单个物体</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707163851617.png" alt="image-20230707163851617" style="zoom:80%;" /></p>
<p> <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164054000.png" alt="image-20230707164054000" style="zoom:80%;" /></p>
<h3 id="4-3-2-层次化视锥裁剪"><a href="#4-3-2-层次化视锥裁剪" class="headerlink" title="4.3.2    层次化视锥裁剪"></a>4.3.2    层次化视锥裁剪</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164118391.png" alt="image-20230707164118391" style="zoom:80%;" /></p>
<h3 id="4-3-3-BVH的构建和插入"><a href="#4-3-3-BVH的构建和插入" class="headerlink" title="4.3.3    BVH的构建和插入"></a>4.3.3    BVH的构建和插入</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164226928.png" alt="image-20230707164226928" style="zoom:80%;" /></p>
<h3 id="4-3-4-PVS：潜在可视集合"><a href="#4-3-4-PVS：潜在可视集合" class="headerlink" title="4.3.4    PVS：潜在可视集合"></a>4.3.4    PVS：潜在可视集合</h3><ol>
<li>将世界划分为不同的区域，只预加载PVS中的数据</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164305703.png" alt="image-20230707164305703" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707164406281.png" alt="image-20230707164406281" style="zoom:80%;" /></p>
<h3 id="4-3-5-GPU-Culling"><a href="#4-3-5-GPU-Culling" class="headerlink" title="4.3.5    GPU Culling"></a>4.3.5    GPU Culling</h3><ol>
<li>让GPU判断哪个物体可见，GPU返回一个bit，表示是否可见</li>
<li>GPU可以先绘制一次深度，通过深度判断是否可见</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707165105476.png" alt="image-20230707165105476" style="zoom:80%;" /></p>
<h2 id="4-4-纹理压缩"><a href="#4-4-纹理压缩" class="headerlink" title="4.4    纹理压缩"></a>4.4    纹理压缩</h2><ol>
<li>计算机压缩图片与纹理压缩图片不同，计算机压缩的图片无法支持随机访问，且读取时需要很大计算量</li>
<li>Block Compression：BC7<ol>
<li>以4×4为基本块，记录最亮和最暗的颜色值，每个像素存储一个alpha值，表示这两个颜色通过当前比例混合，可以得到原像素值</li>
<li>计算消耗很低，可以进行实时压缩</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707165753355.png" alt="image-20230707165753355" style="zoom:80%;" /></p>
<h2 id="4-5-新的模型管线：Cluster-Based-Mesh-Pipeline"><a href="#4-5-新的模型管线：Cluster-Based-Mesh-Pipeline" class="headerlink" title="4.5    新的模型管线：Cluster-Based Mesh Pipeline"></a>4.5    新的模型管线：Cluster-Based Mesh Pipeline</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707171224144.png" alt="image-20230707171224144" style="zoom:80%;" /></p>
<p>现代的游戏，模型精度越来越高，地图越来越大，数据量越来越多</p>
<ol>
<li>核心思想：将模型划分为小的<strong>面片</strong>，每个面片有固定的三角形数目(如32个/64个)，由GPU创建几何细节</li>
<li>当面皮的包含的三角形数目固定之后，可以由GPU并行地生成细节</li>
<li>用相同的算法，基于数据，凭空生成几何细节；并且根据距离相机的远近，选择精度<ol>
<li>GPU处理最高效的，就是相同的一个个小块</li>
</ol>
</li>
<li>可以基于面皮，进行可视性裁剪</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707171436864.png" alt="image-20230707171436864" style="zoom:80%;" /></p>
<ol>
<li>UE的Nanite技术就是基于这个思想，进行开发的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230707171736708.png" alt="image-20230707171736708" style="zoom:80%;" /></p>
<h2 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5    总结"></a>4.5    总结</h2><ol>
<li>游戏引擎的设计，与现代显卡的架构及其相关</li>
<li>游戏引擎的核心问题，就是mesh、模型、材质这些数据之间的关系</li>
<li>在绘制的时候，尽可能通过运算，把需要绘制的物体减到越少越好</li>
<li>越来越多复杂的运算，从CPU移到了GPU，从而减轻CPU的负担</li>
</ol>
<h1 id="五、渲染：光和材质的数学魔法"><a href="#五、渲染：光和材质的数学魔法" class="headerlink" title="五、渲染：光和材质的数学魔法"></a>五、渲染：光和材质的数学魔法</h1><h2 id="5-1-渲染方程及挑战"><a href="#5-1-渲染方程及挑战" class="headerlink" title="5.1    渲染方程及挑战"></a>5.1    渲染方程及挑战</h2><h3 id="5-1-1-渲染方程"><a href="#5-1-1-渲染方程" class="headerlink" title="5.1.1    渲染方程"></a>5.1.1    渲染方程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710111512770.png" alt="image-20230710111512770" style="zoom:80%;" /></p>
<script type="math/tex; mode=display">
L_o(x,\omega_o)=L_e(x,\omega_o)+\int_{H^2}f_r(x,\omega_o,\omega_i)L_i(x,\omega_i)\cos\theta_id\omega_i</script><p><strong>radiance</strong>：辐射度；光照到物体上，物体反射出去的能量</p>
<p><strong>irradiance</strong>：入射的能量</p>
<p>$L_o(x,\omega_o)$：观察点为$x$，观察方向为$\omega_o$，观察到的radiance即为$L_o(x,\omega_o)$</p>
<ol>
<li>$L_e(x,\omega_o)$：观察点$x$，在$\omega_o$方向的自发光</li>
<li>$\int_{H^2}f_r(x,\omega_o,\omega_i)L_i(x,\omega_i)\cos\theta_id\omega_i$：观察点$x$接受所有方向射来的光，反射到$\omega_o$方向的光<ol>
<li>$f_r(x,\omega_o,\omega_i)$：观察点$x$，入射方向为$\omega_i$，反射方向为$\omega_o$，反射光能量占入射光能量的比例</li>
<li>$L_i(x,\omega_i)$：观察点$x$，接受到的入射方向为$\omega_i$的光的能量</li>
<li>$\cos\theta_i$：光线与平面的夹角</li>
</ol>
</li>
</ol>
<h3 id="5-1-2-挑战1：如何得到irradiance"><a href="#5-1-2-挑战1：如何得到irradiance" class="headerlink" title="5.1.2    挑战1：如何得到irradiance"></a>5.1.2    挑战1：如何得到irradiance</h3><p>对光源的可见性（阴影）</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710113016584.png" alt="image-20230710113016584" style="zoom:80%;" /></p>
<p>光源本身的复杂性</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710113045374.png" alt="image-20230710113045374" style="zoom:80%;" /></p>
<h3 id="5-1-4-挑战2：如何快速地在球面上进行积分"><a href="#5-1-4-挑战2：如何快速地在球面上进行积分" class="headerlink" title="5.1.4    挑战2：如何快速地在球面上进行积分"></a>5.1.4    挑战2：如何快速地在球面上进行积分</h3><p>如何计算光与表面的作用，即材质的影响</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710113110253.png" alt="image-20230710113110253" style="zoom:80%;" /></p>
<h3 id="5-1-5-挑战3：所有的物体都可能是光源"><a href="#5-1-5-挑战3：所有的物体都可能是光源" class="headerlink" title="5.1.5    挑战3：所有的物体都可能是光源"></a>5.1.5    挑战3：所有的物体都可能是光源</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710113218876.png" alt="image-20230710113218876" style="zoom:80%;" /></p>
<h2 id="5-2-基础光照解决方案"><a href="#5-2-基础光照解决方案" class="headerlink" title="5.2    基础光照解决方案"></a>5.2    基础光照解决方案</h2><h3 id="5-2-1-简化光源：Main-Light-Ambient-Light-Environment-Map"><a href="#5-2-1-简化光源：Main-Light-Ambient-Light-Environment-Map" class="headerlink" title="5.2.1    简化光源：Main Light + Ambient Light + Environment Map"></a>5.2.1    简化光源：Main Light + Ambient Light + Environment Map</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710114440708.png" alt="image-20230710114440708" style="zoom:80%;" /></p>
<ol>
<li><p>简化光源的种类：主光<strong>dominant light</strong></p>
<ol>
<li>要么是点光源，要么是方向光源，要么是锥形光源</li>
</ol>
</li>
<li><p>简化光场的表示：环境光<strong>ambient light</strong></p>
<ol>
<li>将四面八方的光，用平均值代替</li>
</ol>
</li>
<li><p>环境光贴图：<strong>Environment Map</strong></p>
<ol>
<li>贴图是一个立方体</li>
<li>根据顶点的法线方向，计算观察到的颜色</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec3</span> N = <span class="built_in">normalize</span>(normal);</span><br><span class="line">    <span class="type">vec3</span> V = <span class="built_in">normalize</span>(camera_position - world_position);</span><br><span class="line">    <span class="type">vec3</span> R = <span class="built_in">reflect</span>(V,N);</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(cube_texture, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-2-2-简化积分：Blinn-Phong-材质"><a href="#5-2-2-简化积分：Blinn-Phong-材质" class="headerlink" title="5.2.2    简化积分：Blinn-Phong 材质"></a>5.2.2    简化积分：Blinn-Phong 材质</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710115348670.png" alt="image-20230710115348670" style="zoom:80%;" /></p>
<p>将材质分为三类：$L=L_a+L_d+L_s$</p>
<ol>
<li>环境光项<strong>Ambient</strong>：$L_a=k_aI_a$</li>
<li>漫反射项<strong>Diffuse</strong>：$L_d=k_d\frac{I}{r^2}\max(0,\textbf{n}·\textbf{l})$</li>
<li>镜面反射项<strong>Specular</strong>：$L_s=k_s\frac{I}{r^2}\max(0,\textbf{n}·\textbf{h})^p$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710115748614.png" alt="image-20230710115748614" style="zoom:80%;" /></p>
<h3 id="5-2-3-阴影"><a href="#5-2-3-阴影" class="headerlink" title="5.2.3    阴影"></a>5.2.3    阴影</h3><p>目标问题：场景中看到的每个点，对于光源是否可见</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710115844674.png" alt="image-20230710115844674" style="zoom:80%;" /></p>
<p>解决方法：<strong>shadow map</strong></p>
<ol>
<li>从光的角度渲染一张深度图</li>
<li>观察时，每个点投影回光源的视角，根据深度判断是否可见</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将当前点投影到shadow map</span></span><br><span class="line"><span class="type">vec4</span> proj_pos = shadow_viewproj * pos;</span><br><span class="line"><span class="comment">// 从 homogeneous 转化为 clip space</span></span><br><span class="line"><span class="type">vec2</span> shadow_uv = proj_pos.xy / proj_pos.w;</span><br><span class="line"><span class="comment">// 从 clip space 转化为 uv space</span></span><br><span class="line">shadow_uv = shadow_ucv * <span class="number">0.5</span> + <span class="type">vec2</span>(<span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// 获取当前点的深度 [-1, +1]</span></span><br><span class="line"><span class="type">float</span> real_depth = proj_pos.z / proj_pos.w;</span><br><span class="line"><span class="comment">// 标准化到[0, 1]</span></span><br><span class="line">real_depth = real_depth * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">// 从深度缓冲中读取深度</span></span><br><span class="line"><span class="type">float</span> shadow_depth = <span class="built_in">texture</span>(shadowmap, shadow_uv).x;</span><br><span class="line"><span class="comment">// 计算是否在阴影中</span></span><br><span class="line"><span class="type">float</span> shadow_factor = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">if</span>(shadow_depth &lt; real_depth)</span><br><span class="line">    shadow_factor = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710120120070.png" alt="image-20230710120120070" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710120752077.png" alt="image-20230710120752077" style="zoom:80%;" /></p>
<h2 id="5-3-基于预计算的全局光照（空间换时间）"><a href="#5-3-基于预计算的全局光照（空间换时间）" class="headerlink" title="5.3    基于预计算的全局光照（空间换时间）"></a>5.3    基于预计算的全局光照（空间换时间）</h2><p><strong>假设场景中90%的物体是不动的，每个场景太阳的角度是锁死的，那么就可以通过预计算，简化计算</strong></p>
<h3 id="5-3-1-全局光照：直接光照-间接光照"><a href="#5-3-1-全局光照：直接光照-间接光照" class="headerlink" title="5.3.1    全局光照：直接光照+间接光照"></a>5.3.1    全局光照：直接光照+间接光照</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710121655099.png" alt="image-20230710121655099" style="zoom:80%;" /></p>
<h3 id="5-3-2-如何表示间接光照-L-i-x-vec-omega-i"><a href="#5-3-2-如何表示间接光照-L-i-x-vec-omega-i" class="headerlink" title="5.3.2    如何表示间接光照$L_i(x,\vec{\omega_i})$"></a>5.3.2    如何表示间接光照$L_i(x,\vec{\omega_i})$</h3><h4 id="5-3-2-1-傅里叶变换："><a href="#5-3-2-1-傅里叶变换：" class="headerlink" title="5.3.2.1    傅里叶变换："></a>5.3.2.1    傅里叶变换：</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710122010062.png" alt="image-20230710122010062" style="zoom:80%;" /></p>
<h4 id="5-3-2-2-卷积定理："><a href="#5-3-2-2-卷积定理：" class="headerlink" title="5.3.2.2    卷积定理："></a>5.3.2.2    卷积定理：</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710122240919.png" alt="image-20230710122240919" style="zoom:80%;" /></p>
<h4 id="5-3-2-3-球谐函数-Spherical-Harmonics："><a href="#5-3-2-3-球谐函数-Spherical-Harmonics：" class="headerlink" title="5.3.2.3    球谐函数 Spherical Harmonics："></a>5.3.2.3    球谐函数 Spherical Harmonics：</h4><p>球谐函数本质上是一组基于球坐标系$(\theta,\phi)$的基函数，基函数的计算公式为：$Y<em>{lm}(\theta,\phi)   &amp;= N</em>{lm}P_{lm}(\cos\theta)e^{Im\phi} \$</p>
<ol>
<li>正交：任意两个基函数卷积为0</li>
<li>二阶导永远为0：函数永远是光滑的</li>
</ol>
<script type="math/tex; mode=display">
\begin{aligned}
Y_{0, 0}(\theta,\phi) &= 1 \\ \\

Y_{1,-1}(\theta,\phi) &= y = \sin\theta\sin\phi \\
Y_{1, 0}(\theta,\phi) &= z = \cos\theta         \\
Y_{1, 1}(\theta,\phi) &= x = \sin\theta\cos\phi \\ \\

Y_{2,-2}(\theta,\phi) &= xy      = \sin^2\theta\sin\phi\cos\phi    \\
Y_{2,-1}(\theta,\phi) &= yz      = \sin\theta\cos\theta\sin\phi    \\
Y_{2, 0}(\theta,\phi) &= 3z^2-1  = 3\cos^2\theta-1                \\
Y_{2, 1}(\theta,\phi) &= zx      = \sin\theta\cos\theta\cos\phi    \\
Y_{2, 2}(\theta,\phi) &= x^2-y^2 = \sin^2\theta(\cos^2\phi-\sin^2\phi) \\
\end{aligned}</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710122403478.png" alt="image-20230710122403478" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710142506684.png" alt="image-20230710142506684" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710142724812.png" alt="image-20230710142724812" style="zoom:80%;" /></p>
<p>由于环境光通常是低频的，因此只需要用二阶函数即可近似表达</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710143143488.png" alt="image-20230710143143488" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710143341600.png" alt="image-20230710143341600" style="zoom:80%;" /></p>
<h3 id="5-3-3-光照贴图-Lightmap"><a href="#5-3-3-光照贴图-Lightmap" class="headerlink" title="5.3.3    光照贴图 Lightmap"></a>5.3.3    光照贴图 Lightmap</h3><p>优点：</p>
<ol>
<li>runtime的时候效率很高</li>
<li>离线渲染，可以表示很多细节</li>
</ol>
<p>缺点：</p>
<ol>
<li>预计算时间非常长</li>
<li>只能处理静态物体、静态光</li>
<li>占用存储空间，通常在几十MB~一百MB </li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710143550991.png" alt="image-20230710143550991" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710143647404.png" alt="image-20230710143647404" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710144115534.png" alt="image-20230710144115534" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710144140615.png" alt="image-20230710144140615" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710144204813.png" alt="image-20230710144204813" style="zoom:80%;" /></p>
<h3 id="5-3-4-光照探针-Light-Probe"><a href="#5-3-4-光照探针-Light-Probe" class="headerlink" title="5.3.4    光照探针 Light Probe"></a>5.3.4    光照探针 Light Probe</h3><p><strong>空间体素化</strong></p>
<ol>
<li>在场景中添加若干探针，针对每个探针计算全局光照</li>
<li>当需要某个点的全局光照时，对周围的探针进行插值</li>
</ol>
<p>优点：</p>
<ol>
<li>runtime时效率高</li>
<li>可以处理静态物体和动态物体，可以动态更新</li>
<li>处理了diffuse、specular的渲染</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法实现类似lightmap的细节</li>
<li>SH light probe需要预计算</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710144730913.png" alt="image-20230710144730913" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710145020056.png" alt="image-20230710145020056" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710145217849.png" alt="image-20230710145217849" style="zoom:80%;" /></p>
<h2 id="5-4-基于物理的材质-Physical-Based-Material-PBR"><a href="#5-4-基于物理的材质-Physical-Based-Material-PBR" class="headerlink" title="5.4    基于物理的材质 Physical-Based Material PBR"></a>5.4    基于物理的材质 Physical-Based Material PBR</h2><h3 id="5-4-1-微平面理论"><a href="#5-4-1-微平面理论" class="headerlink" title="5.4.1    微平面理论"></a>5.4.1    微平面理论</h3><ol>
<li>假设任意面都由很多小的微平面组成，每个微平面都是镜面反射</li>
<li>如果微平面的法线方向集中，则是镜面反射；如果发散，则是漫反射</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710145814669.png" alt="image-20230710145814669" style="zoom:80%;" /></p>
<h3 id="5-4-2-基于微平面的BRDF模型"><a href="#5-4-2-基于微平面的BRDF模型" class="headerlink" title="5.4.2    基于微平面的BRDF模型"></a>5.4.2    基于微平面的BRDF模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710145923736.png" alt="image-20230710145923736" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710150553439.png" alt="image-20230710150553439" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710150927605.png" alt="image-20230710150927605" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710151100153.png" alt="image-20230710151100153" style="zoom:80%;" /></p>
<h3 id="5-4-3-Disney-Principled-BRDF"><a href="#5-4-3-Disney-Principled-BRDF" class="headerlink" title="5.4.3    Disney Principled BRDF"></a>5.4.3    Disney Principled BRDF</h3><p>五个原则</p>
<ol>
<li>参数的含义要足够直观</li>
<li>参数要尽可能少</li>
<li>参数的范围要尽可能在<code>[0,1]</code>之间</li>
<li>参数的范围也可以超过<code>[0,1]</code>，但是这必须是有意义的</li>
<li>参数的组合不会产生非常诡异的结果，每个参数的组合都是有意义的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152058624.png" alt="image-20230710152058624" style="zoom:80%;" /></p>
<h3 id="5-4-4-PBR-Specular-Glossiness"><a href="#5-4-4-PBR-Specular-Glossiness" class="headerlink" title="5.4.4    PBR Specular Glossiness"></a>5.4.4    PBR Specular Glossiness</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152319575.png" alt="image-20230710152319575" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152356799.png" alt="image-20230710152356799" style="zoom:80%;" /></p>
<h3 id="5-4-5-PBR-Metallic-Roughness"><a href="#5-4-5-PBR-Metallic-Roughness" class="headerlink" title="5.4.5    PBR Metallic Roughness"></a>5.4.5    PBR Metallic Roughness</h3><p>在SG模型的基础上进行封装，不是直接给出菲涅尔项的参数，而是通过metallic属性，对base_color进行插值</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152711140.png" alt="image-20230710152711140" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710152730662.png" alt="image-20230710152730662" style="zoom:80%;" /></p>
<h2 id="5-5-基于图像的光照：Image-Based-Lighting（IBL）"><a href="#5-5-基于图像的光照：Image-Based-Lighting（IBL）" class="headerlink" title="5.5    基于图像的光照：Image-Based Lighting（IBL）"></a>5.5    基于图像的光照：Image-Based Lighting（IBL）</h2><p>基础想法：对环境光照做一些预处理，从而快速计算环境光照与材质的卷积运算</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153710856.png" alt="image-20230710153710856" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153723495.png" alt="image-20230710153723495" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153902074.png" alt="image-20230710153902074" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153919760.png" alt="image-20230710153919760" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710153937924.png" alt="image-20230710153937924" style="zoom:80%;" /></p>
<h2 id="5-6-经典阴影方法"><a href="#5-6-经典阴影方法" class="headerlink" title="5.6    经典阴影方法"></a>5.6    经典阴影方法</h2><h3 id="5-6-1-Cascade-Shadow"><a href="#5-6-1-Cascade-Shadow" class="headerlink" title="5.6.1    Cascade Shadow"></a>5.6.1    Cascade Shadow</h3><ol>
<li>将环境分为不同层，离玩家越近，shadow map的精度越高</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154217910.png" alt="image-20230710154217910" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154229321.png" alt="image-20230710154229321" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154423464.png" alt="image-20230710154423464" style="zoom:80%;" /></p>
<h3 id="5-6-2-PCF"><a href="#5-6-2-PCF" class="headerlink" title="5.6.2    PCF"></a>5.6.2    PCF</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154627569.png" alt="image-20230710154627569" style="zoom:80%;" /></p>
<h3 id="5-6-3-PCSS"><a href="#5-6-3-PCSS" class="headerlink" title="5.6.3    PCSS"></a>5.6.3    PCSS</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154641878.png" alt="image-20230710154641878" style="zoom:80%;" /></p>
<h3 id="5-6-4-Variance-Soft-Shadow-Map（VSSM）"><a href="#5-6-4-Variance-Soft-Shadow-Map（VSSM）" class="headerlink" title="5.6.4    Variance Soft Shadow Map（VSSM）"></a>5.6.4    Variance Soft Shadow Map（VSSM）</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710154731623.png" alt="image-20230710154731623" style="zoom:80%;" /></p>
<h2 id="5-7-总结"><a href="#5-7-总结" class="headerlink" title="5.7    总结"></a>5.7    总结</h2><ol>
<li>光：Lightmap + Lightporbe</li>
<li>材质：PBR + IBL</li>
<li>阴影：Cascade shadow + VSSM</li>
</ol>
<h1 id="六、渲染：地形、大气、云的渲染"><a href="#六、渲染：地形、大气、云的渲染" class="headerlink" title="六、渲染：地形、大气、云的渲染"></a>六、渲染：地形、大气、云的渲染</h1><h2 id="6-1-地形的几何"><a href="#6-1-地形的几何" class="headerlink" title="6.1    地形的几何"></a>6.1    地形的几何</h2><h3 id="6-1-1-Heightfield"><a href="#6-1-1-Heightfield" class="headerlink" title="6.1.1    Heightfield"></a>6.1.1    Heightfield</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710164528555.png" alt="image-20230710164528555" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710164711163.png" alt="image-20230710164711163" style="zoom:80%;" /></p>
<h3 id="6-1-3-两个优化的准则"><a href="#6-1-3-两个优化的准则" class="headerlink" title="6.1.3    两个优化的准则"></a>6.1.3    两个优化的准则</h3><ol>
<li>FOV越窄，三角形划分越密集</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710165356323.png" alt="image-20230710165356323" style="zoom:80%;" /></p>
<ol>
<li>和ground truth在屏幕上的误差不要超过一个像素</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710171620877.png" alt="image-20230710171620877" style="zoom:80%;" /></p>
<h3 id="6-1-4-基于三角形的剖分"><a href="#6-1-4-基于三角形的剖分" class="headerlink" title="6.1.4    基于三角形的剖分"></a>6.1.4    基于三角形的剖分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710171859276.png" alt="image-20230710171859276" style="zoom:80%;" /></p>
<p><strong>T-Junctions</strong></p>
<ol>
<li>问题：当两个相邻的三角形在同一个边上，这个三角形没有切分这条边，而相邻三角形切分了(高度会随之变化)，会导致地形上有个裂缝</li>
<li>解决方法：如果发现边上有邻居对相邻边的切分更密集，则当前三角形也需要将该边切分，直到与邻居的切分数相同</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710172014900.png" alt="image-20230710172014900" style="zoom:80%;" /></p>
<h3 id="6-1-5-基于四叉树的切分"><a href="#6-1-5-基于四叉树的切分" class="headerlink" title="6.1.5    基于四叉树的切分"></a>6.1.5    基于四叉树的切分</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710172614256.png" alt="image-20230710172614256" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230710172803559.png" alt="image-20230710172803559" style="zoom:80%;" /></p>
<p>解决T-Junctions的问题：<strong>Stitching吸附</strong></p>
<ol>
<li>将划分更密集的那个三角形的中心，对齐到更稀疏的三角形上</li>
<li>即划分出了一个面积为0的三角形</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713102702521.png" alt="image-20230713102702521" style="zoom:80%;" /></p>
<h3 id="6-1-6-基于不规则三角形的绘制-TIN"><a href="#6-1-6-基于不规则三角形的绘制-TIN" class="headerlink" title="6.1.6    基于不规则三角形的绘制 TIN"></a>6.1.6    基于不规则三角形的绘制 TIN</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713103514295.png" alt="image-20230713103514295" style="zoom:80%;" /></p>
<p>通过顶点简化，减少三角形的数目</p>
<p>优点：</p>
<ol>
<li>通常情况下，三角形的数目更少</li>
</ol>
<p>缺点：</p>
<ol>
<li>地形的三角形难以在渲染的时候调整</li>
</ol>
<h3 id="6-1-7-基于GPU的曲面细分-Tessellation"><a href="#6-1-7-基于GPU的曲面细分-Tessellation" class="headerlink" title="6.1.7    基于GPU的曲面细分(Tessellation)"></a>6.1.7    基于GPU的曲面细分(Tessellation)</h3><p>DirectX12开始支持Mesh Shader</p>
<ol>
<li>在给定Mesh Shader之后，Mesh Shader会生成一小块meshlit(一小片顶点&amp;三角形)，顶点&amp;三角形如何插值、如何凸包由shader控制</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713104436099.png" alt="image-20230713104436099" style="zoom:80%;" /></p>
<h3 id="6-1-8-Real-Time-Deformable-Terrain"><a href="#6-1-8-Real-Time-Deformable-Terrain" class="headerlink" title="6.1.8    Real-Time Deformable Terrain"></a>6.1.8    Real-Time Deformable Terrain</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713105028872.png" alt="image-20230713105028872" style="zoom:80%;" /></p>
<p>如果所有顶点的位置都可以在runtime动态调整，则可以让地形产生动态效果</p>
<ol>
<li>在人物的周边生成一个terrain deformable的texture，将这上面的脚印记录在texture上</li>
<li>当移动的时候，texture跟着角色走，但是要保持数据一致性</li>
<li>由于地形数据是实时细分出来的，就可以根据texture添加一些offset</li>
<li>还要注意更新地形的碰撞</li>
</ol>
<h3 id="6-1-9-Non-Heightfield-Terrain"><a href="#6-1-9-Non-Heightfield-Terrain" class="headerlink" title="6.1.9    Non-Heightfield Terrain"></a>6.1.9    Non-Heightfield Terrain</h3><p>地形不止有起伏，还有悬崖山洞之类的物体</p>
<h4 id="6-1-9-1-在Terrain中开一个洞"><a href="#6-1-9-1-在Terrain中开一个洞" class="headerlink" title="6.1.9.1    在Terrain中开一个洞"></a>6.1.9.1    在Terrain中开一个洞</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713105844108.png" alt="image-20230713105844108" style="zoom:80%;" /></p>
<ol>
<li>可以在设置顶点位置的时候，判断一下这个顶点是否在洞中</li>
<li>如果在洞中，则将其位置设为NaN</li>
<li>GPU在看到位置为NaN的顶点后，不会绘制用到这个顶点的所有物体</li>
<li>然后再通过加一个山洞的模型，避免地形上的zigzag条纹显示出来</li>
</ol>
<h4 id="6-1-9-2-地形体素化表达"><a href="#6-1-9-2-地形体素化表达" class="headerlink" title="6.1.9.2    地形体素化表达"></a>6.1.9.2    地形体素化表达</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713110208576.png" alt="image-20230713110208576" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713110303928.png" alt="image-20230713110303928" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713110648064.png" alt="image-20230713110648064" style="zoom:80%;" /></p>
<ol>
<li>将地形表示为三维空间，三维空间中的每个点存一个权重值，表示这个位置是否有物质、物质的密度</li>
<li>通过Marching Cubes方法，找到等值面，切分立方体，形成一个水密的三角面片集，把形状表达出来</li>
</ol>
<h2 id="6-2-地形的材质"><a href="#6-2-地形的材质" class="headerlink" title="6.2    地形的材质"></a>6.2    地形的材质</h2><h3 id="6-2-1-Texture-Splatting"><a href="#6-2-1-Texture-Splatting" class="headerlink" title="6.2.1    Texture Splatting"></a>6.2.1    Texture Splatting</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713110922421.png" alt="image-20230713110922421" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713111446052.png" alt="image-20230713111446052" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713111410233.png" alt="image-20230713111410233" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713111837774.png" alt="image-20230713111837774" style="zoom:80%;" /></p>
<ol>
<li>每个材质存储Base Color、Normal、Roughness、Height四种贴图</li>
<li>再存储一张混合贴图，每个channel表示一种贴图的权重，通过笔刷设置不同材质的权重</li>
<li>在过渡的时候，如果需要混合两种材质，则根据height对权重进行调整，height高的权重下降慢<ol>
<li>缺点：由于是01切换，当相机移动的时候，会有很多抖动，导致分界线过硬</li>
<li>解决方法：添加一个bias，当两者高度差&lt;bias的时候，用权重进行插值</li>
</ol>
</li>
</ol>
<h3 id="6-2-2-在Texture-Array中采样"><a href="#6-2-2-在Texture-Array中采样" class="headerlink" title="6.2.2    在Texture Array中采样"></a>6.2.2    在Texture Array中采样</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713112037261.png" alt="image-20230713112037261" style="zoom:80%;" /></p>
<ol>
<li>将地表的多种材质存储为一个数组，每次采样仅会采样其中一个材质</li>
<li>混合的时候，根据位置、权重、index，判断采样哪种材质，采样的权重是但多少</li>
</ol>
<h3 id="6-2-3-Displacement-Mapping"><a href="#6-2-3-Displacement-Mapping" class="headerlink" title="6.2.3    Displacement Mapping"></a>6.2.3    Displacement Mapping</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713112551490.png" alt="image-20230713112551490" style="zoom:80%;" /></p>
<h3 id="6-2-4-Expensive-Material-Blending"><a href="#6-2-4-Expensive-Material-Blending" class="headerlink" title="6.2.4    Expensive Material Blending"></a>6.2.4    Expensive Material Blending</h3><ol>
<li>每一次进行纹理采样，都需要采样8个点，进行7次插值</li>
<li>一个点有几种材质进行混合，就需要在上述基础上乘几</li>
<li>而这些采样的数据在内存中的不同地方，address的不停跳跃会非常浪费时间</li>
<li>事实上，我们看到的地形仅有地形的一部分，其他部分都会被裁剪掉</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713113001442.png" alt="image-20230713113001442" style="zoom:80%;" /></p>
<h3 id="6-2-5-Virtual-Texture"><a href="#6-2-5-Virtual-Texture" class="headerlink" title="6.2.5    Virtual Texture"></a>6.2.5    Virtual Texture</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713113417200.png" alt="image-20230713113417200" style="zoom:80%;" /></p>
<p>核心思想：将用到的东西装载到内存中</p>
<ol>
<li>将纹理分为不同块，分块数满足2的幂次</li>
<li>然后根据分块对纹理建立Mipmap</li>
<li>绘制时，只将看到的纹理LOD层加载到内存</li>
</ol>
<h3 id="6-2-6-浮点数精度溢出"><a href="#6-2-6-浮点数精度溢出" class="headerlink" title="6.2.6    浮点数精度溢出"></a>6.2.6    浮点数精度溢出</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713114800746.png" alt="image-20230713114800746" style="zoom:80%;" /></p>
<ol>
<li>当摄像机&amp;地形的全局坐标很大(如1km)，而地形上的物体与地形距离很近(如0.5m)的时候，远处的地形与物体就会由于精度问题产生抖动</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713115131010.png" alt="image-20230713115131010" style="zoom:80%;" /></p>
<ol>
<li>解决方法：<ol>
<li>将相机的位置强行设置为0，地形的位置坐标根据相机的位置设置，此时两者使用到的坐标都不会很大，就可以保证小数点后的精度了<ol>
<li>修改前：地形位置1000010m、物体位置1000010.5m、相机位置1000000m</li>
<li>修改后：地形位置10m、物体位置10.5m、相机位置0m</li>
</ol>
</li>
<li>也可以将整个大型关卡切分为不同的小关卡，每个小关卡拥有自己的全局坐标系</li>
</ol>
</li>
</ol>
<h2 id="6-3-植被道路贴花等"><a href="#6-3-植被道路贴花等" class="headerlink" title="6.3    植被道路贴花等"></a>6.3    植被道路贴花等</h2><h3 id="6-3-1-树木渲染"><a href="#6-3-1-树木渲染" class="headerlink" title="6.3.1    树木渲染"></a>6.3.1    树木渲染</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713123021648.png" alt="image-20230713123021648" style="zoom:80%;" /></p>
<h3 id="6-3-2-装饰物渲染-Decorator"><a href="#6-3-2-装饰物渲染-Decorator" class="headerlink" title="6.3.2    装饰物渲染 Decorator"></a>6.3.2    装饰物渲染 Decorator</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713123446738.png" alt="image-20230713123446738" style="zoom:80%;" /></p>
<h3 id="6-3-3-道路和贴画渲染"><a href="#6-3-3-道路和贴画渲染" class="headerlink" title="6.3.3    道路和贴画渲染"></a>6.3.3    道路和贴画渲染</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230713123544838.png" alt="image-20230713123544838" style="zoom:80%;" /></p>
<ol>
<li>将地形的纹理、道路的纹理、贴画的纹理全部放到Virtual Texture中，runtime的时候直接调用virtual texture即可</li>
<li>计算的复杂度集中在bake中，runtime的时候只需要将纹理贴上去即可，开销很低</li>
</ol>
<h2 id="6-4-大气散射理论"><a href="#6-4-大气散射理论" class="headerlink" title="6.4    大气散射理论"></a>6.4    大气散射理论</h2><h3 id="6-4-1-Analytic-Atmosphere-Apperance-Modeling"><a href="#6-4-1-Analytic-Atmosphere-Apperance-Modeling" class="headerlink" title="6.4.1    Analytic Atmosphere Apperance Modeling"></a>6.4.1    Analytic Atmosphere Apperance Modeling</h3><script type="math/tex; mode=display">
F(\theta,\gamma)=(1+Ae^{\frac{B}{\cos\theta+0.01}})·(C+De^{E\gamma}+F\cos^2\gamma+G·\chi(H,\gamma)+I\cos^{\frac{1}{2}}\theta) \\
L_\lambda=F(\theta,\gamma)·L_{M\lambda}</script><p>优点：</p>
<ol>
<li>便于计算</li>
</ol>
<p>缺点：</p>
<ol>
<li>只能在地表</li>
<li>参数是写死的，无法自由的更改</li>
</ol>
<h3 id="6-4-2-Participating-Media"><a href="#6-4-2-Participating-Media" class="headerlink" title="6.4.2    Participating Media"></a>6.4.2    Participating Media</h3><p>空气是由两种粒子构成的：</p>
<ol>
<li>各种气体分子：如N2、O2、CO2</li>
<li>气溶胶：空气中的灰尘形成的小的气溶胶分子</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717170023348.png" alt="image-20230717170023348" style="zoom:80%;" /></p>
<h3 id="6-4-3-光与Participating-Media的交互：Radiative-Transfer-Function-RTF"><a href="#6-4-3-光与Participating-Media的交互：Radiative-Transfer-Function-RTF" class="headerlink" title="6.4.3    光与Participating Media的交互：Radiative Transfer Function (RTF)"></a>6.4.3    光与Participating Media的交互：Radiative Transfer Function (RTF)</h3><ol>
<li>吸收：$-\sigma_\alpha L(x,\omega)$</li>
<li>散射：$-\sigma_sL(x,\omega)$</li>
<li>自发光：$\sigma_\alpha L_e(x,\omega)$</li>
<li>其他气体分子的影响：$\sigma<em>s\int</em>{S^2}f_p(x,\omega,\omega’)L(x,\omega’)d\omega’$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717170238128.png" alt="image-20230717170238128" style="zoom:80%;" /></p>
<h3 id="6-4-4-Volume-Rendering-Equation-VRE"><a href="#6-4-4-Volume-Rendering-Equation-VRE" class="headerlink" title="6.4.4    Volume Rendering Equation (VRE)"></a>6.4.4    Volume Rendering Equation (VRE)</h3><ol>
<li><strong>Transmittance 通透度</strong>：在M点看到的东西，由多少会保留到在P点看到的东西，是路径积分的结果</li>
<li><strong>scattering function 散射方程</strong>：从M点到P点，叠加的其他粒子的效果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717170857327.png" alt="image-20230717170857327" style="zoom:80%;" /></p>
<h3 id="6-4-5-大气的实际物理"><a href="#6-4-5-大气的实际物理" class="headerlink" title="6.4.5    大气的实际物理"></a>6.4.5    大气的实际物理</h3><ol>
<li>太阳光由不同波长的光组成</li>
<li>大气由两种粒子构成：<ol>
<li>气体分子：直径小于光的波长</li>
<li>气溶胶分子：直径接近于光的波长</li>
</ol>
</li>
</ol>
<h4 id="6-4-5-1-散射"><a href="#6-4-5-1-散射" class="headerlink" title="6.4.5.1    散射"></a>6.4.5.1    散射</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717171902619.png" alt="image-20230717171902619" style="zoom:80%;" /></p>
<p>两种散射类型</p>
<ol>
<li><p>瑞利散射：当粒子的直径远小于光的波长的时候，光会均匀散射，波长越短散射越明显</p>
<ol>
<li>$\lambda$：光的波长</li>
<li>$\theta$：观察方向与光方向的夹角</li>
<li>$h$：海拔高度</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172209324.png" alt="image-20230717172209324" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172535846.png" alt="image-20230717172535846" style="zoom:80%;" /></p>
</li>
<li><p>幂散射：当粒子的直径接近或大于光的波长的时候，光的散射会有方向性，且对波长不敏感</p>
<ol>
<li>$\lambda$：光的波长</li>
<li>$\theta$：观察方向与光方向的夹角</li>
<li>$h$：海拔高度</li>
<li>$g$：几何参数，由艺术家调整</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172604878.png" alt="image-20230717172604878" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172731013.png" alt="image-20230717172731013" style="zoom:80%;" /></p>
</li>
</ol>
<h4 id="6-4-5-2-吸收"><a href="#6-4-5-2-吸收" class="headerlink" title="6.4.5.2    吸收"></a>6.4.5.2    吸收</h4><ol>
<li>O3：吸收红光、橙光、黄光</li>
<li>CH4：吸收红光</li>
<li>假设大气中的O3、CH4均匀分布</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717172849011.png" alt="image-20230717172849011" style="zoom:80%;" /></p>
<h3 id="6-4-6-单次散射-amp-多次散射"><a href="#6-4-6-单次散射-amp-多次散射" class="headerlink" title="6.4.6    单次散射 &amp; 多次散射"></a>6.4.6    单次散射 &amp; 多次散射</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717173525948.png" alt="image-20230717173525948" style="zoom:80%;" /></p>
<h3 id="6-4-7-Ray-Marching"><a href="#6-4-7-Ray-Marching" class="headerlink" title="6.4.7    Ray Marching"></a>6.4.7    Ray Marching</h3><ol>
<li>沿着一条视线，均匀地采很多点，把沿途的效果一步一步地积分起来</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717174657314.png" alt="image-20230717174657314" style="zoom:80%;" /></p>
<h2 id="6-5-实时大气渲染"><a href="#6-5-实时大气渲染" class="headerlink" title="6.5    实时大气渲染"></a>6.5    实时大气渲染</h2><h3 id="6-5-1-Transmittance-LUT-mu-r"><a href="#6-5-1-Transmittance-LUT-mu-r" class="headerlink" title="6.5.1    Transmittance LUT $(\mu,r)$"></a>6.5.1    Transmittance LUT $(\mu,r)$</h3><ol>
<li>选择一个海拔高度为$h$的点，在当前海拔高度存储两个值<ol>
<li>视线和天顶之间的夹角为$\theta$，用$\cos\theta$进行参数化表达</li>
<li>从当前点$X_v$出发，沿视线方向走到大气层的边界，与边界的交点为$B$</li>
</ol>
</li>
<li>此时，我们可以计算出整个大气层的通透度，即：$T(X_v → B)$</li>
<li>假设在远处有一个物体在点$X_m$处发出光，则该处的光到达当前点$X_v$的通透度为：$T(X_v→X_m)=\frac{T(X_v→B)}{T(X_m→B)}$</li>
<li>此时，我们可以通过一个简单的二维方程，通过除法，即可表达原先的四维方程</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230717174857029.png" alt="image-20230717174857029" style="zoom:80%;" /></p>
<h3 id="6-5-2-Single-Scattering-LUT-v-mu-s-mu-r"><a href="#6-5-2-Single-Scattering-LUT-v-mu-s-mu-r" class="headerlink" title="6.5.2    Single Scattering LUT $(v,\mu_s,\mu,r)$"></a>6.5.2    Single Scattering LUT $(v,\mu_s,\mu,r)$</h3><ol>
<li>视线方向：$\theta$<ol>
<li>选择一个海拔高度为$h$的点$X_v$，朝着一个方向去看，此时可以得到天顶角$\theta$</li>
<li>由于大气层是个球，因此有了起点和方向，即可得知$B$与$X_v$的距离</li>
</ol>
</li>
<li>太阳到天顶的角度为：$\eta$</li>
<li>视线与太阳之间的夹角：$\phi$</li>
<li>如果大气层各项同性，则只需要存储$(\theta,\eta,\phi)$对应的散射，即可得到某个点看向太空中的点的Single Scattering</li>
<li>再沿着高度$h$进行采样，即可得到一个四维表，可以将其存储到3D Texture Array中</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230719151741381.png" alt="image-20230719151741381" style="zoom:80%;" /></p>
<h3 id="6-5-3-计算Multi-Scattering"><a href="#6-5-3-计算Multi-Scattering" class="headerlink" title="6.5.3    计算Multi Scattering"></a>6.5.3    计算Multi Scattering</h3><ol>
<li>将Single Scattering照亮的点，通过Transmittance进行多次积分，即可得到Multi Scattering<ol>
<li>通常只做3~4次</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230719153923385.png" alt="image-20230719153923385" style="zoom:80%;" /></p>
<h3 id="6-5-4-缺点"><a href="#6-5-4-缺点" class="headerlink" title="6.5.4    缺点"></a>6.5.4    缺点</h3><ol>
<li>预计算的计算量很大</li>
<li>场景变化后，需要重新计算：如天空忽然开始下雨，设计场景时更改参数的值</li>
<li>实时计算时，需要做很多次高维表查值，导致时间开销较大</li>
</ol>
<h3 id="6-5-5-Production-Friendly-Quick-Sky-and-Atmosphere-Rendering"><a href="#6-5-5-Production-Friendly-Quick-Sky-and-Atmosphere-Rendering" class="headerlink" title="6.5.5    Production Friendly Quick Sky and Atmosphere Rendering"></a>6.5.5    Production Friendly Quick Sky and Atmosphere Rendering</h3><p>假设：在空气中的散射是低频的，对空气中的一个分子，来自于不同方向的散射在各向分布都是同样的</p>
<p>从而会导致每个分子的多次散射，实际上是一个等比衰减，比例可以通过计算两次&amp;三次散射得到</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721171740498.png" alt="image-20230721171740498" style="zoom:80%;" /></p>
<p>由于每一帧都要计算LUT，因此可以假设太阳位置不变、角色位置不变，从而可以删除两维</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721171756792.png" alt="image-20230721171756792" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721171919821.png" alt="image-20230721171919821" style="zoom:80%;" /></p>
<h2 id="6-6-云的渲染"><a href="#6-6-云的渲染" class="headerlink" title="6.6    云的渲染"></a>6.6    云的渲染</h2><h3 id="6-6-1-云的类型"><a href="#6-6-1-云的类型" class="headerlink" title="6.6.1    云的类型"></a>6.6.1    云的类型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172318834.png" alt="image-20230721172318834" style="zoom:80%;" /></p>
<h3 id="6-6-2-Billboard-Cloud"><a href="#6-6-2-Billboard-Cloud" class="headerlink" title="6.6.2    Billboard Cloud"></a>6.6.2    Billboard Cloud</h3><p>通过大量2D图片的混合，实现云的效果</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172435886.png" alt="image-20230721172435886" style="zoom:80%;" /></p>
<h3 id="6-6-3-Volumetric-Cloud-Modeling"><a href="#6-6-3-Volumetric-Cloud-Modeling" class="headerlink" title="6.6.3    Volumetric Cloud Modeling"></a>6.6.3    Volumetric Cloud Modeling</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172511551.png" alt="image-20230721172511551" style="zoom:80%;" /></p>
<h4 id="6-6-3-1-Weather-Texture"><a href="#6-6-3-1-Weather-Texture" class="headerlink" title="6.6.3.1    Weather Texture"></a>6.6.3.1    Weather Texture</h4><ol>
<li>云的随机分布</li>
<li>云的厚度：0~1的值</li>
</ol>
<p>让云飘起来：对Weather Texture进行平移</p>
<p>让云产生变化：对Weather Texture进行扰动</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172636329.png" alt="image-20230721172636329" style="zoom:80%;" /></p>
<h4 id="6-6-3-2-Noise-Function"><a href="#6-6-3-2-Noise-Function" class="headerlink" title="6.6.3.2    Noise Function"></a>6.6.3.2    Noise Function</h4><p>Perlin噪声：在多项式时间内产生棉花絮之类的效果</p>
<p>Worley噪声：形成泡泡絮的效果</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721172956467.png" alt="image-20230721172956467" style="zoom:80%;" /></p>
<h4 id="6-6-3-3-Cloud-Density-Model"><a href="#6-6-3-3-Cloud-Density-Model" class="headerlink" title="6.6.3.3    Cloud Density Model"></a>6.6.3.3    Cloud Density Model</h4><ol>
<li>基础的云是柱状的，需要添加噪声优化效果</li>
<li>先用低频噪声，删除一部分</li>
<li>在添加高频的细节</li>
<li>从而可以模拟数学上的分形效果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721173021690.png" alt="image-20230721173021690" style="zoom:80%;" /></p>
<h4 id="6-6-3-4-Rendering-Cloud-by-Ray-Marching"><a href="#6-6-3-4-Rendering-Cloud-by-Ray-Marching" class="headerlink" title="6.6.3.4    Rendering Cloud by Ray Marching"></a>6.6.3.4    Rendering Cloud by Ray Marching</h4><ol>
<li>从相机发送射线，判断是否能打到云上<ol>
<li>开始时步长较大</li>
</ol>
</li>
<li>一旦与云相交，就缩小步长，在每一个点计算大气的通透和散射<ol>
<li>由于云的通透度很低，因此可以做大量假设，简化渲染方程</li>
</ol>
</li>
<li>天空中的云实际上是GPU中的一个3D纹理，通过Ray Marching的方法解析该纹理的结果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230721173206921.png" alt="image-20230721173206921" style="zoom:80%;" /></p>
<h1 id="七、渲染：渲染管线、后处理和其他的一切"><a href="#七、渲染：渲染管线、后处理和其他的一切" class="headerlink" title="七、渲染：渲染管线、后处理和其他的一切"></a>七、渲染：渲染管线、后处理和其他的一切</h1><h2 id="7-1-环境光遮罩-Ambient-Occlusion：AO"><a href="#7-1-环境光遮罩-Ambient-Occlusion：AO" class="headerlink" title="7.1    环境光遮罩 Ambient Occlusion：AO"></a>7.1    环境光遮罩 Ambient Occlusion：AO</h2><p>原理：在物体中，只有一部分能看到天光，其他部分会被遮挡住</p>
<script type="math/tex; mode=display">
AO(\bold{p,n})=\frac{1}{\pi}\int_{\Omega}V(\bold{p},\omega)\bold{n}·\omega \ d\omega</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724102810366.png" alt="image-20230724102810366" style="zoom:80%;" /></p>
<h3 id="7-1-1-预计算AO"><a href="#7-1-1-预计算AO" class="headerlink" title="7.1.1    预计算AO"></a>7.1.1    预计算AO</h3><p>使用光线追踪的算法，离线计算AO并将其保存到纹理中</p>
<ol>
<li>需要额外的存储</li>
<li>只能应用于静态物体</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724103150057.png" alt="image-20230724103150057" style="zoom:80%;" /></p>
<h3 id="7-1-2-SSAO：Screen-Space-Ambient-Occlusion"><a href="#7-1-2-SSAO：Screen-Space-Ambient-Occlusion" class="headerlink" title="7.1.2    SSAO：Screen Space Ambient Occlusion"></a>7.1.2    SSAO：Screen Space Ambient Occlusion</h3><p>思想：</p>
<ol>
<li>在渲染的每一帧中，可以得到每个像素的颜色&amp;深度</li>
<li>将每个像素的深度信息连接到一起，就可以得到height field</li>
<li>根据height field可以得到几何关系，从而估算自遮挡</li>
</ol>
<p>估算自遮挡：</p>
<ol>
<li>在观察点p的给定半径的球形空间内，随机采样N个点</li>
<li>对这N个采样点，通过相机去投射，可以得到这些点的深度，与Z-Buffer中的深度进行对比<ol>
<li>深度比Z-Buffer中的近，则证明其可以看见光</li>
<li>深度比Z-Buffer中的远，则证明其被当前绘制中的某个几何挡住了</li>
</ol>
</li>
<li>则最后的自遮挡为：$A(p)=1-\frac{Occlusion}{N}$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724103340183.png" alt="image-20230724103340183" style="zoom:80%;" /></p>
<h3 id="7-1-3-SSAO"><a href="#7-1-3-SSAO" class="headerlink" title="7.1.3    SSAO+"></a>7.1.3    SSAO+</h3><ol>
<li>沿着p点的法线方向，采样半球面</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724104812491.png" alt="image-20230724104812491" style="zoom:80%;" /></p>
<h3 id="7-1-4-HBAO：Horizon-Based-Ambient-Occlusion"><a href="#7-1-4-HBAO：Horizon-Based-Ambient-Occlusion" class="headerlink" title="7.1.4    HBAO：Horizon Based Ambient Occlusion"></a>7.1.4    HBAO：Horizon Based Ambient Occlusion</h3><p>思想：</p>
<ol>
<li>要求的实际上是球面空间上的可见性</li>
<li>从p点出发，沿着各个方向去转，找到光线能够越过最高邻居的仰角，称为pitch angle</li>
<li>如果在每个方向都找到了，则会得到Occluded Area</li>
<li>根据Occluded Area，可以估算出有多大面积的天顶是可见的</li>
<li>attenuation function：如果某个山离p点过远，则认为其对我没有影响</li>
</ol>
<script type="math/tex; mode=display">
A=1-\frac{1}{2\pi}\int_{\theta=-\pi}^{\pi}\int_{\alpha=t(\theta)}^{h(\theta)}W(\vec{\omega})\cos(\alpha)\ d\alpha d\theta</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724105031680.png" alt="image-20230724105031680" style="zoom:80%;" /></p>
<p>具体实现：ray marching</p>
<ol>
<li>将Z-Buffer视为height field</li>
<li>以P点为圆心，以几个像素为固定步长进行采样，采样一圈，得到最大horizon angle</li>
<li>注意：对于每个像素，要随机抖动步长、旋转方向</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724105717883.png" alt="image-20230724105717883" style="zoom:80%;" /></p>
<h3 id="7-1-5-GTAO：Ground-Truth-based-Ambient-Occlusion"><a href="#7-1-5-GTAO：Ground-Truth-based-Ambient-Occlusion" class="headerlink" title="7.1.5    GTAO：Ground Truth-based Ambient Occlusion"></a>7.1.5    GTAO：Ground Truth-based Ambient Occlusion</h3><p>问题：不同方向的光，对于P点的反射贡献是不同的，有一个 $\cos\theta$ 的修正</p>
<script type="math/tex; mode=display">
\hat{A}(x)=\frac{1}{\pi}\int_{0}^{\pi}\int_{\theta_1(\phi)}^{\theta_2(\phi)}\cos(\theta-\gamma)^+|\sin(\theta)|\ d\theta d\phi\\
\gamma=angle(\vec{n},\vec{v})</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724110713853.png" alt="image-20230724110713853" style="zoom:80%;" /></p>
<ol>
<li>根据计算出的AO值，可以猜测光射进山谷后，多次Bounce后形成的亮度<ol>
<li>例如山谷虽然被周围的山遮挡住了，但是底部仍旧有光，并且底部的光与周围的山的面的颜色有关系</li>
</ol>
</li>
<li>根据不同的AO值，与对应的Multi Scattering值进行分析，得到一个多项式的关联</li>
<li>从而根据一个多项式，将Single Bounce转换为Multi Bounce的效果<ol>
<li>AO的值类似于BRDF中的roughness值，表示周围区域对当前点的遮挡性</li>
<li>GTAO的发现类似于用多项式方程拟合了积分的效果</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724111134323.png" alt="image-20230724111134323" style="zoom:80%;" /></p>
<h3 id="7-1-6-Ray-Tracing-Ambient-Occlusion"><a href="#7-1-6-Ray-Tracing-Ambient-Occlusion" class="headerlink" title="7.1.6    Ray-Tracing Ambient Occlusion"></a>7.1.6    Ray-Tracing Ambient Occlusion</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724112133504.png" alt="image-20230724112133504" style="zoom:80%;" /></p>
<h2 id="7-2-雾效"><a href="#7-2-雾效" class="headerlink" title="7.2    雾效"></a>7.2    雾效</h2><h3 id="7-2-1-Depth-Fog"><a href="#7-2-1-Depth-Fog" class="headerlink" title="7.2.1    Depth Fog"></a>7.2.1    Depth Fog</h3><p>思想：从眼睛看过去，随着距离，能见度逐渐下降</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724112307755.png" alt="image-20230724112307755" style="zoom:80%;" /></p>
<h3 id="7-2-2-Height-Fog"><a href="#7-2-2-Height-Fog" class="headerlink" title="7.2.2    Height Fog"></a>7.2.2    Height Fog</h3><p>思想：不同高度，雾的浓度不同</p>
<ol>
<li>Fog有一个最大值：当低于某个高度时，都是最大的Fog；当高于该高度时，Fog是以指数递减的</li>
<li>当人的位置$O_z$高于目标位置时，Fog要通过Ray Marching算法，从目标位置到当前位置进行积分</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724112613301.png" alt="image-20230724112613301" style="zoom:80%;" /></p>
<h3 id="7-2-3-Voxel-Based-Volumetric-Fog"><a href="#7-2-3-Voxel-Based-Volumetric-Fog" class="headerlink" title="7.2.3    Voxel-Based Volumetric Fog"></a>7.2.3    Voxel-Based Volumetric Fog</h3><p>将相机空间非均匀体素化：根据视锥进行切分(如左上图所示)</p>
<ol>
<li>原因：如果进行均匀体素化，那么近处的颗粒太大，远处的颗粒太细</li>
<li>一般会用一个3D纹理存储运算结构</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724113400597.png" alt="image-20230724113400597" style="zoom:80%;" /></p>
<h2 id="7-3-抗锯齿"><a href="#7-3-抗锯齿" class="headerlink" title="7.3    抗锯齿"></a>7.3    抗锯齿</h2><h3 id="7-3-1-锯齿产生的原因"><a href="#7-3-1-锯齿产生的原因" class="headerlink" title="7.3.1    锯齿产生的原因"></a>7.3.1    锯齿产生的原因</h3><p>产生锯齿的原因：屏幕的分辨率是有限的，而几何世界的分辨率是无限的</p>
<ol>
<li>边界的采样</li>
<li>纹理的采样</li>
<li>高光的采样</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724114416137.png" alt="image-20230724114416137" style="zoom:80%;" /></p>
<h3 id="7-3-2-Anti-aliasing"><a href="#7-3-2-Anti-aliasing" class="headerlink" title="7.3.2    Anti-aliasing"></a>7.3.2    Anti-aliasing</h3><p>多采样几次，进行平均，从而产生过渡区域</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724114726723.png" alt="image-20230724114726723" style="zoom:80%;" /></p>
<h3 id="7-3-3-SSAA-Super-sample-AA-amp-MSAA-Multi-sample-AA"><a href="#7-3-3-SSAA-Super-sample-AA-amp-MSAA-Multi-sample-AA" class="headerlink" title="7.3.3    SSAA(Super-sample AA) &amp; MSAA(Multi-sample AA)"></a>7.3.3    SSAA(Super-sample AA) &amp; MSAA(Multi-sample AA)</h3><p>SSAA：</p>
<ol>
<li>在屏幕分辨率的基础上，绘制更高分辨率的图片，然后对高分辨率的图片进行下采样，得到屏幕上的图片</li>
<li>缺点：所有buffer、shading均变成原来的4倍</li>
</ol>
<p>MSAA：</p>
<ol>
<li>对空间仍是4倍采样，但是在渲染时，如果这4个sub-pixel对三角形的贡献相同的话，只进行一次shading；如果不止一个贡献的话，则对四个采样点均进行一次shading，然后计算平均值</li>
<li>只有在最后的shading时，会省略一些不需要的渲染</li>
<li>缺点：当三角形数量高于像素数量时，MSAA会彻底失效</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724114910115.png" alt="image-20230724114910115" style="zoom:80%;" /></p>
<h3 id="7-3-4-FXAA：Fast-Approximate-Anti-Aliasing"><a href="#7-3-4-FXAA：Fast-Approximate-Anti-Aliasing" class="headerlink" title="7.3.4    FXAA：Fast Approximate Anti-Aliasing"></a>7.3.4    FXAA：Fast Approximate Anti-Aliasing</h3><p>在采样率不变的情况下，进行抗锯齿</p>
<p>思想：产生锯齿的地方，一般都是边界，此时会产生颜色的跳变，只需要对边界进行抗锯齿即可</p>
<ol>
<li><p>对每个像素点，进行十字滤波：</p>
<ol>
<li>计算上下左右四个邻居以及自己的差异值，当差异值大于某个阈值时，就是边界</li>
<li>将颜色转化为亮度，只计算亮度的差异值：$L=0.299<em>R+0.587</em>G+0.114*B$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724115838038.png" alt="image-20230724115838038" style="zoom:80%;" /></p>
</li>
<li><p>计算差异的方向：</p>
<ol>
<li>使用两个卷积矩阵，分别计算横向与纵向的差异权重，判断差异方向</li>
<li>确定方向后，比较两个邻居，判断谁的差异更大</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724120357356.png" alt="image-20230724120357356" style="zoom:80%;" /></p>
</li>
<li><p>边界搜索算法：</p>
<ol>
<li>从当前点出发，与应该与其进行混合的点形成一对，求亮度平均值$L<em>{avg}$、亮度差异值$L</em>{offset}$</li>
<li>朝着垂直于这一对的方向的两边进行搜索，找到像素对的颜色变化与当前点像素对不同为止</li>
<li>此时就找到了边界的两个端点</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724144851026.png" alt="image-20230724144851026" style="zoom:80%;" /></p>
</li>
<li><p>计算混合系数</p>
<ol>
<li>比较当前点距离左端和右端的距离，找到更近的端点$targetP$</li>
<li>根据平均亮度、当前点亮度、端点亮度，计算混合系数</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724145257417.png" alt="image-20230724145257417" style="zoom:80%;" /></p>
</li>
<li><p>与相邻的像素进行混合</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724145657591.png" alt="image-20230724145657591" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="7-3-5-TAA：Teamporal-Anti-Aliasing"><a href="#7-3-5-TAA：Teamporal-Anti-Aliasing" class="headerlink" title="7.3.5    TAA：Teamporal Anti-Aliasing"></a>7.3.5    TAA：Teamporal Anti-Aliasing</h3><ol>
<li>利用前一帧的数据进行混合</li>
<li>每个点都需要计算上一帧的对应位置，生成motion vector</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724145900584.png" alt="image-20230724145900584" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724150017897.png" alt="image-20230724150017897" style="zoom:80%;" /></p>
<h2 id="7-4-后处理"><a href="#7-4-后处理" class="headerlink" title="7.4    后处理"></a>7.4    后处理</h2><h3 id="7-4-1-Blooming-光晕效果"><a href="#7-4-1-Blooming-光晕效果" class="headerlink" title="7.4.1    Blooming 光晕效果"></a>7.4.1    Blooming 光晕效果</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724152124723.png" alt="image-20230724152124723" style="zoom:80%;" /></p>
<ol>
<li><p>首先，取出当前帧中高亮的部分</p>
<ol>
<li>计算每一个像素的亮度，与平均光场亮度做对比，超过阈值的像素取出其RGB值</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724154401888.png" alt="image-20230724154401888" style="zoom:80%;" /></p>
</li>
<li><p>然后，对取出的像素进行高斯模糊</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724154659877.png" alt="image-20230724154659877" style="zoom:80%;" /></p>
</li>
<li><p>先进行几次下采样，对下采样之后的结果进行Blur，然后再进行上采样，与原有的图像进行混合，此时模糊的区域就会很大</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724155120135.png" alt="image-20230724155120135" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="7-4-2-Tone-Mapping"><a href="#7-4-2-Tone-Mapping" class="headerlink" title="7.4.2    Tone Mapping"></a>7.4.2    Tone Mapping</h3><p>将HDR颜色转化为SDR颜色，从而显示HDR图像</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724162530557.png" alt="image-20230724162530557" style="zoom:80%;" /></p>
<p>关键在于定义一条Tone Mapping曲线，用于转换颜色</p>
<ol>
<li><p>filmic曲线</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724163300239.png" alt="image-20230724163300239" style="zoom:80%;" /></p>
</li>
<li><p>ACES：Academy Color Encoding System</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724163550628.png" alt="image-20230724163550628" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="7-4-3-Color-Grading"><a href="#7-4-3-Color-Grading" class="headerlink" title="7.4.3    Color Grading"></a>7.4.3    Color Grading</h3><p>通过一个Lookup Table，整体改变图像的色彩空间，从而快速修改游戏画面的颜色</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724163949045.png" alt="image-20230724163949045" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724164015141.png" alt="image-20230724164015141" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724164344381.png" alt="image-20230724164344381" style="zoom:80%;" /></p>
<h2 id="7-5-渲染管线"><a href="#7-5-渲染管线" class="headerlink" title="7.5    渲染管线"></a>7.5    渲染管线</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724164827551.png" alt="image-20230724164827551" style="zoom:80%;" /></p>
<h3 id="7-5-1-Forward-Rendering"><a href="#7-5-1-Forward-Rendering" class="headerlink" title="7.5.1    Forward Rendering"></a>7.5.1    Forward Rendering</h3><p>对每一个mesh、每一个light，渲染一遍</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165010279.png" alt="image-20230724165010279" style="zoom:67%;" /></p>
<ol>
<li>透明物体必须在不透明物体之后绘制</li>
<li>多个透明物体按照由远及近的顺序绘制</li>
<li>天空最后绘制</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165037797.png" alt="image-20230724165037797" style="zoom:80%;" /></p>
<h3 id="7-5-2-Deffered-Rendering-延迟渲染"><a href="#7-5-2-Deffered-Rendering-延迟渲染" class="headerlink" title="7.5.2    Deffered Rendering 延迟渲染"></a>7.5.2    Deffered Rendering 延迟渲染</h3><ol>
<li>先计算所有物体的材质信息，将其保存到一个巨大的G-Buffer中</li>
<li>然后再计算所有的光，将其应用到G-Buffer中</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165433022.png" alt="image-20230724165433022" style="zoom:80%;" /></p>
<p>优点：</p>
<ol>
<li>对光的处理非常方便</li>
<li>渲染很容易debug</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要更多的内存、读写开销</li>
<li>不支持透明物体</li>
<li>对MSAA不友好</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165643986.png" alt="image-20230724165643986" style="zoom:80%;" /></p>
<h3 id="7-5-3-Tile-based-Rendering"><a href="#7-5-3-Tile-based-Rendering" class="headerlink" title="7.5.3    Tile-based Rendering"></a>7.5.3    Tile-based Rendering</h3><p>将画面拆成一小块一小块，降低对读写的压力</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724165933701.png" alt="image-20230724165933701" style="zoom:80%;" /></p>
<p>从而可以判断每个光会对哪些tile产生影响，进行光的裁剪</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170117258.png" alt="image-20230724170117258" style="zoom:80%;" /></p>
<p>对于每一个tile，可以在计算Z-Buffer的时候，得到该tile的深度范围，从而计算出光源可能影响到的tile</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170247601.png" alt="image-20230724170247601" style="zoom:80%;" /></p>
<h3 id="7-5-4-Forward-Rendering"><a href="#7-5-4-Forward-Rendering" class="headerlink" title="7.5.4    Forward+ Rendering"></a>7.5.4    Forward+ Rendering</h3><p>分块进行Forward Rendering</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170500085.png" alt="image-20230724170500085" style="zoom:80%;" /></p>
<h3 id="7-5-5-Cluster-based-Rendering"><a href="#7-5-5-Cluster-based-Rendering" class="headerlink" title="7.5.5    Cluster-based Rendering"></a>7.5.5    Cluster-based Rendering</h3><p>直接对Z空间进行切分，划分为一个个的四棱锥</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170548584.png" alt="image-20230724170548584" style="zoom:80%;" /></p>
<h3 id="7-5-6-Visibility-Buffer"><a href="#7-5-6-Visibility-Buffer" class="headerlink" title="7.5.6    Visibility Buffer"></a>7.5.6    Visibility Buffer</h3><p>将几何信息与材质信息分开，存储几何信息，反向找到材质</p>
<ol>
<li>在Visibility Buffer中，记录每个像素属于哪个几何体的哪个三角形，从而可以反向查该三角形应用哪种材质</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724170734043.png" alt="image-20230724170734043" style="zoom:80%;" /></p>
<h2 id="7-6-Frame-Graph"><a href="#7-6-Frame-Graph" class="headerlink" title="7.6    Frame Graph"></a>7.6    Frame Graph</h2><p>用一个有向无环图表示资源之间的依赖关系，由系统自动管理实际资源的使用和释放</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724173121032.png" alt="image-20230724173121032" style="zoom:80%;" /></p>
<h2 id="7-7-V-Sync-amp-G-Sync"><a href="#7-7-V-Sync-amp-G-Sync" class="headerlink" title="7.7    V-Sync &amp; G-Sync"></a>7.7    V-Sync &amp; G-Sync</h2><h3 id="7-7-1-Screen-Tearing-屏幕撕裂"><a href="#7-7-1-Screen-Tearing-屏幕撕裂" class="headerlink" title="7.7.1    Screen Tearing 屏幕撕裂"></a>7.7.1    Screen Tearing 屏幕撕裂</h3><p>引擎渲染的刷新率是不一定的，而屏幕的刷新率是固定的，从而会导致画面的撕裂</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724173615680.png" alt="image-20230724173615680" style="zoom:80%;" /></p>
<h3 id="7-7-2-V-Sync-垂直同步"><a href="#7-7-2-V-Sync-垂直同步" class="headerlink" title="7.7.2    V-Sync 垂直同步"></a>7.7.2    V-Sync 垂直同步</h3><blockquote>
<p><strong>垂直同步(VSync)</strong> ：将游戏或应用程序的图像帧速率与显示监视器的刷新速率进行同步，有助于建立稳定性。 如果不同步，则可能会导致画面撕裂，即图像看起来在整个屏幕上呈现水平方向毛刺或重影的效果。 启用VSync 后，便会获得完美对齐的画面而不会出现毛刺</p>
</blockquote>
<p>将整个Frame渲染完成后，等到下一个屏幕刷新时间，统一写进去</p>
<ol>
<li>可能会导致画面一会快一会慢</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230724173646994.png" alt="image-20230724173646994" style="zoom:80%;" /></p>
<h1 id="八、动画：动画技术基础"><a href="#八、动画：动画技术基础" class="headerlink" title="八、动画：动画技术基础"></a>八、动画：动画技术基础</h1><h2 id="8-1-2D游戏动画技术"><a href="#8-1-2D游戏动画技术" class="headerlink" title="8.1    2D游戏动画技术"></a>8.1    2D游戏动画技术</h2><h3 id="8-1-1-Sprite-Animation"><a href="#8-1-1-Sprite-Animation" class="headerlink" title="8.1.1    Sprite Animation"></a>8.1.1    Sprite Animation</h3><p>记录每一帧的动作，循环播放</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725172639259.png" alt="image-20230725172639259" style="zoom:80%;" /></p>
<p>在不同视角采样一系列的动作，根据当前视角播放不同动画</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173034724.png" alt="image-20230725173034724" style="zoom:80%;" /></p>
<p>现代游戏引擎中，粒子效果就是Sprite Animation</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173149954.png" alt="image-20230725173149954" style="zoom:80%;" /></p>
<h3 id="8-1-2-Live2D"><a href="#8-1-2-Live2D" class="headerlink" title="8.1.2    Live2D"></a>8.1.2    Live2D</h3><p>将一个角色的所有元素，变成一个个小图元，通过变换图元，组成人物的不同姿态</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173218195.png" alt="image-20230725173218195" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173430996.png" alt="image-20230725173430996" style="zoom:80%;" /></p>
<ol>
<li><p>首先，定义不同图元的深度，以控制图元是否出现，不同图元之间的层次关系</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173813825.png" alt="image-20230725173813825" style="zoom:80%;" /></p>
</li>
<li><p>然后，生成ArtMesh，通过拖动ArtMesh上的控制点，控制图元的变化</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173852827.png" alt="image-20230725173852827" style="zoom:80%;" /></p>
</li>
<li><p>设置动画关键帧，从而进行动画插值</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725173944369.png" alt="image-20230725173944369" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="8-2-3D游戏动画技术"><a href="#8-2-3D游戏动画技术" class="headerlink" title="8.2    3D游戏动画技术"></a>8.2    3D游戏动画技术</h2><h3 id="8-2-1-DoF：Degress-of-Freedom-自由度"><a href="#8-2-1-DoF：Degress-of-Freedom-自由度" class="headerlink" title="8.2.1    DoF：Degress of Freedom 自由度"></a>8.2.1    DoF：Degress of Freedom 自由度</h3><p>一个物体可以在多少个维度进行变化</p>
<ol>
<li>刚体：6个自由度，平移3个，旋转3个</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725174149918.png" alt="image-20230725174149918" style="zoom:80%;" /></p>
<h3 id="8-2-2-Rigid-Hierarchical-Animation"><a href="#8-2-2-Rigid-Hierarchical-Animation" class="headerlink" title="8.2.2    Rigid Hierarchical Animation"></a>8.2.2    Rigid Hierarchical Animation</h3><ol>
<li>将mesh分为层次化的多个可以变化的刚体，动画即是改变这些刚体的平移/旋转</li>
<li>缺点：不同关节之间可能会穿插</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725174416495.png" alt="image-20230725174416495" style="zoom:80%;" /></p>
<h3 id="8-2-3-Per-vertex-Animation-顶点动画"><a href="#8-2-3-Per-vertex-Animation-顶点动画" class="headerlink" title="8.2.3    Per-vertex Animation 顶点动画"></a>8.2.3    Per-vertex Animation 顶点动画</h3><p>顶点动画：</p>
<ol>
<li>记录每个顶点的位置随时间的变化</li>
<li>一般存两个texture，一个texture记录顶点的位置，另一个记录顶点的法向</li>
<li>通常是用物理引擎离线计算好，然后存到texture中</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725174558034.png" alt="image-20230725174558034" style="zoom:80%;" /></p>
<h3 id="8-2-4-Morph-Target-Animation"><a href="#8-2-4-Morph-Target-Animation" class="headerlink" title="8.2.4    Morph Target Animation"></a>8.2.4    Morph Target Animation</h3><ol>
<li>也是一种顶点动画，但是记录的是顶点影响权重</li>
<li>存储多个Key Poses，然后在Key Poses之间进行插值</li>
<li>在捏脸系统中更好用</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725174900318.png" alt="image-20230725174900318" style="zoom:80%;" /></p>
<h3 id="8-2-5-Skinned-Animation-蒙皮动画"><a href="#8-2-5-Skinned-Animation-蒙皮动画" class="headerlink" title="8.2.5    Skinned Animation 蒙皮动画"></a>8.2.5    Skinned Animation 蒙皮动画</h3><p>刚体骨骼驱动外表的蒙皮进行动画，每个顶点由多个骨骼同时影响</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725175213453.png" alt="image-20230725175213453" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725175347643.png" alt="image-20230725175347643" style="zoom:80%;" /></p>
<h3 id="8-2-6-Physics-based-Animation"><a href="#8-2-6-Physics-based-Animation" class="headerlink" title="8.2.6    Physics-based Animation"></a>8.2.6    Physics-based Animation</h3><ol>
<li>布娃娃系统</li>
<li>衣料、流体模拟</li>
<li>IK反向动力学</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725175428162.png" alt="image-20230725175428162" style="zoom:80%;" /></p>
<h3 id="8-2-7-Animation-Content-Creation"><a href="#8-2-7-Animation-Content-Creation" class="headerlink" title="8.2.7    Animation Content Creation"></a>8.2.7    Animation Content Creation</h3><ol>
<li>动画师设置关键帧</li>
<li>动捕</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230725175649795.png" alt="image-20230725175649795" style="zoom:80%;" /></p>
<h2 id="8-3-蒙皮动画的实现"><a href="#8-3-蒙皮动画的实现" class="headerlink" title="8.3    蒙皮动画的实现"></a>8.3    蒙皮动画的实现</h2><h3 id="8-3-1-如何让Mesh播放动画"><a href="#8-3-1-如何让Mesh播放动画" class="headerlink" title="8.3.1    如何让Mesh播放动画"></a>8.3.1    如何让Mesh播放动画</h3><ol>
<li>创建mesh的binding pose</li>
<li>创建binding skeleton</li>
<li>刷上蒙皮，告诉每个顶点应该受到哪些骨骼的影响</li>
<li>移动skeleton</li>
<li>蒙皮上的顶点会跟着运动</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726102514399.png" alt="image-20230726102514399" style="zoom:80%;" /></p>
<h3 id="8-3-2-不同的空间"><a href="#8-3-2-不同的空间" class="headerlink" title="8.3.2    不同的空间"></a>8.3.2    不同的空间</h3><ol>
<li>世界空间：全局坐标系</li>
<li>模型空间：以角色为中心，相对世界空间有平移&amp;旋转</li>
<li>局部空间：每根骨骼的坐标系，每根骨骼都不相同，需要逐步累加进来</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726102748726.png" alt="image-20230726102748726" style="zoom:80%;" /></p>
<h3 id="8-3-3-两种骨骼"><a href="#8-3-3-两种骨骼" class="headerlink" title="8.3.3    两种骨骼"></a>8.3.3    两种骨骼</h3><p>Humanoid Skeleton：两足动物的骨骼</p>
<ol>
<li>起点在人的胯部：Pelvis</li>
<li>有时会在Pelvis之上添加一个root</li>
</ol>
<p>Non-humanoid Skeleton：四足动物的骨骼</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726103147477.png" alt="image-20230726103147477" style="zoom:80%;" /></p>
<h3 id="8-3-4-骨骼-Bone-amp-关节-Joint"><a href="#8-3-4-骨骼-Bone-amp-关节-Joint" class="headerlink" title="8.3.4    骨骼 Bone &amp; 关节 Joint"></a>8.3.4    骨骼 Bone &amp; 关节 Joint</h3><ol>
<li>在引擎中，存储的是关节的信息</li>
<li>相邻两个关节定义一个骨骼</li>
<li>joint是严格的刚体，无法被扭曲；而bone是可以扭曲的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726103450456.png" alt="image-20230726103450456" style="zoom:80%;" /></p>
<h3 id="8-3-5-游戏中的关节"><a href="#8-3-5-游戏中的关节" class="headerlink" title="8.3.5    游戏中的关节"></a>8.3.5    游戏中的关节</h3><ol>
<li>通常会添加一些额外的骨骼，用于控制角色的面部表情、衣物等附加物</li>
<li>武器、骑乘等都会有对应的关节，用于绑定外部物品</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726103902491.png" alt="image-20230726103902491" style="zoom:80%;" /></p>
<h3 id="8-3-6-根骨骼"><a href="#8-3-6-根骨骼" class="headerlink" title="8.3.6    根骨骼"></a>8.3.6    根骨骼</h3><ol>
<li>通常会放置于两脚之间，便于表示离地高度、移速等属性</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104007356.png" alt="image-20230726104007356" style="zoom:80%;" /></p>
<ol>
<li>四足动物的Pelvis在尾椎处，而root在肚子下四足中心</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104125333.png" alt="image-20230726104125333" style="zoom:80%;" /></p>
<h3 id="8-3-7-绑定动画"><a href="#8-3-7-绑定动画" class="headerlink" title="8.3.7    绑定动画"></a>8.3.7    绑定动画</h3><ol>
<li>当人物骑乘在马身上时，两者的bind point就会绑定到一起<ol>
<li>不仅仅是位置的绑定，还有旋转的绑定</li>
</ol>
</li>
<li>两者分别播放自己的动画</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104219332.png" alt="image-20230726104219332" style="zoom:80%;" /></p>
<h3 id="8-3-8-绑定姿势：T-pose-vs-A-pose"><a href="#8-3-8-绑定姿势：T-pose-vs-A-pose" class="headerlink" title="8.3.8    绑定姿势：T-pose vs A-pose"></a>8.3.8    绑定姿势：T-pose vs A-pose</h3><p>T-pose：肩胛处的骨骼是压缩的，精度不够</p>
<p>A-pose：人相对自然的站在那里，肩胛处的精度会更高</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104519860.png" alt="image-20230726104519860" style="zoom:80%;" /></p>
<h3 id="8-3-9-骨骼姿势"><a href="#8-3-9-骨骼姿势" class="headerlink" title="8.3.9    骨骼姿势"></a>8.3.9    骨骼姿势</h3><p>关节姿势有9个自由度：平移、旋转、缩放</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104647937.png" alt="image-20230726104647937" style="zoom:80%;" /></p>
<h2 id="8-4-3D旋转的数学原理"><a href="#8-4-3D旋转的数学原理" class="headerlink" title="8.4    3D旋转的数学原理"></a>8.4    3D旋转的数学原理</h2><h3 id="8-4-1-2D空间的旋转"><a href="#8-4-1-2D空间的旋转" class="headerlink" title="8.4.1    2D空间的旋转"></a>8.4.1    2D空间的旋转</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726104902602.png" alt="image-20230726104902602" style="zoom:80%;" /></p>
<h3 id="8-4-2-3D空间的旋转：欧拉角"><a href="#8-4-2-3D空间的旋转：欧拉角" class="headerlink" title="8.4.2    3D空间的旋转：欧拉角"></a>8.4.2    3D空间的旋转：欧拉角</h3><h4 id="8-4-2-1-旋转矩阵"><a href="#8-4-2-1-旋转矩阵" class="headerlink" title="8.4.2.1    旋转矩阵"></a>8.4.2.1    旋转矩阵</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105052981.png" alt="image-20230726105052981" style="zoom:80%;" /></p>
<h4 id="8-4-2-2-Yaw-amp-Pitch-amp-Roll"><a href="#8-4-2-2-Yaw-amp-Pitch-amp-Roll" class="headerlink" title="8.4.2.2    Yaw &amp; Pitch &amp; Roll"></a>8.4.2.2    Yaw &amp; Pitch &amp; Roll</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105207538.png" alt="image-20230726105207538" style="zoom:80%;" /></p>
<h4 id="8-4-2-3-问题：欧拉角的运算是严格依赖顺序的"><a href="#8-4-2-3-问题：欧拉角的运算是严格依赖顺序的" class="headerlink" title="8.4.2.3    问题：欧拉角的运算是严格依赖顺序的"></a>8.4.2.3    问题：欧拉角的运算是严格依赖顺序的</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105341930.png" alt="image-20230726105341930" style="zoom:80%;" /></p>
<h4 id="8-4-2-4-万向锁：Gimbal-lock"><a href="#8-4-2-4-万向锁：Gimbal-lock" class="headerlink" title="8.4.2.4    万向锁：Gimbal lock"></a>8.4.2.4    万向锁：Gimbal lock</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105432867.png" alt="image-20230726105432867" style="zoom:80%;" /></p>
<h4 id="8-4-2-5-欧拉角的退化现象：β-90°"><a href="#8-4-2-5-欧拉角的退化现象：β-90°" class="headerlink" title="8.4.2.5    欧拉角的退化现象：β=90°"></a>8.4.2.5    欧拉角的退化现象：β=90°</h4><p>当β=90°时，α和γ各自都没有意义，只有α-γ有意义，此时最终的DoF变为了1</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105811316.png" alt="image-20230726105811316" style="zoom:80%;" /></p>
<h4 id="8-4-2-6-欧拉角的问题"><a href="#8-4-2-6-欧拉角的问题" class="headerlink" title="8.4.2.6    欧拉角的问题"></a>8.4.2.6    欧拉角的问题</h4><ol>
<li>万向锁</li>
<li>难以插值</li>
<li>难以进行旋转的叠加，必须通过旋转矩阵相乘</li>
<li>难以进行任意轴旋转，必须将其分解为XYZ轴的旋转</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726105951500.png" alt="image-20230726105951500" style="zoom:80%;" /></p>
<h3 id="8-4-3-四元数-Quaternion"><a href="#8-4-3-四元数-Quaternion" class="headerlink" title="8.4.3    四元数 Quaternion"></a>8.4.3    四元数 Quaternion</h3><h4 id="8-4-3-1-用复数表示2D旋转"><a href="#8-4-3-1-用复数表示2D旋转" class="headerlink" title="8.4.3.1    用复数表示2D旋转"></a>8.4.3.1    用复数表示2D旋转</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726110321992.png" alt="image-20230726110321992" style="zoom:80%;" /></p>
<h4 id="8-4-3-2-四元数的定义"><a href="#8-4-3-2-四元数的定义" class="headerlink" title="8.4.3.2    四元数的定义"></a>8.4.3.2    四元数的定义</h4><p>定义：$q=a+bi+cj+dk \ (a,b,c,d\in R)$，其中 $i^2=j^2=k^2=ijk=-1$</p>
<p>性质：单位四元数的共轭，就是它的逆</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726115007887.png" alt="image-20230726115007887" style="zoom:80%;" /></p>
<h4 id="8-4-3-3-欧拉角-gt-四元数"><a href="#8-4-3-3-欧拉角-gt-四元数" class="headerlink" title="8.4.3.3    欧拉角 =&gt; 四元数"></a>8.4.3.3    欧拉角 =&gt; 四元数</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726111111068.png" alt="image-20230726111111068" style="zoom:80%;" /></p>
<h4 id="8-4-3-4-用四元数表示旋转"><a href="#8-4-3-4-用四元数表示旋转" class="headerlink" title="8.4.3.4    用四元数表示旋转"></a>8.4.3.4    用四元数表示旋转</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726114919429.png" alt="image-20230726114919429" style="zoom: 67%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726115156359.png" alt="image-20230726115156359" style="zoom: 60%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726115332722.png" alt="image-20230726115332722" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726140131693.png" alt="image-20230726140131693" style="zoom:80%;" /></p>
<h2 id="8-5-关节与蒙皮"><a href="#8-5-关节与蒙皮" class="headerlink" title="8.5    关节与蒙皮"></a>8.5    关节与蒙皮</h2><h3 id="8-5-1-三种数据：旋转、平移、缩放"><a href="#8-5-1-三种数据：旋转、平移、缩放" class="headerlink" title="8.5.1    三种数据：旋转、平移、缩放"></a>8.5.1    三种数据：旋转、平移、缩放</h3><ol>
<li><p>Orientation 空间上的朝向</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726140531917.png" alt="image-20230726140531917" style="zoom:80%;" /></p>
</li>
<li><p>Position</p>
<ol>
<li>通常是不变的</li>
<li>但是当角色蹲下时，是通过pelvis相对于root的位置变换表示的</li>
<li>表情动画也会用到位置变换</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726140846380.png" alt="image-20230726140846380" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141023444.png" alt="image-20230726141023444" style="zoom:80%;" /></p>
</li>
<li><p>Scale：缩放变换</p>
<ol>
<li>通常也不会变</li>
<li>但是在更改角色面部关节时，可能会改变</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141049396.png" alt="image-20230726141049396" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141102714.png" alt="image-20230726141102714" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="8-5-2-Affine-Matrix-仿射矩阵"><a href="#8-5-2-Affine-Matrix-仿射矩阵" class="headerlink" title="8.5.2    Affine Matrix 仿射矩阵"></a>8.5.2    Affine Matrix 仿射矩阵</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141216420.png" alt="image-20230726141216420" style="zoom:80%;" /></p>
<h2 id="8-5-3-局部空间-gt-模型空间"><a href="#8-5-3-局部空间-gt-模型空间" class="headerlink" title="8.5.3    局部空间 =&gt; 模型空间"></a>8.5.3    局部空间 =&gt; 模型空间</h2><p>对于每一个关节$j$：</p>
<ol>
<li>$p(j)$：父关节</li>
<li>$M_{p(j)}^l$：父关节在局部空间的关节姿势</li>
<li>$M_j^m$：关节在模型空间的关节姿势</li>
</ol>
<script type="math/tex; mode=display">
M_j^m=\prod_{j=J}^0 M_{p(j)}^l</script><p>即从当前节点开始，逐步乘父节点的关节姿势，直到到达根节点</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141439188.png" alt="image-20230726141439188" style="zoom:80%;" /></p>
<h3 id="8-5-4-关节姿势的插值：局部空间-vs-模型空间"><a href="#8-5-4-关节姿势的插值：局部空间-vs-模型空间" class="headerlink" title="8.5.4    关节姿势的插值：局部空间 vs 模型空间"></a>8.5.4    关节姿势的插值：局部空间 vs 模型空间</h3><p>将动画存储在局部坐标系</p>
<ol>
<li>transform中的数据更少</li>
<li>更容易进行插值/混合</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726141729580.png" alt="image-20230726141729580" style="zoom:80%;" /></p>
<h3 id="8-5-5-Single-Joint-Skin"><a href="#8-5-5-Single-Joint-Skin" class="headerlink" title="8.5.5    Single Joint Skin"></a>8.5.5    Single Joint Skin</h3><h4 id="8-5-5-1-顶点相对于关节的局部坐标永远不变"><a href="#8-5-5-1-顶点相对于关节的局部坐标永远不变" class="headerlink" title="8.5.5.1    顶点相对于关节的局部坐标永远不变"></a>8.5.5.1    顶点相对于关节的局部坐标永远不变</h4><p>将mesh上的一个顶点，绑定到一个骨骼上</p>
<ol>
<li>每个顶点可以绑定一个或多个关节，每个关节有不同的权重</li>
<li>顶点在每个绑定关节的局部空间的位置是固定的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726142238716.png" alt="image-20230726142238716" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726143414912.png" alt="image-20230726143414912" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726143513171.png" alt="image-20230726143513171" style="zoom:80%;" /></p>
<h4 id="8-5-5-2-Skinning-Matrix-Palette"><a href="#8-5-5-2-Skinning-Matrix-Palette" class="headerlink" title="8.5.5.2    Skinning Matrix Palette"></a>8.5.5.2    Skinning Matrix Palette</h4><ol>
<li>先计算每一个关节的Skinning Matrix，保存起来</li>
<li>在渲染顶点的时候，可以直接查表，不用重新计算蒙皮矩阵</li>
</ol>
<p>优化：通常会再乘上$M^w$，将模型空间转化为世界空间</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726143715728.png" alt="image-20230726143715728" style="zoom:80%;" /></p>
<h4 id="8-5-5-3-在内存中表示一个骨骼"><a href="#8-5-5-3-在内存中表示一个骨骼" class="headerlink" title="8.5.5.3    在内存中表示一个骨骼"></a>8.5.5.3    在内存中表示一个骨骼</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726144203453.png" alt="image-20230726144203453" style="zoom:80%;" /></p>
<h3 id="8-5-6-Weighted-Skinning-with-Multi-joints"><a href="#8-5-6-Weighted-Skinning-with-Multi-joints" class="headerlink" title="8.5.6    Weighted Skinning with Multi-joints"></a>8.5.6    Weighted Skinning with Multi-joints</h3><ol>
<li>每个mesh上的顶点会由多个关节同时作用</li>
<li>每个关节有不同的权重，但是要求权重和为1</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726144503596.png" alt="image-20230726144503596" style="zoom:80%;" /></p>
<ol>
<li>计算每个关节对应的顶点的模型空间坐标，在模型空间中进行混合</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726144939033.png" alt="image-20230726144939033" style="zoom:80%;" /></p>
<h3 id="8-5-7-Clip"><a href="#8-5-7-Clip" class="headerlink" title="8.5.7    Clip"></a>8.5.7    Clip</h3><p>将每一帧的骨骼姿势放在一个序列里面，称为一个clip</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726145536660.png" alt="image-20230726145536660" style="zoom:80%;" /></p>
<h3 id="8-5-8-在不同Pose之间进行插值"><a href="#8-5-8-在不同Pose之间进行插值" class="headerlink" title="8.5.8    在不同Pose之间进行插值"></a>8.5.8    在不同Pose之间进行插值</h3><p><strong>位移&amp;缩放 lerp</strong>：线性插值</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726145711201.png" alt="image-20230726145711201" style="zoom:80%;" /></p>
<p><strong>旋转 Nlerp</strong>：q1和q2的线性插值，然后进行归一化</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726145736080.png" alt="image-20230726145736080" style="zoom:80%;" /></p>
<p><strong>最短路径插值</strong>：判断一下q1·q2，如果是&lt;0，则需要反向插值</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726150409999.png" alt="image-20230726150409999" style="zoom:80%;" /></p>
<p><strong>Nlerp的问题</strong>：插值的角速度不恒定</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726150653720.png" alt="image-20230726150653720" style="zoom:80%;" /></p>
<p><strong>Slerp</strong>：通过arccos，计算两个方向的夹角，通过θ插值</p>
<ol>
<li>但是计算比较费资源</li>
<li>并且当角度很小时，结果不精确</li>
<li>通常会指定一个角度，小于它用NLERP，大于它用SLERP</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726150718402.png" alt="image-20230726150718402" style="zoom:80%;" /></p>
<h3 id="8-5-9-简单动画的Runtime-Pipeline"><a href="#8-5-9-简单动画的Runtime-Pipeline" class="headerlink" title="8.5.9    简单动画的Runtime Pipeline"></a>8.5.9    简单动画的Runtime Pipeline</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726151230438.png" alt="image-20230726151230438" style="zoom:80%;" /></p>
<h2 id="8-6-动画压缩技术"><a href="#8-6-动画压缩技术" class="headerlink" title="8.6    动画压缩技术"></a>8.6    动画压缩技术</h2><h3 id="8-6-1-减少DoF"><a href="#8-6-1-减少DoF" class="headerlink" title="8.6.1    减少DoF"></a>8.6.1    减少DoF</h3><ol>
<li><p>Scale：直接忽略</p>
</li>
<li><p>Translation：只存储最初的值</p>
</li>
<li><p>Rotation：通过关键帧进行插值</p>
<ol>
<li>以第0帧作为第一个关键帧，通过插值计算下一帧</li>
<li>如果误差高于某个值，则将其作为下一个关键帧</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726151745711.png" alt="image-20230726151745711" style="zoom:80%;" /></p>
</li>
<li><p>Catmull-Rom曲线：</p>
<ol>
<li>由四个控制点生成一个曲线，拟合原有的旋转曲线</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726151936487.png" alt="image-20230726151936487" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152053696.png" alt="image-20230726152053696" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="8-6-2-用定点数代替float"><a href="#8-6-2-用定点数代替float" class="headerlink" title="8.6.2    用定点数代替float"></a>8.6.2    用定点数代替float</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152215646.png" alt="image-20230726152215646" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152341008.png" alt="image-20230726152341008" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152358663.png" alt="image-20230726152358663" style="zoom:80%;" /></p>
<h3 id="8-6-3-误差传播"><a href="#8-6-3-误差传播" class="headerlink" title="8.6.3    误差传播"></a>8.6.3    误差传播</h3><p>由于关节的模型坐标是从根节点累乘得到的，因此会导致误差的累积</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152529422.png" alt="image-20230726152529422" style="zoom:80%;" /></p>
<p>衡量精确度：Visual Error</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152700328.png" alt="image-20230726152700328" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726152726472.png" alt="image-20230726152726472" style="zoom:80%;" /></p>
<p>误差补偿：子骨骼对父骨骼产生的误差进行补偿</p>
<ol>
<li>缺点：父骨骼的误差叠加后，可能在子骨骼上产生高频数据，导致末端骨骼产生高频抖动</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153005119.png" alt="image-20230726153005119" style="zoom:80%;" /></p>
<h2 id="8-7-动画制作流程"><a href="#8-7-动画制作流程" class="headerlink" title="8.7    动画制作流程"></a>8.7    动画制作流程</h2><ol>
<li><p>构建mesh，用低精度的mesh做动画</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153201327.png" alt="image-20230726153201327" style="zoom:80%;" /></p>
</li>
<li><p>在关节处添加网格，防止关节处变形</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153255760.png" alt="image-20230726153255760" style="zoom:80%;" /></p>
</li>
<li><p>骨架绑定，并添加Game Play关节（如武器关节、Pelvis、root）</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153358233.png" alt="image-20230726153358233" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153421687.png" alt="image-20230726153421687" style="zoom:80%;" /></p>
</li>
<li><p>自动计算skinning</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153522586.png" alt="image-20230726153522586" style="zoom:80%;" /></p>
</li>
<li><p>手动调整skinning</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153553479.png" alt="image-20230726153553479" style="zoom:80%;" /></p>
</li>
<li><p>制作动画：设置关键帧及时间间隔</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153629247.png" alt="image-20230726153629247" style="zoom:80%;" /></p>
</li>
<li><p>导出动画</p>
<ol>
<li>如果在动画中root产生位移，会将root的移动单独导出为一个位移曲线给引擎用</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153644960.png" alt="image-20230726153644960" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726153828377.png" alt="image-20230726153828377" style="zoom:80%;" /></p>
</li>
</ol>
<h1 id="九、动画：动画树、IK、表情动画"><a href="#九、动画：动画树、IK、表情动画" class="headerlink" title="九、动画：动画树、IK、表情动画"></a>九、动画：动画树、IK、表情动画</h1><h2 id="9-1-动画混合：LERP"><a href="#9-1-动画混合：LERP" class="headerlink" title="9.1    动画混合：LERP"></a>9.1    动画混合：LERP</h2><p>在不同动画内，各取一帧，进行插值</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726161349832.png" alt="image-20230726161349832" style="zoom:80%;" /></p>
<h3 id="9-1-1-计算混合权重"><a href="#9-1-1-计算混合权重" class="headerlink" title="9.1.1    计算混合权重"></a>9.1.1    计算混合权重</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726161520179.png" alt="image-20230726161520179" style="zoom:80%;" /></p>
<h3 id="9-1-2-对齐混合时间线"><a href="#9-1-2-对齐混合时间线" class="headerlink" title="9.1.2    对齐混合时间线"></a>9.1.2    对齐混合时间线</h3><ol>
<li>将动画的时间归一化<ol>
<li>对于走和跑的两个动画，保证：0-没有动，0.25-抬左脚，0.5-放左脚，0.75-抬右脚，1.0-放右脚</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726161637220.png" alt="image-20230726161637220" style="zoom:80%;" /></p>
<h2 id="9-2-混合空间"><a href="#9-2-混合空间" class="headerlink" title="9.2    混合空间"></a>9.2    混合空间</h2><h3 id="9-2-1-1D混合空间"><a href="#9-2-1-1D混合空间" class="headerlink" title="9.2.1    1D混合空间"></a>9.2.1    1D混合空间</h3><ol>
<li>可以有多个动画，通过一个变量进行混合</li>
<li>并且动画切换的密度也不一定是均匀的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726162032131.png" alt="image-20230726162032131" style="zoom:80%;" /></p>
<h3 id="9-2-2-2D混合空间"><a href="#9-2-2-2D混合空间" class="headerlink" title="9.2.2    2D混合空间"></a>9.2.2    2D混合空间</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726162328115.png" alt="image-20230726162328115" style="zoom:80%;" /></p>
<ol>
<li>Delaunay三角化：根据给定的多个顶点，生成空间的三角形划分</li>
<li>根据速度&amp;方向两个值，确定二维空间上的唯一点，选择临近的三个动画，通过重心坐标的方法进行插值</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726162413212.png" alt="image-20230726162413212" style="zoom:80%;" /></p>
<h3 id="9-2-3-Skeleton-Masked-Blending"><a href="#9-2-3-Skeleton-Masked-Blending" class="headerlink" title="9.2.3    Skeleton Masked Blending"></a>9.2.3    Skeleton Masked Blending</h3><p>通过mask，控制动画影响的关节</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726162907137.png" alt="image-20230726162907137" style="zoom:80%;" /></p>
<h3 id="9-2-4-Additive-Blending"><a href="#9-2-4-Additive-Blending" class="headerlink" title="9.2.4    Additive Blending"></a>9.2.4    Additive Blending</h3><p>动画只影响局部关节，且只保留变化量，在原有骨骼之上添加额外的transform</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726163020077.png" alt="image-20230726163020077" style="zoom:80%;" /></p>
<p>叠加动画可能回调导致非正常的骨骼结果</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726163239755.png" alt="image-20230726163239755" style="zoom:80%;" /></p>
<h2 id="9-3-动画状态机-ASM-Animation-State-Machine"><a href="#9-3-动画状态机-ASM-Animation-State-Machine" class="headerlink" title="9.3    动画状态机 ASM Animation State Machine"></a>9.3    动画状态机 ASM Animation State Machine</h2><h3 id="9-3-1-ASM的定义"><a href="#9-3-1-ASM的定义" class="headerlink" title="9.3.1    ASM的定义"></a>9.3.1    ASM的定义</h3><p>ASM的节点：</p>
<ol>
<li>可以是一个动画，也可以是混合空间，还可以是动画树</li>
<li>要求节点的产出必须是一个pose</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726163706843.png" alt="image-20230726163706843" style="zoom:80%;" /></p>
<p>状态过渡：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726163926818.png" alt="image-20230726163926818" style="zoom:80%;" /></p>
<p>状态过渡时的Fade：</p>
<ol>
<li>Smooth Transition：两个动画进行插值</li>
<li>Frozen Transition：上一个动画停止，下一个动画逐步进入</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164019587.png" alt="image-20230726164019587" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164219218.png" alt="image-20230726164219218" style="zoom:80%;" /></p>
<h3 id="9-3-2-Layered-ASM"><a href="#9-3-2-Layered-ASM" class="headerlink" title="9.3.2    Layered ASM"></a>9.3.2    Layered ASM</h3><p>分为不同层，控制角色的不同部分</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164525801.png" alt="image-20230726164525801" style="zoom:80%;" /></p>
<h2 id="9-4-动画混合树"><a href="#9-4-动画混合树" class="headerlink" title="9.4    动画混合树"></a>9.4    动画混合树</h2><h3 id="9-4-1-混合树"><a href="#9-4-1-混合树" class="headerlink" title="9.4.1    混合树"></a>9.4.1    混合树</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164757665.png" alt="image-20230726164757665" style="zoom:80%;" /></p>
<h3 id="9-4-2-混合节点"><a href="#9-4-2-混合节点" class="headerlink" title="9.4.2    混合节点"></a>9.4.2    混合节点</h3><h4 id="9-4-2-1-LERP混合节点"><a href="#9-4-2-1-LERP混合节点" class="headerlink" title="9.4.2.1    LERP混合节点"></a>9.4.2.1    LERP混合节点</h4><p>二通道插值：一个权重，控制两者比例</p>
<p>多通道插值：通常需要自己定义动画各自的比例</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164820353.png" alt="image-20230726164820353" style="zoom:80%;" /></p>
<h4 id="9-4-2-2-Additive混合节点"><a href="#9-4-2-2-Additive混合节点" class="headerlink" title="9.4.2.2    Additive混合节点"></a>9.4.2.2    Additive混合节点</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726164944591.png" alt="image-20230726164944591" style="zoom:80%;" /></p>
<h4 id="9-4-2-3-混合树节点"><a href="#9-4-2-3-混合树节点" class="headerlink" title="9.4.2.3    混合树节点"></a>9.4.2.3    混合树节点</h4><p>叶节点：动画、混合空间、动画状态机</p>
<p>中间节点：LERP混合节点、Additive混合节点</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726165138287.png" alt="image-20230726165138287" style="zoom:80%;" /></p>
<h3 id="9-4-3-混合树控制参数"><a href="#9-4-3-混合树控制参数" class="headerlink" title="9.4.3    混合树控制参数"></a>9.4.3    混合树控制参数</h3><ol>
<li>混合树上要暴露大量的控制参数，由Game Play控制不同节点的混合、状态机</li>
<li>可以通过事件控制参数的改变</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726165450780.png" alt="image-20230726165450780" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726165816283.png" alt="image-20230726165816283" style="zoom:80%;" /></p>
<h2 id="9-5-IK技术"><a href="#9-5-IK技术" class="headerlink" title="9.5    IK技术"></a>9.5    IK技术</h2><h3 id="9-5-1-基本概念"><a href="#9-5-1-基本概念" class="headerlink" title="9.5.1    基本概念"></a>9.5.1    基本概念</h3><p>End-Effector：希望被移动到目标位置的末端关节</p>
<p>IK：给定end-effecto的期望位置，反向求解骨骼的变换</p>
<p>FK：给定骨骼的变化，计算end-effector的位置</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726170138434.png" alt="image-20230726170138434" style="zoom:80%;" /></p>
<h3 id="9-5-2-Two-Bones-IK"><a href="#9-5-2-Two-Bones-IK" class="headerlink" title="9.5.2    Two Bones IK"></a>9.5.2    Two Bones IK</h3><ol>
<li>大腿和小腿两根骨头 =&gt; 三角形的两条边</li>
<li>脚的位置/地面的位置 =&gt; 目标点</li>
<li>大腿根部到目标点的距离 =&gt; 三角形的第三条边</li>
</ol>
<p>根据三角形的三条边边长，可以唯一确定一个三角形，从而求解出大腿、小腿各自的旋转</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726170422401.png" alt="image-20230726170422401" style="zoom:80%;" /></p>
<p>上述算法解出的实际上是一个圆环</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726170647922.png" alt="image-20230726170647922" style="zoom:80%;" /></p>
<p>通过额外给定一个reference vector，确定是圆环上的哪个点</p>
<ol>
<li>通过reference vector、大腿和目标点的连线，确定一个平面</li>
<li>平面与圆环求交，得到两个交点</li>
<li>通过向量点乘，确定哪个点是正向的，哪个点是反向的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726170731090.png" alt="image-20230726170731090" style="zoom:80%;" /></p>
<h3 id="9-5-3-多关节IK计算"><a href="#9-5-3-多关节IK计算" class="headerlink" title="9.5.3    多关节IK计算"></a>9.5.3    多关节IK计算</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726171113977.png" alt="image-20230726171113977" style="zoom:80%;" /></p>
<h4 id="9-5-3-1-可达性判断"><a href="#9-5-3-1-可达性判断" class="headerlink" title="9.5.3.1    可达性判断"></a>9.5.3.1    可达性判断</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726171154553.png" alt="image-20230726171154553" style="zoom:80%;" /></p>
<h4 id="9-5-3-2-关节约束"><a href="#9-5-3-2-关节约束" class="headerlink" title="9.5.3.2    关节约束"></a>9.5.3.2    关节约束</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726171245185.png" alt="image-20230726171245185" style="zoom:80%;" /></p>
<h4 id="9-5-3-3-CCD：Cyclic-Coordinate-Decent"><a href="#9-5-3-3-CCD：Cyclic-Coordinate-Decent" class="headerlink" title="9.5.3.3    CCD：Cyclic Coordinate Decent"></a>9.5.3.3    CCD：Cyclic Coordinate Decent</h4><ol>
<li>将最末端的关节，向上一个关节与目标点的连线方向旋转，逐步旋转所有关节</li>
<li>重复上述步骤，直到每一次旋转几乎不变</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726171715760.png" alt="image-20230726171715760" style="zoom:80%;" /></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172025542.png" alt="image-20230726172025542" style="zoom: 50%;" /></th>
<th style="text-align:center"><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172049462.png" alt="image-20230726172049462" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="9-5-3-4-优化CCD"><a href="#9-5-3-4-优化CCD" class="headerlink" title="9.5.3.4    优化CCD"></a>9.5.3.4    优化CCD</h4><ol>
<li>旋转时不需要要求骨骼一定要到达目标位置，只需要到达一个范围即可 or 设置旋转角度上限</li>
<li>每次迭代逐渐缩小范围</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172307179.png" alt="image-20230726172307179" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172453544.png" alt="image-20230726172453544" style="zoom:80%;" /></p>
<h4 id="9-5-3-5-FABRIK：Forward-And-Backward-Reaching-IK"><a href="#9-5-3-5-FABRIK：Forward-And-Backward-Reaching-IK" class="headerlink" title="9.5.3.5    FABRIK：Forward And Backward Reaching IK"></a>9.5.3.5    FABRIK：Forward And Backward Reaching IK</h4><p>Forward：</p>
<ol>
<li>从End-Effector开始，把第一个关节强行拉到目标点</li>
<li>根据上一个关节点的原有位置，与当前关节点连一条线，将骨骼旋转到连线上</li>
<li>骨骼的另一端即为下一个关键点的目标位置</li>
<li>重复上述步骤，直到根节点为止</li>
<li>此时会由于凑关键点位置，导致根节点移动，需要通过Backward解决</li>
</ol>
<p>Backward：</p>
<ol>
<li>从根节点开始，将根节点拉回到原点</li>
<li>依次移动对应骨骼和另一端的关节点，直到拉到End-Effector</li>
</ol>
<p>重复Forward和Backward，直到End-Effector非常接近目标点</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726172950697.png" alt="image-20230726172950697" style="zoom:80%;" /></p>
<p>骨骼约束：将目标点投影到约束的平面，得到新的目标点，然后再移动骨骼</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726173401688.png" alt="image-20230726173401688" style="zoom:80%;" /></p>
<h3 id="9-5-4-多End-Effectors"><a href="#9-5-4-多End-Effectors" class="headerlink" title="9.5.4    多End-Effectors"></a>9.5.4    多End-Effectors</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726173555467.png" alt="image-20230726173555467" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726173636640.png" alt="image-20230726173636640" style="zoom:80%;" /></p>
<h4 id="9-5-4-1-Jacobian-Matrix"><a href="#9-5-4-1-Jacobian-Matrix" class="headerlink" title="9.5.4.1    Jacobian Matrix"></a>9.5.4.1    Jacobian Matrix</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726173727183.png" alt="image-20230726173727183" style="zoom:80%;" /></p>
<p>通过雅可比矩阵，逐步逼近目标点</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726174159735.png" alt="image-20230726174159735" style="zoom:80%;" /></p>
<h3 id="9-5-5-其他IK解法"><a href="#9-5-5-其他IK解法" class="headerlink" title="9.5.5    其他IK解法"></a>9.5.5    其他IK解法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726174332161.png" alt="image-20230726174332161" style="zoom:80%;" /></p>
<h3 id="9-5-6-IK的问题"><a href="#9-5-6-IK的问题" class="headerlink" title="9.5.6    IK的问题"></a>9.5.6    IK的问题</h3><ol>
<li>IK会认为骨骼是没有体积的，从而导致解出的骨骼由穿插</li>
<li>IK无法预测环境</li>
<li>IK解出的解不考虑平衡重心等问题</li>
</ol>
<h3 id="9-5-7-添加IK之后的动画Pipeline"><a href="#9-5-7-添加IK之后的动画Pipeline" class="headerlink" title="9.5.7    添加IK之后的动画Pipeline"></a>9.5.7    添加IK之后的动画Pipeline</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726174830356.png" alt="image-20230726174830356" style="zoom:80%;" /></p>
<h2 id="9-6-面部动画"><a href="#9-6-面部动画" class="headerlink" title="9.6    面部动画"></a>9.6    面部动画</h2><h3 id="9-6-1-表情由复杂的肌肉系统驱动"><a href="#9-6-1-表情由复杂的肌肉系统驱动" class="headerlink" title="9.6.1    表情由复杂的肌肉系统驱动"></a>9.6.1    表情由复杂的肌肉系统驱动</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175017486.png" alt="image-20230726175017486" style="zoom:80%;" /></p>
<h3 id="9-6-2-面部动作编码系统-FACS"><a href="#9-6-2-面部动作编码系统-FACS" class="headerlink" title="9.6.2    面部动作编码系统 FACS"></a>9.6.2    面部动作编码系统 FACS</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175211494.png" alt="image-20230726175211494" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175311165.png" alt="image-20230726175311165" style="zoom:80%;" /></p>
<h3 id="9-6-3-28个核心AU"><a href="#9-6-3-28个核心AU" class="headerlink" title="9.6.3    28个核心AU"></a>9.6.3    28个核心AU</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175719857.png" alt="image-20230726175719857" style="zoom:80%;" /></p>
<h3 id="9-6-4-关键姿势混合"><a href="#9-6-4-关键姿势混合" class="headerlink" title="9.6.4    关键姿势混合"></a>9.6.4    关键姿势混合</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175742143.png" alt="image-20230726175742143" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175818590.png" alt="image-20230726175818590" style="zoom:80%;" /></p>
<p>实际存储的是某一个表情对应中性表情的offset</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230726175907342.png" alt="image-20230726175907342" style="zoom:80%;" /></p>
<h3 id="9-6-5-UV-Texture-Facial-Animation"><a href="#9-6-5-UV-Texture-Facial-Animation" class="headerlink" title="9.6.5    UV Texture Facial Animation"></a>9.6.5    UV Texture Facial Animation</h3><p>用纹理表达面部表情</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727100531316.png" alt="image-20230727100531316" style="zoom:80%;" /></p>
<h3 id="9-6-6-Muscle-Model-Animation"><a href="#9-6-6-Muscle-Model-Animation" class="headerlink" title="9.6.6    Muscle Model Animation"></a>9.6.6    Muscle Model Animation</h3><p>通过46个实际肌肉控制面部运动</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727100640384.png" alt="image-20230727100640384" style="zoom:80%;" /></p>
<h2 id="9-7-动画重定向"><a href="#9-7-动画重定向" class="headerlink" title="9.7    动画重定向"></a>9.7    动画重定向</h2><h3 id="9-7-1-相关术语-Terminology"><a href="#9-7-1-相关术语-Terminology" class="headerlink" title="9.7.1    相关术语 Terminology"></a>9.7.1    相关术语 Terminology</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101019327.png" alt="image-20230727101019327" style="zoom:80%;" /></p>
<h3 id="9-7-2-重定向的方法"><a href="#9-7-2-重定向的方法" class="headerlink" title="9.7.2    重定向的方法"></a>9.7.2    重定向的方法</h3><ol>
<li><p>骨骼一根对一根，忽略位移项</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101219102.png" alt="image-20230727101219102" style="zoom:80%;" /></p>
</li>
<li><p>应用每一帧相对binding pose的位移，而不是绝对值</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101307534.png" alt="image-20230727101307534" style="zoom:80%;" /></p>
</li>
<li><p>把source character的</p>
<ol>
<li>旋转动画：直接应用到target character上</li>
<li>平移动画：考虑骨骼的相对长度，等比例放缩</li>
<li>缩放动画：直接应用到target character上</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101506030.png" alt="image-20230727101506030" style="zoom:80%;" /></p>
</li>
<li><p>通过Pelvis高度对齐运动</p>
<ol>
<li>通过最初的腰眼离地的距离，等比例缩放运动速度</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101720649.png" alt="image-20230727101720649" style="zoom:80%;" /></p>
</li>
<li><p>重定向之后，通过IK将脚锁死在地上</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727101938145.png" alt="image-20230727101938145" style="zoom:80%;" /></p>
</li>
<li><p>通常是使用离线算法，进行重定向的计算</p>
</li>
</ol>
<h3 id="9-7-3-不同骨骼结构之间的重定向"><a href="#9-7-3-不同骨骼结构之间的重定向" class="headerlink" title="9.7.3    不同骨骼结构之间的重定向"></a>9.7.3    不同骨骼结构之间的重定向</h3><ol>
<li>找到不同骨骼结构之间，对应的骨骼</li>
<li>将骨骼归一化到[0, 1]之间，然后进行插值</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727102206721.png" alt="image-20230727102206721" style="zoom:80%;" /></p>
<h3 id="9-7-4-未解决的问题"><a href="#9-7-4-未解决的问题" class="headerlink" title="9.7.4    未解决的问题"></a>9.7.4    未解决的问题</h3><ol>
<li>骨骼穿插问题</li>
<li>由于骨骼大小不一样，导致的效果不佳，如鼓掌等语义动作</li>
<li>目标角色的平衡</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727102448557.png" alt="image-20230727102448557" style="zoom:80%;" /></p>
<h3 id="9-7-5-Morph-Animation重定向"><a href="#9-7-5-Morph-Animation重定向" class="headerlink" title="9.7.5    Morph Animation重定向"></a>9.7.5    Morph Animation重定向</h3><ol>
<li>不同face使用相同的拓扑结构</li>
<li>存储顶点的相对位移</li>
<li>应用重定向后，强制将某些顶点移动到目标位置，然后用拉普拉斯算子计算剩下的顶点</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727102755696.png" alt="image-20230727102755696" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727102852037.png" alt="image-20230727102852037" style="zoom:80%;" /></p>
<h1 id="十、物理：基础理论和算法"><a href="#十、物理：基础理论和算法" class="headerlink" title="十、物理：基础理论和算法"></a>十、物理：基础理论和算法</h1><h2 id="10-1-物理对象与形状"><a href="#10-1-物理对象与形状" class="headerlink" title="10.1    物理对象与形状"></a>10.1    物理对象与形状</h2><h3 id="10-1-1-Actor"><a href="#10-1-1-Actor" class="headerlink" title="10.1.1    Actor"></a>10.1.1    Actor</h3><ol>
<li>static actor：静态物体，不移动，不用解算</li>
<li>dynamic actor：动态物体，每一帧都需要计算其状态</li>
<li>trigger：触发器，和物理世界没有关系</li>
<li>kinematic actor：运动学物体，无视物理规则，直接由游戏逻辑控制</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727110520872.png" alt="image-20230727110520872" style="zoom:80%;" /></p>
<h3 id="10-1-2-Actor-Shapes"><a href="#10-1-2-Actor-Shapes" class="headerlink" title="10.1.2    Actor Shapes"></a>10.1.2    Actor Shapes</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727110718269.png" alt="image-20230727110718269" style="zoom:80%;" /></p>
<h3 id="10-1-3-Shape属性"><a href="#10-1-3-Shape属性" class="headerlink" title="10.1.3    Shape属性"></a>10.1.3    Shape属性</h3><p>质量 Mass &amp; 密度 Density</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727111612952.png" alt="image-20230727111612952" style="zoom:80%;" /></p>
<p>质心 Center of Mass</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727111727898.png" alt="image-20230727111727898" style="zoom:80%;" /></p>
<p>物理材质：摩擦系数 Friction、弹性系数 Restitution</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727111749362.png" alt="image-20230727111749362" style="zoom:80%;" /></p>
<h2 id="10-2-力与运动"><a href="#10-2-力与运动" class="headerlink" title="10.2    力与运动"></a>10.2    力与运动</h2><h3 id="10-2-1-力的种类"><a href="#10-2-1-力的种类" class="headerlink" title="10.2.1    力的种类"></a>10.2.1    力的种类</h3><p>Force：有一定持续时间的力，如重力、拉力、摩擦力</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727114748641.png" alt="image-20230727114748641" style="zoom:80%;" /></p>
<p>Impulse：冲量</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727114857546.png" alt="image-20230727114857546" style="zoom:80%;" /></p>
<h3 id="10-2-2-移动"><a href="#10-2-2-移动" class="headerlink" title="10.2.2    移动"></a>10.2.2    移动</h3><p>显式欧拉法：用当前的力&amp;速度计算位移</p>
<ol>
<li>优点：容易计算</li>
<li>缺点：能量不守恒</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727143630198.png" alt="image-20230727143630198" style="zoom:80%;" /></p>
<p>隐式欧拉法：用未来的力&amp;速度计算位移</p>
<ol>
<li>优点：能量会衰减，从而保证计算是稳定的，衰减很小时可以被视为转化为热能</li>
<li>缺点：如果力是取决于位置的，那么在位置不确定的情况下，无法知道未来的力</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727143510570.png" alt="image-20230727143510570" style="zoom:80%;" /></p>
<p>半隐式欧拉法：用当前的力、未来的速度计算位移</p>
<ol>
<li>优点：更加稳定，并且容易计算</li>
<li>缺点：积分出来的周期会比实际的周期长一点，导致有一定的相位差</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727144235099.png" alt="image-20230727144235099" style="zoom:80%;" /></p>
<h2 id="10-3-刚体动力学"><a href="#10-3-刚体动力学" class="headerlink" title="10.3    刚体动力学"></a>10.3    刚体动力学</h2><h3 id="10-3-1-质点动力学"><a href="#10-3-1-质点动力学" class="headerlink" title="10.3.1    质点动力学"></a>10.3.1    质点动力学</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727144551982.png" alt="image-20230727144551982" style="zoom:80%;" /></p>
<h3 id="10-3-2-基础概念"><a href="#10-3-2-基础概念" class="headerlink" title="10.3.2    基础概念"></a>10.3.2    基础概念</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727144854761.png" alt="image-20230727144854761" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727145512765.png" alt="image-20230727145512765" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727145535306.png" alt="image-20230727145535306" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727145737642.png" alt="image-20230727145737642" style="zoom: 80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727145758977.png" alt="image-20230727145758977" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727150006906.png" alt="image-20230727150006906" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727150041602.png" alt="image-20230727150041602" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727150231290.png" alt="image-20230727150231290" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727150318355.png" alt="image-20230727150318355" style="zoom:80%;" /></p>
<h2 id="10-4-碰撞检测"><a href="#10-4-碰撞检测" class="headerlink" title="10.4    碰撞检测"></a>10.4    碰撞检测</h2><h3 id="10-4-1-两个阶段"><a href="#10-4-1-两个阶段" class="headerlink" title="10.4.1    两个阶段"></a>10.4.1    两个阶段</h3><ol>
<li>Broad Phase：使用AABB包围盒，快速筛除一些不会碰撞的物体</li>
<li>Narrow Phase：精确判断是否能够碰撞，生成碰撞信息</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151246689.png" alt="image-20230727151246689" style="zoom:80%;" /></p>
<h3 id="10-4-2-Broad-Phase"><a href="#10-4-2-Broad-Phase" class="headerlink" title="10.4.2    Broad Phase"></a>10.4.2    Broad Phase</h3><h4 id="10-4-2-1-BVH树"><a href="#10-4-2-1-BVH树" class="headerlink" title="10.4.2.1    BVH树"></a>10.4.2.1    BVH树</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151333377.png" alt="image-20230727151333377" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151359255.png" alt="image-20230727151359255" style="zoom:80%;" /></p>
<h4 id="10-4-2-2-Sort-and-Sweep"><a href="#10-4-2-2-Sort-and-Sweep" class="headerlink" title="10.4.2.2    Sort and Sweep"></a>10.4.2.2    Sort and Sweep</h4><p>对于AABB包围盒来说：</p>
<ol>
<li>将每个包围盒按照x轴上的两个边界排序</li>
<li>如果在轴上分离，则一定无法碰撞</li>
<li>如果在轴上交错，则可能碰撞，此时计算y轴是否交错</li>
<li>只有两个轴上都交错，才会碰撞</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151415157.png" alt="image-20230727151415157" style="zoom:80%;" /></p>
<p>更新时：</p>
<ol>
<li>相当于在一个已经排好序的数组中，更新某个数的位置，效率很高</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727151708077.png" alt="image-20230727151708077" style="zoom:80%;" /></p>
<h3 id="10-4-3-Narrow-Phase"><a href="#10-4-3-Narrow-Phase" class="headerlink" title="10.4.3    Narrow Phase"></a>10.4.3    Narrow Phase</h3><ol>
<li>准确检测碰撞</li>
<li>生成碰撞信息<ol>
<li>碰撞采样：生成碰撞点的集合</li>
<li>碰撞法线</li>
<li>穿透深度</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727171236961.png" alt="image-20230727171236961" style="zoom:80%;" /></p>
<h4 id="10-4-3-1-基础图形碰撞检测"><a href="#10-4-3-1-基础图形碰撞检测" class="headerlink" title="10.4.3.1    基础图形碰撞检测"></a>10.4.3.1    基础图形碰撞检测</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727172955545.png" alt="image-20230727172955545" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727173031040.png" alt="image-20230727173031040" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727175222136.png" alt="image-20230727175222136" style="zoom:80%;" /></p>
<h4 id="10-4-3-2-Minkowski算法"><a href="#10-4-3-2-Minkowski算法" class="headerlink" title="10.4.3.2    Minkowski算法"></a>10.4.3.2    Minkowski算法</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230727175329180.png" alt="image-20230727175329180" style="zoom:80%;" /></p>
<h1 id="十八、网络游戏的架构基础"><a href="#十八、网络游戏的架构基础" class="headerlink" title="十八、网络游戏的架构基础"></a>十八、网络游戏的架构基础</h1><h2 id="18-1-同步算法"><a href="#18-1-同步算法" class="headerlink" title="18.1    同步算法"></a>18.1    同步算法</h2><h3 id="18-1-1-快照同步Snapshot"><a href="#18-1-1-快照同步Snapshot" class="headerlink" title="18.1.1    快照同步Snapshot"></a>18.1.1    快照同步Snapshot</h3><blockquote>
<p>如Quake</p>
</blockquote>
<ol>
<li>步骤：<ol>
<li>客户端：把<strong>输入</strong>发送给服务器</li>
<li>服务器：将所有客户的输入集合起来，在服务器中进行<strong>游戏世界的模拟</strong>，然后将<strong>游戏世界的状态</strong>生成<strong>快照</strong>返回给客户端</li>
<li>客户端：拿到服务器给的快照后，将所有对象设置为对应的状态，然后进行<strong>渲染</strong></li>
</ol>
</li>
<li>优点：<ol>
<li>结构清晰，保证了绝<strong>对的一致性</strong>，无法作弊</li>
<li>不用担心同步的问题</li>
<li>客户端只负责输入和最后的渲染</li>
<li>当客户端非常多时，服务器的计算量是最低的，因为只需要对世界模拟一次即可</li>
</ol>
</li>
<li>针对实际情况的改进：<ol>
<li>服务器端的帧率通常会很低，需要客户端进行插值</li>
<li>快照可能包含非常多的信息，但是相邻两帧通常差距不大，因此可以只传delta，从而降低信息量</li>
</ol>
</li>
<li>缺点：<ol>
<li>浪费了客户端的算力</li>
<li>服务器生成快照传递给每一个客户端，会占用非常大的服务器处的上行带宽</li>
</ol>
</li>
</ol>
<h3 id="18-1-2-帧同步Lockstep"><a href="#18-1-2-帧同步Lockstep" class="headerlink" title="18.1.2    帧同步Lockstep"></a>18.1.2    帧同步Lockstep</h3><blockquote>
<p>如DOOM、王者荣耀</p>
</blockquote>
<ol>
<li>步骤：<ol>
<li>每一帧：客户端把输入统一交给服务器</li>
<li>服务器等待所有服务器提交输入，然后把所有输入分发给客户端</li>
<li>客户端得到服务器的指令，做一致的游戏逻辑模拟，得到的结果一定相同</li>
<li>要求所有客户端进行初始化，初始条件必须相同</li>
</ol>
</li>
<li>针对实际情况的改进：<ol>
<li>如果有一个客户端发送输入总是很慢，就需要其他客户端等待它<ol>
<li><strong>Bucket Synchronization</strong>：每隔固定的时间收集一次信息，服务器没收到的就当没发生</li>
</ol>
</li>
</ol>
</li>
<li>缺点：<ol>
<li>一样的输入，得到的结果<strong>不一定</strong>相同，因为会有随机数、浮点数等<strong>不确定</strong>的因素<ol>
<li>浮点数：要求满足IEE754标准</li>
<li>随机数：要求随机数种子、随机数算法严格相同</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="18-1-3-状态同步State-Synchornization"><a href="#18-1-3-状态同步State-Synchornization" class="headerlink" title="18.1.3    状态同步State Synchornization"></a>18.1.3    状态同步State Synchornization</h3><blockquote>
<p>如CS</p>
</blockquote>
<ol>
<li>步骤：<ol>
<li>客户端：Authorized将命令发送给服务器(如向某个方向发射一个炮弹)</li>
<li>服务器：接收客户端的命令，模拟操作(如打中某个对象)，然后将改变的状态广播给所有客户端</li>
<li>客户端：接收服务器的对场景状态的改变，模拟出整个世界</li>
</ol>
</li>
<li>针对实际情况的改进：<ol>
<li>客户端发送指令，服务器接受指令并确返回结果，会存在延迟<ol>
<li><strong>Client-side prediction</strong>：客户端要进行预测操作，即先将客户的指令执行，然后再和服务器对齐<ol>
<li>守望先锋：预测半个RTT+一个命令帧时间</li>
</ol>
</li>
<li><strong>Server Reconciliation</strong>：预测与服务器的返回不一致时，客户端要与服务器对齐<ol>
<li>平滑的差值对齐</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="unicorn2022.github.io">华丰夏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hzoi-unicorn.top/2023/04/01/GAMES104/">https://hzoi-unicorn.top/2023/04/01/GAMES104/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hzoi-unicorn.top" target="_blank">华风夏韵</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GAMES%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B/">GAMES系列课程</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="hexo常用指令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">hexo常用指令</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" title="人工智能"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">人工智能</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/26/GAMES101/" title="GAMES101"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="title">GAMES101</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">华丰夏</div><div class="author-info__description">一切都是上天最好的安排</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/unicorn2022"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/unicorn2022" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:496300118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">愿你前行的道路有群星闪耀。愿你留下的足迹有百花绽放。你即是上帝的馈赠，世界因你而瑰丽。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%80%BB%E8%A7%88%EF%BC%9A%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%95%B4%E4%BD%93pipeline"><span class="toc-text">二、总览：引擎架构分层与整体pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%88%86%E5%B1%82%E7%AE%80%E4%BB%8B-5-1"><span class="toc-text">2.1    游戏引擎分层简介 5+1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%B5%84%E6%BA%90%E5%B1%82"><span class="toc-text">2.2    资源层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%8A%9F%E8%83%BD%E5%B1%82"><span class="toc-text">2.3    功能层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%A0%B8%E5%BF%83%E5%B1%82"><span class="toc-text">2.4    核心层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%B9%B3%E5%8F%B0%E5%B1%82"><span class="toc-text">2.5    平台层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%B7%A5%E5%85%B7%E5%B1%82"><span class="toc-text">2.6    工具层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-text">2.7    为什么要分层架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E8%A7%88%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%B8%B8%E6%88%8F%E4%B8%96%E7%95%8C"><span class="toc-text">三、总览：如何构建游戏世界</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Event%E6%9C%BA%E5%88%B6"><span class="toc-text">3.1    Event机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86"><span class="toc-text">3.2    场景管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-GO%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="toc-text">3.3    GO的绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Q-amp-A"><span class="toc-text">3.4    Q&amp;A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AAtick%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">3.4.1    如果一个tick时间过长怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E7%A9%BA%E6%B0%94%E5%A2%99%E5%92%8C%E5%85%B6%E4%BB%96GO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">3.4.2    空气墙和其他GO有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-tick%E6%97%B6%EF%BC%8C%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%80%BB%E8%BE%91%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%90%8C%E6%AD%A5"><span class="toc-text">3.4.3    tick时，渲染线程和逻辑线程怎么同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%8A%A8%E6%80%81%E7%89%A9%E4%BD%93"><span class="toc-text">3.4.4    空间划分如何处理动态物体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E7%89%A9%E7%90%86%E5%92%8C%E5%8A%A8%E7%94%BB%E7%9B%B8%E4%BA%92%E5%BD%B1%E5%93%8D%E6%97%B6%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">3.4.5    物理和动画相互影响时怎么处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B8%B2%E6%9F%93%EF%BC%9A%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5"><span class="toc-text">四、渲染：游戏引擎中的渲染实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">4.1    渲染流水线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8F%AF%E6%B8%B2%E6%9F%93%E7%89%A9%E4%BD%93-Renderable"><span class="toc-text">4.2    可渲染物体 Renderable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-Mesh-Render-Component"><span class="toc-text">4.2.1    Mesh Render Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-Renderable%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">4.2.2    Renderable的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-Mesh-Primitive"><span class="toc-text">4.2.3    Mesh Primitive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-Vertex%E5%92%8CIndex%E7%BC%93%E5%AD%98"><span class="toc-text">4.2.4    Vertex和Index缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-Mesh%E5%88%92%E5%88%86"><span class="toc-text">4.2.5    Mesh划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-Resource-Pool"><span class="toc-text">4.2.6    Resource Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-7-%E7%BB%98%E5%88%B6%E6%97%B6%E6%A0%B9%E6%8D%AE%E6%9D%90%E8%B4%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">4.2.7    绘制时根据材质排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-8-GPU-Batch-Rendering"><span class="toc-text">4.2.8    GPU Batch Rendering</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A3%81%E5%89%AA"><span class="toc-text">4.3    可见性裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E8%A3%81%E5%89%AA%E5%8D%95%E4%B8%AA%E7%89%A9%E4%BD%93"><span class="toc-text">4.3.1    裁剪单个物体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%B1%82%E6%AC%A1%E5%8C%96%E8%A7%86%E9%94%A5%E8%A3%81%E5%89%AA"><span class="toc-text">4.3.2    层次化视锥裁剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-BVH%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E6%8F%92%E5%85%A5"><span class="toc-text">4.3.3    BVH的构建和插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-PVS%EF%BC%9A%E6%BD%9C%E5%9C%A8%E5%8F%AF%E8%A7%86%E9%9B%86%E5%90%88"><span class="toc-text">4.3.4    PVS：潜在可视集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-GPU-Culling"><span class="toc-text">4.3.5    GPU Culling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9"><span class="toc-text">4.4    纹理压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%96%B0%E7%9A%84%E6%A8%A1%E5%9E%8B%E7%AE%A1%E7%BA%BF%EF%BC%9ACluster-Based-Mesh-Pipeline"><span class="toc-text">4.5    新的模型管线：Cluster-Based Mesh Pipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%80%BB%E7%BB%93"><span class="toc-text">4.5    总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%85%89%E5%92%8C%E6%9D%90%E8%B4%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E9%AD%94%E6%B3%95"><span class="toc-text">五、渲染：光和材质的数学魔法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E5%8F%8A%E6%8C%91%E6%88%98"><span class="toc-text">5.1    渲染方程及挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B"><span class="toc-text">5.1.1    渲染方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E6%8C%91%E6%88%981%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0irradiance"><span class="toc-text">5.1.2    挑战1：如何得到irradiance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-%E6%8C%91%E6%88%982%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9C%A8%E7%90%83%E9%9D%A2%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%A7%AF%E5%88%86"><span class="toc-text">5.1.4    挑战2：如何快速地在球面上进行积分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5-%E6%8C%91%E6%88%983%EF%BC%9A%E6%89%80%E6%9C%89%E7%9A%84%E7%89%A9%E4%BD%93%E9%83%BD%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%89%E6%BA%90"><span class="toc-text">5.1.5    挑战3：所有的物体都可能是光源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">5.2    基础光照解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E7%AE%80%E5%8C%96%E5%85%89%E6%BA%90%EF%BC%9AMain-Light-Ambient-Light-Environment-Map"><span class="toc-text">5.2.1    简化光源：Main Light + Ambient Light + Environment Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E7%AE%80%E5%8C%96%E7%A7%AF%E5%88%86%EF%BC%9ABlinn-Phong-%E6%9D%90%E8%B4%A8"><span class="toc-text">5.2.2    简化积分：Blinn-Phong 材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E9%98%B4%E5%BD%B1"><span class="toc-text">5.2.3    阴影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%9F%BA%E4%BA%8E%E9%A2%84%E8%AE%A1%E7%AE%97%E7%9A%84%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%88%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%EF%BC%89"><span class="toc-text">5.3    基于预计算的全局光照（空间换时间）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%85%89%E7%85%A7-%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7"><span class="toc-text">5.3.1    全局光照：直接光照+间接光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7-L-i-x-vec-omega-i"><span class="toc-text">5.3.2    如何表示间接光照$L_i(x,\vec{\omega_i})$</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-1-%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%9A"><span class="toc-text">5.3.2.1    傅里叶变换：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-2-%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%EF%BC%9A"><span class="toc-text">5.3.2.2    卷积定理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-3-%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0-Spherical-Harmonics%EF%BC%9A"><span class="toc-text">5.3.2.3    球谐函数 Spherical Harmonics：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE-Lightmap"><span class="toc-text">5.3.3    光照贴图 Lightmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E5%85%89%E7%85%A7%E6%8E%A2%E9%92%88-Light-Probe"><span class="toc-text">5.3.4    光照探针 Light Probe</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8-Physical-Based-Material-PBR"><span class="toc-text">5.4    基于物理的材质 Physical-Based Material PBR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA"><span class="toc-text">5.4.1    微平面理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E5%9F%BA%E4%BA%8E%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%9A%84BRDF%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.4.2    基于微平面的BRDF模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-Disney-Principled-BRDF"><span class="toc-text">5.4.3    Disney Principled BRDF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-PBR-Specular-Glossiness"><span class="toc-text">5.4.4    PBR Specular Glossiness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-5-PBR-Metallic-Roughness"><span class="toc-text">5.4.5    PBR Metallic Roughness</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E5%85%89%E7%85%A7%EF%BC%9AImage-Based-Lighting%EF%BC%88IBL%EF%BC%89"><span class="toc-text">5.5    基于图像的光照：Image-Based Lighting（IBL）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E7%BB%8F%E5%85%B8%E9%98%B4%E5%BD%B1%E6%96%B9%E6%B3%95"><span class="toc-text">5.6    经典阴影方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-Cascade-Shadow"><span class="toc-text">5.6.1    Cascade Shadow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-PCF"><span class="toc-text">5.6.2    PCF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-3-PCSS"><span class="toc-text">5.6.3    PCSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-4-Variance-Soft-Shadow-Map%EF%BC%88VSSM%EF%BC%89"><span class="toc-text">5.6.4    Variance Soft Shadow Map（VSSM）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E6%80%BB%E7%BB%93"><span class="toc-text">5.7    总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%9C%B0%E5%BD%A2%E3%80%81%E5%A4%A7%E6%B0%94%E3%80%81%E4%BA%91%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-text">六、渲染：地形、大气、云的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%9C%B0%E5%BD%A2%E7%9A%84%E5%87%A0%E4%BD%95"><span class="toc-text">6.1    地形的几何</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-Heightfield"><span class="toc-text">6.1.1    Heightfield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E4%B8%A4%E4%B8%AA%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-text">6.1.3    两个优化的准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E5%9F%BA%E4%BA%8E%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%89%96%E5%88%86"><span class="toc-text">6.1.4    基于三角形的剖分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-%E5%9F%BA%E4%BA%8E%E5%9B%9B%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%87%E5%88%86"><span class="toc-text">6.1.5    基于四叉树的切分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-6-%E5%9F%BA%E4%BA%8E%E4%B8%8D%E8%A7%84%E5%88%99%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%BB%98%E5%88%B6-TIN"><span class="toc-text">6.1.6    基于不规则三角形的绘制 TIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-7-%E5%9F%BA%E4%BA%8EGPU%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86-Tessellation"><span class="toc-text">6.1.7    基于GPU的曲面细分(Tessellation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-8-Real-Time-Deformable-Terrain"><span class="toc-text">6.1.8    Real-Time Deformable Terrain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-9-Non-Heightfield-Terrain"><span class="toc-text">6.1.9    Non-Heightfield Terrain</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-9-1-%E5%9C%A8Terrain%E4%B8%AD%E5%BC%80%E4%B8%80%E4%B8%AA%E6%B4%9E"><span class="toc-text">6.1.9.1    在Terrain中开一个洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-9-2-%E5%9C%B0%E5%BD%A2%E4%BD%93%E7%B4%A0%E5%8C%96%E8%A1%A8%E8%BE%BE"><span class="toc-text">6.1.9.2    地形体素化表达</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%9C%B0%E5%BD%A2%E7%9A%84%E6%9D%90%E8%B4%A8"><span class="toc-text">6.2    地形的材质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-Texture-Splatting"><span class="toc-text">6.2.1    Texture Splatting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E5%9C%A8Texture-Array%E4%B8%AD%E9%87%87%E6%A0%B7"><span class="toc-text">6.2.2    在Texture Array中采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-Displacement-Mapping"><span class="toc-text">6.2.3    Displacement Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-Expensive-Material-Blending"><span class="toc-text">6.2.4    Expensive Material Blending</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-Virtual-Texture"><span class="toc-text">6.2.5    Virtual Texture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E6%BA%A2%E5%87%BA"><span class="toc-text">6.2.6    浮点数精度溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%A4%8D%E8%A2%AB%E9%81%93%E8%B7%AF%E8%B4%B4%E8%8A%B1%E7%AD%89"><span class="toc-text">6.3    植被道路贴花等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E6%A0%91%E6%9C%A8%E6%B8%B2%E6%9F%93"><span class="toc-text">6.3.1    树木渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E8%A3%85%E9%A5%B0%E7%89%A9%E6%B8%B2%E6%9F%93-Decorator"><span class="toc-text">6.3.2    装饰物渲染 Decorator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E9%81%93%E8%B7%AF%E5%92%8C%E8%B4%B4%E7%94%BB%E6%B8%B2%E6%9F%93"><span class="toc-text">6.3.3    道路和贴画渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84%E7%90%86%E8%AE%BA"><span class="toc-text">6.4    大气散射理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-Analytic-Atmosphere-Apperance-Modeling"><span class="toc-text">6.4.1    Analytic Atmosphere Apperance Modeling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-Participating-Media"><span class="toc-text">6.4.2    Participating Media</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-%E5%85%89%E4%B8%8EParticipating-Media%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%9ARadiative-Transfer-Function-RTF"><span class="toc-text">6.4.3    光与Participating Media的交互：Radiative Transfer Function (RTF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-4-Volume-Rendering-Equation-VRE"><span class="toc-text">6.4.4    Volume Rendering Equation (VRE)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-5-%E5%A4%A7%E6%B0%94%E7%9A%84%E5%AE%9E%E9%99%85%E7%89%A9%E7%90%86"><span class="toc-text">6.4.5    大气的实际物理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-1-%E6%95%A3%E5%B0%84"><span class="toc-text">6.4.5.1    散射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-2-%E5%90%B8%E6%94%B6"><span class="toc-text">6.4.5.2    吸收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-6-%E5%8D%95%E6%AC%A1%E6%95%A3%E5%B0%84-amp-%E5%A4%9A%E6%AC%A1%E6%95%A3%E5%B0%84"><span class="toc-text">6.4.6    单次散射 &amp; 多次散射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-7-Ray-Marching"><span class="toc-text">6.4.7    Ray Marching</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%AE%9E%E6%97%B6%E5%A4%A7%E6%B0%94%E6%B8%B2%E6%9F%93"><span class="toc-text">6.5    实时大气渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-Transmittance-LUT-mu-r"><span class="toc-text">6.5.1    Transmittance LUT $(\mu,r)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-Single-Scattering-LUT-v-mu-s-mu-r"><span class="toc-text">6.5.2    Single Scattering LUT $(v,\mu_s,\mu,r)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3-%E8%AE%A1%E7%AE%97Multi-Scattering"><span class="toc-text">6.5.3    计算Multi Scattering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">6.5.4    缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-5-Production-Friendly-Quick-Sky-and-Atmosphere-Rendering"><span class="toc-text">6.5.5    Production Friendly Quick Sky and Atmosphere Rendering</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E4%BA%91%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-text">6.6    云的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E4%BA%91%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">6.6.1    云的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-Billboard-Cloud"><span class="toc-text">6.6.2    Billboard Cloud</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-Volumetric-Cloud-Modeling"><span class="toc-text">6.6.3    Volumetric Cloud Modeling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-1-Weather-Texture"><span class="toc-text">6.6.3.1    Weather Texture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-2-Noise-Function"><span class="toc-text">6.6.3.2    Noise Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-3-Cloud-Density-Model"><span class="toc-text">6.6.3.3    Cloud Density Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-4-Rendering-Cloud-by-Ray-Marching"><span class="toc-text">6.6.3.4    Rendering Cloud by Ray Marching</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B8%B2%E6%9F%93%EF%BC%9A%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E3%80%81%E5%90%8E%E5%A4%84%E7%90%86%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E5%88%87"><span class="toc-text">七、渲染：渲染管线、后处理和其他的一切</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E7%BD%A9-Ambient-Occlusion%EF%BC%9AAO"><span class="toc-text">7.1    环境光遮罩 Ambient Occlusion：AO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E9%A2%84%E8%AE%A1%E7%AE%97AO"><span class="toc-text">7.1.1    预计算AO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-SSAO%EF%BC%9AScreen-Space-Ambient-Occlusion"><span class="toc-text">7.1.2    SSAO：Screen Space Ambient Occlusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-SSAO"><span class="toc-text">7.1.3    SSAO+</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-HBAO%EF%BC%9AHorizon-Based-Ambient-Occlusion"><span class="toc-text">7.1.4    HBAO：Horizon Based Ambient Occlusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-5-GTAO%EF%BC%9AGround-Truth-based-Ambient-Occlusion"><span class="toc-text">7.1.5    GTAO：Ground Truth-based Ambient Occlusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-6-Ray-Tracing-Ambient-Occlusion"><span class="toc-text">7.1.6    Ray-Tracing Ambient Occlusion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E9%9B%BE%E6%95%88"><span class="toc-text">7.2    雾效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-Depth-Fog"><span class="toc-text">7.2.1    Depth Fog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-Height-Fog"><span class="toc-text">7.2.2    Height Fog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-Voxel-Based-Volumetric-Fog"><span class="toc-text">7.2.3    Voxel-Based Volumetric Fog</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="toc-text">7.3    抗锯齿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E9%94%AF%E9%BD%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">7.3.1    锯齿产生的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-Anti-aliasing"><span class="toc-text">7.3.2    Anti-aliasing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-SSAA-Super-sample-AA-amp-MSAA-Multi-sample-AA"><span class="toc-text">7.3.3    SSAA(Super-sample AA) &amp; MSAA(Multi-sample AA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-FXAA%EF%BC%9AFast-Approximate-Anti-Aliasing"><span class="toc-text">7.3.4    FXAA：Fast Approximate Anti-Aliasing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-5-TAA%EF%BC%9ATeamporal-Anti-Aliasing"><span class="toc-text">7.3.5    TAA：Teamporal Anti-Aliasing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%90%8E%E5%A4%84%E7%90%86"><span class="toc-text">7.4    后处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-Blooming-%E5%85%89%E6%99%95%E6%95%88%E6%9E%9C"><span class="toc-text">7.4.1    Blooming 光晕效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-Tone-Mapping"><span class="toc-text">7.4.2    Tone Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-Color-Grading"><span class="toc-text">7.4.3    Color Grading</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="toc-text">7.5    渲染管线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-Forward-Rendering"><span class="toc-text">7.5.1    Forward Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-Deffered-Rendering-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93"><span class="toc-text">7.5.2    Deffered Rendering 延迟渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3-Tile-based-Rendering"><span class="toc-text">7.5.3    Tile-based Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-4-Forward-Rendering"><span class="toc-text">7.5.4    Forward+ Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-5-Cluster-based-Rendering"><span class="toc-text">7.5.5    Cluster-based Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-6-Visibility-Buffer"><span class="toc-text">7.5.6    Visibility Buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-Frame-Graph"><span class="toc-text">7.6    Frame Graph</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-V-Sync-amp-G-Sync"><span class="toc-text">7.7    V-Sync &amp; G-Sync</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-1-Screen-Tearing-%E5%B1%8F%E5%B9%95%E6%92%95%E8%A3%82"><span class="toc-text">7.7.1    Screen Tearing 屏幕撕裂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-2-V-Sync-%E5%9E%82%E7%9B%B4%E5%90%8C%E6%AD%A5"><span class="toc-text">7.7.2    V-Sync 垂直同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%8A%A8%E7%94%BB%EF%BC%9A%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80"><span class="toc-text">八、动画：动画技术基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-2D%E6%B8%B8%E6%88%8F%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF"><span class="toc-text">8.1    2D游戏动画技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-Sprite-Animation"><span class="toc-text">8.1.1    Sprite Animation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-Live2D"><span class="toc-text">8.1.2    Live2D</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-3D%E6%B8%B8%E6%88%8F%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF"><span class="toc-text">8.2    3D游戏动画技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-DoF%EF%BC%9ADegress-of-Freedom-%E8%87%AA%E7%94%B1%E5%BA%A6"><span class="toc-text">8.2.1    DoF：Degress of Freedom 自由度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-Rigid-Hierarchical-Animation"><span class="toc-text">8.2.2    Rigid Hierarchical Animation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-Per-vertex-Animation-%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB"><span class="toc-text">8.2.3    Per-vertex Animation 顶点动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-Morph-Target-Animation"><span class="toc-text">8.2.4    Morph Target Animation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5-Skinned-Animation-%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB"><span class="toc-text">8.2.5    Skinned Animation 蒙皮动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-6-Physics-based-Animation"><span class="toc-text">8.2.6    Physics-based Animation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-7-Animation-Content-Creation"><span class="toc-text">8.2.7    Animation Content Creation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">8.3    蒙皮动画的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E5%A6%82%E4%BD%95%E8%AE%A9Mesh%E6%92%AD%E6%94%BE%E5%8A%A8%E7%94%BB"><span class="toc-text">8.3.1    如何让Mesh播放动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E4%B8%8D%E5%90%8C%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-text">8.3.2    不同的空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-%E4%B8%A4%E7%A7%8D%E9%AA%A8%E9%AA%BC"><span class="toc-text">8.3.3    两种骨骼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4-%E9%AA%A8%E9%AA%BC-Bone-amp-%E5%85%B3%E8%8A%82-Joint"><span class="toc-text">8.3.4    骨骼 Bone &amp; 关节 Joint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-5-%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%85%B3%E8%8A%82"><span class="toc-text">8.3.5    游戏中的关节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-6-%E6%A0%B9%E9%AA%A8%E9%AA%BC"><span class="toc-text">8.3.6    根骨骼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-7-%E7%BB%91%E5%AE%9A%E5%8A%A8%E7%94%BB"><span class="toc-text">8.3.7    绑定动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-8-%E7%BB%91%E5%AE%9A%E5%A7%BF%E5%8A%BF%EF%BC%9AT-pose-vs-A-pose"><span class="toc-text">8.3.8    绑定姿势：T-pose vs A-pose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-9-%E9%AA%A8%E9%AA%BC%E5%A7%BF%E5%8A%BF"><span class="toc-text">8.3.9    骨骼姿势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-3D%E6%97%8B%E8%BD%AC%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86"><span class="toc-text">8.4    3D旋转的数学原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-2D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%97%8B%E8%BD%AC"><span class="toc-text">8.4.1    2D空间的旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-3D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%97%8B%E8%BD%AC%EF%BC%9A%E6%AC%A7%E6%8B%89%E8%A7%92"><span class="toc-text">8.4.2    3D空间的旋转：欧拉角</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-1-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="toc-text">8.4.2.1    旋转矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-2-Yaw-amp-Pitch-amp-Roll"><span class="toc-text">8.4.2.2    Yaw &amp; Pitch &amp; Roll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-3-%E9%97%AE%E9%A2%98%EF%BC%9A%E6%AC%A7%E6%8B%89%E8%A7%92%E7%9A%84%E8%BF%90%E7%AE%97%E6%98%AF%E4%B8%A5%E6%A0%BC%E4%BE%9D%E8%B5%96%E9%A1%BA%E5%BA%8F%E7%9A%84"><span class="toc-text">8.4.2.3    问题：欧拉角的运算是严格依赖顺序的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-4-%E4%B8%87%E5%90%91%E9%94%81%EF%BC%9AGimbal-lock"><span class="toc-text">8.4.2.4    万向锁：Gimbal lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-5-%E6%AC%A7%E6%8B%89%E8%A7%92%E7%9A%84%E9%80%80%E5%8C%96%E7%8E%B0%E8%B1%A1%EF%BC%9A%CE%B2-90%C2%B0"><span class="toc-text">8.4.2.5    欧拉角的退化现象：β&#x3D;90°</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-6-%E6%AC%A7%E6%8B%89%E8%A7%92%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">8.4.2.6    欧拉角的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-3-%E5%9B%9B%E5%85%83%E6%95%B0-Quaternion"><span class="toc-text">8.4.3    四元数 Quaternion</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-1-%E7%94%A8%E5%A4%8D%E6%95%B0%E8%A1%A8%E7%A4%BA2D%E6%97%8B%E8%BD%AC"><span class="toc-text">8.4.3.1    用复数表示2D旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-2-%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">8.4.3.2    四元数的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-3-%E6%AC%A7%E6%8B%89%E8%A7%92-gt-%E5%9B%9B%E5%85%83%E6%95%B0"><span class="toc-text">8.4.3.3    欧拉角 &#x3D;&gt; 四元数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-4-%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%97%8B%E8%BD%AC"><span class="toc-text">8.4.3.4    用四元数表示旋转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%85%B3%E8%8A%82%E4%B8%8E%E8%92%99%E7%9A%AE"><span class="toc-text">8.5    关节与蒙皮</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1-%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%EF%BC%9A%E6%97%8B%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB%E3%80%81%E7%BC%A9%E6%94%BE"><span class="toc-text">8.5.1    三种数据：旋转、平移、缩放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-2-Affine-Matrix-%E4%BB%BF%E5%B0%84%E7%9F%A9%E9%98%B5"><span class="toc-text">8.5.2    Affine Matrix 仿射矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-3-%E5%B1%80%E9%83%A8%E7%A9%BA%E9%97%B4-gt-%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4"><span class="toc-text">8.5.3    局部空间 &#x3D;&gt; 模型空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-4-%E5%85%B3%E8%8A%82%E5%A7%BF%E5%8A%BF%E7%9A%84%E6%8F%92%E5%80%BC%EF%BC%9A%E5%B1%80%E9%83%A8%E7%A9%BA%E9%97%B4-vs-%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4"><span class="toc-text">8.5.4    关节姿势的插值：局部空间 vs 模型空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-5-Single-Joint-Skin"><span class="toc-text">8.5.5    Single Joint Skin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-5-1-%E9%A1%B6%E7%82%B9%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%B3%E8%8A%82%E7%9A%84%E5%B1%80%E9%83%A8%E5%9D%90%E6%A0%87%E6%B0%B8%E8%BF%9C%E4%B8%8D%E5%8F%98"><span class="toc-text">8.5.5.1    顶点相对于关节的局部坐标永远不变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-5-2-Skinning-Matrix-Palette"><span class="toc-text">8.5.5.2    Skinning Matrix Palette</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-5-3-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E9%AA%A8%E9%AA%BC"><span class="toc-text">8.5.5.3    在内存中表示一个骨骼</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-6-Weighted-Skinning-with-Multi-joints"><span class="toc-text">8.5.6    Weighted Skinning with Multi-joints</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-7-Clip"><span class="toc-text">8.5.7    Clip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-8-%E5%9C%A8%E4%B8%8D%E5%90%8CPose%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%80%BC"><span class="toc-text">8.5.8    在不同Pose之间进行插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-9-%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB%E7%9A%84Runtime-Pipeline"><span class="toc-text">8.5.9    简单动画的Runtime Pipeline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E5%8A%A8%E7%94%BB%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF"><span class="toc-text">8.6    动画压缩技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-1-%E5%87%8F%E5%B0%91DoF"><span class="toc-text">8.6.1    减少DoF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-2-%E7%94%A8%E5%AE%9A%E7%82%B9%E6%95%B0%E4%BB%A3%E6%9B%BFfloat"><span class="toc-text">8.6.2    用定点数代替float</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-3-%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD"><span class="toc-text">8.6.3    误差传播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">8.7    动画制作流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%8A%A8%E7%94%BB%EF%BC%9A%E5%8A%A8%E7%94%BB%E6%A0%91%E3%80%81IK%E3%80%81%E8%A1%A8%E6%83%85%E5%8A%A8%E7%94%BB"><span class="toc-text">九、动画：动画树、IK、表情动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%8A%A8%E7%94%BB%E6%B7%B7%E5%90%88%EF%BC%9ALERP"><span class="toc-text">9.1    动画混合：LERP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E8%AE%A1%E7%AE%97%E6%B7%B7%E5%90%88%E6%9D%83%E9%87%8D"><span class="toc-text">9.1.1    计算混合权重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E5%AF%B9%E9%BD%90%E6%B7%B7%E5%90%88%E6%97%B6%E9%97%B4%E7%BA%BF"><span class="toc-text">9.1.2    对齐混合时间线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4"><span class="toc-text">9.2    混合空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-1D%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4"><span class="toc-text">9.2.1    1D混合空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-2D%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4"><span class="toc-text">9.2.2    2D混合空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-Skeleton-Masked-Blending"><span class="toc-text">9.2.3    Skeleton Masked Blending</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-Additive-Blending"><span class="toc-text">9.2.4    Additive Blending</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%8A%A8%E7%94%BB%E7%8A%B6%E6%80%81%E6%9C%BA-ASM-Animation-State-Machine"><span class="toc-text">9.3    动画状态机 ASM Animation State Machine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-ASM%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">9.3.1    ASM的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-Layered-ASM"><span class="toc-text">9.3.2    Layered ASM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E5%8A%A8%E7%94%BB%E6%B7%B7%E5%90%88%E6%A0%91"><span class="toc-text">9.4    动画混合树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-1-%E6%B7%B7%E5%90%88%E6%A0%91"><span class="toc-text">9.4.1    混合树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-2-%E6%B7%B7%E5%90%88%E8%8A%82%E7%82%B9"><span class="toc-text">9.4.2    混合节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-1-LERP%E6%B7%B7%E5%90%88%E8%8A%82%E7%82%B9"><span class="toc-text">9.4.2.1    LERP混合节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-2-Additive%E6%B7%B7%E5%90%88%E8%8A%82%E7%82%B9"><span class="toc-text">9.4.2.2    Additive混合节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-3-%E6%B7%B7%E5%90%88%E6%A0%91%E8%8A%82%E7%82%B9"><span class="toc-text">9.4.2.3    混合树节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-3-%E6%B7%B7%E5%90%88%E6%A0%91%E6%8E%A7%E5%88%B6%E5%8F%82%E6%95%B0"><span class="toc-text">9.4.3    混合树控制参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-IK%E6%8A%80%E6%9C%AF"><span class="toc-text">9.5    IK技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">9.5.1    基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-2-Two-Bones-IK"><span class="toc-text">9.5.2    Two Bones IK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-3-%E5%A4%9A%E5%85%B3%E8%8A%82IK%E8%AE%A1%E7%AE%97"><span class="toc-text">9.5.3    多关节IK计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-3-1-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%A4%E6%96%AD"><span class="toc-text">9.5.3.1    可达性判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-3-2-%E5%85%B3%E8%8A%82%E7%BA%A6%E6%9D%9F"><span class="toc-text">9.5.3.2    关节约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-3-3-CCD%EF%BC%9ACyclic-Coordinate-Decent"><span class="toc-text">9.5.3.3    CCD：Cyclic Coordinate Decent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-3-4-%E4%BC%98%E5%8C%96CCD"><span class="toc-text">9.5.3.4    优化CCD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-3-5-FABRIK%EF%BC%9AForward-And-Backward-Reaching-IK"><span class="toc-text">9.5.3.5    FABRIK：Forward And Backward Reaching IK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-4-%E5%A4%9AEnd-Effectors"><span class="toc-text">9.5.4    多End-Effectors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-4-1-Jacobian-Matrix"><span class="toc-text">9.5.4.1    Jacobian Matrix</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-5-%E5%85%B6%E4%BB%96IK%E8%A7%A3%E6%B3%95"><span class="toc-text">9.5.5    其他IK解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-6-IK%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">9.5.6    IK的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-7-%E6%B7%BB%E5%8A%A0IK%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8A%A8%E7%94%BBPipeline"><span class="toc-text">9.5.7    添加IK之后的动画Pipeline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E9%9D%A2%E9%83%A8%E5%8A%A8%E7%94%BB"><span class="toc-text">9.6    面部动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-1-%E8%A1%A8%E6%83%85%E7%94%B1%E5%A4%8D%E6%9D%82%E7%9A%84%E8%82%8C%E8%82%89%E7%B3%BB%E7%BB%9F%E9%A9%B1%E5%8A%A8"><span class="toc-text">9.6.1    表情由复杂的肌肉系统驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-2-%E9%9D%A2%E9%83%A8%E5%8A%A8%E4%BD%9C%E7%BC%96%E7%A0%81%E7%B3%BB%E7%BB%9F-FACS"><span class="toc-text">9.6.2    面部动作编码系统 FACS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-3-28%E4%B8%AA%E6%A0%B8%E5%BF%83AU"><span class="toc-text">9.6.3    28个核心AU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-4-%E5%85%B3%E9%94%AE%E5%A7%BF%E5%8A%BF%E6%B7%B7%E5%90%88"><span class="toc-text">9.6.4    关键姿势混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-5-UV-Texture-Facial-Animation"><span class="toc-text">9.6.5    UV Texture Facial Animation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-6-Muscle-Model-Animation"><span class="toc-text">9.6.6    Muscle Model Animation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">9.7    动画重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-1-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD-Terminology"><span class="toc-text">9.7.1    相关术语 Terminology</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-2-%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">9.7.2    重定向的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-3-%E4%B8%8D%E5%90%8C%E9%AA%A8%E9%AA%BC%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">9.7.3    不同骨骼结构之间的重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-4-%E6%9C%AA%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">9.7.4    未解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-5-Morph-Animation%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">9.7.5    Morph Animation重定向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%89%A9%E7%90%86%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-text">十、物理：基础理论和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E7%89%A9%E7%90%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BD%A2%E7%8A%B6"><span class="toc-text">10.1    物理对象与形状</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-Actor"><span class="toc-text">10.1.1    Actor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-2-Actor-Shapes"><span class="toc-text">10.1.2    Actor Shapes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-3-Shape%E5%B1%9E%E6%80%A7"><span class="toc-text">10.1.3    Shape属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%8A%9B%E4%B8%8E%E8%BF%90%E5%8A%A8"><span class="toc-text">10.2    力与运动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-%E5%8A%9B%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">10.2.1    力的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-%E7%A7%BB%E5%8A%A8"><span class="toc-text">10.2.2    移动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%88%9A%E4%BD%93%E5%8A%A8%E5%8A%9B%E5%AD%A6"><span class="toc-text">10.3    刚体动力学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-1-%E8%B4%A8%E7%82%B9%E5%8A%A8%E5%8A%9B%E5%AD%A6"><span class="toc-text">10.3.1    质点动力学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-2-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">10.3.2    基础概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="toc-text">10.4    碰撞检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-1-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">10.4.1    两个阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-2-Broad-Phase"><span class="toc-text">10.4.2    Broad Phase</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-1-BVH%E6%A0%91"><span class="toc-text">10.4.2.1    BVH树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-2-Sort-and-Sweep"><span class="toc-text">10.4.2.2    Sort and Sweep</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-3-Narrow-Phase"><span class="toc-text">10.4.3    Narrow Phase</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3-1-%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="toc-text">10.4.3.1    基础图形碰撞检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3-2-Minkowski%E7%AE%97%E6%B3%95"><span class="toc-text">10.4.3.2    Minkowski算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AB%E3%80%81%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80"><span class="toc-text">十八、网络游戏的架构基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-%E5%90%8C%E6%AD%A5%E7%AE%97%E6%B3%95"><span class="toc-text">18.1    同步算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-1-%E5%BF%AB%E7%85%A7%E5%90%8C%E6%AD%A5Snapshot"><span class="toc-text">18.1.1    快照同步Snapshot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-2-%E5%B8%A7%E5%90%8C%E6%AD%A5Lockstep"><span class="toc-text">18.1.2    帧同步Lockstep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-3-%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5State-Synchornization"><span class="toc-text">18.1.3    状态同步State Synchornization</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/19/cmake%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/" title="cmake指令合集">cmake指令合集</a><time datetime="2023-07-19T12:19:11.000Z" title="发表于 2023-07-19 20:19:11">2023-07-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="cmake学习笔记">cmake学习笔记</a><time datetime="2023-07-15T10:00:00.000Z" title="发表于 2023-07-15 18:00:00">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="hexo常用指令">hexo常用指令</a><time datetime="2023-07-13T13:11:11.000Z" title="发表于 2023-07-13 21:11:11">2023-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/01/GAMES104/" title="GAMES104">GAMES104</a><time datetime="2023-04-01T04:49:00.000Z" title="发表于 2023-04-01 12:49:00">2023-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" title="人工智能">人工智能</a><time datetime="2023-03-01T02:00:00.000Z" title="发表于 2023-03-01 10:00:00">2023-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 华丰夏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>