<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>人工智能 | 华风夏韵</title><meta name="author" content="华丰夏"><meta name="copyright" content="华丰夏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="人工智能学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="人工智能">
<meta property="og:url" content="https://hzoi-unicorn.top/2023/03/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/index.html">
<meta property="og:site_name" content="华风夏韵">
<meta property="og:description" content="人工智能学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hzoi-unicorn.top/img/avatar.png">
<meta property="article:published_time" content="2023-03-01T02:00:00.000Z">
<meta property="article:modified_time" content="2023-07-22T11:42:21.888Z">
<meta property="article:author" content="华丰夏">
<meta property="article:tag" content="专业课">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzoi-unicorn.top/img/avatar.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/unicorn2022/Pictures/main/img/favicon.png"><link rel="canonical" href="https://hzoi-unicorn.top/2023/03/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-PpLfvQYdq5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 华丰夏","link":"链接: ","source":"来源: 华风夏韵","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '人工智能',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-07-22 19:42:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/GAMES104/"><i class="fa-fw fas fa-book"></i><span> GAMES104学习笔记</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/resources/"><i class="fa-fw fa fa-book"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-list"></i><span> 在线工具</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="华风夏韵"><span class="site-name">华风夏韵</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/GAMES104/"><i class="fa-fw fas fa-book"></i><span> GAMES104学习笔记</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/resources/"><i class="fa-fw fa fa-book"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-list"></i><span> 在线工具</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">人工智能</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-01T02:00:00.000Z" title="发表于 2023-03-01 10:00:00">2023-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-22T11:42:21.888Z" title="更新于 2023-07-22 19:42:21">2023-07-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">专业课学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>83分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="人工智能"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><script type="text/javascript"
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<h1 id="一、逻辑与推理"><a href="#一、逻辑与推理" class="headerlink" title="一、逻辑与推理"></a>一、逻辑与推理</h1><ol>
<li><strong>符号主义</strong>人工智能中，所有概念均可通过人类可理解的“符号”及符号之间的关系来表示</li>
<li><strong>符号主义</strong>人工智能方法基于如下假设：<ol>
<li>可通过逻辑方法来对符号及其关系进行计算，实现逻辑推理，辨析符号所描述内容是否正确</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308101352133.png" alt="image-20230308101352133" style="zoom:80%;" /></p>
<h2 id="1-1-命题逻辑-proposition-logic"><a href="#1-1-命题逻辑-proposition-logic" class="headerlink" title="1.1    命题逻辑 proposition logic"></a>1.1    命题逻辑 proposition logic</h2><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1    定义"></a>1.1.1    定义</h3><ol>
<li><p><strong>命题逻辑</strong>：是应用一套形式化规则对以符号表示的描述性陈述进行推理的系统</p>
</li>
<li><p><strong>原子命题</strong>：一个或真或假的描述性陈述被称为原子命题</p>
<ol>
<li>对原子命题的内部结构不做任何解析</li>
</ol>
</li>
<li><p><strong>复合命题(compound proposition)</strong>：若干原子命题可通过逻辑运算符来构成复合命题</p>
</li>
<li><p><strong>命题联结词(connectives)</strong>：通过命题联结词对已有命题进行组合，得到新命题</p>
<ol>
<li>通过命题联结词得到的命题被称为复合命题</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308103020259.png" alt="image-20230308103020259" style="zoom:80%;" /></p>
</li>
<li><p>通过<strong>真值表</strong>来计算复合命题的真假</p>
<ol>
<li><strong>p=&gt;q</strong>是一个蕴含关系，表示<strong>p∈q</strong></li>
<li>如果<strong>p=False</strong>，则<strong>p=&gt;q</strong>恒为<strong>True</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308103137719.png" alt="image-20230308103137719" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="1-1-2-逻辑等价"><a href="#1-1-2-逻辑等价" class="headerlink" title="1.1.2    逻辑等价"></a>1.1.2    逻辑等价</h3><ol>
<li><strong>逻辑等价：</strong>给定命题p和命题q，如果p和q在所有情况下都具有同样真假结果，那么p和q在逻辑上等价，即<strong>p≡q</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308103501121.png" alt="image-20230308103501121" style="zoom:80%;" /></p>
<h3 id="1-1-3-推理规则"><a href="#1-1-3-推理规则" class="headerlink" title="1.1.3    推理规则"></a>1.1.3    推理规则</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308104140298.png" alt="image-20230308104140298" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308104247799.png" alt="image-20230308104247799" style="zoom:80%;" /></p>
<blockquote>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308105126317.png" alt="image-20230308105126317" style="zoom:80%;" /></p>
</blockquote>
<h3 id="1-1-4-命题范式"><a href="#1-1-4-命题范式" class="headerlink" title="1.1.4    命题范式"></a>1.1.4    命题范式</h3><p><strong>范式（normal form)</strong>：把命题公式化归为一种标准的形式</p>
<ol>
<li><p>范式最大的作用是可以进行两个命题的等价判定</p>
</li>
<li><p><strong>析取范式</strong>：有限个简单合取式构成的析取式</p>
</li>
<li><p><strong>合取范式</strong>：有限个简单析取式构成的合取式</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308105600298.png" alt="image-20230308105600298" style="zoom:80%;" /></p>
</li>
<li><p>一个析取范式是不成立的，当且仅当：它的每个简单合取式都不成立</p>
</li>
<li><p>一个合取范式是成立的，当且仅当：它的每个简单析取式都是成立的</p>
</li>
<li><p>任一命题公式都存在着与之等值的析取范式与合取范式</p>
<ol>
<li>注意：命题公式的析取范式与合取范式都不是唯一的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308105751140.png" alt="image-20230308105751140" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="1-2-谓词逻辑"><a href="#1-2-谓词逻辑" class="headerlink" title="1.2    谓词逻辑"></a>1.2    谓词逻辑</h2><h3 id="1-2-1-个体与谓词"><a href="#1-2-1-个体与谓词" class="headerlink" title="1.2.1    个体与谓词"></a>1.2.1    个体与谓词</h3><ol>
<li><p><strong>个体</strong>：个体是指所研究领域中可以独立存在的具体或抽象的概念</p>
</li>
<li><p><strong>谓词</strong>：谓词是用来刻画个体属性或者描述个体之间关系存在性的元素，其值为真或为假</p>
<ol>
<li>包含一个参数的谓词称为<strong>一元谓词</strong>，表示一元关系</li>
<li>包含多个参数的谓词称为<strong>多元谓词</strong>，表示个体之间的多元关系</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308110626463.png" alt="image-20230308110626463" style="zoom:80%;" /></p>
</li>
<li><p>函数与谓词的区别：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308111153776.png" alt="image-20230308111153776" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="1-2-2-量词"><a href="#1-2-2-量词" class="headerlink" title="1.2.2    量词"></a>1.2.2    量词</h3><ol>
<li><strong>全称量词</strong>(universal quantifier, <strong>∀</strong>)：<strong>∀xP(x)</strong>表示定义域中的所有个体具有性质P</li>
<li><strong>存在量词</strong>(existential quantifier, <strong>∃</strong>)：<strong>∃xP(x)</strong>表示定义域中存在一个个体或若干个体具有性质P</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308111508713.png" alt="image-20230308111508713" style="zoom:80%;" /></p>
<h3 id="1-2-3-变元"><a href="#1-2-3-变元" class="headerlink" title="1.2.3    变元"></a>1.2.3    变元</h3><ol>
<li><p><strong>约束变元</strong>：在全称量词或存在量词的约束条件下的变量符号称为约束变元</p>
</li>
<li><p><strong>自由变元</strong>：不受全称量词或存在量词约束的变量符号称为自由变元</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308111625830.png" alt="image-20230308111625830" style="zoom:80%;" /></p>
</li>
<li><p>在约束变元相同的情况下，量词的运算满足<strong>分配律</strong></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308112024333.png" alt="image-20230308112024333" style="zoom:80%;" /></p>
</li>
<li><p>当公式中存在多个量词时，若多个量词都是全称量词或者都是存在量词，则量词的位置可以互换；若多个量词中既有全称量词又有存在量词，则量词的位置不可以随意互换</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308112056373.png" alt="image-20230308112056373" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="1-2-4-项与原子谓词公式"><a href="#1-2-4-项与原子谓词公式" class="headerlink" title="1.2.4    项与原子谓词公式"></a>1.2.4    项与原子谓词公式</h3><ol>
<li>项：项是描述对象的逻辑表达式，被递归地定义为：<ol>
<li>常量符号和变量符号是项；</li>
<li>若$f(x_1,x_2,⋯,x_n)$是$n$元函数符号，$t_1,t_2,⋯,t_n$是项，则$f(t_1,t_2,⋯,t_n)$是项；</li>
<li>有限次数地使用上述规则产生的符号串是项。</li>
</ol>
</li>
<li>原子谓词公式：<ol>
<li>若$P(x_1,x_2,⋯,x_n)$是$n$元谓词，$t_1,t_2,⋯,t_n$是项，则称$P(t_1,t_2,⋯,t_n)$是原子谓词公式，简称原子公式</li>
</ol>
</li>
</ol>
<h3 id="1-2-5-合式公式"><a href="#1-2-5-合式公式" class="headerlink" title="1.2.5    合式公式"></a>1.2.5    合式公式</h3><p>合式公式是由<strong>逻辑联结词</strong>和<strong>原子公式</strong>构成的用于陈述事实的复杂语句，又称<strong>谓词公式</strong>，由以下规则定义：</p>
<ol>
<li>命题常项、命题变项、原子谓词公式是合式公式</li>
<li>如果A是合式公式，则¬A也是合式公式</li>
<li>如果A和B是合式公式，则A∧B、A∨B、A→B 、B→A、A⟷B 都是合式公式</li>
<li>如果A是合式公式，x是个体变项，则(∃x)A(x) 和(∀x)A(x)也是合式公式</li>
<li>有限次数地使用上述规则构成的表达式是合式公式</li>
</ol>
<h3 id="1-2-6-推理规则"><a href="#1-2-6-推理规则" class="headerlink" title="1.2.6    推理规则"></a>1.2.6    推理规则</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308112437690.png" alt="image-20230308112437690" style="zoom:80%;" /></p>
<h3 id="1-2-7-专家系统的构成"><a href="#1-2-7-专家系统的构成" class="headerlink" title="1.2.7    专家系统的构成"></a>1.2.7    专家系统的构成</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308113530071.png" alt="image-20230308113530071" style="zoom:80%;" /></p>
<h2 id="1-3-知识图谱"><a href="#1-3-知识图谱" class="headerlink" title="1.3    知识图谱"></a>1.3    知识图谱</h2><h3 id="1-3-1-基本概念"><a href="#1-3-1-基本概念" class="headerlink" title="1.3.1    基本概念"></a>1.3.1    基本概念</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308114245048.png" alt="image-20230308114245048" style="zoom: 80%;" /></p>
<ol>
<li><strong>知识图谱</strong>可视为包含多种关系的图<ol>
<li>在图中，每个<strong>节点</strong>是一个实体（如人名、地名、事件和活动等）</li>
<li>任意两个节点之间的<strong>边</strong>表示这两个节点之间存在的关系</li>
<li>一般而言，可将知识图谱中<strong>任意两个相连节点及其连接边</strong>表示成一个三元组（triplet）, 即 <strong>(left_node, relation, right_node)</strong></li>
</ol>
</li>
<li>知识图谱中存在连线的两个实体可表达为形如<strong><left_node, relation, right_node ></strong>的三元组形式<ol>
<li>这种三元组也可以表示为一阶逻辑<strong>(first order logic, FOL)</strong>的形式，从而为基于知识图谱的推理创造了条件</li>
<li>例如从&lt;奥巴马，出生地，夏威夷&gt;和&lt;夏威夷，属于，美国&gt;两个三元组，可推理得到&lt;奥巴马，国籍，美国&gt;</li>
</ol>
</li>
</ol>
<h3 id="1-3-2-知识图谱推理"><a href="#1-3-2-知识图谱推理" class="headerlink" title="1.3.2    知识图谱推理"></a>1.3.2    知识图谱推理</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308114752378.png" alt="image-20230308114752378" style="zoom:80%;" /></p>
<ol>
<li>可利用<strong>一阶谓词</strong>来表达刻画知识图谱中节点之间存在的关系<ol>
<li>如图中形如<James,Couple,David>的关系可用一阶逻辑的形式来描述，即Couple(James, David)</li>
<li>Couple(x, y)是一阶谓词，Couple是图中实体之间具有的关系，x和y是谓词变量</li>
<li>从图中已有关系可推知David和Ann具有父女关系，但这一关系在图中初始图(无红线)中并不存在，是需要推理的目标</li>
</ol>
</li>
</ol>
<h3 id="1-3-3-归纳学习"><a href="#1-3-3-归纳学习" class="headerlink" title="1.3.3    归纳学习"></a>1.3.3    归纳学习</h3><ol>
<li><strong>归纳逻辑程序设计ILP</strong>(Inductive Logic Programming)：是机器学习和逻辑程序设计交叉领域的研究内容</li>
<li>ILP使用一阶谓词逻辑进行知识表示，通过修改和扩充逻辑表达式对现有知识归纳，完成推理任务</li>
<li>作为ILP的代表性方法，<strong>FOIL</strong>(First Order Inductive Learner)通过<strong>序贯覆盖</strong>实现规则推理</li>
</ol>
<h3 id="1-3-4-一阶推导学习-FOIL"><a href="#1-3-4-一阶推导学习-FOIL" class="headerlink" title="1.3.4    一阶推导学习 FOIL"></a>1.3.4    一阶推导学习 FOIL</h3><blockquote>
<p><strong>FOIL</strong>：First Order Inductive Learner</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308121022320.png" alt="image-20230308121022320" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308121146128.png" alt="image-20230308121146128" style="zoom:80%;" /></p>
<ol>
<li><p><strong>目标谓词：</strong><code>Father(x, y)</code></p>
</li>
<li><p><strong>正例</strong>：目标谓词只有一个正例<code>Father(David, Mike)</code>。</p>
</li>
<li><p><strong>反例</strong>：在知识图谱中一般不会显式给出，但可从知识图谱中构造出来</p>
<ol>
<li>如从知识图谱中已经知道<code>Couple(David, James)</code>成立，则<code>Father(David, James)</code>可作为目标谓词P的一个反例，记为<code>¬Father (David, James)</code>。</li>
<li>只能在已知两个实体的关系且确定其关系与目标谓词相悖时，才能将这两个实体用于构建目标谓词的反例</li>
<li>而不能在不知两个实体是否满足目标谓词前提下将它们来构造目标谓词的反例</li>
</ol>
</li>
<li><p><strong>背景知识</strong>：知识图谱中目标谓词以外的其他谓词实例化结果，如<code>Sibling(Ann, Mike)</code></p>
</li>
<li><p><strong>推理思路：</strong>从一般到特殊，逐步给目标谓词添加前提约束谓词，直到所构成的推理规则<strong>不覆盖任何反例</strong></p>
<ol>
<li><strong>从一般到特殊</strong>：对目标谓词或前提约束谓词中的变量赋予具体值</li>
<li>如将<code>(∀x)(∀y)(∀z)(Mother(z, y)∧Couple(x,z) → Father(x, y))</code>这一推理规则所包含的目标谓词<code>Father(x, y)</code>中<code>x</code>和<code>y</code>分别赋值为<code>David</code>和<code>Ann</code>，进而进行推理</li>
</ol>
</li>
<li><p>如何选择约束谓词：<strong>信息增益值最大</strong></p>
<ol>
<li>要求添加该谓词后，可以覆盖的正例更多，负例更少</li>
<li>直到只覆盖正例，不覆盖负例</li>
</ol>
</li>
<li><p><strong>信息增益值：描述了添加某个谓词后，$\frac{正例}{正例+反例}$的比例变化</strong></p>
<script type="math/tex; mode=display">
FOIL\_Gain=\hat{m_+}(\log_2\frac{\hat{m_+}}{\hat{m_+}+\hat{m_-}}-\log_2\frac{m_+}{m_++m_-})</script></li>
</ol>
<p>   <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308115343756.png" alt="image-20230308115343756" style="zoom:80%;" /></p>
<blockquote>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308115624013.png" alt="image-20230308115624013" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308115903721.png" alt="image-20230308115903721" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120227606.png" alt="image-20230308120227606" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120240453.png" alt="image-20230308120240453" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120259169.png" alt="image-20230308120259169" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120313852.png" alt="image-20230308120313852" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120348725.png" alt="image-20230308120348725" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120452139.png" alt="image-20230308120452139" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230308120757276.png" alt="image-20230308120757276" style="zoom:80%;" /></p>
</blockquote>
<h3 id="1-3-5-路径排序推理-PRA"><a href="#1-3-5-路径排序推理-PRA" class="headerlink" title="1.3.5    路径排序推理 PRA"></a>1.3.5    路径排序推理 PRA</h3><blockquote>
<p><strong>Path Ranking Algorithm</strong></p>
</blockquote>
<ol>
<li><strong>基本思想：将实体之间的关联路径作为特征，来学习目标关系的分类器</strong></li>
<li>工作流程主要分为三步：<ol>
<li><strong>特征抽取</strong>：生成并选择路径特征集合<ol>
<li>生成路径的方式有：随机游走、广度优先搜索、深度优先搜索等</li>
</ol>
</li>
<li><strong>特征计算</strong>：计算每个训练样例的特征值$𝑃(𝑠→𝑡;𝜋_𝑗)$<ol>
<li>该特征值可以是：从实体节点$𝑠$出发，通过关系路径$𝜋_𝑗$到达实体节点$𝑡$的概率；</li>
<li>也可以是：<strong>布尔值，表示实体$𝑠$到实体$𝑡$之间是否存在路径$𝜋_𝑗$；</strong></li>
<li>还可以是：实体$𝑠$和实体$𝑡$之间路径出现频次、频率等</li>
</ol>
</li>
<li><strong>分类器训练</strong>：根据训练样例的特征值，为目标关系训练分类器<ol>
<li>当训练好分类器后，即可将该分类器用于推理两个实体之间是否存在目标关系</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>特征向量的含义：布尔值，表示实体$𝑠$到实体$𝑡$之间是否存在路径$𝜋_𝑗$；</p>
<ol>
<li>[Couple→Mother，Father→Mother^-1^，Mother→Sibling，Couple→Father]</li>
</ol>
<p>如(David, Ann)：只可以通过Couple→Mother这条路径链接，因此特征向量是[1, 0, 0, 0]</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315102434738.png" alt="image-20230315102434738" style="zoom:80%;" /></p>
<h3 id="1-3-6-基于分布式的知识推理"><a href="#1-3-6-基于分布式的知识推理" class="headerlink" title="1.3.6    基于分布式的知识推理"></a>1.3.6    基于分布式的知识推理</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315102756553.png" alt="image-20230315102756553" style="zoom:80%;" /></p>
<h3 id="1-3-7-马尔可夫逻辑网络"><a href="#1-3-7-马尔可夫逻辑网络" class="headerlink" title="1.3.7    马尔可夫逻辑网络"></a>1.3.7    马尔可夫逻辑网络</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315102819660.png" alt="image-20230315102819660" style="zoom:80%;" /></p>
<h2 id="不考-1-4-因果推理"><a href="#不考-1-4-因果推理" class="headerlink" title="(不考)1.4    因果推理"></a>(不考)1.4    因果推理</h2><ol>
<li><p>传统以统计建模为核心的推理手段：AI学习联合分布的概率</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315103929751.png" alt="image-20230315103929751" style="zoom:80%;" /></p>
</li>
<li><p>因果推理：改变控制变量的取值后，会导致结果如何变化</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315104033233.png" alt="image-20230315104033233" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="不考-1-4-1-三种因果推理"><a href="#不考-1-4-1-三种因果推理" class="headerlink" title="(不考)1.4.1    三种因果推理"></a>(不考)1.4.1    三种因果推理</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315105108127.png" alt="image-20230315105108127" style="zoom:80%;" /></p>
<h3 id="不考-1-4-2-因果推理的主要模型"><a href="#不考-1-4-2-因果推理的主要模型" class="headerlink" title="(不考)1.4.2    因果推理的主要模型"></a>(不考)1.4.2    因果推理的主要模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315105456694.png" alt="image-20230315105456694" style="zoom:80%;" /></p>
<h3 id="不考-1-4-3-结构因果模型"><a href="#不考-1-4-3-结构因果模型" class="headerlink" title="(不考)1.4.3    结构因果模型"></a>(不考)1.4.3    结构因果模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110036244.png" alt="image-20230315110036244" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315105725408.png" alt="image-20230315105725408" style="zoom:80%;" /></p>
<h2 id="不考-1-5-因果图模型"><a href="#不考-1-5-因果图模型" class="headerlink" title="(不考)1.5    因果图模型"></a>(不考)1.5    因果图模型</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110335591.png" alt="image-20230315110335591" style="zoom:80%;" /></p>
<h3 id="不考-1-5-1-联合概率分布"><a href="#不考-1-5-1-联合概率分布" class="headerlink" title="(不考)1.5.1    联合概率分布"></a>(不考)1.5.1    联合概率分布</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110202244.png" alt="image-20230315110202244" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110432875.png" alt="image-20230315110432875" style="zoom:80%;" /></p>
<h3 id="不考-1-5-2-链"><a href="#不考-1-5-2-链" class="headerlink" title="(不考)1.5.2    链"></a>(不考)1.5.2    链</h3><blockquote>
<p><strong>中间节点$Z$一旦给定，两端的节点$X,Y$条件独立</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315110902668.png" alt="image-20230315110902668" style="zoom:80%;" /></p>
<h3 id="不考-1-5-3-分连"><a href="#不考-1-5-3-分连" class="headerlink" title="(不考)1.5.3    分连"></a>(不考)1.5.3    分连</h3><blockquote>
<p><strong>中间节点$Z$一旦给定，两端的节点$X,Y$条件独立</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315111057252.png" alt="image-20230315111057252" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315111105731.png" alt="image-20230315111105731" style="zoom:80%;" /></p>
<h3 id="不考-1-5-4-汇连"><a href="#不考-1-5-4-汇连" class="headerlink" title="(不考)1.5.4    汇连"></a>(不考)1.5.4    汇连</h3><blockquote>
<p><strong>中间节点$Z$给定时，两端的节点$X,Y$条件相关</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315111519449.png" alt="image-20230315111519449" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315111527551.png" alt="image-20230315111527551" style="zoom:80%;" /></p>
<h3 id="不考-1-5-5-D-分离"><a href="#不考-1-5-5-D-分离" class="headerlink" title="(不考)1.5.5    D-分离"></a>(不考)1.5.5    D-分离</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315112208471.png" alt="image-20230315112208471" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315112216700.png" alt="image-20230315112216700" style="zoom:80%;" /></p>
<h3 id="不考-1-5-6-干预的因果效应"><a href="#不考-1-5-6-干预的因果效应" class="headerlink" title="(不考)1.5.6    干预的因果效应"></a>(不考)1.5.6    干预的因果效应</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315112519863.png" alt="image-20230315112519863" style="zoom:80%;" /></p>
<h3 id="不考-1-5-7-因果效应差"><a href="#不考-1-5-7-因果效应差" class="headerlink" title="(不考)1.5.7    因果效应差"></a>(不考)1.5.7    因果效应差</h3><blockquote>
<p>因果效应差越大，表示该变量对结果的因果效应越大</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315112809443.png" alt="image-20230315112809443" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315113312157.png" alt="image-20230315113312157" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315113138273.png" alt="image-20230315113138273" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315113700564.png" alt="image-20230315113700564" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315113745900.png" alt="image-20230315113745900" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114236896.png" alt="image-20230315114236896" style="zoom:80%;" /></p>
<h3 id="不考-1-5-8-反事实模型"><a href="#不考-1-5-8-反事实模型" class="headerlink" title="(不考)1.5.8    反事实模型"></a>(不考)1.5.8    反事实模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114453721.png" alt="image-20230315114453721" style="zoom:80%;" /></p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114501042.png" alt="image-20230315114501042" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114507047.png" alt="image-20230315114507047" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114515725.png" alt="image-20230315114515725" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114522281.png" alt="image-20230315114522281" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114533679.png" alt="image-20230315114533679" style="zoom:80%;" /></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114651422.png" alt="image-20230315114651422" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114705326.png" alt="image-20230315114705326" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315114716032.png" alt="image-20230315114716032" style="zoom:80%;" /></p>
<h1 id="二、搜索与求解"><a href="#二、搜索与求解" class="headerlink" title="二、搜索与求解"></a>二、搜索与求解</h1><h2 id="2-1-搜索算法基础"><a href="#2-1-搜索算法基础" class="headerlink" title="2.1    搜索算法基础"></a>2.1    搜索算法基础</h2><h3 id="2-1-1-搜索算法的形式化描述"><a href="#2-1-1-搜索算法的形式化描述" class="headerlink" title="2.1.1    搜索算法的形式化描述"></a>2.1.1    搜索算法的形式化描述</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619174409045.png" alt="image-20230619174409045" style="zoom:80%;" /></p>
<ol>
<li><strong>状态</strong>：对智能体和环境当前情形的描述<ol>
<li>例如，在最短路径问题中，城市可作为状态</li>
<li>将原问题城市对应的状态称为初始状态</li>
</ol>
</li>
<li><strong>动作</strong>：从当前时刻所处状态转移到下一时刻所处状态所进行操作<ol>
<li>一般而言这些操作都是离散的</li>
</ol>
</li>
<li><strong>状态转移</strong>：智能体选择了一个动作之后，其所处状态的相应变化</li>
<li><strong>路径/代价</strong>：一个状态序列。该状态序列被一系列操作所连接<ol>
<li>如从A到K所形成的路径。</li>
</ol>
</li>
<li><strong>目标测试</strong>：评估当前状态是否为所求解的目标状态</li>
</ol>
<h3 id="2-1-2-评价指标"><a href="#2-1-2-评价指标" class="headerlink" title="2.1.2    评价指标"></a>2.1.2    评价指标</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315120043120.png" alt="image-20230315120043120" style="zoom:80%;" /></p>
<h3 id="2-1-3-树搜索"><a href="#2-1-3-树搜索" class="headerlink" title="2.1.3    树搜索"></a>2.1.3    树搜索</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315120320565.png" alt="image-20230315120320565" style="zoom:80%;" /></p>
<h3 id="2-1-4-剪枝搜索"><a href="#2-1-4-剪枝搜索" class="headerlink" title="2.1.4    剪枝搜索"></a>2.1.4    剪枝搜索</h3><ol>
<li><p>主动放弃一些后继节点，可以提高搜索效率，而不会影响最终的搜索效果</p>
<ol>
<li>如删除已访问节点</li>
</ol>
</li>
</ol>
<p>   <img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315120803013.png" alt="image-20230315120803013" style="zoom:80%;" /></p>
<h2 id="2-2-启发式搜索"><a href="#2-2-启发式搜索" class="headerlink" title="2.2    启发式搜索"></a>2.2    启发式搜索</h2><h3 id="2-2-1-贪婪最佳优先搜索-Greedy-best-first-search"><a href="#2-2-1-贪婪最佳优先搜索-Greedy-best-first-search" class="headerlink" title="2.2.1    贪婪最佳优先搜索 Greedy best-first search"></a>2.2.1    贪婪最佳优先搜索 Greedy best-first search</h3><p><strong>评价函数<code>f(n)</code> = 启发函数<code>h(n)</code></strong></p>
<ol>
<li><code>f(n)</code>：评价函数，判定下一个节点是谁</li>
<li><code>h(n)</code>：启发函数，预估完成任务的最小代价</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230315121011296.png" alt="image-20230315121011296" style="zoom:80%;" /></p>
<h3 id="2-2-2-A-算法"><a href="#2-2-2-A-算法" class="headerlink" title="2.2.2    A*算法"></a>2.2.2    A*算法</h3><h4 id="2-2-2-1-A-算法的定义"><a href="#2-2-2-1-A-算法的定义" class="headerlink" title="2.2.2.1    A*算法的定义"></a>2.2.2.1    A*算法的定义</h4><p><strong>评价函数<code>f(n) = g(n) + h(n)</code></strong></p>
<ol>
<li><code>f(n)</code>：评价函数，判定下一个节点是谁</li>
<li><code>h(n)</code>：启发函数，预估完成任务的最小代价</li>
<li><code>g(n)</code>：从起始节点到当前节点的代价</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322100826151.png" alt="image-20230322100826151" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322101907861.png" alt="image-20230322101907861" style="zoom:80%;" /></p>
<h4 id="不考-2-2-2-2-A-算法的性能分析"><a href="#不考-2-2-2-2-A-算法的性能分析" class="headerlink" title="(不考)2.2.2.2    A*算法的性能分析"></a>(不考)2.2.2.2    A*算法的性能分析</h4><ol>
<li><p>A*算法的完备性、最优性，取决于搜索问题和启发函数的性质</p>
<ol>
<li>完备性：一定能找到解</li>
<li>最优性：解最优</li>
</ol>
</li>
<li><p>相关定义</p>
<ol>
<li><code>f(n)</code>：评价函数，判定下一个节点是谁</li>
<li><code>h(n)</code>：启发函数，预估完成任务的最小代价</li>
<li><code>g(n)</code>：从起始节点到当前节点的代价</li>
<li><code>c(n,a,n&#39;)</code>：从节点n，执行动作a，到达节点n’的单步代价</li>
<li><code>h*(n)</code>：从节点n到终点的实际最小代价</li>
</ol>
</li>
<li><p>启发函数<code>h(n)</code>需要满足的性质：</p>
<ol>
<li><p><strong>可容性admissible</strong>：<code>h(n) ≤ h*(n)</code>，预估代价不超过实际代价</p>
</li>
<li><p><strong>一致性consistency</strong>：<code>h(n) ≤ c(n,a,n&#39;) + h(n&#39;)</code>，从当前节点直接到达终点的代价，不超过到达下一节点，然后再到达终点的代价</p>
</li>
<li><p><strong>满足一致性，一定满足可容性</strong>：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322102849176.png" alt="image-20230322102849176" style="zoom:80%;" /></p>
</li>
</ol>
</li>
</ol>
<h4 id="不考-2-2-2-3-A-算法的完备性"><a href="#不考-2-2-2-3-A-算法的完备性" class="headerlink" title="(不考)2.2.2.3    A*算法的完备性"></a>(不考)2.2.2.3    A*算法的完备性</h4><ol>
<li><strong>完备性</strong>：如果在起始节点和终止节点之间有路径存在，那么一定可以得到解。得不到解一定说明没有解存在</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322103132962.png" alt="image-20230322103132962" style="zoom:80%;" /></p>
<h4 id="不考-2-2-2-4-A-算法的最优性"><a href="#不考-2-2-2-4-A-算法的最优性" class="headerlink" title="(不考)2.2.2.4    A*算法的最优性"></a>(不考)2.2.2.4    A*算法的最优性</h4><ol>
<li>树搜索算法：如果启发函数满足<strong>可容性</strong>，则A<em>算法满足<em>*最优性</em></em></li>
<li>图搜索算法：如果启发函数满足<strong>一致性</strong>，则A<em>算法满足<em>*最优性</em></em></li>
<li>对于任意一个状态<strong>t</strong>，它第一次被加入搜索树时的路径必然是最短路径</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322103300921.png" alt="image-20230322103300921" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322104535118.png" alt="image-20230322104535118" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322104917057.png" alt="image-20230322104917057" style="zoom:80%;" /></p>
<h2 id="2-3-对抗搜索-博弈搜索"><a href="#2-3-对抗搜索-博弈搜索" class="headerlink" title="2.3    对抗搜索/博弈搜索"></a>2.3    对抗搜索/博弈搜索</h2><blockquote>
<p>Adversarial / Game Search</p>
</blockquote>
<ol>
<li><p>在一个竞争的环境中，智能体(agents)之间通过竞争实现相反的利益，一方<strong>最大化</strong>这个利益，另外一方<strong>最小化</strong>这个利益</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322105746718.png" alt="image-20230322105746718" style="zoom:80%;" /></p>
</li>
<li><p>分为三种搜索策略</p>
<ol>
<li><strong>最小最大搜索(Minimax Search)</strong>：最小最大搜索是在对抗搜索中最为基本的一种让玩家来计算最优策略的方法</li>
<li><strong>Alpha-Beta剪枝搜索(Pruning Search)</strong>：一种对最小最大搜索进行改进的算法，即在搜索过程中可剪除无需搜索的分支节点，且不影响搜索结果。</li>
<li><strong>蒙特卡洛树搜索(Monte-Carlo Tree Search)</strong>：通过采样而非穷举方法来实现搜索</li>
</ol>
</li>
<li><p>本书的讨论范围：</p>
<ol>
<li>确定的、全局可观察的、竞争对手轮流行动、零和游戏</li>
</ol>
</li>
<li><p>形式化描述：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322105943064.png" alt="image-20230322105943064" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="2-3-1-最小最大搜索-Minimax"><a href="#2-3-1-最小最大搜索-Minimax" class="headerlink" title="2.3.1    最小最大搜索 Minimax"></a>2.3.1    最小最大搜索 Minimax</h3><blockquote>
<ol>
<li>当前收益：<code>minimax(s)</code></li>
<li>选择动作<code>a</code>后的可能收益：<code>minimax(result(s,a))</code></li>
</ol>
</blockquote>
<ol>
<li>如果为终止状态：返回当前状态的得分<code>utility(s)</code></li>
<li>如果当前玩家为MAX：选择可能收益最大的动作，返回执行该动作后的可能收益</li>
<li>如果当前玩家为MIN：选择可能收益最小的动作，返回执行该动作后的可能收益</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322110053522.png" alt="image-20230322110053522" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619180342828.png" alt="image-20230619180342828" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 玩家MAX行动下, 当前的最优动作ans</span></span><br><span class="line"><span class="function">Action <span class="title">MinimaxDecision</span><span class="params">(State s)</span></span>&#123;</span><br><span class="line">    Action ans = null;</span><br><span class="line">    Value maxValue = -INF;</span><br><span class="line">    <span class="keyword">for</span>(a in <span class="built_in">Action</span>(s))&#123;</span><br><span class="line">        State nextState = <span class="built_in">result</span>(s,a);</span><br><span class="line">        Value nextValue = <span class="built_in">MinValue</span>(nextState);</span><br><span class="line">        <span class="keyword">if</span>(maxValue &lt; nextValue)&#123;</span><br><span class="line">            ans = a;</span><br><span class="line">            maxValue = nexValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 玩家MAX行动下, 当前状态的得分 v = minimax(s, MAX)</span></span><br><span class="line"><span class="function">Value <span class="title">MaxValue</span><span class="params">(State s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == terminal_state) <span class="keyword">return</span> <span class="built_in">utility</span>(s);</span><br><span class="line">    Value v = -INF;</span><br><span class="line">    <span class="keyword">for</span>(a in <span class="built_in">Action</span>(s))&#123;</span><br><span class="line">        State nextState = <span class="built_in">result</span>(s,a);</span><br><span class="line">        Value nextValue = <span class="built_in">MinValue</span>(nextState);</span><br><span class="line">        v = <span class="built_in">max</span>(v, nextValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 玩家MIN行动下, 当前状态的得分 v = minimax(s, MINs)</span></span><br><span class="line"><span class="function">Value <span class="title">MinValue</span><span class="params">(State s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == terminal_state) <span class="keyword">return</span> <span class="built_in">utility</span>(s);</span><br><span class="line">    Value v = INF;</span><br><span class="line">    <span class="keyword">for</span>(a in <span class="built_in">Action</span>(s))&#123;</span><br><span class="line">        State nextState = <span class="built_in">result</span>(s,a);</span><br><span class="line">        Value nextValue = <span class="built_in">MaxValue</span>(nextState);</span><br><span class="line">        v = <span class="built_in">min</span>(v, nextValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-Alpha-Beta剪枝搜索"><a href="#2-3-2-Alpha-Beta剪枝搜索" class="headerlink" title="2.3.2    Alpha-Beta剪枝搜索"></a>2.3.2    Alpha-Beta剪枝搜索</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322111238257.png" alt="image-20230322111238257" style="zoom:80%;" /></p>
<blockquote>
<p>MIN节点$m$：alpha剪枝</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322111253530.png" alt="image-20230322111253530" style="zoom:80%;" /></p>
<blockquote>
<p>MAX节点$m$：beta剪枝</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322111434761.png" alt="image-20230322111434761" style="zoom: 80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322111745307.png" alt="image-20230322111745307" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619180431404.png" alt="image-20230619180431404" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619180437563.png" alt="image-20230619180437563" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 玩家MAX行动下, 当前的最优动作ans</span></span><br><span class="line">&#123;Value,Action&#125; <span class="built_in">AlphaBetaDecision</span>(State s)&#123;</span><br><span class="line">    Action ans;</span><br><span class="line">    Value v;</span><br><span class="line">    &#123;v, ans&#125; = <span class="built_in">MaxValue</span>(s, -INF, INF);</span><br><span class="line">    <span class="keyword">return</span> &#123;v, ans&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家MIN行动下, 当前状态的得分 v = minimax(s, MIN)和最优动作 ans</span></span><br><span class="line">&#123;Value,Action&#125; <span class="built_in">MuValue</span>(State s, Value α, Value β)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == terminal_state) <span class="keyword">return</span> &#123;<span class="built_in">utility</span>(s), null&#125;;</span><br><span class="line">    Value v = INF;</span><br><span class="line">    Action ans = null;</span><br><span class="line">    <span class="keyword">for</span>(a in <span class="built_in">Action</span>(s))&#123;</span><br><span class="line">        State nextState = <span class="built_in">result</span>(s,a);</span><br><span class="line">        &#123;vv, aa&#125; = <span class="built_in">MaxValue</span>(nextState, α, β);</span><br><span class="line">       	<span class="keyword">if</span>(vv &lt; v)&#123;</span><br><span class="line">            v = vv; </span><br><span class="line">            ans = aa;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        β = <span class="built_in">min</span>(β, v);</span><br><span class="line">        <span class="keyword">if</span>(α &gt; β) <span class="keyword">return</span> &#123;v, ans&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>算法性能：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322112244614.png" alt="image-20230322112244614" style="zoom:80%;" /></p>
<h2 id="2-4-蒙特卡洛树搜索"><a href="#2-4-蒙特卡洛树搜索" class="headerlink" title="2.4    蒙特卡洛树搜索"></a>2.4    蒙特卡洛树搜索</h2><h3 id="2-4-1-问题定义"><a href="#2-4-1-问题定义" class="headerlink" title="2.4.1    问题定义"></a>2.4.1    问题定义</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114448673.png" alt="image-20230322114448673" style="zoom:80%;" /></p>
<h3 id="2-4-2-相关概念"><a href="#2-4-2-相关概念" class="headerlink" title="2.4.2    相关概念"></a>2.4.2    相关概念</h3><blockquote>
<p>核心：降低悔值函数的取值</p>
<p>悔值函数：期望T次操作的得分 - 实际T次操作的得分</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322112850905.png" alt="image-20230322112850905" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114532149.png" alt="image-20230322114532149" style="zoom:80%;" /></p>
<h3 id="2-4-3-贪心算法策略"><a href="#2-4-3-贪心算法策略" class="headerlink" title="2.4.3    贪心算法策略"></a>2.4.3    贪心算法策略</h3><blockquote>
<p>在第t步，选择过去t-1步，平均的得分最高的赌博机</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114605324.png" alt="image-20230322114605324" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114641449.png" alt="image-20230322114641449" style="zoom:80%;" /></p>
<h3 id="2-4-4-ε-贪心算法"><a href="#2-4-4-ε-贪心算法" class="headerlink" title="2.4.4    ε-贪心算法"></a>2.4.4    ε-贪心算法</h3><blockquote>
<p>在第t步，1-ε的概率取平均分最高，ε的概率取一个随机的赌博机</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114709158.png" alt="image-20230322114709158" style="zoom:80%;" /></p>
<h3 id="2-4-5-上限置信区间算法UCD1：Upper-Confidence-Bounds"><a href="#2-4-5-上限置信区间算法UCD1：Upper-Confidence-Bounds" class="headerlink" title="2.4.5    上限置信区间算法UCD1：Upper Confidence Bounds"></a>2.4.5    上限置信区间算法UCD1：Upper Confidence Bounds</h3><blockquote>
<p>估计每一个动作的奖励区间，优先选取上限高的动作</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114742922.png" alt="image-20230322114742922" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114332302.png" alt="image-20230322114332302" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114838614.png" alt="image-20230322114838614" style="zoom:80%;" /></p>
<h3 id="2-4-6-对抗搜索：蒙特卡洛树搜索"><a href="#2-4-6-对抗搜索：蒙特卡洛树搜索" class="headerlink" title="2.4.6    对抗搜索：蒙特卡洛树搜索"></a>2.4.6    对抗搜索：蒙特卡洛树搜索</h3><blockquote>
<p>使用UCB1算法，预估下一步操作的收益</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322114946852.png" alt="image-20230322114946852" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115203632.png" alt="image-20230322115203632" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115316924.png" alt="image-20230322115316924" style="zoom:80%;" /></p>
<blockquote>
<p>示例</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115348387.png" alt="image-20230322115348387" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115358630.png" alt="image-20230322115358630" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115410222.png" alt="image-20230322115410222" style="zoom:80%;" /></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230322115632518.png" alt="image-20230322115632518" style="zoom:80%;" /></p>
<h1 id="三、监督学习"><a href="#三、监督学习" class="headerlink" title="三、监督学习"></a>三、监督学习</h1><h2 id="3-1-机器学习的基本概念"><a href="#3-1-机器学习的基本概念" class="headerlink" title="3.1    机器学习的基本概念"></a>3.1    机器学习的基本概念</h2><ol>
<li>从原始数据中提取<strong>特征</strong></li>
<li>学习<strong>映射函数𝑓</strong></li>
<li>通过映射函数𝑓将<strong>原始数据</strong>映射到<strong>语义任务空间</strong>，即寻找数据和任务目标之间的关系</li>
</ol>
<h3 id="3-1-1-机器学习的分类"><a href="#3-1-1-机器学习的分类" class="headerlink" title="3.1.1    机器学习的分类"></a>3.1.1    机器学习的分类</h3><ol>
<li><strong>监督学习</strong>：数据有标签，一般为回归/分类等任务</li>
<li><strong>无监督学习</strong>：数据无标签，一般为聚类/若干降维任务<ol>
<li>同一类物体之间总有一定的相似性</li>
</ol>
</li>
<li><strong>半监督学习</strong>：有的数据有标签，有的数据无标签</li>
<li><strong>强化学习</strong>：序列数据决策学习，一般为从环境交互中学习</li>
</ol>
<h3 id="3-1-2-监督学习的重要元素"><a href="#3-1-2-监督学习的重要元素" class="headerlink" title="3.1.2    监督学习的重要元素"></a>3.1.2    监督学习的重要元素</h3><ol>
<li><strong>标注数据</strong>：标识了类别信息的数据，学什么</li>
<li><strong>学习模型</strong>：如何学习到映射模型，如何学</li>
<li><strong>损失函数</strong>：如何对学习结果进行度量，是否学到</li>
</ol>
<blockquote>
<p>没有免费午餐定理NFL：任何机器学习模型在<strong>所有问题</strong>上的<strong>性能都是相同</strong>的，其总误差和模型本身是没有关系的。一种算法（算法A）在特定数据集上的表现优于另一种算法（算法B）的同时，一定伴随着算法A在另外某一个特定的数据集上有着不如算法B的表现</p>
</blockquote>
<h3 id="3-1-3-监督学习"><a href="#3-1-3-监督学习" class="headerlink" title="3.1.3    监督学习"></a>3.1.3    监督学习</h3><h4 id="3-1-3-1-损失函数"><a href="#3-1-3-1-损失函数" class="headerlink" title="3.1.3.1    损失函数"></a>3.1.3.1    损失函数</h4><ol>
<li>设共有n个标注数据，第i个标记数据为$(x_i,y_i)$，其中$x_i$为样本数据，$y_i$是标注信息</li>
<li>设学习到的映射函数为$f$，对$x_i$的预测结果为$f(x_i)$</li>
<li>损失函数即为计算$y_i$和$f(x_i)$之间的差值的函数</li>
<li>训练的目标是：在训练数据集上得到的损失之和最小，即$min\sum_{i=1}^nLoss(f(x_i),y_i)$</li>
<li>典型损失函数：<ol>
<li><strong>0-1损失函数</strong>：$Loss(y_i,f(x_i))={1, f(x_i)\ne y_i;\ \ 0,f(x_i)=y_i}$</li>
<li><strong>平方损失函数</strong>：$Loss(y_i,f(x_i))=(y_i-f(x_i))^2$</li>
<li><strong>绝对损失函数</strong>：$Loss(y_i,f(x_i))=|y_i-f(x_i)|$</li>
<li><strong>对数损失函数/对数似然损失函数</strong>：$Loss(y_i,P(y_i|x_i))=-\log P(y_i|x_i)$</li>
</ol>
</li>
</ol>
<h4 id="3-1-3-2-训练数据与测试数据"><a href="#3-1-3-2-训练数据与测试数据" class="headerlink" title="3.1.3.2    训练数据与测试数据"></a>3.1.3.2    训练数据与测试数据</h4><ol>
<li><strong>训练精度</strong>：在<strong>测试数据集</strong>上的精度，因为在训练集上一定是100%通过的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329104355044.png" alt="image-20230329104355044" style="zoom:80%;" /></p>
<h4 id="3-1-3-3-经验风险、期望风险"><a href="#3-1-3-3-经验风险、期望风险" class="headerlink" title="3.1.3.3    经验风险、期望风险"></a>3.1.3.3    经验风险、期望风险</h4><p><strong>经验风险 empirical risk</strong>：<strong>训练集</strong>中数据产生的损失</p>
<ol>
<li><p>经验风险越小说明学习模型对训练数据拟合程度越好</p>
</li>
<li><p>经验风险最小化<strong>ERM</strong></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329104913964.png" alt="image-20230329104913964" style="zoom:80%;" /></p>
</li>
</ol>
<p><strong>期望风险 expected risk</strong>：当测试集中存在<strong>无穷多数据</strong>时产生的损失</p>
<ol>
<li><p>期望风险越小，学习所得模型越好</p>
</li>
<li><p>期望风险最小化<strong>ERM</strong></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329104945313.png" alt="image-20230329104945313" style="zoom:80%;" /></p>
</li>
</ol>
<h4 id="3-1-3-4-过学习-amp-欠学习"><a href="#3-1-3-4-过学习-amp-欠学习" class="headerlink" title="3.1.3.4    过学习 &amp; 欠学习"></a>3.1.3.4    过学习 &amp; 欠学习</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329105537971.png" alt="image-20230329105537971" style="zoom:80%;" /></p>
<h4 id="3-1-3-5-结构风险最小"><a href="#3-1-3-5-结构风险最小" class="headerlink" title="3.1.3.5    结构风险最小"></a>3.1.3.5    结构风险最小</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329105621040.png" alt="image-20230329105621040" style="zoom:80%;" /></p>
<h4 id="3-1-3-6-判别模型-amp-生成模型"><a href="#3-1-3-6-判别模型-amp-生成模型" class="headerlink" title="3.1.3.6    判别模型 &amp; 生成模型"></a>3.1.3.6    判别模型 &amp; 生成模型</h4><ol>
<li><p><strong>判别模型</strong>：</p>
<ol>
<li>建立输入到输出的映射函数：$f(输入)=人脸$</li>
<li>判断输入属于输出空间的概率有多大：$P(人脸|输入)=0.99$</li>
</ol>
</li>
<li><p><strong>生成模型</strong>：</p>
<ol>
<li><p>学习联合概率分布$P(X,Y)$（通过似然概率$P(X|Y)$和类概率$P(Y)$的乘积来求取）</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329110247031.png" alt="image-20230329110247031" style="zoom: 80%;" /></p>
</li>
<li><p>典型方法：贝叶斯方法、隐马尔科夫链</p>
</li>
<li><p>似然概率：计算导致样本$X$出现的模型参数值</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329110443829.png" alt="image-20230329110443829" style="zoom:80%;" /></p>
</li>
<li><p>联合概率分布$P(X,Y)$、似然概率$P(X|Y)$求取很困难</p>
</li>
</ol>
</li>
</ol>
<h2 id="3-2-回归分析"><a href="#3-2-回归分析" class="headerlink" title="3.2    回归分析"></a>3.2    回归分析</h2><h3 id="3-2-1-线性回归"><a href="#3-2-1-线性回归" class="headerlink" title="3.2.1    线性回归"></a>3.2.1    线性回归</h3><ol>
<li><strong>回归分析</strong>：分析不同变量之间存在的关系</li>
<li><strong>回归模型</strong>：刻画不同变量之间关系的模型</li>
<li><strong>线性回归模型</strong>：回归模型是线性的</li>
</ol>
<h4 id="3-2-1-1-一元线性回归"><a href="#3-2-1-1-一元线性回归" class="headerlink" title="3.2.1.1    一元线性回归"></a>3.2.1.1    一元线性回归</h4><ol>
<li><p>一个变量，对另一个变量的影响</p>
</li>
<li><p>回归模型：$f(x_i)=ax_i+b$</p>
</li>
<li><p>要求：$\frac{1}{N}\sum(y-\hat y)^2$最小</p>
</li>
<li><p>计算结果：</p>
<script type="math/tex; mode=display">
b=\overline{y}-a\overline{x}\\
a=\frac{\sum_{i=1}^{n}x_iy_i-n\overline{x}·\overline{y}}{\sum_{i=1}^{n}x_i^2-n\overline{x}^2}</script></li>
</ol>
<blockquote>
<p>计算过程：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329114630713.png" alt="image-20230329114630713" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329114704437.png" alt="image-20230329114704437" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329114740563.png" alt="image-20230329114740563" style="zoom:80%;" /></p>
</blockquote>
<h4 id="3-2-1-2-多元线性回归"><a href="#3-2-1-2-多元线性回归" class="headerlink" title="3.2.1.2    多元线性回归"></a>3.2.1.2    多元线性回归</h4><ol>
<li>多个变量，对一个变量产生影响</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329112909723.png" alt="image-20230329112909723" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329113152461.png" alt="image-20230329113152461" style="zoom:80%;" /></p>
<h4 id="3-2-1-3-logistics-回归-对数几率回归"><a href="#3-2-1-3-logistics-回归-对数几率回归" class="headerlink" title="3.2.1.3    logistics 回归/对数几率回归"></a>3.2.1.3    logistics 回归/对数几率回归</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329112837126.png" alt="image-20230329112837126" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329113104137.png" alt="image-20230329113104137" style="zoom:80%;" /></p>
<h4 id="3-2-1-4-二分类问题"><a href="#3-2-1-4-二分类问题" class="headerlink" title="3.2.1.4    二分类问题"></a>3.2.1.4    二分类问题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329113409355.png" alt="image-20230329113409355" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329113443038.png" alt="image-20230329113443038" style="zoom:80%;" /></p>
<h4 id="3-2-1-5-基于似然函数的参数优化"><a href="#3-2-1-5-基于似然函数的参数优化" class="headerlink" title="3.2.1.5    基于似然函数的参数优化"></a>3.2.1.5    基于似然函数的参数优化</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329120546389.png" alt="image-20230329120546389" style="zoom:80%;" /></p>
<blockquote>
<p>使用梯度下降公式，快速到达导数接近0的位置，出口为：</p>
<ol>
<li>迭代次数到达预定次数</li>
<li>相邻两次差值小于某个值</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329115050889.png" alt="image-20230329115050889" style="zoom:80%;" /></p>
<h4 id="3-2-1-6-MLE最大似然估计-amp-MAP最大后验概率估计"><a href="#3-2-1-6-MLE最大似然估计-amp-MAP最大后验概率估计" class="headerlink" title="3.2.1.6    MLE最大似然估计 &amp; MAP最大后验概率估计"></a>3.2.1.6    MLE最大似然估计 &amp; MAP最大后验概率估计</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230329115330878.png" alt="image-20230329115330878" style="zoom:80%;" /></p>
<h2 id="3-3-决策树"><a href="#3-3-决策树" class="headerlink" title="3.3    决策树"></a>3.3    决策树</h2><p>决策树是一种通过树形结构来进行分类的方法。</p>
<ol>
<li>在决策树中，树形结构中每个非叶子节点表示对分类目标在某个属性上的一个判断，每个分支代表基于该属性做出的一个判断，最后树形结构中每个叶子节点代表一种分类结果</li>
<li>所以决策树可以看作是一系列以叶子节点为输出的决策规则</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412100433480.png" alt="image-20230412100433480" style="zoom:80%;" /></p>
</blockquote>
<h3 id="3-3-1-信息熵-E-D"><a href="#3-3-1-信息熵-E-D" class="headerlink" title="3.3.1    信息熵 E(D)"></a>3.3.1    信息熵 E(D)</h3><blockquote>
<p>构建决策树时<strong>划分属性的顺序</strong>选择是重要的。</p>
<p>性能好的决策树随着划分不断进行，决策树分支结点样本集的“纯度”会越来越高，即其所包含样本尽可能属于相同类别，即<strong>E(D)尽可能小</strong></p>
</blockquote>
<ol>
<li><p>假设有$K$个信息，组成了集合样本$D$，第$k$个信息发生的概览为$p_k(1\le k\le K)$，则这$K$个信息的<strong>信息熵</strong>为：</p>
<script type="math/tex; mode=display">
E(D)=-\sum_{k=1}^Kp_k\log_2\ p_k</script><ol>
<li>其中，$\sum_{k=1}^{K}p_k=1$</li>
</ol>
</li>
<li><p>$E(D)$值越小，表示$D$包含的信息越确定，即$D$的纯度越高</p>
<ol>
<li>当$p_k=1$时，$E(D)=0$，信息熵为0，即包含的信息量很小</li>
</ol>
</li>
</ol>
<blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">年龄属性取值 a~i~</th>
<th style="text-align:center">“&gt;30”</th>
<th style="text-align:center">“20~30”</th>
<th style="text-align:center">“&lt;20”</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">对应样本数 \</td>
<td style="text-align:center">D~i~\</td>
<td style="text-align:center"></td>
<td style="text-align:center">5</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td style="text-align:center">正负样本数量</td>
<td style="text-align:center">(2+,  3-)</td>
<td style="text-align:center">(4+，0-)</td>
<td style="text-align:center">(3+，2-)</td>
</tr>
</tbody>
</table>
</div>
<p>计算E(D)：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412101818991.png" alt="image-20230412101818991" style="zoom:80%;" /></p>
</blockquote>
<h3 id="3-3-2-信息增益-Gain-D-A"><a href="#3-3-2-信息增益-Gain-D-A" class="headerlink" title="3.3.2    信息增益 Gain(D,A)"></a>3.3.2    信息增益 Gain(D,A)</h3><ol>
<li><p>得到信息熵后，可进一步计算使用某个特定属性<strong>A</strong>对原样本集<strong>D</strong>进行划分后的<strong>信息增益</strong>，计算公式为：</p>
<script type="math/tex; mode=display">
Gain(D,A)=E(D)-\sum_{i=1}^{n}\frac{|D_i|}{|D|}E(D_i)</script><ol>
<li>其中，属性$A$将$D$划分为了$n$类，分别为$D_1,…D_n$</li>
</ol>
</li>
<li><p>取<strong>信息增益最大</strong>的属性，作为决策树中靠近根节点的属性</p>
</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412102039855.png" alt="image-20230412102039855" style="zoom:80%;" /></p>
</blockquote>
<h3 id="3-3-3-信息熵和物理熵的区别"><a href="#3-3-3-信息熵和物理熵的区别" class="headerlink" title="3.3.3    信息熵和物理熵的区别"></a>3.3.3    信息熵和物理熵的区别</h3><ol>
<li>信息熵：描述信息的价值，某个信息发生概率越小，带来的信息量越大，信息熵就越大<ol>
<li>香农用信息熵的概念来描述信源的不确定度</li>
</ol>
</li>
<li>物理熵：表示分子状态混乱程度的物理量<ol>
<li>熵越大，越失去次序，不确定性越大</li>
</ol>
</li>
</ol>
<h2 id="3-4-线性区别分析-LDA"><a href="#3-4-线性区别分析-LDA" class="headerlink" title="3.4    线性区别分析 LDA"></a>3.4    线性区别分析 LDA</h2><blockquote>
<p><strong>Linear discriminant analysis</strong></p>
</blockquote>
<p>线性判别分析是一种基于监督学习的<strong>降维方法</strong>，也称为Fisher线性判别分析</p>
<ol>
<li>对于一组具有标签信息的高维数据样本，LDA利用其类别信息，将其线性投影到一个低维空间</li>
<li>在低维空间中同一类别样本尽可能靠近，不同类别样本尽可能彼此远离，不要有交叉的部分</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412102938493.png" alt="image-20230412102938493" style="zoom:80%;" /></p>
</blockquote>
<h3 id="3-4-1-符号定义"><a href="#3-4-1-符号定义" class="headerlink" title="3.4.1    符号定义"></a>3.4.1    符号定义</h3><ol>
<li>设样本集为：$D={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$<ol>
<li>$x_i\in R^d$表示样本，对应的标签为$y_i$</li>
<li>$y_i \in {C_1,C_2,…,C_k}$，表示一共有$K$类样本</li>
</ol>
</li>
<li>$X$：所有样本构成的集合</li>
<li>$N_i$：第$i$个类别包含的样本个数</li>
<li>$X_i$：第$i$类样本的集合</li>
<li>$m$：所有样本的均值向量</li>
<li>$m_i$：第$i$类样本的均值向量</li>
<li>$\Sigma<em>i$：第$i$类样本的协方差矩阵，$\Sigma_i=\sum</em>{x\in X_i}(x-m_i)(x-m_i)^T$</li>
</ol>
<h3 id="3-4-2-二分类问题"><a href="#3-4-2-二分类问题" class="headerlink" title="3.4.2    二分类问题"></a>3.4.2    二分类问题</h3><p>$K=2$时，表示二分类问题，其样本的标签为${C_1,C_2}$，并通过线性函数$y(x)=w^Tx\ \ \ (w\in R^n)$投影到一维空间</p>
<ol>
<li>$w$：系数<strong>矩阵</strong>，需要通过数据学习</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412104306809.png" alt="image-20230412104306809" style="zoom:80%;" /></p>
</blockquote>
<p>计算系数矩阵$w$的方法：</p>
<script type="math/tex; mode=display">
w=S_w^{-1}(m_2-m_1)=(\Sigma_1+\Sigma_2)^{-1}(m_2-m_1)</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412104553768.png" alt="image-20230412104553768" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412104858207.png" alt="image-20230412104858207" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412105046102.png" alt="image-20230412105046102" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412105534388.png" alt="image-20230412105534388" style="zoom:80%;" /></p>
<p>投影过程中，保持方差结构不变：即原来两类包含的是某些样本，投影完之后依旧分别包含这些样本</p>
<h3 id="3-4-3-多分类问题"><a href="#3-4-3-多分类问题" class="headerlink" title="3.4.3    多分类问题"></a>3.4.3    多分类问题</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412110526430.png" alt="image-20230412110526430" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412110537158.png" alt="image-20230412110537158" style="zoom:80%;" /></p>
<h3 id="3-4-4-线性判别分析的降维步骤"><a href="#3-4-4-线性判别分析的降维步骤" class="headerlink" title="3.4.4    线性判别分析的降维步骤"></a>3.4.4    线性判别分析的降维步骤</h3><ol>
<li>计算数据样本集中，每个类别样本的均值$m_i$</li>
<li>计算类内散度矩阵$S_w$、类间散度矩阵$S_b$</li>
<li>根据$S_w^{-1}S_bW=\lambda W$，求解$S_w^{-1}S_b$对应的前$r$个最大特征根对应的特征向量$(w_1,w_2,…,w_r)$，构成投影矩阵$W$</li>
<li>通过矩阵$W$将每个样本映射到低维空间，实现特征降维</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412110824855.png" alt="image-20230412110824855" style="zoom:80%;" /></p>
<h2 id="3-5-Ada-Boosting"><a href="#3-5-Ada-Boosting" class="headerlink" title="3.5    Ada Boosting"></a>3.5    Ada Boosting</h2><blockquote>
<p>adaptive boosting，自适应提升</p>
</blockquote>
<ol>
<li>对于一个复杂的分类任务，可以将其分解为若干子任务，然后将若干子任务完成方法综合，最终完成该复杂任务</li>
<li>将若干个弱分类器(weak classifiers)组合起来，形成一个强分类器(strong classifier)</li>
</ol>
<h3 id="3-5-1-计算学习理论：霍夫丁不等式"><a href="#3-5-1-计算学习理论：霍夫丁不等式" class="headerlink" title="3.5.1    计算学习理论：霍夫丁不等式"></a>3.5.1    计算学习理论：霍夫丁不等式</h3><ol>
<li>学习任务：统计某个电视节目在全国的收视率</li>
<li>方法：不可能去统计整个国家中每个人是否观看电视节目、进而算出收视率。只能抽样一部分人口，然后将<strong>抽样人口</strong>中观看该电视节目的比例作为该电视节目的全国收视率</li>
<li><strong>霍夫丁不等式</strong>：全国人口中看该电视节目的人口比例$x$与抽样人口中观看该电视节目的人口比例$y$满足关系：$P(|x-y|\ge \epsilon) \le 2e^{-2N\epsilon^2}$<ol>
<li>$N$：采样人口总数</li>
<li>$\epsilon \in(0,1)$：设定的可容忍误差范围</li>
<li>当$N$足够大时，“全国人口中电视节目收视率”与“样本人口中电视节目收视率”差值超过误差范围$\epsilon$的概率非常小</li>
</ol>
</li>
</ol>
<h3 id="3-5-2-计算学习理论：概率近似正确-PAC"><a href="#3-5-2-计算学习理论：概率近似正确-PAC" class="headerlink" title="3.5.2    计算学习理论：概率近似正确 PAC"></a>3.5.2    计算学习理论：概率近似正确 PAC</h3><blockquote>
<p><strong>probably approximately correct</strong></p>
</blockquote>
<ol>
<li>对于统计电视节目收视率这样的任务，可以通过不同的采样方法（即不同模型）来计算收视率。每个模型会产生不同的误差</li>
<li>任务：得到完成该任务的<strong>若干“弱模型”</strong>，将这些弱模型组合起来<strong>形成一个“强模型”</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412112007331.png" alt="image-20230412112007331" style="zoom:80%;" /></p>
<h3 id="3-5-3-Ada-Boosting：思路描述"><a href="#3-5-3-Ada-Boosting：思路描述" class="headerlink" title="3.5.3    Ada Boosting：思路描述"></a>3.5.3    Ada Boosting：思路描述</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412112101726.png" alt="image-20230412112101726" style="zoom:80%;" /></p>
<p>两个核心问题：</p>
<ol>
<li>在每个<strong>弱分类器学习</strong>过程中：<strong>改变训练数据的权重</strong><ol>
<li><strong>提高</strong>在上一轮中分类<strong>错误样本的权重</strong></li>
<li>即关注上一个弱分类器无法解决的结果，进行优化</li>
</ol>
</li>
<li>如何将一系列弱分类器<strong>组合成强分类器</strong>：<strong>加权多数表决方法</strong><ol>
<li>提高分类误差小的弱分类器的权重，让其在最终分类中起到更大作用</li>
<li>减少分类误差大的弱分类器的权重，让其在最终分类中仅起到较小作用</li>
</ol>
</li>
</ol>
<h3 id="3-5-4-Ada-Boosting：算法描述"><a href="#3-5-4-Ada-Boosting：算法描述" class="headerlink" title="3.5.4    Ada Boosting：算法描述"></a>3.5.4    Ada Boosting：算法描述</h3><h4 id="3-5-4-1-数据样本权重初始化"><a href="#3-5-4-1-数据样本权重初始化" class="headerlink" title="3.5.4.1    数据样本权重初始化"></a>3.5.4.1    数据样本权重初始化</h4><ol>
<li>给定包含$N$个标注数据的训练集合$\Gamma$<ol>
<li>$\Gamma={(x_1,y_1),…,(x_N,y_N)}$，其中$x_i\in X\sub R^n, y_i\in Y={-1,1}$</li>
</ol>
</li>
<li>初始化每个训练样本的权重：<ol>
<li>$D<em>1=(w</em>{11},…,w<em>{1N}),\ w</em>{1i}=\frac{1}{N}$</li>
</ol>
</li>
</ol>
<h4 id="3-5-4-2-第m个弱分类器的训练"><a href="#3-5-4-2-第m个弱分类器的训练" class="headerlink" title="3.5.4.2    第m个弱分类器的训练"></a>3.5.4.2    第m个弱分类器的训练</h4><p>对于$m=1,2,…M$</p>
<ol>
<li>使用具有分布权重$D_m$的训练数据，学习得到第m个弱分类器$G_m$<ol>
<li>$G_m(x): X \rightarrow {-1,1}$</li>
</ol>
</li>
<li>计算$G_m(x)$在训练数据集上的分类误差：<ol>
<li>$err<em>m=\sum</em>{i=1}^Nw_{mi}\ I(G_m(x_i)\neq y_i)$</li>
<li>其中，$I(G_m(x_i)\neq y_i)$表示：当$G_m(x_i)\neq y_i$时为1，否则为0</li>
</ol>
</li>
<li>计算$G_m(x)$的权重：<strong>弱分类器的权重和不为1</strong><ol>
<li>$\alpha_m=\frac{1}{2}\ln \frac{1-err_m}{err_m}$</li>
</ol>
</li>
<li>更新训练样本数据的分布权重：<strong>每一轮样本的权重和为1</strong><ol>
<li>$D<em>{m+1}=w</em>{m+1,i}=\frac{w_{m,i}}{Z_m}e^{-\alpha_my_iG_m(x_i)}$</li>
<li>其中，$Z<em>m$是归一化因子，使得$D</em>{m+1}$为概率分布</li>
<li>$Z<em>m=\sum</em>{i=1}^Nw_{m,i}e^{-\alpha_my_iG_m(x_i)}$</li>
</ol>
</li>
</ol>
<h4 id="3-5-4-3-弱分类器组合成强分类器"><a href="#3-5-4-3-弱分类器组合成强分类器" class="headerlink" title="3.5.4.3    弱分类器组合成强分类器"></a>3.5.4.3    弱分类器组合成强分类器</h4><ol>
<li>以线性加权形式来组合弱分类器$f(x)$：$f(x)=\sum_{i=1}^M\alpha_mG_m(x)$</li>
<li>得到强分类器$G(x)$：$G(x)=sign(f(x))=sign(\sum_{i=1}^M\alpha_mG_m(x))$</li>
</ol>
<h3 id="3-5-5-Ada-Boosting：算法解释"><a href="#3-5-5-Ada-Boosting：算法解释" class="headerlink" title="3.5.5    Ada Boosting：算法解释"></a>3.5.5    Ada Boosting：算法解释</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114227541.png" alt="image-20230412114227541" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114209654.png" alt="image-20230412114209654" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114237511.png" alt="image-20230412114237511" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114246140.png" alt="image-20230412114246140" style="zoom:80%;" /></p>
<h3 id="3-5-6-Ada-Boosting：回看霍夫丁不等式"><a href="#3-5-6-Ada-Boosting：回看霍夫丁不等式" class="headerlink" title="3.5.6    Ada Boosting：回看霍夫丁不等式"></a>3.5.6    Ada Boosting：回看霍夫丁不等式</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114318932.png" alt="image-20230412114318932" style="zoom:80%;" /></p>
<h3 id="3-5-7-Ada-Boosting：优化目标"><a href="#3-5-7-Ada-Boosting：优化目标" class="headerlink" title="3.5.7    Ada Boosting：优化目标"></a>3.5.7    Ada Boosting：优化目标</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412114340961.png" alt="image-20230412114340961" style="zoom:80%;" /></p>
<h3 id="3-5-8-回归和分类的区别"><a href="#3-5-8-回归和分类的区别" class="headerlink" title="3.5.8    回归和分类的区别"></a>3.5.8    回归和分类的区别</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412115552314.png" alt="image-20230412115552314" style="zoom:80%;" /></p>
<h2 id="不考-3-6-支持向量机"><a href="#不考-3-6-支持向量机" class="headerlink" title="(不考)3.6    支持向量机"></a>(不考)3.6    支持向量机</h2><h3 id="不考-3-6-1-VC维与结构风险最小化"><a href="#不考-3-6-1-VC维与结构风险最小化" class="headerlink" title="(不考)3.6.1    VC维与结构风险最小化"></a>(不考)3.6.1    VC维与结构风险最小化</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412120217404.png" alt="image-20230412120217404" style="zoom:80%;" /></p>
<blockquote>
<p>h：反应机器复杂程度的VC维，要求机器本身不要太复杂</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412120649871.png" alt="image-20230412120649871" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412120933462.png" alt="image-20230412120933462" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121034169.png" alt="image-20230412121034169" style="zoom:80%;" /></p>
<h3 id="不考-3-6-2-线性可分支持向量机"><a href="#不考-3-6-2-线性可分支持向量机" class="headerlink" title="(不考)3.6.2    线性可分支持向量机"></a>(不考)3.6.2    线性可分支持向量机</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121242624.png" alt="image-20230412121242624" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121251130.png" alt="image-20230412121251130" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121440464.png" alt="image-20230412121440464" style="zoom:80%;" /></p>
<h3 id="不考-3-6-3-松弛变量，软间隔与hinge损失函数"><a href="#不考-3-6-3-松弛变量，软间隔与hinge损失函数" class="headerlink" title="(不考)3.6.3    松弛变量，软间隔与hinge损失函数"></a>(不考)3.6.3    松弛变量，软间隔与hinge损失函数</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121602099.png" alt="image-20230412121602099" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230412121629302.png" alt="image-20230412121629302" style="zoom:80%;" /></p>
<h2 id="不考-3-7-生成学习模型"><a href="#不考-3-7-生成学习模型" class="headerlink" title="(不考)3.7    生成学习模型"></a>(不考)3.7    生成学习模型</h2><p>生成学习方法从数据中学习联合概率分布$P(X,C)$，然后求出条件概率分布$P(C|X)$作为预测模型，即$P(c_i|x)=\frac{P(x,c_i)}{P(x)}$</p>
<ol>
<li>$P(x,c_i)=P(x|c_i)×P(c_i)$<ol>
<li>$P(x|c_i)$：似然概率</li>
<li>$P(c_i)$：先验概率</li>
</ol>
</li>
<li>$P(c_i|x)=\frac{P(x,c_i)}{P(x)}=\frac{P(x|c_i)×P(c_i)}{P(x)}$<ol>
<li>$P(c_i|x)$：后验概率，表示样本$x$属于类别$c_i$的概率</li>
<li>$P(x,c_i)$：联合概率</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419101607549.png" alt="image-20230419101607549" style="zoom:80%;" /></p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419101552222.png" alt="image-20230419101552222" style="zoom:80%;" /></p>
<p>生成式学习：</p>
<ol>
<li>学习某个输入与某个类别同时出现的概率，根据某个输入出现的概率，计算某个输入对应某个类别的概率</li>
<li>模拟了数据生成的方法</li>
<li>但是联合概率难以学习，因为训练数据中输入与类别没有同时出现，不代表以后永远不会同时出现</li>
<li>以购买商品为例：<ol>
<li>联合概率$P(x,c_i)$：某个人购买了某个商品的概率</li>
<li>似然概率$P(x|c_i)$：某个商品让某个人购买的概率，某个人没有买，但是与之类似的人买过，此时可以转换为某个商品让某个人购买的概率有多大</li>
<li>先验概率$P(c_i)$：某个商品出现的概率，即在所有卖出的商品中，该商品出现的概率</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419101626670.png" alt="image-20230419101626670" style="zoom:80%;" /></p>
<p>判别式学习：直接学习某个输入对应某个类别的概率</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419102048725.png" alt="image-20230419102048725" style="zoom:80%;" /></p>
</blockquote>
<h1 id="四、无监督学习"><a href="#四、无监督学习" class="headerlink" title="四、无监督学习"></a>四、无监督学习</h1><p>无监督学习从<strong>非标注样本</strong>出发来<strong>学习数据的分布</strong>，这是一个异常困难的工作。由于无法利用标注信息，因此在无监督学习只能利用假设数据具有某些结构来进行学习。正如拉普拉斯所言“概率论只不过是把常识用数学公式表达了出来”，无监督学习就是把预设数据具有某种结构作为一种“知识”来指导模型的学习。</p>
<h2 id="4-1-K均值聚类"><a href="#4-1-K均值聚类" class="headerlink" title="4.1    K均值聚类"></a>4.1    K均值聚类</h2><p>输入：n个数据，无标注信息</p>
<p>输出：k个聚类结果</p>
<p>目的：将n个数据聚类到k个集合(类簇)</p>
<h3 id="4-1-1-算法描述"><a href="#4-1-1-算法描述" class="headerlink" title="4.1.1    算法描述"></a>4.1.1    算法描述</h3><p>定义：</p>
<ol>
<li>n个m维数据${x_1,x_2,…x_n}, x_i\in R^m$</li>
<li>两个m维数据之间的欧氏距离为：$d(x<em>i,x_j)=\sqrt{(x</em>{i1}-x<em>{j1})^2+(x</em>{i2}-x<em>{j2})^2+…+(x</em>{im}-x_{jm})^2}$<ol>
<li>欧氏距离并不一定能够刻画语义上的相似性</li>
<li>但是总要找一个函数表示数据之间的相似性，这里就以欧氏距离为例</li>
</ol>
</li>
<li>聚类集合数目：$k$</li>
</ol>
<h4 id="4-1-1-1-初始化聚类质心"><a href="#4-1-1-1-初始化聚类质心" class="headerlink" title="4.1.1.1    初始化聚类质心"></a>4.1.1.1    初始化聚类质心</h4><ol>
<li>初始化$k$个聚类质心$c={c_1, c_2,…,c_k}$，$c_j\in R^m,1\le j \le k$</li>
<li>每个聚类质心$c_j$所在的集合记为$G_j$</li>
</ol>
<h4 id="4-1-1-2-将每个待聚类数据放入唯一一个聚类集合中"><a href="#4-1-1-2-将每个待聚类数据放入唯一一个聚类集合中" class="headerlink" title="4.1.1.2    将每个待聚类数据放入唯一一个聚类集合中"></a>4.1.1.2    将每个待聚类数据放入唯一一个聚类集合中</h4><ol>
<li>计算待聚类数据$x_i$和质心$c_j$之间的欧氏距离$d(x_i,c_j)$，$1\le i\le n, 1\le j \le k$</li>
<li>将每个$x_i$放入与之距离最近的聚类质心所在聚类集合中，即</li>
</ol>
<script type="math/tex; mode=display">
argmin_{c_{j\in C}}d(x_i,c_j)</script><h4 id="4-1-1-3-根据聚类结果，更新聚类质心"><a href="#4-1-1-3-根据聚类结果，更新聚类质心" class="headerlink" title="4.1.1.3    根据聚类结果，更新聚类质心"></a>4.1.1.3    根据聚类结果，更新聚类质心</h4><ol>
<li>聚类$G_j$的新的聚类质心$c_j$为：</li>
</ol>
<script type="math/tex; mode=display">
c_j=\frac{1}{|G_j|}\sum_{x_i\in G_j}x_i</script><h4 id="4-1-1-4-算法循环迭代，直到满足条件"><a href="#4-1-1-4-算法循环迭代，直到满足条件" class="headerlink" title="4.1.1.4    算法循环迭代，直到满足条件"></a>4.1.1.4    算法循环迭代，直到满足条件</h4><ol>
<li>在新的聚类质心基础上，根据欧氏距离的大小，将每个待聚类数据放入唯一一个聚类集合中</li>
<li>根据聚类结果，更新聚类质心</li>
<li>重复上述两个步骤，直到满足一下任意一个条件：<ol>
<li>前后两次迭代中，聚类质心基本保持不变<ol>
<li>此时算法收敛，结果相对来说比较好</li>
</ol>
</li>
<li>迭代次数达到上限<ol>
<li>此时算法不收敛，可能是由于欧氏距离并不能很好的刻画数据的相似度</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="4-1-2-另一个视角：最小化每个类簇的方差"><a href="#4-1-2-另一个视角：最小化每个类簇的方差" class="headerlink" title="4.1.2    另一个视角：最小化每个类簇的方差"></a>4.1.2    另一个视角：最小化每个类簇的方差</h3><p>方差：计算变量(观察值)与样本平均值之间的差异</p>
<script type="math/tex; mode=display">
argmin_{G}\sum_{i=1}^k\sum_{x \in G_i}|x-G_i|^2=argmin_{G}\sum_{i=1}^k|G_i|Var\ G_i</script><p>第$i$个类簇的方差：</p>
<script type="math/tex; mode=display">
var(G_i)=\frac{1}{|G_i|}\sum_{x \in G_i}|x-G_i|^2</script><ol>
<li>欧氏距离与方差量纲相同</li>
<li>最小化每个类簇方差将使得最终聚类结果中每个聚类集合中所包含数据呈现出来差异性最小</li>
</ol>
<h3 id="4-1-3-K均值聚类算法的不足"><a href="#4-1-3-K均值聚类算法的不足" class="headerlink" title="4.1.3    K均值聚类算法的不足"></a>4.1.3    K均值聚类算法的不足</h3><ol>
<li>需要事先确定聚类数目，很多时候我们并不知道数据应被聚类的数目</li>
<li>需要初始化聚类质心，初始化聚类中心对聚类结果有较大的影响</li>
<li>算法是迭代执行，时间开销非常大</li>
<li>欧氏距离假设数据每个维度之间的重要性是一样的</li>
</ol>
<h2 id="4-2-主成分分析-PCA"><a href="#4-2-主成分分析-PCA" class="headerlink" title="4.2    主成分分析 PCA"></a>4.2    主成分分析 PCA</h2><blockquote>
<p><strong>Principle Component Analysis</strong></p>
</blockquote>
<p>主成分分析是一种<strong>特征降维</strong>方法（与线性区别分析的目的是一样的）</p>
<ol>
<li>要尽可能将投影后的数据打散，即方差最大</li>
<li>设原数据为$X<em>{n×d}$，投影后的数据为$Y</em>{n×l}$，投影矩阵为$W_{d×l}$，则有$Y=XW$</li>
<li>投影矩阵$W<em>{d×l}$为：协方差矩阵$\Sigma$前$l$个最大的特征根对应的特征向量$</em>{d×1}$组成的矩阵$_{d×l}$</li>
</ol>
<h3 id="4-2-1-相关概念"><a href="#4-2-1-相关概念" class="headerlink" title="4.2.1    相关概念"></a>4.2.1    相关概念</h3><p>假设有n个数据，记为$X={x_i}, i=1,…n$</p>
<ol>
<li><strong>方差</strong>：描述样本数据的波动程度<script type="math/tex; mode=display">
Var(X)=\frac{1}{n}\sum_{i=1}^n(x_i-u)^2\\
u=\frac{1}{n}\sum_{i=1}^n x_i</script></li>
</ol>
<p>假设有n个二维变量数据，记为$(X,Y)={(x_i,y_i)}, i=1,…n$</p>
<ol>
<li><p><strong>协方差</strong>：衡量两个维度之间的相关度</p>
<ol>
<li>协方差$cov(X,Y)&gt;0$时：正相关</li>
<li>协方差$cov(X,Y)&lt;0$时：负相关</li>
<li>协方差$cov(X,Y)=0$时：线性意义下不相关</li>
</ol>
<script type="math/tex; mode=display">
cov(X,Y)=\frac{1}{n}\sum_{i=1}^n(x_i-E(X))(y_i-E(Y))\\
E(X)=\frac{1}{n}\sum_{i=1}^nx_i,\ \ E(Y)=\frac{1}{n}\sum_{i=1}^ny_i</script></li>
<li><p><strong>皮尔逊相关系数</strong>：将协方差归一化</p>
<ol>
<li>$|corr(X,Y)|\le1$</li>
<li>$|corr(X,Y)=1|$ &lt;=&gt; 存在常数$a,b$，使得$Y=aX+b$</li>
<li>$corr(X,Y)=corr(Y,X)$</li>
</ol>
<script type="math/tex; mode=display">
corr(X,Y)=\frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}=\frac{Cov(X,Y)}{\sigma_x\sigma_y}</script></li>
<li><p><strong>相关性</strong>与<strong>独立性</strong>：</p>
<ol>
<li>如果$X$与$Y$线性不相关，则$|corr(X,Y)|=0$</li>
<li>如果$X$与$Y$独立，则$|corr(X,Y)|=0$，且$X$与$Y$不存在任何线性、非线性关系</li>
<li>独立一定不相关，但不相关不一定独立</li>
</ol>
</li>
</ol>
<h3 id="4-2-2-算法动机"><a href="#4-2-2-算法动机" class="headerlink" title="4.2.2    算法动机"></a>4.2.2    算法动机</h3><ol>
<li>在数理统计中，方差被经常用来度量数据和其数学期望（即均值）之间偏离程度，这个偏离程度反映了数据分布结构</li>
<li>在许多实际问题中，研究数据和其均值之间的偏离程度有着很重要的意义</li>
<li>在降维之中，需要尽可能将数据向<strong>方差最大方向</strong>进行投影，使得数据所蕴含信息没有丢失，彰显个性。如左下图所示，向𝒚方向投影（使得二维数据映射为一维）就比向𝒙方向投影结果在降维这个意义上而言要好；右下图则是向黑斜线方向投影要好。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419112131702.png" alt="image-20230419112131702" style="zoom:80%;" /></p>
<ol>
<li>主成分分析思想是将𝒏维特征数据映射到𝒍维空间(𝒏 ≫ 𝒍)，去除原始数据之间的冗余性（通过去除相关性手段达到这一目的）。</li>
<li>将原始数据向这些数据方差最大的方向进行投影。一旦发现了方差最大的投影方向，则继续寻找保持方差第二的方向且进行投影。</li>
<li>将每个数据从𝒏维高维空间映射到𝒍维低维空间，每个数据所得到最好的𝒌维特征就是使得每一维上样本方差都尽可能大。</li>
</ol>
<h3 id="4-2-3-算法描述"><a href="#4-2-3-算法描述" class="headerlink" title="4.2.3    算法描述"></a>4.2.3    算法描述</h3><ol>
<li>假设有$𝑛$个$𝑑$维样本数据所构成的集合$𝐷={x_1,x_2,…,x_n}$，其中$x_i(1≤i≤n)∈R^d$</li>
<li>集合$𝐷$可以表示成矩阵$X_{𝑛×𝑑}$<ol>
<li>假定每一维度的特征均值均为零（已经标准化）</li>
</ol>
</li>
<li>主成分分析的目的是求映射矩阵$W_{𝑑×𝑙}$<ol>
<li>给定一个样本$x<em>𝑖$，可将$x</em>𝑖 $从$𝑑$维空间如下映射到$𝑙$维空间： $(x<em>i)</em>{1×d}(W)_{d×l}$</li>
</ol>
</li>
<li>将所有降维后数据用$Y$表示，有$Y=XW$<ol>
<li>$Y$：降维结果，$n×l$</li>
<li>$X$：原始数据，$n×d$</li>
<li>$W$：映射矩阵，$d×l$</li>
</ol>
</li>
</ol>
<p>投影矩阵$W<em>{d×l}$为：协方差矩阵$\Sigma$前$l$个最大的特征根对应的特征向量$</em>{d×1}$组成的矩阵$_{d×l}$</p>
<p>最优方差为：协方差矩阵$\Sigma$前$l$个最大的特征根之和</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419113127137.png" alt="image-20230419113127137" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419113624996.png" alt="image-20230419113624996" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419113632079.png" alt="image-20230419113632079" style="zoom:80%;" /></p>
</blockquote>
<h3 id="4-2-4-其他常用降维方法"><a href="#4-2-4-其他常用降维方法" class="headerlink" title="4.2.4    其他常用降维方法"></a>4.2.4    其他常用降维方法</h3><ol>
<li>非负矩阵分解 NMF：non-negative matrix factorization</li>
<li>多为尺度法MDS：Metric multidimensional</li>
<li>局部先行嵌入LLE：Locally Linear Embedding</li>
</ol>
<h2 id="4-3-特征人脸方法"><a href="#4-3-特征人脸方法" class="headerlink" title="4.3    特征人脸方法"></a>4.3    特征人脸方法</h2><h3 id="4-3-1-动机"><a href="#4-3-1-动机" class="headerlink" title="4.3.1    动机"></a>4.3.1    动机</h3><ol>
<li>特征人脸方法是一种应用主成份分析来实现<strong>人脸图像降维</strong>的方法</li>
<li>其本质是用一种称为<strong>“特征人脸(eigenface)”</strong>的特征向量按照线性组合形式来表达每一张原始人脸图像，进而实现人脸识别</li>
<li>由此可见，这一方法的关键之处在于如何得到特征人脸</li>
<li>用特征人脸表示人脸，而非用像素点表示人脸</li>
</ol>
<h3 id="4-3-2-算法描述"><a href="#4-3-2-算法描述" class="headerlink" title="4.3.2    算法描述"></a>4.3.2    算法描述</h3><ol>
<li><p>将每幅人脸图像转化为列向量</p>
<ol>
<li>例如：将一幅32×32的人脸图像转化为1024×1的列向量</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419115115486.png" alt="image-20230419115115486" style="zoom:80%;" /></p>
</li>
<li><p>执行PCA特征降维</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419115230356.png" alt="image-20230419115230356" style="zoom:80%;" /></p>
</li>
<li><p>每个人脸特征向量$w_i$与原始人脸数据$x_i$的维数是一样的，均为$1024$</p>
</li>
<li><p>可将每个特征向量还原为𝟑𝟐×𝟑𝟐的人脸图像，称之为特征人脸，因此可得到$l$个特征人脸</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419115421635.png" alt="image-20230419115421635" style="zoom:80%;" /></p>
</li>
<li><p>将每幅人脸分别与特征人脸做矩阵乘法，得到一个相关系数</p>
</li>
<li><p>每幅人脸得到$l$个相关系数 =&gt; 每幅人脸从1024维约简到$l$维</p>
</li>
<li><p>由于每幅人脸是所有特征人脸的线性组合，因此就实现人脸从“像素点表达”到“特征人脸表达”的转变。每幅人脸从1024维约减到$l$维</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419120306729.png" alt="image-20230419120306729" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="4-3-3-其他人脸表达的方法：聚类、PCA、非负矩阵分解"><a href="#4-3-3-其他人脸表达的方法：聚类、PCA、非负矩阵分解" class="headerlink" title="4.3.3    其他人脸表达的方法：聚类、PCA、非负矩阵分解"></a>4.3.3    其他人脸表达的方法：聚类、PCA、非负矩阵分解</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230419120942125.png" alt="image-20230419120942125" style="zoom:80%;" /></p>
<h2 id="4-4-潜在语义分析"><a href="#4-4-潜在语义分析" class="headerlink" title="4.4    潜在语义分析"></a>4.4    潜在语义分析</h2><blockquote>
<p><strong>latent semantic analysis</strong>、<strong>latent semantic indexing</strong></p>
</blockquote>
<p><strong>潜在语义分析(LSA或LSI)</strong>：又叫隐形语义分析</p>
<ol>
<li>是一种从海量文本数据中学习<strong>单词-单词</strong>、<strong>单词-文档</strong>以及<strong>文档-文档</strong>之间隐性关系，进而得到<strong>文档和单词</strong>表达<strong>特征</strong>的方法</li>
<li><strong>基本思想</strong>：综合考虑某些单词在哪些文档中同时出现，以此来决定该词语的含义与其他的词语的相似度</li>
</ol>
<h3 id="4-4-1-潜在语义分析思想"><a href="#4-4-1-潜在语义分析思想" class="headerlink" title="4.4.1    潜在语义分析思想"></a>4.4.1    潜在语义分析思想</h3><ol>
<li>先构建一个<strong>单词-文档</strong>(term-document)<strong>矩阵A</strong></li>
<li>进而寻找该<strong>矩阵的低秩逼近</strong>(low rank approximation)，来挖掘<strong>单词-单词、单词-文档以及文档-文档</strong>之间的关联关系</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426101927415.png" alt="image-20230426101927415" style="zoom:80%;" /></p>
</blockquote>
<h3 id="4-4-2-分析过程"><a href="#4-4-2-分析过程" class="headerlink" title="4.4.2    分析过程"></a>4.4.2    分析过程</h3><ol>
<li><p>计算<strong>单词-文档矩阵：$A_{m×n}$</strong></p>
<ol>
<li>某个term在某个document中出现了几次，对应的值即为几</li>
<li>也可以统计：TF×iDF，TF在某个文章中出现的频率，DF在所有文章中出现的频率</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426101941266.png" alt="image-20230426101941266" style="zoom:80%;" /></p>
</li>
<li><p><strong>奇异值分解</strong>：$A<em>{m×n}=U</em>{m×r}D<em>{r×r}V^T</em>{r×n}$</p>
<ol>
<li>SVD分解：将矩阵$A<em>{m×n}$分解为三个矩阵的的乘积$U</em>{m×r}D<em>{r×r}V^T</em>{r×n}$</li>
<li>$D<em>{r×r}=diag(\sigma_1,\sigma_2,…,\sigma_r)$，是$A</em>{m×n}$的所有奇异值，也是$AA^T$特征值的非负平方根，满足$\sigma_1\ge\sigma_2\ge,…,\ge\sigma_r&gt;0$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426102742675.png" alt="image-20230426102742675" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426103032436.png" alt="image-20230426103032436" style="zoom:80%;" /></p>
</li>
<li><p><strong>重建矩阵</strong>：$A<em>{k}=U</em>{m×k}D<em>{k×k}V^T</em>{k×n}$</p>
<ol>
<li>选取前k个特征根及其对应的特征向量，对矩阵A进行重建</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426103044250.png" alt="image-20230426103044250" style="zoom:80%;" /></p>
</li>
<li><p><strong>挖掘语义关系</strong></p>
<ol>
<li>根据由主题重建出来的矩阵$A_k$，计算皮尔逊相关系数</li>
<li>通过分解和重建，可以将主题相关的两个文档之间的相关系数变得更大</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426103537877.png" alt="image-20230426103537877" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426103752281.png" alt="image-20230426103752281" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="4-5-期望最大化算法-EM"><a href="#4-5-期望最大化算法-EM" class="headerlink" title="4.5    期望最大化算法 EM"></a>4.5    期望最大化算法 EM</h2><blockquote>
<p><strong>expectation maximization</strong></p>
</blockquote>
<h3 id="4-5-1-模型参数估计"><a href="#4-5-1-模型参数估计" class="headerlink" title="4.5.1    模型参数估计"></a>4.5.1    模型参数估计</h3><ol>
<li><p>最大似然估计：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426104845910.png" alt="image-20230426104845910" style="zoom:80%;" /></p>
</li>
<li><p>最大后验估计：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426104854324.png" alt="image-20230426104854324" style="zoom:80%;" /></p>
</li>
<li><p>无论是最大似然估计算法或者是最大后验估计算法，都是充分利用已有数据，在<strong>参数模型确定</strong>（只是参数值未知）情况下，对所优化目标中的<strong>参数求导</strong>，<strong>令导数为0</strong>，求取模型的参数值</p>
</li>
<li><p>在解决一些具体问题时，难以事先就将模型确定下来，然后利用数据来求取模型中的参数值。在这样情况下，无法直接利用最大似然估计算法或者最大后验估计算法来求取模型参数</p>
</li>
</ol>
<h3 id="4-5-2-期望最大化算法"><a href="#4-5-2-期望最大化算法" class="headerlink" title="4.5.2    期望最大化算法"></a>4.5.2    期望最大化算法</h3><blockquote>
<p>Expectation Maximization</p>
</blockquote>
<ol>
<li>EM算法是一种重要的用于解决<strong>含有隐变量</strong>(latent variable)问题的<strong>参数估计方法</strong></li>
<li>EM算法分为<strong>求取期望</strong>(E步骤，expectation)和<strong>期望最大化</strong>(M步骤，maximization)两个步骤<ol>
<li>在EM算法的<strong>E步骤</strong>时，先假设模型参数的初始值，估计隐变量取值</li>
<li>在EM算法的<strong>M步骤</strong>时，基于观测数据、模型参数和隐变量取值一起来最大化“拟合”数据，更新模型参数</li>
<li>基于所更新的模型参数，得到新的隐变量取值(EM算法的 E 步)，然后继续极大化“拟合”数据，更新模型参数(EM算法的M步)</li>
<li>以此类推迭代，直到算法收敛，得到合适的模型参数</li>
</ol>
</li>
</ol>
<h3 id="4-5-3-EM示例：二硬币投掷例子"><a href="#4-5-3-EM示例：二硬币投掷例子" class="headerlink" title="4.5.3    EM示例：二硬币投掷例子"></a>4.5.3    EM示例：二硬币投掷例子</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110545341.png" alt="image-20230426110545341" style="zoom:80%;" /></p>
<p><strong>目标/模型参数</strong>：求A/B为正面的概率${\theta_A,\theta_B}$</p>
<p><strong>隐变量</strong>：某一轮是A投出的，还是B投出的</p>
<blockquote>
<p>初始化模型参数${\theta_A,\theta_B}$，即可得到得出某一轮结果是由A/B投出的概率</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426105838487.png" alt="image-20230426105838487" style="zoom:80%;" /></p>
<blockquote>
<p>然后即可得某一轮结果中，A/B投为正/反面的期望次数</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110335936.png" alt="image-20230426110335936" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110349882.png" alt="image-20230426110349882" style="zoom:80%;" /></p>
<blockquote>
<p>根据之前的计算结果，得出A/B投为正/反面的期望次数，从而更新A/B分别投正面的概率</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110256967.png" alt="image-20230426110256967" style="zoom:80%;" /></p>
<blockquote>
<p>不断迭代上述过程，直到算法收敛，就可以得到A/B投为正面的概率</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426110404057.png" alt="image-20230426110404057" style="zoom:80%;" /></p>
<h3 id="4-5-4-EM示例：三硬币投掷例子"><a href="#4-5-4-EM示例：三硬币投掷例子" class="headerlink" title="4.5.4    EM示例：三硬币投掷例子"></a>4.5.4    EM示例：三硬币投掷例子</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426112028228.png" alt="image-20230426112028228" style="zoom:80%;" /></p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426112208421.png" alt="image-20230426112208421" style="zoom:80%;" /></p>
</blockquote>
<p><strong>目标/模型参数</strong>：求0/1/2为正面的概率${\lambda,p_1,p_2}$</p>
<p><strong>隐变量</strong>：硬币0的投掷结果</p>
<blockquote>
<p>初始化模型参数${\lambda,p_1,p_2}$：通过假设每一次0号硬币的结果得出</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426112602109.png" alt="image-20230426112602109" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426112910620.png" alt="image-20230426112910620" style="zoom:80%;" /></p>
<blockquote>
<p>迭代更新模型参数值，直到收敛</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426113059647.png" alt="image-20230426113059647" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426113104146.png" alt="image-20230426113104146" style="zoom:80%;" /></p>
<h3 id="4-5-5-EM算法的一般形式"><a href="#4-5-5-EM算法的一般形式" class="headerlink" title="4.5.5    EM算法的一般形式"></a>4.5.5    EM算法的一般形式</h3><p>​    对n个相互独立的样本$X={x_1,x_2,…,x_n}$及其对应的隐变量$Z={z_1,z_2,…,z_n}$，在假设样本的模型参数为$\Theta$前提下，观测数据$x_i$的概率为$P(x_i|\Theta)$，完全数据$(x_i,z_i)$的<strong>似然函数</strong>为$P(x_i,z_i|\Theta)$</p>
<p>​    在这种表示基础上，优化目标为：求解合适的$\Theta$和$Z$，使得<strong>对数似然函数</strong>最大：</p>
<script type="math/tex; mode=display">
(\Theta,Z)=argmax_{\Theta,Z}L(\Theta,Z)=argmax_{\Theta,Z}\sum_{i=1}^nlog\sum_{z_i}P(x_i,z_i|\Theta)</script><p>​    但是，优化求解含有未观测数据Z的对数似然函数$L(\Theta,Z)$十分困难，EM算法不断构造对数似然函数$L(\Theta,Z)$的一个<strong>下界(E步骤)</strong>，然后<strong>最大化这个下界(M步骤)</strong>，以迭代方式逼近模型参数所能取得极大似然值</p>
<h1 id="五、深度学习"><a href="#五、深度学习" class="headerlink" title="五、深度学习"></a>五、深度学习</h1><h2 id="5-1-深度学习的历史发展"><a href="#5-1-深度学习的历史发展" class="headerlink" title="5.1    深度学习的历史发展"></a>5.1    深度学习的历史发展</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426115207956.png" alt="image-20230426115207956" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426115150060.png" alt="image-20230426115150060" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426115238544.png" alt="image-20230426115238544" style="zoom:80%;" /></p>
<h2 id="5-2-前馈神经网络-FNN"><a href="#5-2-前馈神经网络-FNN" class="headerlink" title="5.2    前馈神经网络 FNN"></a>5.2    前馈神经网络 FNN</h2><h3 id="5-2-1-浅层学习-vs-深层学习：分段学习-gt-逐层端到端学习"><a href="#5-2-1-浅层学习-vs-深层学习：分段学习-gt-逐层端到端学习" class="headerlink" title="5.2.1    浅层学习 vs 深层学习：分段学习=&gt;逐层端到端学习"></a>5.2.1    浅层学习 vs 深层学习：分段学习=&gt;逐层端到端学习</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426115528872.png" alt="image-20230426115528872" style="zoom:80%;" /></p>
<h3 id="5-2-2-深度学习：以端到端的方式逐层抽象、逐层学习"><a href="#5-2-2-深度学习：以端到端的方式逐层抽象、逐层学习" class="headerlink" title="5.2.2    深度学习：以端到端的方式逐层抽象、逐层学习"></a>5.2.2    深度学习：以端到端的方式逐层抽象、逐层学习</h3><ol>
<li>深度学习所得的模型可以视为一个复杂函数</li>
<li>非线性变换与映射的过程：像素点→语义</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514150442883.png" alt="image-20230514150442883" style="zoom:80%;" /></p>
<h3 id="5-2-3-MCP神经元"><a href="#5-2-3-MCP神经元" class="headerlink" title="5.2.3    MCP神经元"></a>5.2.3    MCP神经元</h3><ol>
<li>对n个输入数据$x_i$进行线性加权求和，然后利用函数$\Phi(·)$将结果映射为0/1</li>
<li>特点：<ol>
<li>可计算、清晰描述</li>
<li>既包含了物理反应(线性加权求和)，也包含了化学反应(阈值函数)</li>
</ol>
</li>
<li>缺点：<ol>
<li>权重$w_i$是人工定制的，没有通过数据驱动，没有学习的过程</li>
<li>阈值函数的阈值也是人工定制的</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230426121027846.png" alt="image-20230426121027846" style="zoom:80%;" /></p>
<h3 id="5-2-3-激活函数：对输入信息进行非线性变换"><a href="#5-2-3-激活函数：对输入信息进行非线性变换" class="headerlink" title="5.2.3    激活函数：对输入信息进行非线性变换"></a>5.2.3    激活函数：对输入信息进行非线性变换</h3><h4 id="5-2-3-1-常用激活函数：sigmoid、tanh、ReLU"><a href="#5-2-3-1-常用激活函数：sigmoid、tanh、ReLU" class="headerlink" title="5.2.3.1    常用激活函数：sigmoid、tanh、ReLU"></a>5.2.3.1    常用激活函数：sigmoid、tanh、ReLU</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514151508626.png" alt="image-20230514151508626" style="zoom:80%;" /></p>
<h4 id="5-2-3-2-softmax函数：将输出映射到-0-1-概率空间"><a href="#5-2-3-2-softmax函数：将输出映射到-0-1-概率空间" class="headerlink" title="5.2.3.2    softmax函数：将输出映射到[0,1]概率空间"></a>5.2.3.2    softmax函数：将输出映射到[0,1]概率空间</h4><script type="math/tex; mode=display">
y_i=softmax(x_i)=\frac{e^{x_i}}{\sum_{j=1}^k e^{x_j}}</script><ol>
<li>将输入数据$x_i$映射到[0, 1]的概率空间，用于刻画每个输入的<strong>相对重要程度</strong></li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514151849630.png" alt="image-20230514151849630" style="zoom:80%;" /></p>
</blockquote>
<h3 id="5-2-4-单个神经元的功能：加权累加-非线性变换"><a href="#5-2-4-单个神经元的功能：加权累加-非线性变换" class="headerlink" title="5.2.4    单个神经元的功能：加权累加 + 非线性变换"></a>5.2.4    单个神经元的功能：加权累加 + 非线性变换</h3><p><strong>参数是学习出来的</strong></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514152116968.png" alt="image-20230514152116968" style="zoom:80%;" /></p>
<h3 id="5-2-5-损失函数-Loss-Function"><a href="#5-2-5-损失函数-Loss-Function" class="headerlink" title="5.2.5    损失函数 Loss Function"></a>5.2.5    损失函数 Loss Function</h3><p><strong>损失函数</strong>：又称为<strong>代价函数</strong>(Cost Function)</p>
<ol>
<li>用来计算<strong>模型预测值</strong>与<strong>真实值</strong>之间的<strong>误差</strong></li>
<li>损失函数是神经网络设计中的一个重要组成部分，通过定义与任务相关的良好损失函数，在训练过程中可根据损失函数来计算神经网络的误差大小，进而优化神经网络参数</li>
</ol>
<p>两种最常用损失函数：</p>
<ol>
<li>均方误差损失函数</li>
<li>交叉熵损失函数</li>
</ol>
<h4 id="5-2-5-1-均方误差损失-MSE：预测值和实际值之间的差"><a href="#5-2-5-1-均方误差损失-MSE：预测值和实际值之间的差" class="headerlink" title="5.2.5.1    均方误差损失 MSE：预测值和实际值之间的差"></a>5.2.5.1    均方误差损失 MSE：预测值和实际值之间的差</h4><p>均方误差损失函数：</p>
<ol>
<li>计算预测值和实际值之间的<strong>距离</strong>(即误差)<strong>的平方</strong>，衡量模型的优劣</li>
<li>设有n个训练数据$x_i$，每个训练数据的真实输出为$y_i$，模型对$x_i$的预测为$\hat{y_i}$，则该模型在n个训练数据下产生的均方误差损失为：</li>
</ol>
<script type="math/tex; mode=display">
MSE=\frac{1}{n}\sum_{i=1}^n(y_i-\hat{y_i})^2</script><h4 id="5-2-5-2-交叉熵损失函数：两个概率分布之间的距离"><a href="#5-2-5-2-交叉熵损失函数：两个概率分布之间的距离" class="headerlink" title="5.2.5.2    交叉熵损失函数：两个概率分布之间的距离"></a>5.2.5.2    交叉熵损失函数：两个概率分布之间的距离</h4><p>交叉熵(cross entropy)：</p>
<ol>
<li>交叉熵刻画了<strong>两个概率分布之间的距离</strong>，旨在描绘通过概率分布q来表达概率分布p的困难程度</li>
<li><strong>交叉熵越小，两个概率分布p和q越接近</strong></li>
<li>设p和q是数据x的两个概率分布，则<strong>通过q来表示p的交叉熵</strong>为：</li>
</ol>
<script type="math/tex; mode=display">
H(p,q)=-\sum_x p(x)*\log q(x)</script><blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514153303851.png" alt="image-20230514153303851" style="zoom:80%;" /></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194138200.png" alt="image-20230514194138200" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194151894.png" alt="image-20230514194151894" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194235428.png" alt="image-20230514194235428" style="zoom:80%;" /></p>
<h3 id="5-2-6-感知机模型"><a href="#5-2-6-感知机模型" class="headerlink" title="5.2.6    感知机模型"></a>5.2.6    感知机模型</h3><h4 id="5-2-6-1-单层感知机"><a href="#5-2-6-1-单层感知机" class="headerlink" title="5.2.6.1    单层感知机"></a>5.2.6.1    单层感知机</h4><ol>
<li>早期的感知机结构和MCP模型相似，由一个输入层和一个输出层构成，因此也被称为“单层感知机”</li>
<li>感知机的输入层负责接收实数值的输入向量，输出层则能输出1或-1两个值</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514153853900.png" alt="image-20230514153853900" style="zoom:80%;" /></p>
<ol>
<li>单层感知机可被用来<strong>区分线性可分数据</strong></li>
<li>在下图中，AND、NAND和OR为线性可分函数，所以可利用单层感知机来模拟这些逻辑函数</li>
<li>但是，由于XOR是非线性可分的逻辑函数，因此单层感知机无法模拟逻辑异或函数的功能</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514154041975.png" alt="image-20230514154041975" style="zoom:80%;" /></p>
<h4 id="5-2-6-2-多层感知机-前馈神经网络-FNN"><a href="#5-2-6-2-多层感知机-前馈神经网络-FNN" class="headerlink" title="5.2.6.2    多层感知机/前馈神经网络(FNN)"></a>5.2.6.2    多层感知机/前馈神经网络(FNN)</h4><p><strong>多层感知机</strong>：由<strong>输入层</strong>、<strong>输出层</strong>和至少一层的<strong>隐藏层</strong>构成</p>
<ol>
<li>网络中各个隐藏层中神经元可接收相邻<strong>前序隐藏层</strong>中<strong>所有神经元</strong>传递而来的信息，经过加工处理后将信息输出给相邻<strong>后续隐藏层</strong>中<strong>所有神经元</strong></li>
<li>各个神经元接受前一级的输入，并输出到下一级，模型中没有反馈</li>
<li>层与层之间通过“<strong>全连接</strong>”进行链接，即两个相邻层之间的神经元完全成对连接，但层内的神经元不相互连接</li>
<li><strong>前馈神经网络 feedforward neural network</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514154308251.png" alt="image-20230514154308251" style="zoom:80%;" /></p>
<h3 id="5-2-7-参数优化"><a href="#5-2-7-参数优化" class="headerlink" title="5.2.7    参数优化"></a>5.2.7    参数优化</h3><blockquote>
<p><strong>目标：最小化损失函数</strong></p>
</blockquote>
<h4 id="5-2-7-1-梯度下降-Gradient-Descent"><a href="#5-2-7-1-梯度下降-Gradient-Descent" class="headerlink" title="5.2.7.1    梯度下降 Gradient Descent"></a>5.2.7.1    梯度下降 Gradient Descent</h4><p><strong>梯度</strong>：</p>
<ol>
<li><p><strong>一元变量</strong>所构成的函数$f$在$x$处的梯度为：</p>
<script type="math/tex; mode=display">
\frac{df(x)}{dx}=\lim_{h→0} \frac{f(x+h)-f(x)}{h}</script></li>
<li><p>在<strong>多元函数</strong>中，梯度是对<strong>每一变量所求导数</strong>组成的<strong>向量</strong></p>
</li>
<li><p><strong>梯度的反方向</strong>是函数值下降最快的方向，因此是损失函数求解的方向</p>
</li>
<li><p>在实际中，引入<strong>步长η(为定值)</strong>，用$x-η𝜵f(x)$来更新$x$</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514191448977.png" alt="image-20230514191448977" style="zoom:80%;" /></p>
<blockquote>
<p><strong>证明过程</strong>：</p>
<ol>
<li><p>设损失函数$f(x)$是连续可微的多元变量函数，其泰勒展开为：</p>
<script type="math/tex; mode=display">
f(x+Δx) = f(x) + f'(x)Δx + \frac{1}{2}f''(x)(Δx)^2+...+\frac{1}{n!}f^{(n)}(Δx)^n\\
f(x+Δx) - f(x) ≈ (𝜵f(x))^TΔx</script></li>
<li><p>因为我们的目的是最小化损失函数$f(x)$，则$f(x+Δx) &lt; f(x)$，即$(𝜵f(x))^TΔx&lt;0$</p>
</li>
<li><p>在$(𝜵f(x))^TΔx = |𝜵f(x)||Δx|cosθ$中，$|𝜵f(x)|$为损失函数梯度的模，$|Δx|$为下一轮迭代中x取值增量的模，两者均为正数。为了保证损失误差减少，只要保证$cos θ&lt;0$</p>
</li>
<li><p>当$θ = 180°$时，$cos θ=-1$，此时损失函数减少的幅度值$(𝜵f(x))^TΔx$取到最小值</p>
</li>
<li><p>因此$Δx$的选取应该为$𝜵f(x)$的<strong>反方向</strong></p>
</li>
</ol>
</blockquote>
<h4 id="5-2-7-2-误差反向传播-BP"><a href="#5-2-7-2-误差反向传播-BP" class="headerlink" title="5.2.7.2    误差反向传播 BP"></a>5.2.7.2    误差反向传播 BP</h4><blockquote>
<p><strong>Error Back Propagation</strong></p>
</blockquote>
<ol>
<li>BP算法是一种将<strong>输出层误差</strong>反向传播给<strong>隐藏层</strong>进行<strong>参数更新</strong>的方法</li>
<li>将误差从后向前传递，将误差分摊给各层所有单元，从而获得各层单元所产生的误差，进而依据这个误差来让各层单元负起各自责任、修正各单元参数</li>
<li>每个参数经过误差反向传播后，新的参数值为：</li>
</ol>
<script type="math/tex; mode=display">
\begin{aligned}
w^{new}    &=    w_1-η×\frac{\partial{\mathcal{L}}}{\partial{w_1}}\\
        &=    w_1-η×\frac{d\mathcal{L}}{d\mathcal{O}}×\frac{d\mathcal{O}}{d\mathcal{X}}×\frac{d\mathcal{X}}{d\mathcal{w_1}}\\
        &=    w_1-η×\frac{d\mathcal{L}}{d\mathcal{O}}×\frac{1}{1+e^{-x}}×(1-\frac{1}{1+e^{-x}})×out_1
\end{aligned}</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514191608315.png" alt="image-20230514191608315" style="zoom:80%;" /></p>
<h4 id="5-2-7-3-链式求导法则"><a href="#5-2-7-3-链式求导法则" class="headerlink" title="5.2.7.3    链式求导法则"></a>5.2.7.3    链式求导法则</h4><ol>
<li>由于$w_1$与加权累加函数$\mathcal{X}$和<strong>sigmoid</strong>函数均有关，因此$\frac{d\mathcal{L}}{dw_1}=\frac{d\mathcal{L}}{d\mathcal{O}}·\frac{d\mathcal{O}}{d\mathcal{X}}·\frac{d\mathcal{X}}{d\mathcal{w_1}}$</li>
<li>在这个链式求导中：<ol>
<li>$\frac{d\mathcal{L}}{d\mathcal{O}}$：与损失函数的定义有关</li>
<li>$\frac{d\mathcal{O}}{d\mathcal{X}}$：是对<strong>sigmoid</strong>函数求导，结果为$\frac{1}{1+e^{-x}}·(1-\frac{1}{1+e^{-x}})$</li>
<li>$\frac{d\mathcal{X}}{dw<em>1}$：是加权累加函数$\sum</em>{i=1}^n w_i·out_i$，结果为$out_i$</li>
</ol>
</li>
<li>链式求导实现了<strong>损失函数对某个自变量求偏导</strong>，好比将损失误差从输出端向输入端逐层传播，通过这个传播过程来更新该自变量取值。梯度下降法告诉我们，只要沿着损失函数梯度的反方向来更新参数，就可使得损失函数下降最快</li>
</ol>
<h3 id="5-2-8-机器学习的能力在于拟合和优化"><a href="#5-2-8-机器学习的能力在于拟合和优化" class="headerlink" title="5.2.8    机器学习的能力在于拟合和优化"></a>5.2.8    机器学习的能力在于拟合和优化</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194017518.png" alt="image-20230514194017518" style="zoom:80%;" /></p>
<h2 id="5-3-卷积神经网络-CNN"><a href="#5-3-卷积神经网络-CNN" class="headerlink" title="5.3    卷积神经网络 CNN"></a>5.3    卷积神经网络 CNN</h2><blockquote>
<p><strong>convolution neural network</strong></p>
</blockquote>
<p>CNN引入了一个卷积层，将原始图像先经过一次卷积(即下采样)，然后再送入FNN进行学习</p>
<ol>
<li><strong>CNN = 卷积层 + 池化层 + 全连接层 + Softmax激活函数</strong></li>
</ol>
<h3 id="5-3-1-卷积操作：线性操作"><a href="#5-3-1-卷积操作：线性操作" class="headerlink" title="5.3.1    卷积操作：线性操作"></a>5.3.1    卷积操作：线性操作</h3><h4 id="5-3-1-1-卷积核的权重是通过学习得出的"><a href="#5-3-1-1-卷积核的权重是通过学习得出的" class="headerlink" title="5.3.1.1    卷积核的权重是通过学习得出的"></a>5.3.1.1    卷积核的权重是通过学习得出的</h4><ol>
<li><strong>图像</strong>中像素点具有很强的<strong>空间依赖性</strong>，卷积就是针对像素点的空间依赖性来对图像进行处理的一种技术</li>
<li>在图像卷积计算中，需要定义一个<strong>卷积核(kernel)</strong><ol>
<li>卷积核是一个<strong>二维矩阵</strong></li>
<li><strong>矩阵中数值</strong>为对图像中与卷积核同样大小的子块像素点进行卷积计算时所采用的<strong>权重</strong></li>
<li>卷积核中的<strong>权重系数w~i~</strong>是通过数据驱动机制<strong>学习</strong>得到，其用来捕获图像中某像素点及其邻域像素点所构成的特有空间模式</li>
<li>一旦从数据中学习得到权重系数，这些<strong>权重系数</strong>就刻画了<strong>图像中像素点构成的空间分布不同模式</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514194854168.png" alt="image-20230514194854168" style="zoom:80%;" /></p>
</blockquote>
<h4 id="5-3-1-2-对图像进行卷积操作"><a href="#5-3-1-2-对图像进行卷积操作" class="headerlink" title="5.3.1.2    对图像进行卷积操作"></a>5.3.1.2    对图像进行卷积操作</h4><ol>
<li>如果卷积核中心位置的权重系数越小且与其它卷积权重系数差别越小，则卷积所得到图像滤波结果越模糊，这被称为<strong>图像平滑操作</strong></li>
<li><strong>7×7</strong>大小的图像，通过<strong>3×3大小卷积核</strong>以<strong>1的步长</strong>进行卷积操作，可得到<strong>5×5</strong>大小的卷积结果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514195631109.png" alt="image-20230514195631109" style="zoom:80%;" /></p>
<h4 id="5-3-1-3-卷积核、特征图、感受野"><a href="#5-3-1-3-卷积核、特征图、感受野" class="headerlink" title="5.3.1.3    卷积核、特征图、感受野"></a>5.3.1.3    卷积核、特征图、感受野</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514195930797.png" alt="image-20230514195930797" style="zoom:80%;" /></p>
<h3 id="5-3-2-池化操作：非线性操作"><a href="#5-3-2-池化操作：非线性操作" class="headerlink" title="5.3.2    池化操作：非线性操作"></a>5.3.2    池化操作：非线性操作</h3><ol>
<li>进一步进行<strong>下采样</strong>操作</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514200028614.png" alt="image-20230514200028614" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514200107035.png" alt="image-20230514200107035" style="zoom:80%;" /></p>
<h3 id="5-3-3-神经网络正则化：解决过拟合问题"><a href="#5-3-3-神经网络正则化：解决过拟合问题" class="headerlink" title="5.3.3    神经网络正则化：解决过拟合问题"></a>5.3.3    神经网络正则化：解决过拟合问题</h3><p>为了缓解神经网络在训练过程中出现的<strong>过拟合</strong>问题，需要采取一些<strong>正则化技术</strong>来提升神经网络的<strong>泛化能力</strong>(generalization) </p>
<ol>
<li><p><strong>Dropout</strong>：随机删除一定比例的连接</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514200437118.png" alt="image-20230514200437118" style="zoom:67%;" /></p>
</li>
<li><p><strong>Batch-Normalization</strong>：一次送入一批图像，而不是一张图像，一批图像之间有一定的关联度</p>
</li>
<li><p><strong>L1-Norm &amp; L2-Norm</strong>：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514200544741.png" alt="image-20230514200544741" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="5-4-循环神经网络-RNN"><a href="#5-4-循环神经网络-RNN" class="headerlink" title="5.4    循环神经网络 RNN"></a><strong>5.4    循环神经网络 RNN</strong></h2><p>循环神经网络：处理<strong>序列数据</strong>时所采用的网络结构</p>
<ol>
<li>先前所介绍的前馈神经网络或卷积神经网络所需要处理的输入数据一次性给定，难以处理存在前后依赖关系的数据</li>
<li>循环神经网络的本质是希望模拟人所具有的记忆能力，在学习过程中<strong>记住部分已经出现的信息</strong>，并利用所记住的信息影响后续结点输出</li>
<li>循环神经网络在自然语言处理，例如语音识别、情感分析、机器翻译等领域有重要应用</li>
</ol>
<h3 id="5-4-1-RNN的结构"><a href="#5-4-1-RNN的结构" class="headerlink" title="5.4.1    RNN的结构"></a>5.4.1    RNN的结构</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514214259608.png" alt="image-20230514214259608" style="zoom:80%;" /></p>
<ol>
<li><p>循环神经网络在处理数据过程中构成了一个循环体</p>
<ol>
<li>对于一个序列数据，在每一时刻$t$，循环神经网络单元会读取当前输入数据$x<em>t$和前一时刻输入数据$x</em>{t−1}$所对应的隐式编码结果$h_{t−1}$，一同生成$t$时刻的隐式编码结果$h_t$</li>
<li>接着将$h<em>t$后传，去参与生成$t+1$时刻输入数据$x</em>{t+1}$的隐式编码$h_{t+1}$</li>
</ol>
</li>
<li><p><strong>时刻$t$所得到的隐式编码$h<em>t$是由上一时刻隐式编码$h</em>{t-1}$和当前输入$x_t$共同参与生成的</strong></p>
<ol>
<li>这可认为隐式编码$h_{t-1}$已经“记忆”了$t$时刻之前的时序信息，或者说前序时刻信息影响了后续时刻信息的处理</li>
<li>与前馈神经网络和卷积神经网络在处理时需要将所有数据一次性输入不同，这体现了循环神经网络可刻画<strong>序列数据存在时序依赖</strong>这一重要特点</li>
</ol>
</li>
<li><p>在时刻$t$，一旦得到当前输入数据$x<em>t$，RNN会结合前一时刻的隐式编码$h</em>{t-1}$，生成当前时刻的隐式编码$h_t$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
h_t    &=    \Phi(U×x_t+W×h_{t-1}) \\
    &=    \Phi(U×x_t+W×\Phi(U×x_{t-1}+W×h_{t-2})) \\
    &=    \Phi(U×x_t+W×\Phi(U×x_{t-1}+W×\Phi(U×x_{t-2}+...))))
\end{aligned}</script><ol>
<li>$\Phi(·)$：激活函数，一般为Sigmoid或Tanh，使模型能够忘掉一些信息，同时更新记忆内容</li>
<li>$U、W$：模型参数，对于每一时刻都是共用的</li>
</ol>
</li>
</ol>
<h3 id="5-4-2-沿时间反向传播算法-BPTT"><a href="#5-4-2-沿时间反向传播算法-BPTT" class="headerlink" title="5.4.2    沿时间反向传播算法 BPTT"></a>5.4.2    沿时间反向传播算法 BPTT</h3><blockquote>
<p><strong>Back Propagation Through Time</strong></p>
</blockquote>
<h4 id="5-4-2-1-思想"><a href="#5-4-2-1-思想" class="headerlink" title="5.4.2.1    思想"></a>5.4.2.1    思想</h4><ol>
<li>按照时间将RNN展开后，可以得到一个和FNN相似的网络结构</li>
<li>这个网络结构可以利用BP和Gradient Descent算法来训练模型参数，这种训练方法被称为<strong>BPTT</strong></li>
<li>由于RNN每一时刻都有一个输出，因此在计算RNN的损失时，需要将所有时刻上的损失进行累加</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514220258231.png" alt="image-20230514220258231" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514220315167.png" alt="image-20230514220315167" style="zoom:80%;" /></p>
</blockquote>
<h4 id="5-4-2-2-算法"><a href="#5-4-2-2-算法" class="headerlink" title="5.4.2.2    算法"></a>5.4.2.2    算法</h4><ol>
<li><p>设时刻$t$隐式编码如下得到：</p>
<script type="math/tex; mode=display">
h_t=tanh(W_xt_x+W_hh_{t-1}+b)</script></li>
<li><p>使用交叉熵损失函数计算时刻$t$预测输出与实际输出的误差为$E_t$，则整个序列产生的误差为：</p>
<script type="math/tex; mode=display">
E=\frac{1}{2}\sum_{t=1}^T E_t</script></li>
<li><p>根据时刻$t$所得到的误差来更新参数$W_x$的方法为：</p>
<ol>
<li>在时刻$t$计算所得的$O_t$不仅涉及到了$t$时刻的$W_x$，而且也涉及了前面所有时刻的$W_x$</li>
<li>按照链式求导法则，$E_t$对$W_x$求导时，也需要对前面时刻的$W_x$依次求导，然后再将求导结构进行累加，即：</li>
</ol>
<script type="math/tex; mode=display">
\frac{\partial E_t}{\partial W_x}=\sum_{i=1}^y \frac{dE_t}{dO_t}·\frac{dO_t}{dh_t}·(\prod_{j=i+1}^t \frac{dh_j}{dh_{j-1}})·\frac{dh_i}{dW_x}\\
其中, \prod_{j=i+1}^t \frac{dh_j}{dh_{j-1}}=\prod_{j=i+1}^t tanh'×W_h</script></li>
<li><p>令$t=3$，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial E_3}{\partial W_x}&=\frac{dE_3}{dO_3}·\frac{dO_3}{dh_3}·\frac{dh_3}{dW_x}\\
&+\frac{dE_3}{dO_3}·\frac{dO_3}{dh_3}·\frac{dh_3}{dh_2}·\frac{dh_2}{dW_x}\\
&+\frac{dE_3}{dO_3}·\frac{dO_3}{dh_3}·\frac{dh_3}{dh_2}·\frac{dh_2}{dh_1}·\frac{dh_1}{dW_x}
\end{aligned}</script></li>
<li><p>由于tanh函数的导数取值位于[0,1]区间，对于长序列而言，若干个[0,1]区间的小数相乘，会使得参数求导结果很小，引发<strong>梯度消失</strong>问题。$E_t$对$W_h$的求导类似。</p>
</li>
<li><p>为了解决梯度消失问题，提出了<strong>长短时记忆模型(LSTM)</strong></p>
</li>
</ol>
<h4 id="5-4-2-3-应用"><a href="#5-4-2-3-应用" class="headerlink" title="5.4.2.3    应用"></a>5.4.2.3    应用</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514221952266.png" alt="image-20230514221952266" style="zoom:80%;" /></p>
<h3 id="5-4-3-长短时记忆模型-LSTM：解决RNN梯度消失的问题"><a href="#5-4-3-长短时记忆模型-LSTM：解决RNN梯度消失的问题" class="headerlink" title="5.4.3    长短时记忆模型 LSTM：解决RNN梯度消失的问题"></a>5.4.3    长短时记忆模型 LSTM：解决RNN梯度消失的问题</h3><blockquote>
<p><strong>Long-Short-Term-Memory</strong></p>
</blockquote>
<h4 id="5-4-3-1-思想"><a href="#5-4-3-1-思想" class="headerlink" title="5.4.3.1    思想"></a>5.4.3.1    思想</h4><p>LSTM网络中引入了<strong>内部记忆单元(internal memory cell)</strong>和<strong>门(gates)</strong>两种结构来对当前时刻输入信息以及前序时刻所生成信息进行整合和传递</p>
<ol>
<li>在这里，内部记忆单元中信息可视为对“历史信息”的累积</li>
<li>常见的LSTM模型中有<strong>输入门(input gate)</strong>、<strong>遗忘门(forget gate)</strong>和<strong>输出门(output gate)</strong>三种门结构</li>
<li>对于给定的当前时刻输入数据$x<em>t$和前一时刻隐式编码$h</em>{t-1}$，输入门、遗忘门和输出门通过各自参数对其编码，分别得到三种门结构的输出$i_t, f_t, o_t$</li>
<li>在此基础上，再进一步结合前一时刻内部记忆单元信息$c_{t-1}$来更新当前时刻内部记忆单元信息$c_t$，最终得到当前时刻的隐式编码$h_t$</li>
<li>$h_t$对应短期记忆，$c_t$对应长期记忆<ol>
<li>RNN直接传递短期记忆，因此容易遗忘</li>
<li>而LSTM通过门的作用，将短期记忆转化为长期记忆，因此记忆能力更强</li>
</ol>
</li>
</ol>
<h4 id="5-4-3-2-符号定义"><a href="#5-4-3-2-符号定义" class="headerlink" title="5.4.3.2    符号定义"></a>5.4.3.2    符号定义</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230514223119712.png" alt="image-20230514223119712" style="zoom:80%;" /></p>
<ol>
<li>输入门、遗忘门和输出门通过各自参数对当前时刻输入数据$x<em>𝑡$和前一时刻隐式编码$h</em>{t-1}$处理后，利用$𝑠𝑖𝑔𝑚𝑜𝑖𝑑$对处理结果进行非线性映射，因此三种门结构的输出$i_t,f_t,o_t \in(0,1)$</li>
<li>正是由于三个门结构的输出值为位于0到1之间的向量，因此其在信息处理中起到了“调控开关”的“门”作用</li>
<li>三个门结构所输出向量的维数、内部记忆单元的维数和隐式编码的维数均相等</li>
</ol>
<h4 id="5-4-3-3-LSTM结构"><a href="#5-4-3-3-LSTM结构" class="headerlink" title="5.4.3.3    LSTM结构"></a>5.4.3.3    LSTM结构</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515001733288.png" alt="image-20230515001733288" style="zoom:80%;" /></p>
<ol>
<li>在每个时刻$t$<ol>
<li>包含序列信息的变量为：$c_t，h_t$</li>
<li>输出为$t$时刻的隐式编码：$h_t=o_t⊙tanh(c_t)$</li>
</ol>
</li>
<li>LSTM中的参数有：<ol>
<li>输入门$i<em>t$的参数：  $W</em>{xi},W<em>{hi},b_i → i_t=sigmoid(W</em>{xi}x<em>t+W</em>{hi}h_{t-1}+b_i)$</li>
<li>遗忘门$f<em>t$的参数： $W</em>{xf},W<em>{hf},b_f→ f_t=sigmoid(W</em>{xf}x<em>t+W</em>{hf}h_{t-1}+b_f)$</li>
<li>输出门$o<em>t$的参数： $W</em>{xo},W<em>{ho},b_o→ o_t=sigmoid(W</em>{xo}x<em>t+W</em>{ho}h_{t-1}+b_o)$</li>
<li>内部记忆单元$c<em>t$的参数：$W</em>{xc},W_{hc},b_c$</li>
</ol>
</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515191651335.png" alt="image-20230515191651335" style="zoom:80%;" /></p>
</blockquote>
<ol>
<li>从$c<em>t=f_t⊙c</em>{t-1}+i<em>t⊙tanh(W</em>{xc}x<em>t+W</em>{hc}h_{t-1}+b_c)$可以得出，对于当前时刻$t$所对应内部记忆单元种信息的调整，涉及到：<ol>
<li>遗忘门信息$f_t$</li>
<li>$t-1$时刻所对应内部记忆单元中的信息$c_{t-1}$</li>
<li>输入门信息$i_t$</li>
<li>$t-1$时刻的隐式编码$h_{t-1}$</li>
</ol>
</li>
<li>$sigmoid(x)\in(0,1)$：因此输入门、输出门、遗忘门三种门结构起到了信息控制门的作用</li>
<li>$tanh(x)\in(-1,1)$：因此内部记忆单元$c_t$、隐式编码$h_t$在进行信息整合时，可以起到信息增(为正)或信息减(为负)的效果</li>
</ol>
<h4 id="5-4-3-4-LSTM如何克服梯度消失"><a href="#5-4-3-4-LSTM如何克服梯度消失" class="headerlink" title="5.4.3.4    LSTM如何克服梯度消失"></a>5.4.3.4    LSTM如何克服梯度消失</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515193712715.png" alt="image-20230515193712715" style="zoom:80%;" /></p>
<h3 id="5-4-4-GRU门控循环单元神经网络"><a href="#5-4-4-GRU门控循环单元神经网络" class="headerlink" title="5.4.4    GRU门控循环单元神经网络"></a>5.4.4    GRU门控循环单元神经网络</h3><p>与LSTM类似，引入<strong>门结构</strong>解决梯度消失问题</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515193901099.png" alt="image-20230515193901099" style="zoom:80%;" /></p>
<h2 id="不考-5-5-深度生成学习"><a href="#不考-5-5-深度生成学习" class="headerlink" title="(不考)5.5    深度生成学习"></a>(不考)5.5    深度生成学习</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515194317721.png" alt="image-20230515194317721" style="zoom:80%;" /></p>
<ol>
<li>在本章之前的介绍中，神经网络模型从数据中提取出高层语义在数据中所蕴含的<strong>“模式”</strong>，并利用这些模式实现<strong>对数据的分类和检测</strong>等，这种模型通常称为<strong>判别模型</strong>：判别模型不关心数据如何生成，它只关心数据蕴含哪些模式以及如何将数据进行分类</li>
<li>与之相对的模型类型被称为<strong>生成模型(generative model)</strong>：生成模型需要学习目标数据的分布规律，以<strong>合成</strong>属于目标数据空间的<strong>新数据</strong></li>
<li>生成模型代表：<ol>
<li>变分自编码器(variational auto-encoder, VAE)</li>
<li>自回归模型(Autoregressive models)</li>
<li>生成对抗网络（generative adversarial network，GAN）</li>
</ol>
</li>
</ol>
<h2 id="5-6-深度学习应用"><a href="#5-6-深度学习应用" class="headerlink" title="5.6    深度学习应用"></a>5.6    深度学习应用</h2><h3 id="5-6-1-自然语言中词向量生成"><a href="#5-6-1-自然语言中词向量生成" class="headerlink" title="5.6.1    自然语言中词向量生成"></a>5.6.1    自然语言中词向量生成</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515195126133.png" alt="image-20230515195126133" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515195158097.png" alt="image-20230515195158097" style="zoom:80%;" /></p>
<h3 id="5-6-2-Word2Vec模型"><a href="#5-6-2-Word2Vec模型" class="headerlink" title="5.6.2    Word2Vec模型"></a>5.6.2    Word2Vec模型</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515195221719.png" alt="image-20230515195221719" style="zoom:80%;" /></p>
<ol>
<li><p>假设词典中有$V$个不同的单词，现在考虑如何生成第$k$个单词的$N$维词向量</p>
<ol>
<li>首先，将该单词表示成$V$维<strong>one-hot向量</strong>$X$，向量$X$中第$k$个位置取值为1、其余位置取值均为0，one-hot向量$X$表示词典中的一个单词</li>
<li>隐藏层神经元大小为$N$，每个神经元记为$h_i (1≤i≤N)$</li>
<li>向量$X$中每个$x<em>i (1≤i≤V)$与隐藏层神经元是全连接，连接权重矩阵为$W</em>{V×N}$</li>
<li>输出层是$V$维归一化的概率值，其中$y_k$对应第$k$个单词归一化的概率值，显然其取值应该远大于其它输出所对应的归一化概率值</li>
</ol>
</li>
<li><p>因此，某个输入单词对应的$N$维词向量为：$[w<em>{k1},w</em>{k2},…,w_{kN}]$</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515200909879.png" alt="image-20230515200909879" style="zoom:80%;" /></p>
</blockquote>
</li>
<li><p>训练词向量模型的目标为：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515200951193.png" alt="image-20230515200951193" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="5-6-3-CBOW模型：通过上下文预测单词"><a href="#5-6-3-CBOW模型：通过上下文预测单词" class="headerlink" title="5.6.3    CBOW模型：通过上下文预测单词"></a>5.6.3    CBOW模型：通过上下文预测单词</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515201117406.png" alt="image-20230515201117406" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515201230336.png" alt="image-20230515201230336" style="zoom:80%;" /></p>
<h3 id="5-6-4-图像分类和目标定位"><a href="#5-6-4-图像分类和目标定位" class="headerlink" title="5.6.4    图像分类和目标定位"></a>5.6.4    图像分类和目标定位</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230515201257374.png" alt="image-20230515201257374" style="zoom:80%;" /></p>
<h1 id="六、强化学习"><a href="#六、强化学习" class="headerlink" title="六、强化学习"></a>六、强化学习</h1><h2 id="6-1-强化学习问题定义"><a href="#6-1-强化学习问题定义" class="headerlink" title="6.1    强化学习问题定义"></a>6.1    强化学习问题定义</h2><h3 id="6-1-1-强化学习中的概念"><a href="#6-1-1-强化学习中的概念" class="headerlink" title="6.1.1    强化学习中的概念"></a>6.1.1    强化学习中的概念</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517103207132.png" alt="image-20230517103207132" style="zoom:80%;" /></p>
<ol>
<li><strong>智能体（agent）</strong>：智能体是强化学习算法的主体，它能够根据经验做出主观判断并执行动作，是整个智能系统的核心</li>
<li><strong>环境（environment）</strong>：智能体以外的一切统称为环境，环境在与智能体的交互中，能被智能体所采取的动作影响，同时环境也能向智能体反馈状态和奖励</li>
<li><strong>状态（state）</strong>：状态可以理解为智能体对环境的一种理解和编码，通常包含了对智能体所采取决策产生影响的信息</li>
<li><strong>动作（action）</strong>：动作是智能体对环境产生影响的方式</li>
<li><strong>策略（policy）</strong>：策略是智能体在所处状态下去执行某个动作的依据，即给定一个状态，智能体可根据一个策略来选择应该采取的动作</li>
<li><strong>奖励（reward）</strong>：奖励是智能体序贯式采取一系列动作后从环境获得的收益</li>
</ol>
<h3 id="6-1-2-强化学习的特点"><a href="#6-1-2-强化学习的特点" class="headerlink" title="6.1.2    强化学习的特点"></a>6.1.2    强化学习的特点</h3><ol>
<li><strong>基于评估</strong>：强化学习利用环境评估当前策略，以此为依据进行优化</li>
<li><strong>交互性</strong>：强化学习的数据在与环境的交互中产生</li>
<li><strong>序列决策过程</strong>：智能主体在与环境的交互中需要作出一系列的决策，这些决策往往是前后关联的</li>
<li>注：现实中强化学习问题往往还具有<strong>奖励滞后</strong>，<strong>基于采样的评估</strong>等特点</li>
</ol>
<h3 id="6-1-3-马尔可夫决策过程"><a href="#6-1-3-马尔可夫决策过程" class="headerlink" title="6.1.3    马尔可夫决策过程"></a>6.1.3    马尔可夫决策过程</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517103826163.png" alt="image-20230517103826163" style="zoom: 50%;" /></p>
<p>序列优化问题描述：</p>
<ol>
<li>在下图网格中，假设有一个机器人位于$s_1$，其每一步只能向上或向右移动一格，跃出方格会被惩罚（且游戏停止）</li>
<li>如何使用强化学习找到一种策略，使机器人从$s_1$到达$s_9$？</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">智能主体 Agent</th>
<th style="text-align:center">迷宫机器人</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">环境</td>
<td style="text-align:center">3×3方格</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:center">机器人当前时刻所处方格</td>
</tr>
<tr>
<td style="text-align:center">动作</td>
<td style="text-align:center">每次移动一个方格</td>
</tr>
<tr>
<td style="text-align:center">奖励</td>
<td style="text-align:center">到达$s_9$时给予奖励，越界时给予惩罚</td>
</tr>
</tbody>
</table>
</div>
<h4 id="6-1-3-1-离散马尔可夫过程-Discrete-Markov-Process"><a href="#6-1-3-1-离散马尔可夫过程-Discrete-Markov-Process" class="headerlink" title="6.1.3.1    离散马尔可夫过程 Discrete Markov Process"></a>6.1.3.1    离散马尔可夫过程 Discrete Markov Process</h4><ol>
<li><p><strong>离散随机过程</strong>：一个随机过程实际上是一系列随时间变化的随机变量，其中当时间是离散量时，一个随机过程可以表示为${X<em>t}</em>{t=0,1,2…}$，其中每个$X_t$都是一个随机变量，这被称为离散随机过程</p>
</li>
<li><p><strong>马尔科夫链</strong>：满足马尔可夫性质的离散随机过程。也被称为离散马尔可夫过程</p>
<ol>
<li>马尔可夫性质：<strong>t+1时刻状态仅与t时刻状态相关</strong></li>
</ol>
<script type="math/tex; mode=display">
P(X_{t+1}=x_{t+1}|X_0=x_0,X_1=x_1,...,X_t=x_t)=P(X_{t+1}=x_{t+1}|X_t=x_t)</script></li>
</ol>
<h4 id="6-1-3-2-马尔可夫奖励过程-Markov-Reward-Process：引入奖励"><a href="#6-1-3-2-马尔可夫奖励过程-Markov-Reward-Process：引入奖励" class="headerlink" title="6.1.3.2    马尔可夫奖励过程 Markov Reward Process：引入奖励"></a>6.1.3.2    马尔可夫奖励过程 Markov Reward Process：引入奖励</h4><h5 id="6-1-3-2-1-奖励机制"><a href="#6-1-3-2-1-奖励机制" class="headerlink" title="6.1.3.2.1    奖励机制"></a>6.1.3.2.1    奖励机制</h5><p>为了在序列决策中对目标进行优化，在马尔可夫随机过程框架中加入了奖励机制：</p>
<ol>
<li>奖励函数$𝑹:𝑺×𝑺↦ℝ$，其中$𝑹(𝑺<em>𝒕,𝑺</em>{𝒕+𝟏})$描述了从第$𝒕$步状态转移到第$𝒕+𝟏$步状态所获得奖励</li>
<li>在一个序列决策过程中，不同状态之间的转移产生了一系列的奖励$(𝑹<em>𝟏,𝑹</em>𝟐,⋯)$，其中$𝑹<em>{𝒕+𝟏}$为$𝑹(𝑺</em>𝒕,𝑺_{𝒕+𝟏})$的简便记法。</li>
<li>引入奖励机制，这样可以衡量任意序列的优劣，即对序列决策进行评价。</li>
</ol>
<h5 id="6-1-3-2-2-反馈、折扣系数"><a href="#6-1-3-2-2-反馈、折扣系数" class="headerlink" title="6.1.3.2.2    反馈、折扣系数"></a>6.1.3.2.2    反馈、折扣系数</h5><p>问题：给定两个因为状态转移而产生的奖励序列$(𝟏,𝟏,𝟎,𝟎)$和$(𝟎,𝟎,𝟏,𝟏)$，哪个奖励序列更好？</p>
<ol>
<li><strong>反馈 Return</strong>：反应累加奖励，$G<em>t=R</em>{t+1}+\gamma R<em>{t+w}+\gamma^2 R</em>{t+3}+…$</li>
<li><strong>折扣系数 discount factor</strong>：$\gamma \in [0,1]$</li>
<li>反馈值反映了某个时刻后所得到累加奖励，当衰退系数小于1时，越是遥远的未来对累加反馈的贡献越少</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517104754931.png" alt="image-20230517104754931" style="zoom:80%;" /></p>
</blockquote>
<h4 id="6-1-3-3-马尔可夫决策过程-Markov-Decision-Process：引入动作"><a href="#6-1-3-3-马尔可夫决策过程-Markov-Decision-Process：引入动作" class="headerlink" title="6.1.3.3    马尔可夫决策过程 Markov Decision Process：引入动作"></a>6.1.3.3    马尔可夫决策过程 Markov Decision Process：引入动作</h4><p>在强化学习问题中，智能主体与环境交互过程中可自主决定所采取的动作，不同<strong>动作</strong>会对环境产生不同影响，为此：</p>
<ol>
<li>定义智能主体能够采取的<strong>动作集合</strong>为$𝑨$</li>
<li>由于不同的动作对环境造成的影响不同，因此状态转移概率定义为$𝑷(𝑺<em>{𝒕+𝟏}│𝑺</em>𝒕,𝒂<em>𝒕 )$，其中$𝒂</em>𝒕∈𝑨$为第$𝒕$步采取的动作</li>
<li>奖励可能受动作的影响，因此修改奖励函数为$𝑹(𝑺<em>𝒕,𝒂</em>𝒕,𝑺_{𝒕+𝟏})$</li>
<li>动作集合$𝑨$可以是有限的，也可以是无限的</li>
<li>状态转移可是确定（deterministic）的，也可以是随机概率性（stochastic）的。</li>
<li>确定状态转移相当于发生从$𝑺<em>𝒕$到$𝑺</em>{𝒕+𝟏}$的转移概率为1</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517105910270.png" alt="image-20230517105910270" style="zoom:80%;" /></p>
<h4 id="6-1-3-4-使用离散马尔可夫过程描述机器人移动问题"><a href="#6-1-3-4-使用离散马尔可夫过程描述机器人移动问题" class="headerlink" title="6.1.3.4    使用离散马尔可夫过程描述机器人移动问题"></a>6.1.3.4    使用离散马尔可夫过程描述机器人移动问题</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517110515225.png" alt="image-20230517110515225" style="zoom:50%;" /></p>
<ol>
<li>随机变量序列${S<em>t}</em>{t=0,1,2,…}$：$S_t$表示机器人第$t$步的位置(即状态)，每个随机变量$S_t$的取值范围为$S={s_1,s_2,⋯, s_9,s_d}$</li>
<li>动作集合：$A={上,右}$</li>
<li>状态转移概率$P(S_{t+1} |S_t,a_t)$：满足马尔可夫性，其中$a_t\in A$，状态转移如图所示</li>
<li>奖励函数：$R(S<em>t,a_t,S</em>{t+𝟏} )$，从$S<em>t$采取行动$a_t$到$S</em>{t+1}$所获得奖励</li>
<li>衰退系数：$\gamma∈[0, 1]$</li>
<li>综上，可以使用$MDP={S, A, P, R, \gamma}$来刻画马尔可夫决策过程</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517110654230.png" alt="image-20230517110654230" style="zoom:67%;" /></p>
<p>马尔可夫过程中产生的状态序列称为<strong>轨迹(trajectory)</strong>，可以如下表示：</p>
<script type="math/tex; mode=display">
(S_0,a_0,R_1,S_1,a_1,R_2,...,S_T)</script><ol>
<li>轨迹长度可以是无限的，也可以有终止状态$S_T$</li>
<li>有终止状态的问题叫做<strong>分段的(episodic, 即存在回合的)</strong>，否则叫做<strong>持续的(continuing)</strong></li>
<li>分段问题中，一个从初始状态到终止状态的完整轨迹称为一个<strong>片段或回合(episode)</strong>。如围棋对弈中一个胜败对局为一个回合</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517110917886.png" alt="image-20230517110917886" style="zoom:80%;" /></p>
</blockquote>
<h3 id="6-1-4-强化学习中的策略学习"><a href="#6-1-4-强化学习中的策略学习" class="headerlink" title="6.1.4    强化学习中的策略学习"></a>6.1.4    强化学习中的策略学习</h3><p><strong>策略函数</strong>：</p>
<ol>
<li>策略函数$𝜋:𝑆×𝐴↦[0, 1]$，其中$𝜋(𝑠,𝑎)$的值表示在状态$s$下采取动作$a$的概率。</li>
<li>策略函数的输出可以是确定的，即给定$s$情况下，只有一个动作$a$使得概率$𝜋(𝑠,𝑎)$取值为1</li>
<li>对于确定的策略，记为$𝑎=𝜋(𝑠)$</li>
</ol>
<h3 id="6-1-5-强化学习问题定义"><a href="#6-1-5-强化学习问题定义" class="headerlink" title="6.1.5    强化学习问题定义"></a>6.1.5    强化学习问题定义</h3><ol>
<li>给定一个马尔可夫决策过程$MDP=(S,A,P,R,\gamma)$，学习一个最优策略$\pi^<em>$，对于任意$s\in S$，使得$V_{\pi^</em>}(s)$的值最大<ol>
<li><strong>策略函数</strong>：$𝜋:𝑆×𝐴↦[0, 1]$，$𝜋(𝑠,𝑎)$表示智能体在状态$𝑠$下采取动作$𝑎$的概率</li>
<li>最大化每一时刻的<strong>回报值</strong>：$G<em>t=R</em>{t+1}+\gamma R<em>{t+w}+\gamma^2 R</em>{t+3}+…$</li>
<li><strong>价值函数</strong>：$𝑉:𝑆↦R$，其中$𝑉<em>𝜋 (𝑠)=𝔼</em>𝜋 [𝐺<em>𝑡 |𝑆</em>𝑡=𝑠]$<ol>
<li>表示在第$t$步状态为$s$时，按照策略$\pi$行动后，在未来所获得反馈值的期望</li>
</ol>
</li>
<li><strong>动作-价值函数</strong>：$𝑞:𝑆×𝐴↦R$，其中$𝑞<em>𝜋 (𝑠,𝑎)= E</em>𝜋 [𝐺<em>𝑡 |𝑆</em>𝑡=𝑠,𝐴_𝑡=𝑎]$<ol>
<li>表示在第𝑡步状态为𝑠时，按照策略𝜋采取动作𝑎后，在未来所获得反馈值的期望</li>
</ol>
</li>
<li><strong>价值函数</strong>和<strong>动作-价值函数</strong>反映了智能体在某一策略下所对应状态序列<strong>获得回报的期望</strong>，它比回报本身更加准确地刻画了智能体的目标</li>
<li><strong>价值函数</strong>和<strong>动作-价值函数</strong>的定义之所以能够成立，离不开决策过程所具有的马尔可夫性，即当位于当前状态$s$时，无论当前时刻$t$的取值是多少，一个策略回报值的期望是一定的。<strong>当前状态只与前一状态有关，与时间无关</strong></li>
</ol>
</li>
</ol>
<h3 id="6-1-6-贝尔曼方程-lt-gt-动态规划方程"><a href="#6-1-6-贝尔曼方程-lt-gt-动态规划方程" class="headerlink" title="6.1.6    贝尔曼方程 &lt;=&gt; 动态规划方程"></a>6.1.6    贝尔曼方程 &lt;=&gt; 动态规划方程</h3><blockquote>
<p><strong>Bellman Equation</strong> &lt;=&gt; <strong>Dynamic Programming Equation</strong></p>
</blockquote>
<ol>
<li><p><strong>价值函数</strong>：$V<em>\pi(s)=E</em>\pi [R<em>{t+1}+\gamma R</em>{t+2}+\gamma^2 R_{t+3}+… |S_t=s]$</p>
</li>
<li><p><strong>动作-价值函数</strong>：$q<em>\pi(s,a)=E</em>\pi [R<em>{t+1}+\gamma R</em>{t+2}+\gamma^2 R_{t+3}+… |S_t=s, A_t=a]$</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517114027577.png" alt="image-20230517114027577" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517114407250.png" alt="image-20230517114407250" style="zoom:80%;" /></p>
</blockquote>
</li>
<li><p><strong>贝尔曼方程</strong>：</p>
<ol>
<li><p><strong>价值函数的贝尔曼方程</strong>：</p>
<script type="math/tex; mode=display">
V_\pi(s)=\sum_{a\in A}\pi(s,a)q_\pi(s,a)</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517115250091.png" alt="image-20230517115250091" style="zoom:80%;" /></p>
<ol>
<li>描述了当前状态价值函数和其后续状态价值函数之间的关系</li>
<li>即当前状态价值函数等于瞬时奖励的期望加上后续状态的（折扣）价值函数的期望</li>
</ol>
</li>
<li><p><strong>动作-价值函数的贝尔曼方程</strong>：</p>
<script type="math/tex; mode=display">
q_\pi(s,a)=\sum_{s'\in S}P(s'|s,a)[R(s,a,s')+\gamma V_\pi(s')]</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517115306429.png" alt="image-20230517115306429" style="zoom:80%;" /></p>
<ol>
<li>描述了当前动作-价值函数和其后续动作-价值函数之间的关系</li>
<li>即当前状态下的动作-价值函数等于瞬时奖励的期望加上后续状态的（折扣）动作-价值函数的期望</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517115337147.png" alt="image-20230517115337147" style="zoom:80%;" /></p>
</blockquote>
<h2 id="6-2-基于价值的强化学习"><a href="#6-2-基于价值的强化学习" class="headerlink" title="6.2    基于价值的强化学习"></a>6.2    基于价值的强化学习</h2><p>强化学习问题的定义：</p>
<ol>
<li>给定一个马尔可夫决策过程$MDP=(S,A,P,R,\gamma)$</li>
<li>学习一个最优策略$\pi^<em>$，对于任意$s\in S$，使得$V_{\pi^</em>}(s)$的值最大</li>
</ol>
<h3 id="6-2-1-策略迭代"><a href="#6-2-1-策略迭代" class="headerlink" title="6.2.1    策略迭代"></a>6.2.1    策略迭代</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517115738367.png" alt="image-20230517115738367" style="zoom:80%;" /></p>
<ol>
<li>从一个任意的策略开始，首先计算该策略下价值函数（或动作-价值函数），然后根据价值函数调整改进策略使其更优，不断迭代这个过程直到策略收敛</li>
<li>通过策略计算价值函数的过程叫做<strong>策略评估（policy evaluation）</strong></li>
<li>通过价值函数优化策略的过程叫做<strong>策略优化（policy improvement）</strong></li>
<li>策略评估和策略优化交替进行的强化学习求解方法叫做<strong>通用策略迭代（Generalized Policy Iteration，GPI）</strong></li>
</ol>
<h3 id="6-2-2-强化学习中的策略优化"><a href="#6-2-2-强化学习中的策略优化" class="headerlink" title="6.2.2    强化学习中的策略优化"></a>6.2.2    强化学习中的策略优化</h3><p><strong>策略优化定理</strong>：</p>
<ol>
<li>对于确定的策略$\pi$和$\pi’$，如果对于任意状态$s\in S$，均有$q<em>\pi(s,\pi’(s)) \ge q</em>\pi(s,\pi(s))$</li>
<li>那么对于任意状态$s\in S$，有$V<em>{\pi’}(s) \ge V</em>{\pi}(s)$</li>
</ol>
<p>给定当前策略$\pi$、价值函数$V<em>\pi$、行动-价值函数$q</em>\pi$，构造新策略$\pi’$满足如下条件：</p>
<script type="math/tex; mode=display">
\forall s \in S,\pi'(s)=argmax_a\ q_{\pi}(s,a)</script><ol>
<li>则$\pi’$就是对$\pi$的一个改进</li>
<li>于是对于$\forall s \in S$，有：</li>
</ol>
<script type="math/tex; mode=display">
q_\pi(s,\pi'(s))=q_\pi(s,argmax_a\ q_\pi(s,a))=max_{a}\ q_\pi(s,a) \ge q_\pi(s,\pi(s))</script><blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517120713430.png" alt="image-20230517120713430" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517120730339.png" alt="image-20230517120730339" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517120756408.png" alt="image-20230517120756408" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230517120829356.png" alt="image-20230517120829356" style="zoom:80%;" /></p>
</blockquote>
<h3 id="6-2-3-强化学习中的策略评估方法"><a href="#6-2-3-强化学习中的策略评估方法" class="headerlink" title="6.2.3    强化学习中的策略评估方法"></a>6.2.3    强化学习中的策略评估方法</h3><p>假定当前策略为$𝜋$，<strong>策略评估</strong>指的是：根据策略$𝜋$来计算相应的价值函数$𝑉<em>𝜋$或动作-价值函数$𝑞</em>𝜋$。</p>
<p>这里将介绍在状态集合有限前提下三种常见的策略评估方法，它们分别是</p>
<ol>
<li>动态规划</li>
<li>蒙特卡洛采样</li>
<li>时序差分（temporal difference）</li>
</ol>
<h4 id="6-2-3-1-动态规划"><a href="#6-2-3-1-动态规划" class="headerlink" title="6.2.3.1    动态规划"></a>6.2.3.1    动态规划</h4><p>基于动态规划的价值函数更新：使用<strong>迭代</strong>的方法<strong>求解贝尔曼方程组</strong></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524103752806.png" alt="image-20230524103752806" style="zoom:80%;" /></p>
<p>缺点：</p>
<ol>
<li>agent需要事先知道状态转移概率$Pr(s’|s,a)$</li>
<li>无法处理状态集合大小无限的情况</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524104106939.png" alt="image-20230524104106939" style="zoom:80%;" /></p>
</blockquote>
<h4 id="6-2-3-2-蒙特卡洛采样"><a href="#6-2-3-2-蒙特卡洛采样" class="headerlink" title="6.2.3.2    蒙特卡洛采样"></a>6.2.3.2    蒙特卡洛采样</h4><p>基于蒙特卡洛采样的价值函数更新：</p>
<ol>
<li>轨迹：从当前状态出发，不停采样，直到到达终止状态</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524104237120.png" alt="image-20230524104237120" style="zoom:80%;" /></p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524104717419.png" alt="image-20230524104717419" style="zoom:80%;" /></p>
</blockquote>
<p>优点：</p>
<ol>
<li>agent不必知道状态转移的概率</li>
<li>容易扩展到无限状态集合的问题中</li>
</ol>
<p>缺点：</p>
<ol>
<li>状态集合比较大时，一个状态在轨迹可能非常稀疏，不利于估计期望</li>
<li>在实际问题中，最终反馈需要在终止状态才能知晓，导致反馈周期较长</li>
</ol>
<h4 id="6-2-3-3-时序差分-Temporal-Difference"><a href="#6-2-3-3-时序差分-Temporal-Difference" class="headerlink" title="6.2.3.3    时序差分 Temporal Difference"></a>6.2.3.3    时序差分 Temporal Difference</h4><script type="math/tex; mode=display">
\begin{aligned}
V_\pi(s) &← (1-\alpha)V_\pi(s) + \alpha[R+\gamma V_\pi(s')]\\
         &= V_\pi(s) + \alpha[R+\gamma V_\pi(s')-V_\pi(s)]
\end{aligned}</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111034692.png" alt="image-20230524111034692" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111010163.png" alt="image-20230524111010163" style="zoom:80%;" /></p>
<ol>
<li><strong>时序差分法</strong>可以看作<strong>蒙特卡罗方法</strong>和<strong>动态规划方法</strong>的有机结合<ol>
<li>时序差分算法与蒙特卡洛方法相似之处在于：时序差分方法从实际经验中获取信息，无需提前获知环境模型的全部信息</li>
<li>时序差分算法与动态规划方法的相似之处在于：时序差分方法能够利用前序已知信息来进行在线实时学习，无需等到整个片段结束（终止状态抵达）再进行价值函数的更新</li>
</ol>
</li>
<li>动态规划法根据贝尔曼方程迭代更新价值函数，要求算法事先知道状态之间的转移概率，这往往是不现实的。为了解决这个问题，时序差分法借鉴蒙特卡洛法思想，通过<strong>采样动作$a$和下一状态$s’$来估计计算$V_\pi(s)$</strong><ol>
<li>由于通过采样进行计算，所得结果可能不准确，因此时序差分法并没有将这个估计值照单全收，而是<strong>以$\alpha$作为权重来接受新的估计值</strong>，即把价值函数更新为$(1−𝛼)𝑉<em>𝜋(𝑠)+𝛼[𝑅+𝛾𝑉</em>𝜋 (s’)]$</li>
<li>对这个式子稍加整理就能得到算法中的形式：$𝑉<em>𝜋(𝑠)←𝑉</em>𝜋(𝑠)+𝛼[𝑅+𝛾𝑉<em>𝜋(s’)−𝑉</em>𝜋(𝑠)]$<ol>
<li>时序差分目标：$𝑅+𝛾𝑉_𝜋(𝑠’)$</li>
<li>时序差分偏差：$𝑅+𝛾𝑉<em>𝜋(𝑠’)−𝑉</em>𝜋(𝑠)$</li>
</ol>
</li>
</ol>
</li>
<li>时序差分法和蒙特卡洛法都是通过采样若干个片段来进行价值函数更新的，但是时序差分法并非使用一个片段中的终止状态所提供的实际回报值来估计价值函数，而是<strong>根据下一个状态的价值函数来估计价值函数</strong>，这样就克服了采样轨迹的稀疏性可能带来样本方差较大的不足问题，同时也缩短了反馈周期</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524110051895.png" alt="image-20230524110051895" style="zoom:80%;" /></p>
</blockquote>
<h4 id="6-2-3-4-Q-learning：直接计算-q-pi"><a href="#6-2-3-4-Q-learning：直接计算-q-pi" class="headerlink" title="6.2.3.4    Q-learning：直接计算$q_\pi$"></a>6.2.3.4    Q-learning：直接计算$q_\pi$</h4><script type="math/tex; mode=display">
\begin{aligned}
q_\pi(s,a) &← (1-\alpha)q_\pi(s,a) + \alpha[R+\gamma \max_{a'} q_\pi(s',a')]\\
           &= q_\pi(s,a) + \alpha[R+\gamma \max_{a'} q_\pi(s',a')-q_\pi(s,a)]
\end{aligned}</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524110407594.png" alt="image-20230524110407594" style="zoom:80%;" /></p>
<ol>
<li>Q-learning中<strong>直接记录和更新动作-价值函数$q_\pi$</strong><ol>
<li>这是因为策略优化要求已知动作-价值函数$q<em>\pi$，如果算法仍然记录值函数$V</em>\pi$，在不知道状态转移概率的情况下将无法求出$q_\pi$</li>
<li>于是，Q-learning中，只有动作-价值函数（即q函数）参与计算</li>
</ol>
</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111115648.png" alt="image-20230524111115648" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111206856.png" alt="image-20230524111206856" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111559060.png" alt="image-20230524111559060" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111640888.png" alt="image-20230524111640888" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524111811375.png" alt="image-20230524111811375" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524112203863.png" alt="image-20230524112203863" style="zoom:80%;" /></p>
</blockquote>
<h4 id="6-2-3-5-ε-greedy策略：策略学习中探索与利用的平衡"><a href="#6-2-3-5-ε-greedy策略：策略学习中探索与利用的平衡" class="headerlink" title="6.2.3.5    ε-greedy策略：策略学习中探索与利用的平衡"></a>6.2.3.5    ε-greedy策略：策略学习中探索与利用的平衡</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524112703162.png" alt="image-20230524112703162" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230619221300001.png" alt="image-20230619221300001" style="zoom:80%;" /></p>
<ol>
<li>ε-greedy策略：大体上遵循最优策略的决定，偶尔(以ε的概率)进行探索<ol>
<li>如上一个例子中，如果偶尔在某些状态随机选择”向右移动一个方格”的动作，则可克服机器人无法走到终点$s_9$这一不足</li>
</ol>
</li>
<li>将动作采样从”确定地选取最优动作” 改为 ”按照ε-greedy策略选取动作“</li>
<li>更新时仍保持用max操作选取最佳策略</li>
<li>像这样，更新时的目标策略与采样策略不同的方法，称为<strong>离策略 off-policy</strong>方法</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524113241486.png" alt="image-20230524113241486" style="zoom:80%;" /></p>
</blockquote>
<h4 id="6-2-3-6-Deep-Q-learning：用神经网络拟合-q-pi"><a href="#6-2-3-6-Deep-Q-learning：用神经网络拟合-q-pi" class="headerlink" title="6.2.3.6    Deep Q-learning：用神经网络拟合$q_\pi$"></a>6.2.3.6    Deep Q-learning：用神经网络拟合$q_\pi$</h4><p>思路：将<strong>q函数参数化</strong>，用一个非线性回归模型来拟合q函数</p>
<ol>
<li>能够用有限的参数刻画无限的状态</li>
<li>由于回归函数的连续性，没有探索过的状态也可以通过周围状态来估计</li>
</ol>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524113539570.png" alt="image-20230524113539570" style="zoom:80%;" /></p>
<ol>
<li>损失函数刻画了<strong>q的估计值$R+\gamma\ max<em>{a’}q</em>\pi(s’,a’;\theta)$与当前值的平方误差</strong></li>
<li>利用梯度下降算法优化参数$\theta$</li>
<li>如果使用深度神经网络来拟合q函数，则该算法称为<strong>Deep Q-learning/深度强化学习</strong></li>
</ol>
<h2 id="不考-6-3-基于策略的强化学习"><a href="#不考-6-3-基于策略的强化学习" class="headerlink" title="(不考)6.3    基于策略的强化学习"></a>(不考)6.3    基于策略的强化学习</h2><p>基于价值的强化学习：</p>
<ol>
<li>以<strong>对价值函数/动作-价值函数的建模</strong>为核心</li>
</ol>
<p>基于策略的强化学习：</p>
<ol>
<li>直接<strong>参数化策略函数</strong>，求解参数化的策略函数的梯度</li>
<li>策略函数的参数化可以表示为$𝝅_𝜽 (𝒔,𝒂)$，其中$𝜽$为一组参数，函数取值表示在状态$𝒔$下选择动作$𝒂$的概率</li>
<li>和Q学习的$𝝐$贪心策略相比，这种参数化的一个显著好处是：选择一个动作的概率是随着参数的改变而光滑变化的，实际上这种光滑性对算法收敛有更好的保证。</li>
</ol>
<h3 id="不考-6-3-1-策略梯度定理"><a href="#不考-6-3-1-策略梯度定理" class="headerlink" title="(不考)6.3.1    策略梯度定理"></a>(不考)6.3.1    策略梯度定理</h3><p>最大化目标：</p>
<script type="math/tex; mode=display">
MAX\ J(\theta)=V_{\pi_\theta}(s_0), 从初始状态出发的价值函数</script><p>策略梯度定理：</p>
<script type="math/tex; mode=display">
∇_\theta J(\theta) \propto \sum_s\mu_{\pi_\theta}(s)\sum_a q_{\pi_\theta}(s,a)∇_\theta\pi_\theta(s,a)</script><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524120505284.png" alt="image-20230524120505284" style="zoom:80%;" /></p>
<h3 id="不考-6-3-2-基于蒙特卡洛采样的策略梯度法"><a href="#不考-6-3-2-基于蒙特卡洛采样的策略梯度法" class="headerlink" title="(不考)6.3.2    基于蒙特卡洛采样的策略梯度法"></a>(不考)6.3.2    基于蒙特卡洛采样的策略梯度法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524120622673.png" alt="image-20230524120622673" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121005545.png" alt="image-20230524121005545" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121431806.png" alt="image-20230524121431806" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121443343.png" alt="image-20230524121443343"></p>
<h3 id="不考-6-3-3-基于时序差分的策略梯度法：Actor-Critic"><a href="#不考-6-3-3-基于时序差分的策略梯度法：Actor-Critic" class="headerlink" title="(不考)6.3.3    基于时序差分的策略梯度法：Actor-Critic"></a>(不考)6.3.3    基于时序差分的策略梯度法：Actor-Critic</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121517685.png" alt="image-20230524121517685" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121527223.png" alt="image-20230524121527223" style="zoom:80%;" /></p>
<h2 id="不考-6-4-深度强化学习的应用"><a href="#不考-6-4-深度强化学习的应用" class="headerlink" title="(不考)6.4    深度强化学习的应用"></a>(不考)6.4    深度强化学习的应用</h2><h3 id="不考-6-4-1-Deep-Q-Learning：围棋博弈"><a href="#不考-6-4-1-Deep-Q-Learning：围棋博弈" class="headerlink" title="(不考)6.4.1    Deep Q-Learning：围棋博弈"></a>(不考)6.4.1    Deep Q-Learning：围棋博弈</h3><blockquote>
<p>围棋游戏的一个片段的轨迹</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121625616.png" alt="image-20230524121625616" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121642810.png" alt="image-20230524121642810" style="zoom:80%;" /></p>
<h3 id="不考-6-4-2-Deep-Q-Learning：雅达利游戏"><a href="#不考-6-4-2-Deep-Q-Learning：雅达利游戏" class="headerlink" title="(不考)6.4.2    Deep Q-Learning：雅达利游戏"></a>(不考)6.4.2    Deep Q-Learning：雅达利游戏</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121731339.png" alt="image-20230524121731339" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121902690.png" alt="image-20230524121902690" style="zoom:80%;" /></p>
<h3 id="不考-6-4-3-难以探索的例子"><a href="#不考-6-4-3-难以探索的例子" class="headerlink" title="(不考)6.4.3    难以探索的例子"></a>(不考)6.4.3    难以探索的例子</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524121930690.png" alt="image-20230524121930690" style="zoom:80%;" /></p>
<h2 id="6-5-强化学习的分类"><a href="#6-5-强化学习的分类" class="headerlink" title="6.5    强化学习的分类"></a>6.5    强化学习的分类</h2><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230524122000911.png" alt="image-20230524122000911" style="zoom:80%;" /></p>
<p>图中从两个角度对强化学习算法做了分类</p>
<ol>
<li>其中依靠对环境（即马尔可夫随机过程）的先验知识或建模的算法称为<strong>基于模型（Model-based）的方法</strong>，反之称为<strong>无模型的方法（Model-free）</strong></li>
<li>只对价值函数建模并利用策略优化定理求解的方法称为<strong>基于价值（Value-based）的方法</strong>，对策略函数建模并利用策略梯度定理求解的方法称为<strong>基于策略（Policy-based）的方法</strong></li>
</ol>
<h1 id="七、人工智能博弈"><a href="#七、人工智能博弈" class="headerlink" title="七、人工智能博弈"></a>七、人工智能博弈</h1><h2 id="7-1-博弈论的相关概念"><a href="#7-1-博弈论的相关概念" class="headerlink" title="7.1    博弈论的相关概念"></a>7.1    博弈论的相关概念</h2><h3 id="7-1-1-博弈的要素"><a href="#7-1-1-博弈的要素" class="headerlink" title="7.1.1    博弈的要素"></a>7.1.1    博弈的要素</h3><ol>
<li><strong>参与者/玩家 player</strong>：参与博弈的决策主体</li>
<li><strong>策略 strategy</strong>：参与者可以采取的行动方案，是在采取行动之前就已经准备好的完整方案<ol>
<li>每个参与者可采纳策略的全体组合形成了<strong>策略集 strategy set</strong></li>
<li>所有参与者各自采取行动后形成的状态被称为<strong>局势 outcome</strong></li>
<li>如果参与者可以通过一定概率分布来选择若干个不同的策略，这样的策略称为<strong>混合策略 mixed strategy</strong>。</li>
<li>若参与者每次行动都选择某个确定的策略，这样的策略称为<strong>纯策略 pure strategy</strong></li>
</ol>
</li>
<li><strong>收益 payoff</strong>：各个参与者在不同局势下得到的利益<ol>
<li>混合策略意义下的收益应为<strong>期望收益 expected payoff</strong></li>
</ol>
</li>
<li><strong>规则 rule</strong>：对参与者行动的先后顺序、参与者获得信息多少等内容的规定</li>
</ol>
<h3 id="7-1-2-研究范式"><a href="#7-1-2-研究范式" class="headerlink" title="7.1.2    研究范式"></a>7.1.2    研究范式</h3><p><strong>研究范式</strong>：建模者对参与者规定可采取的策略集和取得的收益，观察当参与者选择若干策略以最大化其收益时会产生什么结果</p>
<h3 id="7-1-3-囚徒困境-Prisoner’s-Dilemma"><a href="#7-1-3-囚徒困境-Prisoner’s-Dilemma" class="headerlink" title="7.1.3    囚徒困境 Prisoner’s Dilemma"></a>7.1.3    囚徒困境 Prisoner’s Dilemma</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531105937279.png" alt="image-20230531105937279" style="zoom:80%;" /></p>
<ol>
<li><strong>均衡解</strong>：在当前情况下，任意一个人改变策略，而其他人保持不变，改变策略的人得到的收益一定变低</li>
</ol>
<h3 id="7-1-4-博弈的分类"><a href="#7-1-4-博弈的分类" class="headerlink" title="7.1.4    博弈的分类"></a>7.1.4    博弈的分类</h3><p>合作博弈与非合作博弈</p>
<ol>
<li><strong>合作博弈 cooperative game</strong>：部分参与者可以组成联盟以获得更大的收益</li>
<li><strong>非合作博弈 non-cooperative game</strong>：参与者在决策中都彼此独立，不事先达成合作意向</li>
</ol>
<p>静态博弈与动态博弈</p>
<ol>
<li><strong>静态博弈 static game</strong>：所有参与者同时决策，或参与者互相不知道对方的决策</li>
<li><strong>动态博弈 dynamic game</strong>：参与者所采取行为的先后顺序由规则决定，且后行动者知道先行动者所采取的行为</li>
</ol>
<p>完全信息博弈与不完全信息博弈</p>
<ol>
<li><strong>完全信息 complete information</strong>：所有参与者均了解其他参与者的策略集、收益等信息</li>
<li><strong>不完全信息 incomplete information</strong>：并非所有参与者均掌握了所有信息</li>
</ol>
<p>囚徒困境是一种非合作、不完全信息的静态博弈</p>
<h3 id="7-1-5-纳什均衡"><a href="#7-1-5-纳什均衡" class="headerlink" title="7.1.5    纳什均衡"></a>7.1.5    纳什均衡</h3><p>博弈的稳定局势即为<strong>纳什均衡 Nash equilibrium</strong>：</p>
<ol>
<li>指的是参与者所作出的这样一种策略组合，在该策略组合上，任何参与者单独改变策略都不会得到好处</li>
<li>换句话说，如果在一个策略组合上，当所有其他人都不改变策略时，没有人会改变自己的策略，则该策略组合就是一个纳什均衡</li>
<li>纳什均衡的本质：不后悔</li>
</ol>
<p><strong>Nash定理</strong>：</p>
<ol>
<li>若参与者有限，每位参与者的策略集有限，收益函数为实值函数，则博弈必<strong>存在</strong>混合策略意义下的纳什均衡</li>
</ol>
<p>囚徒困境中两人同时认罪就是这一问题的纳什均衡</p>
<p><strong>混合策略纳什均衡</strong>：</p>
<ol>
<li>博弈过程中，博弈方通过概率形式随机从可选策略中选择一个策略而达到的纳什均衡</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531111906949.png" alt="image-20230531111906949" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531111834818.png" alt="image-20230531111834818" style="zoom:80%;" /></p>
<p>设雇主检查的概率为$\alpha$，雇员偷懒的概率为$\beta$，则雇主-雇员之间博弈的期望收益为：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531112006083.png" alt="image-20230531112006083" style="zoom:80%;" /></p>
<p><strong>纳什均衡</strong>：其他参与者策略不变的情况下，某个参与者单独采取其他策略都不会使得收益增加⇔<strong>无论雇主是否检查，雇主的收益都一样；无论雇员是否偷懒，雇员的收益都一样</strong></p>
<ol>
<li>于是有$𝑻<em>𝟏=𝑻</em>𝟐$ 以及$𝑻<em>𝟑=𝑻</em>𝟒$</li>
<li>在纳什均衡下，由于$𝑻<em>𝟑=𝑻</em>𝟒$，可知雇主采取检查策略的概率（雇主趋向于用这个概率去检查）：$𝜶=\frac{𝑯}{𝑾+𝑭}$</li>
<li>在纳什均衡下，由于$𝑻<em>𝟏=𝑻</em>𝟐$，可知雇员采取偷懒策略的概率（雇员趋向于用这个概率去偷懒）：$𝜷=\frac{𝑪}{𝑾+𝑭}$</li>
<li>在检查概率为𝜶之下，雇主的收益：$𝑻<em>𝟏=𝑻</em>𝟐=𝑽−𝑾−\frac{𝑪𝑽}{𝑾+𝑭}$</li>
<li>对上式中$𝑾$求导，则当$𝑾=\sqrt{𝑪𝑽}−𝑭$时，雇主的收益最大，其值为$𝑻_{𝒎𝒂𝒙}=𝑽−𝟐\sqrt{𝑪𝑽}+𝑭$</li>
</ol>
</blockquote>
<h3 id="7-1-6-策梅洛定理"><a href="#7-1-6-策梅洛定理" class="headerlink" title="7.1.6    策梅洛定理"></a>7.1.6    策梅洛定理</h3><p><strong>策梅洛定理 Zermelo’s theorem</strong>：</p>
<ol>
<li>对于任意一个<strong>有限步</strong>的<strong>双人完全信息零和</strong>动态博弈，一定存在<strong>先手必胜</strong>策略或<strong>后手必胜</strong>策略或<strong>双方保平</strong>策略</li>
<li>策梅洛定理仅对<strong>两人博弈</strong>有效，如果博弈竞技者超过了2人，如对于三人博弈，策梅洛定理无法保证三方中一定有一方获胜、其他两方必败或者三方和局的策略</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531113435683.png" alt="image-20230531113435683" style="zoom:80%;" /></p>
</blockquote>
<h2 id="不考-7-2-博弈策略求解"><a href="#不考-7-2-博弈策略求解" class="headerlink" title="(不考)7.2    博弈策略求解"></a>(不考)7.2    博弈策略求解</h2><p>动机</p>
<ol>
<li>博弈论提供了许多问题的数学模型</li>
<li>纳什定理确定了博弈过程问题存在解</li>
<li>人工智能的方法可用来求解均衡局面或者最优策略</li>
</ol>
<p>主要问题</p>
<ol>
<li>如何高效求解博弈参与者的策略以及博弈的均衡局势？</li>
</ol>
<p>应用领域</p>
<ol>
<li>大规模搜索空间的问题求解：围棋</li>
<li>非完全信息博弈问题求解：德州扑克</li>
<li>网络对战游戏智能：Dota、星球大战</li>
<li>动态博弈的均衡解：厂家竞争、信息安全</li>
</ol>
<h3 id="不考-7-2-1-虚拟遗憾最小化算法-Regret-Minimization"><a href="#不考-7-2-1-虚拟遗憾最小化算法-Regret-Minimization" class="headerlink" title="(不考)7.2.1    虚拟遗憾最小化算法 Regret Minimization"></a>(不考)7.2.1    虚拟遗憾最小化算法 Regret Minimization</h3><ol>
<li><p>对于一个有$N$个玩家参加的博弈，玩家$i$在博弈中采取的策略为$\sigma_i$</p>
</li>
<li><p>对于所有玩家来说，他们的所有策略构成了一个策略组合，记为$\sigma={\sigma_1,\sigma_2,…,\sigma_N}$</p>
</li>
<li><p>策略组中，除玩家$i$外，其它玩家的策略组合记为$\sigma<em>{-i}={\sigma_1,\sigma_2,…,\sigma</em>{i-1},\sigma_{i+1},…,\sigma_N}$</p>
</li>
<li><p>给定策略组合$\sigma$，玩家$i$在终结局势下的收益记为$u_i(\sigma)$</p>
</li>
<li><p>在给定其它玩家的策略组合$\sigma_{-i}$的情况下，对玩家$i$而言的<strong>最优反应策略$\sigma_i^*$</strong>满足如下条件：</p>
<script type="math/tex; mode=display">
u_i(\sigma_i^*,\sigma_{-i}) \ge \max_{\sigma_i'\in \sum_i}u_i(\sigma_i',\sigma_{-i})</script><ol>
<li>$\sum_i$是玩家$i$可以选择的所有策略</li>
<li>如上条件表示当玩家$i$采用最优反应策略时，玩家$i$能够获得最大收益</li>
</ol>
</li>
</ol>
<h4 id="不考-7-2-1-1-纳什均衡策略的定义"><a href="#不考-7-2-1-1-纳什均衡策略的定义" class="headerlink" title="(不考)7.2.1.1    纳什均衡策略的定义"></a>(不考)7.2.1.1    纳什均衡策略的定义</h4><ol>
<li><p>在策略组合$𝜎^∗$中，如果每个玩家的策略相对于其他玩家的策略而言都是最佳反应策略，那么策略组合$𝜎^∗$就是一个<strong>纳什均衡策略</strong></p>
<ol>
<li>在有限对手、有限策略情况下，纳什均衡一定存在</li>
<li>策略组$𝜎^∗={𝜎<em>1^∗,𝜎_2^∗,…,𝜎</em>𝑁^∗}$对任意玩家$𝑖=1,..,𝑁$，满足如下条件：</li>
</ol>
</li>
</ol>
<script type="math/tex; mode=display">
   𝑢_𝑖(𝜎^∗) ≥ \max_{𝜎_𝑖^′∈Σ_𝑖} 𝜇_𝑖 (𝜎_1^∗,𝜎_2^∗,…,𝜎_𝑖^′,…,𝜎_𝑁^∗)</script><ol>
<li><p>在博弈策略求解的过程中，希望求解得到<strong>每个玩家最优反应策略</strong>，若所有玩家都是理性的，则算法求解最优反应策略就是一个纳什均衡</p>
</li>
<li><p>考虑到计算资源有限这一前提，难以通过遍历博弈中所有策略组合来找到一个最优反应策略，因此需要找到一种能<strong>快速发现近似纳什均衡</strong>的方法</p>
</li>
</ol>
<h4 id="不考-7-2-1-2-遗憾最小化算法"><a href="#不考-7-2-1-2-遗憾最小化算法" class="headerlink" title="(不考)7.2.1.2    遗憾最小化算法"></a>(不考)7.2.1.2    遗憾最小化算法</h4><p>遗憾最小化算法是一种<strong>根据以往博弈过程中所得遗憾程度来选择未来行为</strong>的方法</p>
<ol>
<li><p>在过去$𝑇$轮中，玩家$𝑖$采取策略$𝜎_𝑖$的<strong>累加遗憾值</strong>定义如下：</p>
<script type="math/tex; mode=display">
Regret_i^T (𝜎_i)=\sum_{𝑡=1}^𝑇 (u_i(𝜎_i,𝜎_{−i}^t) − u_i(𝜎^t))</script><ol>
<li>$𝜎^𝑡$表示：第$𝑡$轮中所有玩家的策略组合</li>
<li>$𝜎_{−𝑖}^𝑡$表示：第$𝑡$轮中除了玩家$𝑖$以外的策略组合</li>
</ol>
</li>
<li><p>简单地说，累加遗憾值代表：</p>
<ol>
<li>在过去$𝑇$轮中，玩家$𝑖$在每一轮中选择策略$𝜎_𝑖$所得收益与采取其他策略所得收益之差的累加</li>
</ol>
</li>
</ol>
<h4 id="不考-7-2-1-3-有效遗憾值"><a href="#不考-7-2-1-3-有效遗憾值" class="headerlink" title="(不考)7.2.1.3    有效遗憾值"></a>(不考)7.2.1.3    有效遗憾值</h4><ol>
<li><p>在得到玩家$i$的所有可选策略的遗憾值后，可以根据遗憾值的大小来选择后续第$𝑇+1$轮博弈的策略，这种选择方式被称为<strong>遗憾匹配</strong></p>
</li>
<li><p>当然，通常遗憾值为负数的策略被认为不能提升下一时刻收益，所以如下定义有效遗憾值：</p>
<script type="math/tex; mode=display">
𝑅𝑒𝑔𝑟𝑒𝑡_𝑖^{𝑇,+} 𝜎_𝑖=\max (𝑅𝑒𝑔𝑟𝑒𝑡_𝑖^𝑇(𝜎_𝑖),0)</script></li>
<li><p>利用有效遗憾值的遗憾匹配，可得到玩家$𝑖$在第$T+1$轮选择策略$𝜎<em>𝑖$的概率$𝑃(𝜎</em>𝑖^{T+1})$为：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531115940689.png" alt="image-20230531115940689" style="zoom:80%;" /></p>
<ol>
<li>$|Σ_i|$表示玩家$𝑖$所有策略的总数</li>
<li>显然，如果在过往$𝑇$轮中策略$𝜎<em>𝑖$所带来的遗憾值大、其他策略$𝜎</em>𝑖^′$所带来的遗憾值小，则在第$𝑇+1$轮选择策略$𝜎<em>𝑖$的概率值$𝑃(𝜎</em>𝑖^{𝑇+1})$就大</li>
<li>即：<strong>带来越大遗憾值的策略具有更高的价值，因此其在后续被选择的概率就应该越大</strong></li>
<li>如果没有一个能够提升前$T$轮收益的策略，则在后续轮次中随机选择一种策略</li>
</ol>
</li>
<li><p>可以依照一定的概率选择行动 </p>
<ol>
<li>为了防止对手发现自己所采取的策略，如采取遗憾值最大的策略</li>
</ol>
</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531120014258.png" alt="image-20230531120014258" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531120224753.png" alt="image-20230531120224753" style="zoom:80%;" /></p>
</blockquote>
<h4 id="不考-7-2-1-4-计算理论"><a href="#不考-7-2-1-4-计算理论" class="headerlink" title="(不考)7.2.1.4    计算理论"></a>(不考)7.2.1.4    计算理论</h4><ol>
<li><p>对于任何序贯决策的博弈对抗，可将博弈过程表示成一棵博弈树，博弈树中的每一个中间节点都是一个<strong>信息集$I$</strong>，信息集中包含了博弈中当前的状态</p>
<ol>
<li>给定博弈树的每一个节点，玩家都可以从一系列的动作中选择一个，然后状态发生转换，如此周而复始，直到终局（博弈树的叶子节点）</li>
<li>玩家在当前状态下可采取的策略就是当前状态下所有可能动作的一个概率分布</li>
</ol>
</li>
<li><p>具体而言，在信息集$𝐼$下，玩家可以采取的<strong>行动集合记作$𝐴(𝐼)$</strong></p>
<ol>
<li>玩家$𝑖$所采取的行动$𝑎<em>𝑖∈𝐴(𝐼)$可认为是其采取的策略$𝜎</em>𝑖$的一部分</li>
<li>在信息集$𝐼$下采取行动$𝑎$所代表的策略记为$𝜎_{𝐼→𝑎}$</li>
<li>这样，要计算虚拟遗憾值的对象，就是博弈树中每个中间节点在信息集下所采取的行动，并根据遗憾值匹配得到该节点在信息集下应该采取的策略$𝜎_{𝐼→𝑎}$</li>
</ol>
</li>
<li><p>在一次博弈中，所有玩家交替采取的<strong>行动序列记为$ℎ$</strong>（从根节点到当前节点的路径）</p>
<ol>
<li>对于所有玩家的策略组合$𝜎$，行动序列ℎ出现的概率记为$𝜋^𝜎 (ℎ)$，不同的行动序列可以从根节点到达当前节点的信息集$𝐼$（即不同决策路径可到达博弈树中同一个中间节点）</li>
<li>在策略组合$𝜎$下，所有能够到达该信息集的行动序列的概率累加就是该信息集的出现概率，即$𝜋^𝜎(𝐼)=∑_{ℎ∈𝐼}𝜋^𝜎 (ℎ)$</li>
</ol>
</li>
<li><p>博弈的<strong>终结局势集合</strong>也就是博弈树中叶子节点的集合，记为$𝑍$</p>
<ol>
<li>对于任意一个终结局势$𝑧∈𝑍$，玩家$𝑖$在此终点局势下的<strong>收益记作$𝑢_𝑖 (𝑧)$</strong></li>
<li>给定行动序列$ℎ$，依照策略组合$𝜎$最终到达终结局势$𝑧$的<strong>概率记作$𝜋^𝜎 (ℎ,𝑧)$</strong></li>
</ol>
</li>
<li><p>在策略组合$𝜎$下，对玩家$𝑖$而言，如下计算从根节点到当前节点的<strong>行动序列路径$ℎ$的虚拟价值$v_i(σ,h)$</strong>： </p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111149556.png" alt="image-20230607111149556" style="zoom:80%;" /></p>
<ol>
<li>在上式中，$𝜋_{−𝑖}^𝜎(ℎ)$表示从根节点出发，不考虑玩家$𝑖$的策略，仅考虑其他玩家策略而经过路径$ℎ$到达当前节点的概率</li>
<li>也就是说，即使玩家𝑖有其他策略，总是要求玩家$𝑖$在每次选择时都选择路径ℎ中对应的动作，以保证从根节点出发能够到达当前节点</li>
<li>可见，行动序列路径ℎ的虚拟价值等于如下三项结果的乘积：不考虑玩家𝑖的策略（仅考虑其他玩家策略）经过路径ℎ到达当前节点的概率、从当前节点走到叶子结点（博弈结束）的概率、所到达叶子节点的收益。</li>
</ol>
</li>
<li><p>在定义了行动序列路径ℎ的虚拟价值之后，就可如下计算玩家$𝑖$在基于路径$ℎ$到达当前节点采取行动$𝑎$的<strong>遗憾值</strong>：</p>
<script type="math/tex; mode=display">
𝑟_𝑖 (ℎ,𝑎)=𝑣_𝑖(𝜎_{𝐼→𝑎},ℎ)−𝑣_𝑖 (𝜎,ℎ)</script><ol>
<li>该遗憾值是玩家$𝑖$通过行动序列$ℎ$到达当前节点采取行动$𝑎$所得虚拟价值减去采用策略$𝜎$所得路径$ℎ$的虚拟价值</li>
</ol>
</li>
<li><p>对能够到达同一个信息集$𝐼$（即博弈树中同一个中间节点）的所有行动序列的遗憾值进行累加，即可得到信息集$𝐼$的遗憾值：</p>
<script type="math/tex; mode=display">
𝑟_𝑖(𝐼,𝑎)=\sum_{ℎ∈𝐼}𝑟_𝑖(ℎ,𝑎)</script></li>
<li><p>类似于遗憾最小化算法，虚拟遗憾最小化的遗憾值是𝑇轮重复博弈后的累加值：</p>
<script type="math/tex; mode=display">
𝑅𝑒𝑔𝑟𝑒𝑡_𝑖^𝑇 (𝐼,𝑎)=∑_{𝑡=1}^𝑇 𝑟_𝑖^𝑡 (𝐼,𝑎)</script><ol>
<li>$𝑟_𝑖^𝑡 (𝐼,𝑎)$表示玩家$𝑖$在第$𝑡$轮中于当前节点选择行动$𝑎$的遗憾值</li>
</ol>
</li>
<li><p>进一步可以定义有效虚拟遗憾值：</p>
<script type="math/tex; mode=display">
𝑅𝑒𝑔𝑟𝑒𝑡_𝑖^{𝑇,+}(𝐼,𝑎)=\max(𝑅_𝑖^𝑇 (𝐼,𝑎),0)</script></li>
<li><p>根据有效虚拟遗憾值进行遗憾匹配以计算经过$𝑇$轮博弈后，玩家$𝑖$在信息集$𝐼$情况下于后续$𝑇+1$轮选择行动$𝑎$的概率：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230531121756780.png" alt="image-20230531121756780" style="zoom:80%;" /></p>
</li>
</ol>
<h4 id="不考-7-2-1-5-虚拟最小化算法步骤"><a href="#不考-7-2-1-5-虚拟最小化算法步骤" class="headerlink" title="(不考)7.2.1.5    虚拟最小化算法步骤"></a>(不考)7.2.1.5    虚拟最小化算法步骤</h4><p>在虚拟最小化算法的求解过程中，同样需要反复模拟多轮博弈来拟合最佳反应策略，算法步骤如下</p>
<ol>
<li>初始化遗憾值和累加策略表为0</li>
<li>采用随机选择的方法来决定策略</li>
<li>利用当前策略与对手进行博弈</li>
<li>计算每个玩家采取每次行为后的遗憾值</li>
<li>根据博弈结果计算每个行动的累加遗憾值大小来更新策略</li>
<li>重复3)到5)步若干次，不断的优化策略</li>
<li>根据重复博弈最终的策略，完成最终的动作选择</li>
</ol>
<h4 id="不考-7-2-1-6-示例"><a href="#不考-7-2-1-6-示例" class="headerlink" title="(不考)7.2.1.6    示例"></a>(不考)7.2.1.6    示例</h4><p>双人库恩扑克游戏</p>
<ol>
<li><p>规则：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607104906067.png" alt="image-20230607104906067" style="zoom:80%;" /></p>
</li>
<li><p>先手玩家A对应的博弈树</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607110005718.png" alt="image-20230607110005718" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607105608061.png" alt="image-20230607105608061" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607105558855.png" alt="image-20230607105558855" style="zoom:80%;" /></p>
</li>
<li><p>计算节点${1PB}$的虚拟价值：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607105808959.png" alt="image-20230607105808959" style="zoom:80%;" /></p>
</li>
<li><p>计算玩家A在节点${1PB}$选择过牌行动后的虚拟价值：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607110243336.png" alt="image-20230607110243336" style="zoom:80%;" /></p>
</li>
<li><p>计算玩家A在节点${1PB}$选择过牌行动后的虚拟遗憾值：</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607110537655.png" alt="image-20230607110537655" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="7-3-博弈规则设计"><a href="#7-3-博弈规则设计" class="headerlink" title="7.3    博弈规则设计"></a>7.3    博弈规则设计</h2><h3 id="7-3-1-研究的问题"><a href="#7-3-1-研究的问题" class="headerlink" title="7.3.1    研究的问题"></a>7.3.1    研究的问题</h3><ol>
<li>在现实生活中，如果所有博弈者都追求自己利益最大化，很可能会导致两败俱伤的下场</li>
<li>那么应该如何设计博弈的规则使得博弈的最终局势能尽可能达到整体利益的最大化呢？</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111305301.png" alt="image-20230607111305301" style="zoom:80%;" /></p>
</blockquote>
<h3 id="7-3-2-双边匹配算法"><a href="#7-3-2-双边匹配算法" class="headerlink" title="7.3.2    双边匹配算法"></a>7.3.2    双边匹配算法</h3><ol>
<li>在生活中，人们常常会碰到与资源匹配相关的决策问题(如求职就业、报考录取等)，这些需要双向选择的情况被称为是<strong>双边匹配问题</strong></li>
<li>在双边匹配问题中，需要双方互相满足对方的需求才会达成匹配</li>
</ol>
<h4 id="7-3-2-1-稳定婚姻问题-Stable-Marriage-Problem"><a href="#7-3-2-1-稳定婚姻问题-Stable-Marriage-Problem" class="headerlink" title="7.3.2.1    稳定婚姻问题 Stable Marriage Problem"></a>7.3.2.1    稳定婚姻问题 Stable Marriage Problem</h4><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112146858.png" alt="image-20230607112146858" style="zoom:80%;" /></p>
<blockquote>
<p>假设有4名单身男性{𝟏,𝟐,𝟑,𝟒}和4名单身女性{𝑨,𝑩,𝑪,𝑫}，他（她）们的、爱慕序列如表8.9所示</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111451720.png" alt="image-20230607111451720" style="zoom:80%;" /></p>
<p>按照“修补”策略，匹配和修补过程如下</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111528939.png" alt="image-20230607111528939" style="zoom:80%;" /></p>
</blockquote>
<h4 id="7-3-2-2-双边匹配问题：G-S算法"><a href="#7-3-2-2-双边匹配问题：G-S算法" class="headerlink" title="7.3.2.2    双边匹配问题：G-S算法"></a>7.3.2.2    双边匹配问题：G-S算法</h4><p>算法过程：</p>
<ol>
<li>单身男性向最喜欢的女性表白</li>
<li>所有收到表白的女性从向其表白男性中选择最喜欢的男性，暂时匹配</li>
<li>未匹配的男性继续向没有拒绝过他的女性表白</li>
<li>收到表白的女性如果没有完成匹配，则从这一批表白者中选择最喜欢男性。即使收到表白的女性已经完成匹配，但是如果她认为有她更喜欢的男性，则可以拒绝之前的匹配者，重新匹配</li>
<li>如此循环迭代，直到所有人都成功匹配为止</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607111755649.png" alt="image-20230607111755649" style="zoom:80%;" /></p>
<ol>
<li>在第一轮中，4名男性分别向自己最喜欢的女性告白，而收到3人告白的女性𝐴选择了自己最喜欢的男性3，另一个收到告白的女性𝐵选择了男性4</li>
<li>在第二轮中，尚未匹配的男性1和男性2继续向自己第二喜欢的对象告白，收到告白的女性𝐵选择了自己更喜欢的男性2而放弃了男性4</li>
<li>同理继续三轮告白和选择，所有人都找到了自己的伴侣，且所有匹配都是稳定的</li>
<li>可以看出，使用G-S算法得到了稳定匹配的结果。</li>
</ol>
</blockquote>
<h3 id="7-3-3-单边匹配问题：最大交易圈算法-Top-trading-cycle-TTC"><a href="#7-3-3-单边匹配问题：最大交易圈算法-Top-trading-cycle-TTC" class="headerlink" title="7.3.3    单边匹配问题：最大交易圈算法 Top-trading cycle TTC"></a>7.3.3    单边匹配问题：最大交易圈算法 Top-trading cycle TTC</h3><p>算法流程：</p>
<ol>
<li>首先记录每个物品的初始占有者，或者对物品进行随机分配</li>
<li>每个交易者连接一条指向他最喜欢的物品的边，并从每一个物品连接到其占有者或是具有高优先权的交易者</li>
<li>此时形成一张有向图，且必存在环，这种环被称为“交易圈”，对于交易圈中的交易者，将每人指向节点所代表的物品赋予交易者，同时交易者放弃原先占有的物品，占有者和匹配成功的物品离开匹配市场</li>
<li>接着从剩余的交易者和物品之间重复进行交易圈匹配，直到无法形成交易圈，算法停止</li>
</ol>
<blockquote>
<p><strong>稳定室友匹配</strong>问题就是一个典型的单边匹配问题</p>
<p>假设某寝室有A、B、C、D四位同学和1、2、3、4四个床位，当前给A、B、C、D四位同学随机分配4、3、2、1四个床位</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112416470.png" alt="image-20230607112416470" style="zoom:80%;" /></p>
<p>第一轮单边匹配：A和D之间构成一个交易圈，可达成交易，所以A得到床位1，D得到床位4，之后将 A和D以及1和4从匹配图中移除</p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112509623.png" alt="image-20230607112509623" style="zoom:80%;" /></p>
<p>第二轮单边匹配：B和C都希望得到床位2，无法再构成交易圈，但是由于C是床位的本身拥有者，所以C仍然得到床位2，B只能选择床位3 </p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112551559.png" alt="image-20230607112551559" style="zoom:80%;" /></p>
<p>最后交易结果A→1，B →3，C →2，D →4</p>
</blockquote>
<h2 id="7-4-非完全信息博弈的实际应用"><a href="#7-4-非完全信息博弈的实际应用" class="headerlink" title="7.4    非完全信息博弈的实际应用"></a>7.4    非完全信息博弈的实际应用</h2><h3 id="7-4-1-博弈论研究内容"><a href="#7-4-1-博弈论研究内容" class="headerlink" title="7.4.1    博弈论研究内容"></a>7.4.1    博弈论研究内容</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112747539.png" alt="image-20230607112747539" style="zoom:80%;" /></p>
<h3 id="7-4-2-求解非完全信息博弈纳什均衡的一般方法"><a href="#7-4-2-求解非完全信息博弈纳什均衡的一般方法" class="headerlink" title="7.4.2    求解非完全信息博弈纳什均衡的一般方法"></a>7.4.2    求解非完全信息博弈纳什均衡的一般方法</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112801250.png" alt="image-20230607112801250" style="zoom:80%;" /></p>
<h3 id="7-4-3-与深度强化学习相结合"><a href="#7-4-3-与深度强化学习相结合" class="headerlink" title="7.4.3    与深度强化学习相结合"></a>7.4.3    与深度强化学习相结合</h3><p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112837994.png" alt="image-20230607112837994" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/unicorn2022/Pictures/main/AssetMarkdown/image-20230607112848255.png" alt="image-20230607112848255" style="zoom:80%;" /></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="unicorn2022.github.io">华丰夏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hzoi-unicorn.top/2023/03/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">https://hzoi-unicorn.top/2023/03/01/人工智能/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hzoi-unicorn.top" target="_blank">华风夏韵</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/01/GAMES104/" title="GAMES104"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GAMES104</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/01/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/" title="多媒体技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多媒体技术</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/19/cmake%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/" title="cmake指令合集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-19</div><div class="title">cmake指令合集</div></div></a></div><div><a href="/2023/07/15/cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="cmake学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-15</div><div class="title">cmake学习笔记</div></div></a></div><div><a href="/2023/03/01/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/" title="多媒体技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="title">多媒体技术</div></div></a></div><div><a href="/2023/02/28/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%AF%BC%E8%AE%BA/" title="自然语言处理导论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">自然语言处理导论</div></div></a></div><div><a href="/2023/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="title">编译原理</div></div></a></div><div><a href="/2022/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" title="计算机图形学"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-15</div><div class="title">计算机图形学</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">华丰夏</div><div class="author-info__description">一切都是上天最好的安排</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/unicorn2022"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/unicorn2022" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:496300118@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">愿你前行的道路有群星闪耀。愿你留下的足迹有百花绽放。你即是上帝的馈赠，世界因你而瑰丽。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%BB%E8%BE%91%E4%B8%8E%E6%8E%A8%E7%90%86"><span class="toc-text">一、逻辑与推理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-proposition-logic"><span class="toc-text">1.1    命题逻辑 proposition logic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1.1    定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7"><span class="toc-text">1.1.2    逻辑等价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-text">1.1.3    推理规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E5%91%BD%E9%A2%98%E8%8C%83%E5%BC%8F"><span class="toc-text">1.1.4    命题范式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91"><span class="toc-text">1.2    谓词逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E4%B8%AA%E4%BD%93%E4%B8%8E%E8%B0%93%E8%AF%8D"><span class="toc-text">1.2.1    个体与谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E9%87%8F%E8%AF%8D"><span class="toc-text">1.2.2    量词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E5%8F%98%E5%85%83"><span class="toc-text">1.2.3    变元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E9%A1%B9%E4%B8%8E%E5%8E%9F%E5%AD%90%E8%B0%93%E8%AF%8D%E5%85%AC%E5%BC%8F"><span class="toc-text">1.2.4    项与原子谓词公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F"><span class="toc-text">1.2.5    合式公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-text">1.2.6    推理规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-7-%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-text">1.2.7    专家系统的构成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1"><span class="toc-text">1.3    知识图谱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.3.1    基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86"><span class="toc-text">1.3.2    知识图谱推理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%BD%92%E7%BA%B3%E5%AD%A6%E4%B9%A0"><span class="toc-text">1.3.3    归纳学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E4%B8%80%E9%98%B6%E6%8E%A8%E5%AF%BC%E5%AD%A6%E4%B9%A0-FOIL"><span class="toc-text">1.3.4    一阶推导学习 FOIL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-5-%E8%B7%AF%E5%BE%84%E6%8E%92%E5%BA%8F%E6%8E%A8%E7%90%86-PRA"><span class="toc-text">1.3.5    路径排序推理 PRA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-6-%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E7%9F%A5%E8%AF%86%E6%8E%A8%E7%90%86"><span class="toc-text">1.3.6    基于分布式的知识推理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-7-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%80%BB%E8%BE%91%E7%BD%91%E7%BB%9C"><span class="toc-text">1.3.7    马尔可夫逻辑网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-4-%E5%9B%A0%E6%9E%9C%E6%8E%A8%E7%90%86"><span class="toc-text">(不考)1.4    因果推理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-4-1-%E4%B8%89%E7%A7%8D%E5%9B%A0%E6%9E%9C%E6%8E%A8%E7%90%86"><span class="toc-text">(不考)1.4.1    三种因果推理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-4-2-%E5%9B%A0%E6%9E%9C%E6%8E%A8%E7%90%86%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">(不考)1.4.2    因果推理的主要模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-4-3-%E7%BB%93%E6%9E%84%E5%9B%A0%E6%9E%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">(不考)1.4.3    结构因果模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">(不考)1.5    因果图模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-1-%E8%81%94%E5%90%88%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83"><span class="toc-text">(不考)1.5.1    联合概率分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-2-%E9%93%BE"><span class="toc-text">(不考)1.5.2    链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-3-%E5%88%86%E8%BF%9E"><span class="toc-text">(不考)1.5.3    分连</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-4-%E6%B1%87%E8%BF%9E"><span class="toc-text">(不考)1.5.4    汇连</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-5-D-%E5%88%86%E7%A6%BB"><span class="toc-text">(不考)1.5.5    D-分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-6-%E5%B9%B2%E9%A2%84%E7%9A%84%E5%9B%A0%E6%9E%9C%E6%95%88%E5%BA%94"><span class="toc-text">(不考)1.5.6    干预的因果效应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-7-%E5%9B%A0%E6%9E%9C%E6%95%88%E5%BA%94%E5%B7%AE"><span class="toc-text">(不考)1.5.7    因果效应差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-1-5-8-%E5%8F%8D%E4%BA%8B%E5%AE%9E%E6%A8%A1%E5%9E%8B"><span class="toc-text">(不考)1.5.8    反事实模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%90%9C%E7%B4%A2%E4%B8%8E%E6%B1%82%E8%A7%A3"><span class="toc-text">二、搜索与求解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">2.1    搜索算法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%8F%8F%E8%BF%B0"><span class="toc-text">2.1.1    搜索算法的形式化描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">2.1.2    评价指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E6%A0%91%E6%90%9C%E7%B4%A2"><span class="toc-text">2.1.3    树搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E5%89%AA%E6%9E%9D%E6%90%9C%E7%B4%A2"><span class="toc-text">2.1.4    剪枝搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2"><span class="toc-text">2.2    启发式搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%B4%AA%E5%A9%AA%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Greedy-best-first-search"><span class="toc-text">2.2.1    贪婪最佳优先搜索 Greedy best-first search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-A-%E7%AE%97%E6%B3%95"><span class="toc-text">2.2.2    A*算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1-A-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2.2.2.1    A*算法的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-2-2-2-2-A-%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">(不考)2.2.2.2    A*算法的性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-2-2-2-3-A-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%8C%E5%A4%87%E6%80%A7"><span class="toc-text">(不考)2.2.2.3    A*算法的完备性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-2-2-2-4-A-%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%80%E4%BC%98%E6%80%A7"><span class="toc-text">(不考)2.2.2.4    A*算法的最优性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AF%B9%E6%8A%97%E6%90%9C%E7%B4%A2-%E5%8D%9A%E5%BC%88%E6%90%9C%E7%B4%A2"><span class="toc-text">2.3    对抗搜索&#x2F;博弈搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2-Minimax"><span class="toc-text">2.3.1    最小最大搜索 Minimax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Alpha-Beta%E5%89%AA%E6%9E%9D%E6%90%9C%E7%B4%A2"><span class="toc-text">2.3.2    Alpha-Beta剪枝搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A0%91%E6%90%9C%E7%B4%A2"><span class="toc-text">2.4    蒙特卡洛树搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="toc-text">2.4.1    问题定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">2.4.2    相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AD%96%E7%95%A5"><span class="toc-text">2.4.3    贪心算法策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%CE%B5-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">2.4.4    ε-贪心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E4%B8%8A%E9%99%90%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E7%AE%97%E6%B3%95UCD1%EF%BC%9AUpper-Confidence-Bounds"><span class="toc-text">2.4.5    上限置信区间算法UCD1：Upper Confidence Bounds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E5%AF%B9%E6%8A%97%E6%90%9C%E7%B4%A2%EF%BC%9A%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A0%91%E6%90%9C%E7%B4%A2"><span class="toc-text">2.4.6    对抗搜索：蒙特卡洛树搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-text">三、监督学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1    机器学习的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">3.1.1    机器学习的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%87%8D%E8%A6%81%E5%85%83%E7%B4%A0"><span class="toc-text">3.1.2    监督学习的重要元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-text">3.1.3    监督学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-1-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-text">3.1.3.1    损失函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-2-%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-text">3.1.3.2    训练数据与测试数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-3-%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9%E3%80%81%E6%9C%9F%E6%9C%9B%E9%A3%8E%E9%99%A9"><span class="toc-text">3.1.3.3    经验风险、期望风险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-4-%E8%BF%87%E5%AD%A6%E4%B9%A0-amp-%E6%AC%A0%E5%AD%A6%E4%B9%A0"><span class="toc-text">3.1.3.4    过学习 &amp; 欠学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-5-%E7%BB%93%E6%9E%84%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F"><span class="toc-text">3.1.3.5    结构风险最小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-6-%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B-amp-%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.1.3.6    判别模型 &amp; 生成模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90"><span class="toc-text">3.2    回归分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-text">3.2.1    线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-1-%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-text">3.2.1.1    一元线性回归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-2-%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-text">3.2.1.2    多元线性回归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-3-logistics-%E5%9B%9E%E5%BD%92-%E5%AF%B9%E6%95%B0%E5%87%A0%E7%8E%87%E5%9B%9E%E5%BD%92"><span class="toc-text">3.2.1.3    logistics 回归&#x2F;对数几率回归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-4-%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">3.2.1.4    二分类问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-5-%E5%9F%BA%E4%BA%8E%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-text">3.2.1.5    基于似然函数的参数优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-6-MLE%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1-amp-MAP%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%E4%BC%B0%E8%AE%A1"><span class="toc-text">3.2.1.6    MLE最大似然估计 &amp; MAP最大后验概率估计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-text">3.3    决策树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E4%BF%A1%E6%81%AF%E7%86%B5-E-D"><span class="toc-text">3.3.1    信息熵 E(D)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A-Gain-D-A"><span class="toc-text">3.3.2    信息增益 Gain(D,A)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E4%BF%A1%E6%81%AF%E7%86%B5%E5%92%8C%E7%89%A9%E7%90%86%E7%86%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.3.3    信息熵和物理熵的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BA%BF%E6%80%A7%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90-LDA"><span class="toc-text">3.4    线性区别分析 LDA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89"><span class="toc-text">3.4.1    符号定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">3.4.2    二分类问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">3.4.3    多分类问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90%E7%9A%84%E9%99%8D%E7%BB%B4%E6%AD%A5%E9%AA%A4"><span class="toc-text">3.4.4    线性判别分析的降维步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Ada-Boosting"><span class="toc-text">3.5    Ada Boosting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%EF%BC%9A%E9%9C%8D%E5%A4%AB%E4%B8%81%E4%B8%8D%E7%AD%89%E5%BC%8F"><span class="toc-text">3.5.1    计算学习理论：霍夫丁不等式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%EF%BC%9A%E6%A6%82%E7%8E%87%E8%BF%91%E4%BC%BC%E6%AD%A3%E7%A1%AE-PAC"><span class="toc-text">3.5.2    计算学习理论：概率近似正确 PAC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-Ada-Boosting%EF%BC%9A%E6%80%9D%E8%B7%AF%E6%8F%8F%E8%BF%B0"><span class="toc-text">3.5.3    Ada Boosting：思路描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-Ada-Boosting%EF%BC%9A%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">3.5.4    Ada Boosting：算法描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-1-%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%AC%E6%9D%83%E9%87%8D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">3.5.4.1    数据样本权重初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-2-%E7%AC%ACm%E4%B8%AA%E5%BC%B1%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84%E8%AE%AD%E7%BB%83"><span class="toc-text">3.5.4.2    第m个弱分类器的训练</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-3-%E5%BC%B1%E5%88%86%E7%B1%BB%E5%99%A8%E7%BB%84%E5%90%88%E6%88%90%E5%BC%BA%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-text">3.5.4.3    弱分类器组合成强分类器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-Ada-Boosting%EF%BC%9A%E7%AE%97%E6%B3%95%E8%A7%A3%E9%87%8A"><span class="toc-text">3.5.5    Ada Boosting：算法解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-6-Ada-Boosting%EF%BC%9A%E5%9B%9E%E7%9C%8B%E9%9C%8D%E5%A4%AB%E4%B8%81%E4%B8%8D%E7%AD%89%E5%BC%8F"><span class="toc-text">3.5.6    Ada Boosting：回看霍夫丁不等式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-7-Ada-Boosting%EF%BC%9A%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87"><span class="toc-text">3.5.7    Ada Boosting：优化目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-8-%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.5.8    回归和分类的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-3-6-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-text">(不考)3.6    支持向量机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-3-6-1-VC%E7%BB%B4%E4%B8%8E%E7%BB%93%E6%9E%84%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="toc-text">(不考)3.6.1    VC维与结构风险最小化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-3-6-2-%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-text">(不考)3.6.2    线性可分支持向量机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-3-6-3-%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F%EF%BC%8C%E8%BD%AF%E9%97%B4%E9%9A%94%E4%B8%8Ehinge%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-text">(不考)3.6.3    松弛变量，软间隔与hinge损失函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-3-7-%E7%94%9F%E6%88%90%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B"><span class="toc-text">(不考)3.7    生成学习模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-text">四、无监督学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB"><span class="toc-text">4.1    K均值聚类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">4.1.1    算法描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%81%9A%E7%B1%BB%E8%B4%A8%E5%BF%83"><span class="toc-text">4.1.1.1    初始化聚类质心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-2-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%BE%85%E8%81%9A%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%94%BE%E5%85%A5%E5%94%AF%E4%B8%80%E4%B8%80%E4%B8%AA%E8%81%9A%E7%B1%BB%E9%9B%86%E5%90%88%E4%B8%AD"><span class="toc-text">4.1.1.2    将每个待聚类数据放入唯一一个聚类集合中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-3-%E6%A0%B9%E6%8D%AE%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C%EF%BC%8C%E6%9B%B4%E6%96%B0%E8%81%9A%E7%B1%BB%E8%B4%A8%E5%BF%83"><span class="toc-text">4.1.1.3    根据聚类结果，更新聚类质心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-4-%E7%AE%97%E6%B3%95%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6"><span class="toc-text">4.1.1.4    算法循环迭代，直到满足条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A7%86%E8%A7%92%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%96%E6%AF%8F%E4%B8%AA%E7%B1%BB%E7%B0%87%E7%9A%84%E6%96%B9%E5%B7%AE"><span class="toc-text">4.1.2    另一个视角：最小化每个类簇的方差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-text">4.1.3    K均值聚类算法的不足</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-PCA"><span class="toc-text">4.2    主成分分析 PCA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">4.2.1    相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%AE%97%E6%B3%95%E5%8A%A8%E6%9C%BA"><span class="toc-text">4.2.2    算法动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">4.2.3    算法描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E9%99%8D%E7%BB%B4%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.4    其他常用降维方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%89%B9%E5%BE%81%E4%BA%BA%E8%84%B8%E6%96%B9%E6%B3%95"><span class="toc-text">4.3    特征人脸方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%8A%A8%E6%9C%BA"><span class="toc-text">4.3.1    动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">4.3.2    算法描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%85%B6%E4%BB%96%E4%BA%BA%E8%84%B8%E8%A1%A8%E8%BE%BE%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%E8%81%9A%E7%B1%BB%E3%80%81PCA%E3%80%81%E9%9D%9E%E8%B4%9F%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3"><span class="toc-text">4.3.3    其他人脸表达的方法：聚类、PCA、非负矩阵分解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%BD%9C%E5%9C%A8%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-text">4.4    潜在语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E6%BD%9C%E5%9C%A8%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E6%80%9D%E6%83%B3"><span class="toc-text">4.4.1    潜在语义分析思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-text">4.4.2    分析过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E7%AE%97%E6%B3%95-EM"><span class="toc-text">4.5    期望最大化算法 EM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="toc-text">4.5.1    模型参数估计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-text">4.5.2    期望最大化算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-EM%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BA%8C%E7%A1%AC%E5%B8%81%E6%8A%95%E6%8E%B7%E4%BE%8B%E5%AD%90"><span class="toc-text">4.5.3    EM示例：二硬币投掷例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-EM%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%89%E7%A1%AC%E5%B8%81%E6%8A%95%E6%8E%B7%E4%BE%8B%E5%AD%90"><span class="toc-text">4.5.4    EM示例：三硬币投掷例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-5-EM%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F"><span class="toc-text">4.5.5    EM算法的一般形式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="toc-text">五、深度学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95"><span class="toc-text">5.1    深度学习的历史发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-FNN"><span class="toc-text">5.2    前馈神经网络 FNN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E6%B5%85%E5%B1%82%E5%AD%A6%E4%B9%A0-vs-%E6%B7%B1%E5%B1%82%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%86%E6%AE%B5%E5%AD%A6%E4%B9%A0-gt-%E9%80%90%E5%B1%82%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%AD%A6%E4%B9%A0"><span class="toc-text">5.2.1    浅层学习 vs 深层学习：分段学习&#x3D;&gt;逐层端到端学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BB%A5%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E6%96%B9%E5%BC%8F%E9%80%90%E5%B1%82%E6%8A%BD%E8%B1%A1%E3%80%81%E9%80%90%E5%B1%82%E5%AD%A6%E4%B9%A0"><span class="toc-text">5.2.2    深度学习：以端到端的方式逐层抽象、逐层学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-MCP%E7%A5%9E%E7%BB%8F%E5%85%83"><span class="toc-text">5.2.3    MCP神经元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%BE%93%E5%85%A5%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="toc-text">5.2.3    激活函数：对输入信息进行非线性变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-1-%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%EF%BC%9Asigmoid%E3%80%81tanh%E3%80%81ReLU"><span class="toc-text">5.2.3.1    常用激活函数：sigmoid、tanh、ReLU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-2-softmax%E5%87%BD%E6%95%B0%EF%BC%9A%E5%B0%86%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84%E5%88%B0-0-1-%E6%A6%82%E7%8E%87%E7%A9%BA%E9%97%B4"><span class="toc-text">5.2.3.2    softmax函数：将输出映射到[0,1]概率空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E5%8D%95%E4%B8%AA%E7%A5%9E%E7%BB%8F%E5%85%83%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9A%E5%8A%A0%E6%9D%83%E7%B4%AF%E5%8A%A0-%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="toc-text">5.2.4    单个神经元的功能：加权累加 + 非线性变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0-Loss-Function"><span class="toc-text">5.2.5    损失函数 Loss Function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-1-%E5%9D%87%E6%96%B9%E8%AF%AF%E5%B7%AE%E6%8D%9F%E5%A4%B1-MSE%EF%BC%9A%E9%A2%84%E6%B5%8B%E5%80%BC%E5%92%8C%E5%AE%9E%E9%99%85%E5%80%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE"><span class="toc-text">5.2.5.1    均方误差损失 MSE：预测值和实际值之间的差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-2-%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="toc-text">5.2.5.2    交叉熵损失函数：两个概率分布之间的距离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6-%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.2.6    感知机模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6-1-%E5%8D%95%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA"><span class="toc-text">5.2.6.1    单层感知机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6-2-%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA-%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-FNN"><span class="toc-text">5.2.6.2    多层感知机&#x2F;前馈神经网络(FNN)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-7-%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-text">5.2.7    参数优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-7-1-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-Gradient-Descent"><span class="toc-text">5.2.7.1    梯度下降 Gradient Descent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-7-2-%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD-BP"><span class="toc-text">5.2.7.2    误差反向传播 BP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-7-3-%E9%93%BE%E5%BC%8F%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99"><span class="toc-text">5.2.7.3    链式求导法则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-8-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%83%BD%E5%8A%9B%E5%9C%A8%E4%BA%8E%E6%8B%9F%E5%90%88%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-text">5.2.8    机器学习的能力在于拟合和优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-CNN"><span class="toc-text">5.3    卷积神经网络 CNN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C%EF%BC%9A%E7%BA%BF%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">5.3.1    卷积操作：线性操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-1-%E5%8D%B7%E7%A7%AF%E6%A0%B8%E7%9A%84%E6%9D%83%E9%87%8D%E6%98%AF%E9%80%9A%E8%BF%87%E5%AD%A6%E4%B9%A0%E5%BE%97%E5%87%BA%E7%9A%84"><span class="toc-text">5.3.1.1    卷积核的权重是通过学习得出的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-2-%E5%AF%B9%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C"><span class="toc-text">5.3.1.2    对图像进行卷积操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-3-%E5%8D%B7%E7%A7%AF%E6%A0%B8%E3%80%81%E7%89%B9%E5%BE%81%E5%9B%BE%E3%80%81%E6%84%9F%E5%8F%97%E9%87%8E"><span class="toc-text">5.3.1.3    卷积核、特征图、感受野</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E6%B1%A0%E5%8C%96%E6%93%8D%E4%BD%9C%EF%BC%9A%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">5.3.2    池化操作：非线性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%AD%A3%E5%88%99%E5%8C%96%EF%BC%9A%E8%A7%A3%E5%86%B3%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-text">5.3.3    神经网络正则化：解决过拟合问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-RNN"><span class="toc-text">5.4    循环神经网络 RNN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-RNN%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">5.4.1    RNN的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E6%B2%BF%E6%97%B6%E9%97%B4%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95-BPTT"><span class="toc-text">5.4.2    沿时间反向传播算法 BPTT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-1-%E6%80%9D%E6%83%B3"><span class="toc-text">5.4.2.1    思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-2-%E7%AE%97%E6%B3%95"><span class="toc-text">5.4.2.2    算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-3-%E5%BA%94%E7%94%A8"><span class="toc-text">5.4.2.3    应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E6%A8%A1%E5%9E%8B-LSTM%EF%BC%9A%E8%A7%A3%E5%86%B3RNN%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">5.4.3    长短时记忆模型 LSTM：解决RNN梯度消失的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-1-%E6%80%9D%E6%83%B3"><span class="toc-text">5.4.3.1    思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-2-%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89"><span class="toc-text">5.4.3.2    符号定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-3-LSTM%E7%BB%93%E6%9E%84"><span class="toc-text">5.4.3.3    LSTM结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-4-LSTM%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1"><span class="toc-text">5.4.3.4    LSTM如何克服梯度消失</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-GRU%E9%97%A8%E6%8E%A7%E5%BE%AA%E7%8E%AF%E5%8D%95%E5%85%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-text">5.4.4    GRU门控循环单元神经网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-5-5-%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E5%AD%A6%E4%B9%A0"><span class="toc-text">(不考)5.5    深度生成学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%94%E7%94%A8"><span class="toc-text">5.6    深度学习应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%AF%8D%E5%90%91%E9%87%8F%E7%94%9F%E6%88%90"><span class="toc-text">5.6.1    自然语言中词向量生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-Word2Vec%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.6.2    Word2Vec模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-3-CBOW%E6%A8%A1%E5%9E%8B%EF%BC%9A%E9%80%9A%E8%BF%87%E4%B8%8A%E4%B8%8B%E6%96%87%E9%A2%84%E6%B5%8B%E5%8D%95%E8%AF%8D"><span class="toc-text">5.6.3    CBOW模型：通过上下文预测单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-4-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E5%92%8C%E7%9B%AE%E6%A0%87%E5%AE%9A%E4%BD%8D"><span class="toc-text">5.6.4    图像分类和目标定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0"><span class="toc-text">六、强化学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="toc-text">6.1    强化学习问题定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">6.1.1    强化学习中的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">6.1.2    强化学习的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B"><span class="toc-text">6.1.3    马尔可夫决策过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-1-%E7%A6%BB%E6%95%A3%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E8%BF%87%E7%A8%8B-Discrete-Markov-Process"><span class="toc-text">6.1.3.1    离散马尔可夫过程 Discrete Markov Process</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-2-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%A5%96%E5%8A%B1%E8%BF%87%E7%A8%8B-Markov-Reward-Process%EF%BC%9A%E5%BC%95%E5%85%A5%E5%A5%96%E5%8A%B1"><span class="toc-text">6.1.3.2    马尔可夫奖励过程 Markov Reward Process：引入奖励</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-3-2-1-%E5%A5%96%E5%8A%B1%E6%9C%BA%E5%88%B6"><span class="toc-text">6.1.3.2.1    奖励机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-3-2-2-%E5%8F%8D%E9%A6%88%E3%80%81%E6%8A%98%E6%89%A3%E7%B3%BB%E6%95%B0"><span class="toc-text">6.1.3.2.2    反馈、折扣系数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-3-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B-Markov-Decision-Process%EF%BC%9A%E5%BC%95%E5%85%A5%E5%8A%A8%E4%BD%9C"><span class="toc-text">6.1.3.3    马尔可夫决策过程 Markov Decision Process：引入动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-4-%E4%BD%BF%E7%94%A8%E7%A6%BB%E6%95%A3%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%A7%BB%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-text">6.1.3.4    使用离散马尔可夫过程描述机器人移动问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E7%AD%96%E7%95%A5%E5%AD%A6%E4%B9%A0"><span class="toc-text">6.1.4    强化学习中的策略学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="toc-text">6.1.5    强化学习问题定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-6-%E8%B4%9D%E5%B0%94%E6%9B%BC%E6%96%B9%E7%A8%8B-lt-gt-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E7%A8%8B"><span class="toc-text">6.1.6    贝尔曼方程 &lt;&#x3D;&gt; 动态规划方程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%9F%BA%E4%BA%8E%E4%BB%B7%E5%80%BC%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0"><span class="toc-text">6.2    基于价值的强化学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E7%AD%96%E7%95%A5%E8%BF%AD%E4%BB%A3"><span class="toc-text">6.2.1    策略迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96"><span class="toc-text">6.2.2    强化学习中的策略优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E7%AD%96%E7%95%A5%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.3    强化学习中的策略评估方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">6.2.3.1    动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-2-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7"><span class="toc-text">6.2.3.2    蒙特卡洛采样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-3-%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86-Temporal-Difference"><span class="toc-text">6.2.3.3    时序差分 Temporal Difference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-4-Q-learning%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%AE%A1%E7%AE%97-q-pi"><span class="toc-text">6.2.3.4    Q-learning：直接计算$q_\pi$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-5-%CE%B5-greedy%E7%AD%96%E7%95%A5%EF%BC%9A%E7%AD%96%E7%95%A5%E5%AD%A6%E4%B9%A0%E4%B8%AD%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%88%A9%E7%94%A8%E7%9A%84%E5%B9%B3%E8%A1%A1"><span class="toc-text">6.2.3.5    ε-greedy策略：策略学习中探索与利用的平衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-6-Deep-Q-learning%EF%BC%9A%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8B%9F%E5%90%88-q-pi"><span class="toc-text">6.2.3.6    Deep Q-learning：用神经网络拟合$q_\pi$</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-6-3-%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0"><span class="toc-text">(不考)6.3    基于策略的强化学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-6-3-1-%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E5%AE%9A%E7%90%86"><span class="toc-text">(不考)6.3.1    策略梯度定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-6-3-2-%E5%9F%BA%E4%BA%8E%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E7%9A%84%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E6%B3%95"><span class="toc-text">(不考)6.3.2    基于蒙特卡洛采样的策略梯度法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-6-3-3-%E5%9F%BA%E4%BA%8E%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86%E7%9A%84%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E6%B3%95%EF%BC%9AActor-Critic"><span class="toc-text">(不考)6.3.3    基于时序差分的策略梯度法：Actor-Critic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-6-4-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">(不考)6.4    深度强化学习的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-6-4-1-Deep-Q-Learning%EF%BC%9A%E5%9B%B4%E6%A3%8B%E5%8D%9A%E5%BC%88"><span class="toc-text">(不考)6.4.1    Deep Q-Learning：围棋博弈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-6-4-2-Deep-Q-Learning%EF%BC%9A%E9%9B%85%E8%BE%BE%E5%88%A9%E6%B8%B8%E6%88%8F"><span class="toc-text">(不考)6.4.2    Deep Q-Learning：雅达利游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-6-4-3-%E9%9A%BE%E4%BB%A5%E6%8E%A2%E7%B4%A2%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">(不考)6.4.3    难以探索的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">6.5    强化学习的分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8D%9A%E5%BC%88"><span class="toc-text">七、人工智能博弈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">7.1    博弈论的相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E5%8D%9A%E5%BC%88%E7%9A%84%E8%A6%81%E7%B4%A0"><span class="toc-text">7.1.1    博弈的要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E7%A0%94%E7%A9%B6%E8%8C%83%E5%BC%8F"><span class="toc-text">7.1.2    研究范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83-Prisoner%E2%80%99s-Dilemma"><span class="toc-text">7.1.3    囚徒困境 Prisoner’s Dilemma</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E5%8D%9A%E5%BC%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">7.1.4    博弈的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-5-%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1"><span class="toc-text">7.1.5    纳什均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-6-%E7%AD%96%E6%A2%85%E6%B4%9B%E5%AE%9A%E7%90%86"><span class="toc-text">7.1.6    策梅洛定理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-7-2-%E5%8D%9A%E5%BC%88%E7%AD%96%E7%95%A5%E6%B1%82%E8%A7%A3"><span class="toc-text">(不考)7.2    博弈策略求解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-7-2-1-%E8%99%9A%E6%8B%9F%E9%81%97%E6%86%BE%E6%9C%80%E5%B0%8F%E5%8C%96%E7%AE%97%E6%B3%95-Regret-Minimization"><span class="toc-text">(不考)7.2.1    虚拟遗憾最小化算法 Regret Minimization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-7-2-1-1-%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">(不考)7.2.1.1    纳什均衡策略的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-7-2-1-2-%E9%81%97%E6%86%BE%E6%9C%80%E5%B0%8F%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-text">(不考)7.2.1.2    遗憾最小化算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-7-2-1-3-%E6%9C%89%E6%95%88%E9%81%97%E6%86%BE%E5%80%BC"><span class="toc-text">(不考)7.2.1.3    有效遗憾值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-7-2-1-4-%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA"><span class="toc-text">(不考)7.2.1.4    计算理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-7-2-1-5-%E8%99%9A%E6%8B%9F%E6%9C%80%E5%B0%8F%E5%8C%96%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">(不考)7.2.1.5    虚拟最小化算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%80%83-7-2-1-6-%E7%A4%BA%E4%BE%8B"><span class="toc-text">(不考)7.2.1.6    示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%8D%9A%E5%BC%88%E8%A7%84%E5%88%99%E8%AE%BE%E8%AE%A1"><span class="toc-text">7.3    博弈规则设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E7%A0%94%E7%A9%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">7.3.1    研究的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E5%8F%8C%E8%BE%B9%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">7.3.2    双边匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-1-%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%E9%97%AE%E9%A2%98-Stable-Marriage-Problem"><span class="toc-text">7.3.2.1    稳定婚姻问题 Stable Marriage Problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-2-%E5%8F%8C%E8%BE%B9%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%EF%BC%9AG-S%E7%AE%97%E6%B3%95"><span class="toc-text">7.3.2.2    双边匹配问题：G-S算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E5%8D%95%E8%BE%B9%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%98%93%E5%9C%88%E7%AE%97%E6%B3%95-Top-trading-cycle-TTC"><span class="toc-text">7.3.3    单边匹配问题：最大交易圈算法 Top-trading cycle TTC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E9%9D%9E%E5%AE%8C%E5%85%A8%E4%BF%A1%E6%81%AF%E5%8D%9A%E5%BC%88%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-text">7.4    非完全信息博弈的实际应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%A0%94%E7%A9%B6%E5%86%85%E5%AE%B9"><span class="toc-text">7.4.1    博弈论研究内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E6%B1%82%E8%A7%A3%E9%9D%9E%E5%AE%8C%E5%85%A8%E4%BF%A1%E6%81%AF%E5%8D%9A%E5%BC%88%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1%E7%9A%84%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95"><span class="toc-text">7.4.2    求解非完全信息博弈纳什均衡的一般方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9B%B8%E7%BB%93%E5%90%88"><span class="toc-text">7.4.3    与深度强化学习相结合</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/19/cmake%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/" title="cmake指令合集">cmake指令合集</a><time datetime="2023-07-19T12:19:11.000Z" title="发表于 2023-07-19 20:19:11">2023-07-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="cmake学习笔记">cmake学习笔记</a><time datetime="2023-07-15T10:00:00.000Z" title="发表于 2023-07-15 18:00:00">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/13/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="hexo常用指令">hexo常用指令</a><time datetime="2023-07-13T13:11:11.000Z" title="发表于 2023-07-13 21:11:11">2023-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/01/GAMES104/" title="GAMES104">GAMES104</a><time datetime="2023-04-01T04:49:00.000Z" title="发表于 2023-04-01 12:49:00">2023-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" title="人工智能">人工智能</a><time datetime="2023-03-01T02:00:00.000Z" title="发表于 2023-03-01 10:00:00">2023-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 华丰夏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>